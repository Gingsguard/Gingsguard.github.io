---
title: Weblogic XMLDecoder RCE分析(CVE-2017-10271)
date: 2019-10-12 15:50:49
tags: [web漏洞分析 ,java]
categories: 技术
cover: https://s2.ax1x.com/2020/01/02/ltCxmt.md.jpg
top_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg
---

Oracle WebLogic Server是Oracle Corporation开发的一款Java EE 应用服务器，其支持EJB、JSP、JMS、XML等多种语言且具有可扩展性、快速开发等多种特性。

Oracle WebLogic Server组件的WLS Security子组件存在安全漏洞。使用精心构造的xml数据可能造成任意代码执行，攻击者只需要发送精心构造的HTTP请求即可拿到目标服务器的权限。

<!--more-->

漏洞分析
--------

本文中所调试的Weblogic版本为10.36

在启动Weblogic前，在startWebLogic.cmd中加入如下图红框处指令

![lY2s54.png](https://s2.ax1x.com/2020/01/02/lY2s54.png)

这将配置Weblogic的远程调试的端口为9999

首先我们回放一下poc数据包，以跟踪漏洞执行流程，注意，这里的poc并不能真正的在笔者的系统上执行，因为我是用了原版poc的payload而并未对其进行windows版本的更改。这里只是观察期执行流程所用

![lYR9iQ.png](https://s2.ax1x.com/2020/01/02/lYR9iQ.png)

其实上图这个数据包的url部分字符串(CoordinatorPortType)并不是固定的

通过查看wls-wsat.war!\\WEB-INF\\web.xml文件可以发现

可以利用的接口有如下几个

CoordinatorPortType  
RegistrationPortTypeRPC  
ParticipantPortType  
RegistrationRequesterPortType  
CoordinatorPortType11  
RegistrationPortTypeRPC11  
ParticipantPortType11  
RegistrationRequesterPortType11



言归正传，回到上文的请求中来。当该请求发送后，可见weblogic返回的响应如下

![lY26PJ.png](https://s2.ax1x.com/2020/01/02/lY26PJ.png)

通过分析weblogic的响应信息，我们可以从中看出一些线索

![lY2XsP.png](https://s2.ax1x.com/2020/01/02/lY2XsP.png)

在上图\<ns2:frame /\>标签中我们可以看出weblogic调用函数XMLDecoder的调用栈

通过\<ns2:frame /\>标签中的信息，我们可以整理出如下的调用链

processRequest\>readHeaderOld\>receive\>receiveRequest\>receiveRequest\>readEntry\>readUTF\>readObject

![lYRSIg.png](https://s2.ax1x.com/2020/01/02/lYRSIg.png)

我们发送的请求从WorkContextServerTube.java文件中的processRequest方法进入，经历了上图一系列处理之后，最终到达XMLDecoder.java文件中的readObject方法，进行XMLDecode,从而触发了漏洞

首先看下processRequest方法

![lY2bRA.png](https://s2.ax1x.com/2020/01/02/lY2bRA.png)

在调用processRequest方法时需要传入参数var1，var1为POST请求中传进来的XML数据，var1数据见下图

![lY25VO.png](https://s2.ax1x.com/2020/01/02/lY25VO.png)

接着，程序将xml头部进行解析并赋值给var3，如果var3不为空，就进入readHeaderOld()方法，见下图

![lY2hqK.png](https://s2.ax1x.com/2020/01/02/lY2hqK.png)

跟入readHeaderOld方法

![lY2DVU.png](https://s2.ax1x.com/2020/01/02/lY2DVU.png)

可见readHeaderOld方法中使用如下红框中操作对缓存区数据进行处理

![lY2xZ8.png](https://s2.ax1x.com/2020/01/02/lY2xZ8.png)

其中var4为poc中构造的payload代码

![lY22x1.png](https://s2.ax1x.com/2020/01/02/lY22x1.png)

对应数据包中红框中数据

![lY2OMt.png](https://s2.ax1x.com/2020/01/02/lY2OMt.png)

接着用var4创建WorkContextXmlInputAdapter类的对象 var6

![lY2jqf.png](https://s2.ax1x.com/2020/01/02/lY2jqf.png)

我们看一下WorkContextXmlInputAdapter的实现，如下图

![lYRizn.png](https://s2.ax1x.com/2020/01/02/lYRizn.png)

可见在该类的构造方法中，将传递进来的XML格式的序列化数据通过XMLDecoder来进行反序列化操作，并传递给this.xmlDecoder

此时var6入下图所示

![lY2WKx.png](https://s2.ax1x.com/2020/01/02/lY2WKx.png)

var6将被传入receive方法进行处理

跟进receive方法

![lY2oIe.png](https://s2.ax1x.com/2020/01/02/lY2oIe.png)

可见我们传入的payload被传入receiveRequest方法中，继续跟入receiveRequest方法

receiveRequest方法

![lY20bT.png](https://s2.ax1x.com/2020/01/02/lY20bT.png)

接着跟入receiveRequest方法中，见下图

![lY2g2R.png](https://s2.ax1x.com/2020/01/02/lY2g2R.png)

可见receiveRequest方法调用了readEntry方法对传入的payload进行处理

继续跟入readEntry方法

![lYRPRs.png](https://s2.ax1x.com/2020/01/02/lYRPRs.png)

在readEntry方法中调用readUTF方法对payload进行处理

跟入readUTF方法

![lY2qxI.png](https://s2.ax1x.com/2020/01/02/lY2qxI.png)

readUTF方法中使用readObject对XMLDecoder对象进行了反序列化，从而导致了代码执行。这里的this.xmlDecoder即为我们传入的payload，见下图

![lY27PH.png](https://s2.ax1x.com/2020/01/02/lY27PH.png)

至此，漏洞利用的这个流程分析完毕，可见构造的xml数据从请求中一路传递到漏洞触发点，在进行反序列化时被触发。关于payload的构造以及xmldecoder反序列化的相关知识，我会在下一篇文章中着重分析。